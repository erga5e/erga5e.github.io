<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ixout&#39;s blog</title>
  
  
  <link href="https://ixout.github.io/atom.xml" rel="self"/>
  
  <link href="https://ixout.github.io/"/>
  <updated>2023-03-15T02:49:36.115Z</updated>
  <id>https://ixout.github.io/</id>
  
  <author>
    <name>ixout</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>堆学习笔记</title>
    <link href="https://ixout.github.io/posts/8932/"/>
    <id>https://ixout.github.io/posts/8932/</id>
    <published>2023-03-02T14:31:03.000Z</published>
    <updated>2023-03-15T02:49:36.115Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近搭建博客花了不少时间，期间对堆的学习就搁置了，现在既然博客搭建完毕，就要利用起来了，刚好用来记录自己的堆学习过程</p><hr><h1 id="学习记录"><a href="#学习记录" class="headerlink" title="学习记录"></a>学习记录</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>ctfwiki的内容讲的已经很细了，不过还是推荐看一看华庭大佬的<a href="https://pan.baidu.com/s/167Z3CHDEeP1dl3c2Ii0lXg?pwd=1234">glibc内存管理-ptmalloc2源码分析</a>,看了之后真的能有很多收获.</p><h2 id="堆是啥"><a href="#堆是啥" class="headerlink" title="堆是啥"></a>堆是啥</h2><blockquote><p>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p><p>堆管理器处于用户程序与内核中间，主要做以下工作</p><ul><li>响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序。同时，为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理器通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</li><li>管理用户所释放的内存。一般来说，用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存的请求。</li></ul><p>引自ctf—wiki</p></blockquote><p>数据结构中也有堆这么个东西，但与这个堆关系不大(大概)</p><h2 id="堆的组成"><a href="#堆的组成" class="headerlink" title="堆的组成"></a>堆的组成</h2><p>在Linux下，glibc的堆是由多个arena组成的，每个arena是一个线程专用的内存池，用于管理内存块的分配和释放。每个arena又由多个subheap组成，每个subheap是一段连续的内存区域，用于存储多个同样大小的内存块。在subheap内部，使用了多种数据结构和技术来管理不同大小的内存块，以提高内存分配和管理的效率。</p><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><h3 id="malloc流程"><a href="#malloc流程" class="headerlink" title="malloc流程"></a>malloc流程</h3><hr><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338164.png" alt="malloc"></p><h3 id="free流程"><a href="#free流程" class="headerlink" title="free流程"></a>free流程</h3><p><img src="https://cdn.staticaly.com/gh/ixout/picture@main/img/1678786338155.png" alt="free"></p><h1 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h1><ul><li>fastbin的堆块结构与常规的chunk是完全一样，除了使用的是单链表。</li><li>每个bin元素都只占一个指针的长度，指向对应链表的头节点。每个bin所指向的链表其具象出的一个对象就是一个freelist。</li><li>heap是用于存储堆内存的虚拟内存区域，而arena是管理heap的数据结构。arena是heap的一个子部分。glibc下arena被实现为结构体。</li><li>在glibc中，每个空闲内存块都是一个结构体。这个结构体在glibc的源码中被称为”mchunk”。堆管理时，指针指向的一般都是chunk的起始地址。</li><li>subheap是arena的一个子部分,在glibc中，arena是一个线程专用的内存池，每个线程拥有一个arena。arena又包含多个subheap，每个subheap是一个内存段，用于存储多个同样大小的内存块。subheap中的内存块可以被分配给应用程序使用，也可以被释放回subheap中进行重复利用。</li><li>在glibc的malloc实现中，subheap是一个中间层的数据结构，用于管理多个subsegment。每个subsegment又包含多个内存块和一系列的bin和free list。</li><li>在glibc中，每个arena都有自己的独立的bin数组，用于管理不同大小的内存块，以提高内存分配和回收的效率。每个bin都有自己的free list，用于存储空闲的内存块。当需要分配一个指定大小的内存块时，glibc会先检查相应的bin的free list中是否有足够大的空闲内存块，如果有，就直接从free list中分配，否则会通过其他方式来获取内存。</li><li>在glibc中，每个bin都对应一个或多个指定大小的内存块的free list，用于存储相应大小的空闲内存块。因此，bin数组中的每个元素都包含一个或多个free list，当需要分配指定大小的内存块时，glibc会首先检查相应的bin的free list中是否有足够大的空闲内存块，如果有，则直接从该bin的free list中获取一个空闲内存块来进行分配。如果没有足够大的空闲内存块，则会通过其他方式获取内存，例如从其他bin的free list中获取一个比所需内存块稍大的空闲块，然后把多余的空间切割成一个新的空闲内存块，并将其添加到对应的bin的free list中。这种设计可以提高内存分配和回收的效率，因为它允许glibc在分配和回收内存时快速地定位合适的空闲内存块，从而避免了不必要的内存分配和释放的开销。</li><li>每个 bin 中的 free list 被串联成一个单向链表，称为“全局 free list”。全局 free list 是按照一定的规则组织起来的，规则与 glibc 版本和编译参数有关。在全局 free list 中，每个 free list 都记录了一个指向下一个 free list 的指针，因此，堆可以通过遍历全局 free list 来查找合适大小的空闲内存块。</li></ul><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>最后，不得不说chatgpt确实是神器，许多难以理解的概念都可以问他，特别是一些搜索引擎搜不到的细节，虽然不一定对(<del>其实可以说是经常出错:(</del> ),但如果仔细甄别，二次询问之后，的的确确能够解决不少困惑。</p>]]></content>
    
    
    <summary type="html">一个字：就TM让人头大</summary>
    
    
    
    <category term="pwn" scheme="https://ixout.github.io/categories/pwn/"/>
    
    
    <category term="堆" scheme="https://ixout.github.io/tags/%E5%A0%86/"/>
    
    <category term="学习记录" scheme="https://ixout.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
