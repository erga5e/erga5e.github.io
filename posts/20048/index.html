<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>符号执行与约束求解初探 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&#x3D;|&#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="符号执行与约束求解初探">
<meta property="og:url" content="https://ixout.github.io/posts/20048/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="&#x3D;|&#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg">
<meta property="article:published_time" content="2024-05-08T11:37:25.000Z">
<meta property="article:modified_time" content="2024-05-09T14:29:50.442Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="符号执行">
<meta property="article:tag" content="约束求解">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/20048/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '符号执行与约束求解初探',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-05-09 22:29:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">63</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">符号执行与约束求解初探</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-08T11:37:25.000Z" title="发表于 2024-05-08 19:37:25">2024-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-09T14:29:50.442Z" title="更新于 2024-05-09 22:29:50">2024-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>26分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266757.htm">[原创]符号执行在自动化Pwn中的简单利用-Pwn-看雪-安全社区|安全招聘|kanxue.com</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bookstack.cn/read/CTF-All-In-One/doc-5.3_symbolic_execution.md">五、高级篇 - 5.3 符号执行 - 《CTF 竞赛入门指南(CTF All In One)》 - 书栈网 · BookStack</a></p>
<p><a target="_blank" rel="noopener" href="https://myts2.cn/guan-yu-fasterde-na-xie-shi/">关于Faster的那些事… (myts2.cn)</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/675592367">符号执行 (Symbolic Execution) 与约束求解 (Constraint Solving) - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/myx-myx/articles/17009330.html">Z3求解器基础学习 （一） 从例子入门 - 说芬兰语的雪 - 博客园 (cnblogs.com)</a></p>
<p>这两个东西应该逆向中会用的比较多,不过也不排除出现在pwn中,而且也可以使用在自动化漏洞挖掘中,先简单学习一下常用的两个工具</p>
<h1 id="符号执行"><a href="#符号执行" class="headerlink" title="符号执行"></a>符号执行</h1><p>什么是符号执行?</p>
<p>简单来说就是将输入符号化,然后找到所有程序可能的执行路径与这些符号的关系</p>
<h2 id="angr"><a href="#angr" class="headerlink" title="angr"></a>angr</h2><p><a target="_blank" rel="noopener" href="https://github.com/angr/angr">angr</a> 是一个多架构的二进制分析平台，具备对二进制文件的动态符号执行能力和多种静态分析能力。</p>
<p>官方文档<a target="_blank" rel="noopener" href="https://docs.angr.io/en/latest/">angr documentation</a></p>
<h3 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h3><p>使用angr 的第一步是新建一个工程，几乎所有的操作都是围绕这个工程展开的：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line">p = angr.Project(<span class="string">&#x27;./pwn&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>载入二进制文件后，我们就可以访问一些基本属性，如文件名、架构、入口地址：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.arch</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.entry</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>proj.filename</span><br></pre></td></tr></table></figure>
<p>angr 中的 CLE 模块用于将二进制文件载入虚拟地址空间，而CLE 最主要的接口就是 loader 类。</p>
<p>可以通过 Project 的 <code>.loader</code>的属性查看</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader</span><br><span class="line">&lt;Loaded pwn, maps [<span class="number">0x400000</span>:<span class="number">0xa07fff</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>通过 loader, 我们可以获得二进制文件的共享库、地址空间等信息。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.loader.shared_objects</span><br><span class="line">OrderedDict([(<span class="string">&#x27;pwn&#x27;</span>, &lt;ELF Object pwn, maps [<span class="number">0x400000</span>:<span class="number">0x40a65f</span>]&gt;), (<span class="string">&#x27;libc.so.6&#x27;</span>, &lt;ELF Object libc-<span class="number">2.31</span>.so, maps [<span class="number">0x500000</span>:<span class="number">0x6f165f</span>]&gt;), (<span class="string">&#x27;ld-linux-x86-64.so.2&#x27;</span>, &lt;ELF Object ld-<span class="number">2.31</span>.so, maps [<span class="number">0x700000</span>:<span class="number">0x72f18f</span>]&gt;), (<span class="string">&#x27;extern-address space&#x27;</span>, &lt;ExternObject Object cle<span class="comment">##externs, maps [0x800000:0x87ffff]&gt;), (&#x27;cle##tls&#x27;, &lt;ELFTLSObjectV2 Object cle##tls, maps [0x900000:0x91500f]&gt;)])</span></span><br></pre></td></tr></table></figure>
<p>但通常我们在创建工程时选择关闭 <code>auto_load_libs</code> 以避免 angr 加载共享库：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = angr.Project(<span class="string">&#x27;/bin/true&#x27;</span>, auto_load_libs=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="动态执行"><a href="#动态执行" class="headerlink" title="动态执行"></a>动态执行</h3><p><code>project.factory</code> 提供了很多类对二进制文件进行分析，它提供了几个方便的构造函数。</p>
<p><code>project.factory.block()</code> 用于从给定地址解析一个 basic block，对象类型为 Block：</p>
<p>step的最小单位是一个基本块，一个基本块<strong>以遇到更改ip指令(比如说jmp,jz,jnz,call等等)为止</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block = proj.factory.block(proj.entry)    <span class="comment"># 从程序头开始解析一个 basic block</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block</span><br><span class="line">&lt;Block <span class="keyword">for</span> <span class="number">0x401370</span>, <span class="number">42</span> <span class="built_in">bytes</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.pp()                  <span class="comment"># 打印</span></span><br><span class="line"><span class="number">0x401370</span>:       xor     ebp, ebp</span><br><span class="line"><span class="number">0x401372</span>:       mov     r9, rdx</span><br><span class="line"><span class="number">0x401375</span>:       pop     rsi</span><br><span class="line"><span class="number">0x401376</span>:       mov     rdx, rsp</span><br><span class="line"><span class="number">0x401379</span>:       <span class="keyword">and</span>     rsp, <span class="number">0xfffffffffffffff0</span></span><br><span class="line"><span class="number">0x40137d</span>:       push    rax</span><br><span class="line"><span class="number">0x40137e</span>:       push    rsp</span><br><span class="line"><span class="number">0x40137f</span>:       lea     r8, qword ptr [rip + <span class="number">0x32da</span>]</span><br><span class="line"><span class="number">0x401386</span>:       lea     rcx, qword ptr [rip + <span class="number">0x3263</span>]</span><br><span class="line"><span class="number">0x40138d</span>:       lea     rdi, qword ptr [rip - <span class="number">0xe4</span>]</span><br><span class="line"><span class="number">0x401394</span>:       call    qword ptr [rip + <span class="number">0x205b76</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instructions          <span class="comment"># 指令数量</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.instruction_addrs     <span class="comment"># 指令地址</span></span><br><span class="line">[<span class="number">4199280L</span>, <span class="number">4199282L</span>, <span class="number">4199285L</span>, <span class="number">4199286L</span>, <span class="number">4199289L</span>, <span class="number">4199293L</span>, <span class="number">4199294L</span>, <span class="number">4199295L</span>, <span class="number">4199302L</span>, <span class="number">4199309L</span>, <span class="number">4199316L</span>]</span><br></pre></td></tr></table></figure>
<p>另外，还可以将 Block 对象转换成其他形式：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>block.capstone&lt;CapstoneBlock <span class="keyword">for</span> <span class="number">0x401370</span>&gt;&gt;&gt;&gt; block.capstone.pp()&gt;&gt;&gt; block.vexIRSB &lt;<span class="number">0x2a</span> <span class="built_in">bytes</span>, <span class="number">11</span> ins., &lt;Arch AMD64 (LE)&gt;&gt; at <span class="number">0x401370</span>&gt;&gt;&gt; block.vex.pp()</span><br></pre></td></tr></table></figure>
<p>程序的执行需要初始化一个模拟程序状态的 <code>SimState</code> 对象：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state = proj.factory.entry_state()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state</span><br><span class="line">&lt;SimState @ <span class="number">0x401370</span>&gt;</span><br></pre></td></tr></table></figure>
<p>该对象包含了程序的内存、寄存器、文件系统数据等等模拟运行时动态变化的数据，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs                          <span class="comment"># 寄存器名对象</span></span><br><span class="line">&lt;angr.state_plugins.view.SimRegNameView <span class="built_in">object</span> at <span class="number">0x7f126fdfe810</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rip                      <span class="comment"># BV64 对象</span></span><br><span class="line">&lt;BV64 <span class="number">0x401370</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsp</span><br><span class="line">&lt;BV64 <span class="number">0x7fffffffffeff98</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsp.length               <span class="comment"># BV 对象都有 .length 属性</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rdi</span><br><span class="line">&lt;BV64 reg_48_0_64&#123;UNINITIALIZED&#125;&gt;       <span class="comment"># BV64 对象，符号变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[proj.entry].<span class="built_in">int</span>.resolved  <span class="comment"># 将入口点的内存解释为 C 语言的 int 类型</span></span><br><span class="line">&lt;BV32 <span class="number">0x8949ed31</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 BV，即 bitvectors，可以理解为一个比特串，用于在 angr 里表示 CPU 数据。看到在这里 rdi 有点特殊，它没有具体的数值，而是在符号执行中所使用的符号变量，稍后再做解释。</p>
<p>下面是 Python int 和 bitvectors 之间的转换：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">32</span>)   <span class="comment"># 创建值 0x1234 的 BV32 对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV32 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv))          <span class="comment"># 将 BV32 对象转换为 Python int</span></span><br><span class="line"><span class="string">&#x27;0x1234&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv = state.solver.BVV(<span class="number">0x1234</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bv</span><br><span class="line">&lt;BV64 <span class="number">0x1234</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">hex</span>(state.solver.<span class="built_in">eval</span>(bv))</span><br><span class="line"><span class="string">&#x27;0x1234L&#x27;</span></span><br></pre></td></tr></table></figure>
<p>于是 bitvectors 可以进行数学运算：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>one = state.solver.BVV(<span class="number">1</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred = state.solver.BVV(<span class="number">100</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred + one                 <span class="comment"># 位数相同时可以直接运算</span></span><br><span class="line">&lt;BV64 <span class="number">0x65</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one_hundred + one + <span class="number">0x100</span></span><br><span class="line">&lt;BV64 <span class="number">0x165</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.solver.BVV(-<span class="number">1</span>, <span class="number">64</span>)          <span class="comment"># 默认为无符号数</span></span><br><span class="line">&lt;BV64 <span class="number">0xffffffffffffffff</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>five = state.solver.BVV(<span class="number">5</span>, <span class="number">27</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>five</span><br><span class="line">&lt;BV27 <span class="number">0x5</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + five.zero_extend(<span class="number">64</span> - <span class="number">27</span>)   <span class="comment"># 位数不同时需要进行扩展</span></span><br><span class="line">&lt;BV64 <span class="number">0x6</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>one + five.sign_extend(<span class="number">64</span> - <span class="number">27</span>)   <span class="comment"># 或者有符号扩展</span></span><br><span class="line">&lt;BV64 <span class="number">0x6</span>&gt;</span><br></pre></td></tr></table></figure>
<p>使用 bitvectors 可以直接来设置寄存器和内存的值，当传入的是 Python int 时，angr 会自动将其转换成 bitvectors：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi = state.solver.BVV(<span class="number">3</span>, <span class="number">64</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rsi</span><br><span class="line">&lt;BV64 <span class="number">0x3</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long = <span class="number">4</span>          <span class="comment"># 在地址 0x1000 存放一个 long 类型的值 4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.resolved     <span class="comment"># .resolved 获取 bitvectors</span></span><br><span class="line">&lt;BV64 <span class="number">0x4</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.mem[<span class="number">0x1000</span>].long.concrete     <span class="comment"># .concrete 获得 Python int</span></span><br><span class="line"><span class="number">4L</span></span><br></pre></td></tr></table></figure>
<p>初始化的 state 可以经过模拟执行得到一系列的 states，模拟管理器（Simulation Managers）的作用就是对这些 states 进行管理：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr = proj.factory.simulation_manager(state)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr</span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.active                        <span class="comment"># 当前 state</span></span><br><span class="line">[&lt;SimState @ <span class="number">0x401370</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.step()                        <span class="comment"># 模拟执行一个 basic block</span></span><br><span class="line">&lt;SimulationManager <span class="keyword">with</span> <span class="number">1</span> active&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.active                        <span class="comment"># 当前 state 被更新</span></span><br><span class="line">[&lt;SimState @ <span class="number">0x1022f80</span>&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>simgr.active[<span class="number">0</span>].regs.rip            <span class="comment"># active[0] 是当前 state</span></span><br><span class="line">&lt;BV64 <span class="number">0x1022f80</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>state.regs.rip                      <span class="comment"># 但原始的 state 并没有改变</span></span><br><span class="line">&lt;BV64 <span class="number">0x401370</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>angr 提供了大量函数用于程序分析，在这些函数在 <code>Project.analyses.</code>，例如：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg = p.analyses.CFGFast()          <span class="comment"># 得到 control-flow graph</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg</span><br><span class="line">&lt;CFGFast Analysis Result at <span class="number">0x7f1265b62650</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cfg.graph</span><br><span class="line">&lt;networkx.classes.digraph.DiGraph <span class="built_in">object</span> at <span class="number">0x7f1265e77310</span>&gt; <span class="comment"># 详情请查看 networkx</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(cfg.graph.nodes())</span><br><span class="line"><span class="number">934</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node = cfg.get_any_node(proj.entry)   <span class="comment"># 得到给定地址的 CFGNode</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>entry_node</span><br><span class="line">&lt;CFGNode <span class="number">0x401370</span>[<span class="number">42</span>]&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(<span class="built_in">list</span>(cfg.graph.successors(entry_node)))</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果要想画出图来，还需要安装 matplotlib。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>matplotlib.use(<span class="string">&#x27;Agg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nx.draw(cfg.graph)                  <span class="comment"># 画图</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>plt.savefig(<span class="string">&#x27;temp.png&#x27;</span>)             <span class="comment"># 保存</span></span><br></pre></td></tr></table></figure>
<h3 id="explore"><a href="#explore" class="headerlink" title="explore"></a>explore</h3><p>explore是在ctf中使用的比较多的共能</p>
<p>通过调用 explore 方法，我们可以探索执行路径，在进行 explore 时，可以设置 find 和 avoid 参数，以便找到符合我们预期的路径。</p>
<p>函数接口如下：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">explore</span>(<span class="params">self, stash=<span class="string">&#x27;active&#x27;</span>, n=<span class="literal">None</span>, find=<span class="literal">None</span>, avoid=<span class="literal">None</span>, find_stash=<span class="string">&#x27;found&#x27;</span>, avoid_stash=<span class="string">&#x27;avoid&#x27;</span>, cfg=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                num_find=<span class="number">1</span>, **kwargs</span>):</span><br></pre></td></tr></table></figure>
<p>例子</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    proj = angr.Project(<span class="string">&#x27;./bin5&#x27;</span>)</span><br><span class="line">    state = proj.factory.entry_state()</span><br><span class="line">    simgr = proj.factory.simgr(state)</span><br><span class="line">    simgr.explore(find=<span class="number">0x08048783</span>)</span><br><span class="line">    payload = simgr.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;payload=<span class="subst">&#123;b2a_hex(payload)&#125;</span>&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure>
<p>angr 提供了多种 <code>explore</code> 技术，即进行路径探索时所采用的策略，可以在 <code>angr.exploration_techniques</code> 条目下中找到。</p>
<p>每个策略都是 <code>ExplorationTechnique</code> 对象，根据策略不同，angr 对 <code>ExplorationTechnique</code> 中的 <code>setup、step</code> 等方法进行覆盖。</p>
<p>通过 <code>simgr.use_technique(tech)</code>设定不同的策略。</p>
<p>下面部分列出策略</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS</td>
<td>Depth first search. Keeps only one state active at once, putting the rest in the <code>deferred</code> stash until it deadends or errors.</td>
</tr>
<tr>
<td>LengthLimiter</td>
<td>Puts a cap on the maximum length of the path a state goes through.</td>
</tr>
<tr>
<td>Tracer</td>
<td>An exploration technique that causes execution to follow a dynamic trace recorded from some other source.</td>
</tr>
<tr>
<td>Oppologist</td>
<td>if this technique is enabled and angr encounters an unsupported instruction, it will concretize all the inputs to that instruction and emulate the single instruction using the unicorn engine, allowing execution to continue.</td>
</tr>
<tr>
<td>Threading</td>
<td>Adds thread-level parallelism to the stepping process.</td>
</tr>
<tr>
<td>Spiller</td>
<td>When there are too many states active, this technique can dump some of them to disk in order to keep memory consumption low.</td>
</tr>
</tbody>
</table>
</div>
<p>如果要让angr跑程序的话，有两点会提高效率，一种是hook代码，一种是设定avoid条件。hook代码即人工把某部分汇编代码翻译成python之后告诉angr，当你执行到这里的时候它其实是这个意思，就不用让他再跑VEX了。路径爆炸是符号执行一定要解决的问题，所以说可以提前帮助angr做剪枝，使得它不会再其他不可能进行下去的分支上耽误太长时间。</p>
<p>getav的思路: 其实还是找规律，一般来说，基本都是不符合条件就直接跳下去，不再继续执行函数，所以说这就是明显的特征之一，找到跳下去的部分，用vex.next看如果不跳下去会到什么地址，然后直接把另一条路拉到avoid里就OK了，这是第一个特征。</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="2021纵横杯决赛-bin1"><a href="#2021纵横杯决赛-bin1" class="headerlink" title="2021纵横杯决赛-bin1"></a>2021纵横杯决赛-bin1</h3><p>程序是一坨的条件判断,存在一条正确的路径可以在最后拿到shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_80485F5</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                  &#123;</span><br><span class="line">                    <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">if</span> ( sub_8054B1A() == <span class="number">1</span> )</span><br><span class="line">                    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">                    .....</span><br><span class="line">                        .....</span><br><span class="line">                        ....</span><br><span class="line">                        ....</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( sub_8054B1A() != <span class="number">1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题是无法直接使用</p>
<p>用符号执行解决这种分支问题有两个思路：</p>
<ol>
<li>找到所有从函数入口到system函数的路径，对每条路径进行操作，在每两个基本块之间进行explore</li>
<li>找到所有从函数入口到system函数的路径，将其他不在路径上的基本块地址添加到<strong>avoid_list</strong>中，再从函数入口开始explore</li>
</ol>
<p>这里计算avoid_list的原因是此题的分支数巨大，每一个分支条件语句都可能会使当前的路径再分支出一条新的路径，而且这是<strong>”指数级”</strong>增长的，也就是说符号执行所需要的时间和空间都会随分支数的增长而”指数级”增长，这显然是我们不愿看到的。<br>所以我们需要计算avoid_list，使符号执行引擎忽略某些根本不可能到达system函数的路径，这样在一定程度上避免了上述问题。</p>
<p>先看一下最终的<strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">from</span> angrmanagement.utils.graph <span class="keyword">import</span> to_supergraph</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> b2a_hex</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取system函数的地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取避免执行到的地址列表</span></span><br><span class="line"><span class="comment">#关键！可以大大提高angr符号执行速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#对目标函数进行符号执行，求解到达call system执行所需要的输入</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_func</span>(<span class="params">proj, target_func, target_block, target_cfg</span>):</span><br><span class="line">    can_reach_target, avoid_list = get_avoid_list(target_cfg, <span class="built_in">list</span>(target_cfg.nodes)[<span class="number">0</span>], target_block)</span><br><span class="line">    <span class="keyword">if</span> can_reach_target:</span><br><span class="line">    	state = proj.factory.call_state(target_func)</span><br><span class="line">    	simgr = proj.factory.simgr(state)</span><br><span class="line">    	simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">    	simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">    	payload_list = []</span><br><span class="line">    	<span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">        	payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">    	<span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#求解所有可行的payload</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">explore_payload</span>(<span class="params">bin_path</span>):</span><br><span class="line">    proj = angr.Project(bin_path, load_options=&#123;<span class="string">&#x27;auto_load_libs&#x27;</span>: <span class="literal">False</span>&#125;)</span><br><span class="line">    proj_cfg = proj.analyses.CFGFast()</span><br><span class="line">    system_addr = get_system_addr(proj_cfg)</span><br><span class="line">    <span class="keyword">if</span> system_addr == <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Found system function in <span class="subst">&#123;<span class="built_in">hex</span>(system_addr)&#125;</span>.&#x27;</span>)</span><br><span class="line">    payload_list = []</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> proj_cfg.functions:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            func = proj_cfg.functions.get(func_addr)</span><br><span class="line">            cfg = func.transition_graph</span><br><span class="line">            cfg = to_supergraph(cfg)</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> cfg.nodes:</span><br><span class="line">                block = proj.factory.block(node.addr)</span><br><span class="line">                <span class="keyword">for</span> inst <span class="keyword">in</span> block.capstone.insns:</span><br><span class="line">                    <span class="keyword">if</span> inst.mnemonic == <span class="string">&#x27;call&#x27;</span> <span class="keyword">and</span> inst.op_str == <span class="built_in">hex</span>(system_addr):</span><br><span class="line">                        target_func = func_addr</span><br><span class="line">                        target_block = block.addr</span><br><span class="line">                        target_cfg = cfg</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target function in <span class="subst">&#123;<span class="built_in">hex</span>(target_func)&#125;</span>&#x27;</span>)</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">f&#x27;Found target block in <span class="subst">&#123;<span class="built_in">hex</span>(target_block)&#125;</span>&#x27;</span>)</span><br><span class="line">                        payload_list += explore_func(proj, target_func, target_block, target_cfg)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            <span class="built_in">print</span>(ex)</span><br><span class="line">    <span class="keyword">return</span> payload_list</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">angr_run</span>():</span><br><span class="line">    payload_list = explore_payload(<span class="string">&#x27;./bin1&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(payload_list)</span><br><span class="line">    <span class="keyword">for</span> payload <span class="keyword">in</span> payload_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;payload=&#x27;</span> +  b2a_hex(payload).decode())</span><br><span class="line"> </span><br><span class="line">angr_run()</span><br></pre></td></tr></table></figure>
<p>嘿嘿,完全看不懂捏,一步一步分析一下</p>
<p>在创建完项目之后,有一句</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proj_cfg = proj.analyses.CFGFast()</span><br></pre></td></tr></table></figure>
<p>用于进行快速构建控制流图（CFG）的一个分析器。CFG 是一个表示程序中基本块之间控制流关系的图形结构，它可以帮助分析程序的结构和逻辑。</p>
<p><code>CFGFast</code> 分析器通过静态分析程序的二进制代码来构建控制流图，而不需要实际执行程序。因此，它是一种快速获取程序结构信息的方法。</p>
<p>此外,还有CFGEmulated通过动态符号执行获得更加准确的CFG。</p>
<p>因为是自动化pwn,所以选择通过分析获得system的地址</p>
<p>原作者是这样做的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg</span>):</span><br><span class="line">    <span class="keyword">for</span> func_addr <span class="keyword">in</span> cfg.functions:</span><br><span class="line">        func = cfg.functions.get(func_addr)</span><br><span class="line">        <span class="keyword">if</span> func.name == <span class="string">&#x27;system&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> func_addr</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<p>但实际上可以更简单的</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_system_addr</span>(<span class="params">cfg,func_name</span>):</span><br><span class="line">	func = cfg.functions.get(func_name)</span><br><span class="line">	<span class="keyword">return</span> func.addr</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>get_system_addr(proj_cfg,<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line"><span class="number">134513728</span></span><br></pre></td></tr></table></figure>
<p>再然后又初始化了一个列表<code>payload_list = []</code></p>
<p>然后遍历每个函数并返回一个cfg-graph,又遍历每一个cfg-graph的nodes</p>
<p>一个node通常表示程序中的一个执行点或者一个特定的结构。在控制流图（CFG）中，节点表示程序中的不同位置或者不同的结构单元.可以是以下几种类型之一：</p>
<ol>
<li><strong>基本块节点（Block Node）</strong>：表示程序中的一个连续的指令序列，通常是在程序中的一个基本块（basic block）内。基本块是一组连续执行的指令，没有条件分支，只有一个入口和一个出口。</li>
<li><strong>函数节点（Function Node）</strong>：表示程序中的一个函数，其中包含了函数的入口点和出口点，以及函数内部的基本块。</li>
<li><strong>钩子节点（Hook Node）</strong>：表示程序中的一个函数调用的目标，通常是一个库函数或者系统函数。</li>
<li><strong>其他类型的节点</strong>：根据具体的分析需求和程序结构，控制流图中可能还包含其他类型的节点，如跳转表节点、异常处理节点等</li>
</ol>
<p>取每一个node作为一个block,然后去判断block中是否存在对system的调用</p>
<p>当找到后进入一次explore_func(在本例中只有一处调用了system,也就是函数sub_80485f5,所以循环实际上会且仅会执行一次explore_func)</p>
<p>explore_func首先进行getav即找到需要避免</p>
<p>仔细看一下这个getav函数</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_avoid_list</span>(<span class="params">cfg, start, target</span>):</span><br><span class="line">    <span class="keyword">if</span> start.addr == target:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">    succs = <span class="built_in">list</span>(cfg.successors(start))</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(succs) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, [start.addr])</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">1</span>:</span><br><span class="line">        can_reach_target, avoid_list = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">len</span>(succs) == <span class="number">2</span>:</span><br><span class="line">        can_reach_target0, avoid_list0 = get_avoid_list(cfg, succs[<span class="number">0</span>], target)</span><br><span class="line">        can_reach_target1, avoid_list1 = get_avoid_list(cfg, succs[<span class="number">1</span>], target)</span><br><span class="line">        <span class="keyword">if</span> can_reach_target0 <span class="keyword">and</span> can_reach_target1:</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, [])</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> can_reach_target0 <span class="keyword">and</span> <span class="keyword">not</span> can_reach_target1:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            avoid_list.append(start.addr)</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">False</span>, avoid_list)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            avoid_list = avoid_list0 + avoid_list1</span><br><span class="line">            <span class="keyword">return</span> (<span class="literal">True</span>, avoid_list)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ol>
<li>如果函数开始的第一个节点就是目标节点那么完全不需要什么avoid_list,直接返回可到达,与空avoid</li>
<li>否则获取后继节点,如果后继节点不存在,那么返回不可到达,并将start.addr作为avoid_list,即这个函数千万别进入</li>
<li>如果后继节点数量为1,递归调用getav,如果返回值是可到达那么直接返回,如果是不可到达则将该节点地址放入avoid_list并返回</li>
<li>如果后继节点为2,分别对两个后继节点递归调用getav,如果两个后继节点都能到达则直接返回可到达与空avoid,如果都不可到达则返回不可到达,并添加avoid,否则分开处理</li>
</ol>
<p>这里为啥后继节点数量不超过2,如果存在switch结构怎么办?完全不用担心,因为switch在汇编上也是jmp实现的,照样会被识别为多个block</p>
<p>这个递归函数很重要,极大节省了时间</p>
<p>视角回到explore_func,此时已经执行完了getav</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">state = proj.factory.call_state(target_func)</span><br><span class="line">   simgr = proj.factory.simgr(state)</span><br><span class="line">   simgr.use_technique(angr.exploration_techniques.DFS())</span><br><span class="line">   simgr.explore(find=target_block, avoid=avoid_list)</span><br><span class="line">   payload_list = []</span><br><span class="line">   <span class="keyword">for</span> found <span class="keyword">in</span> simgr.found:</span><br><span class="line">       payload_list.append(found.posix.dumps(<span class="number">0</span>))</span><br><span class="line">   <span class="keyword">return</span> payload_list</span><br></pre></td></tr></table></figure>
<p>首先进行了<code>proj.factory.call_state()</code>调用,<code>call_state(target_func)</code> 方法会<u>创建一个初始状态</u>，该状态模拟了执行目标函数 <code>target_func</code> 时的程序状态。这个初始状态包含了函数调用的上下文信息，如函数参数、返回地址等，并且可以被用于后续的符号执行分析。可以用于指定分析特定函数调用时的程序行为</p>
<p>然后就是常见的创建一个manager,以及指定使用DFS(深度优先算法)进行模拟探索</p>
<p>正式调用方法<code>explore(find=target_block, avoid=avoid_list)</code>,同时提供之前返回的avoid_list</p>
<p>最终获得所有发现路径中文件描述符为0的数据,即标准输入的数据,并打印出来</p>
<h1 id="约束求解"><a href="#约束求解" class="headerlink" title="约束求解"></a>约束求解</h1><p>约束求解用于解决一组条件的问题，这些条件通常被称为约束，其目的是找到满足这些约束的变量值。</p>
<p>在程序分析中，约束求解通常与符号执行相结合使用。符号执行是一种用符号变量代替具体值的执行技术，它可以在不实际执行程序的情况下探索程序路径，并生成关于程序行为的约束。约束求解器则负责解决这些约束，以确定符号变量可能的取值，从而确定程序执行的路径或找到输入数据的有效值。</p>
<p>约束求解在以下情况下特别有用：</p>
<ol>
<li><strong>程序分析</strong>：通过符号执行和约束求解，可以发现程序中的漏洞、逻辑错误或安全问题。</li>
<li><strong>自动化测试</strong>：使用符号执行和约束求解来生成输入数据，以覆盖代码中的不同执行路径，从而进行自动化测试。</li>
<li><strong>逆向工程</strong>：在逆向工程中，约束求解可以帮助分析者理解程序的行为，并识别关键的代码路径。</li>
<li><strong>二进制分析</strong>：在分析二进制文件时，约束求解可以帮助分析者理解程序逻辑，并发现关键功能。</li>
</ol>
<p>约束求解器的实现通常涉及各种技术和算法，包括基于SAT（可满足性问题）的方法、基于SMT（可满足性模理论）的方法以及其他启发式和优化算法。</p>
<p>下面介绍一下微软开发的z3约束求解器</p>
<h2 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h2><p>z3是一个十分强大的约束求解器,支持众多功能</p>
<h3 id="类型变量"><a href="#类型变量" class="headerlink" title="类型变量"></a>类型变量</h3><p>z3中有3中类型的变量，分别是整型(Int),实型(Real)和向量(BitVec)</p>
<p>Int-整数型</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Int(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个整型变量</span></span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个整型变量</span></span><br></pre></td></tr></table></figure>
<p>Real-实数型</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = Real(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#声明单个实型变量</span></span><br><span class="line">a,b = Reals(<span class="string">&#x27;a b&#x27;</span>)<span class="comment">#声明多个实型变量</span></span><br></pre></td></tr></table></figure>
<p>BitVec-向量</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a = BitVec(<span class="string">&#x27;a&#x27;</span>,<span class="number">8</span>) <span class="comment">#声明单个8位的变量</span></span><br><span class="line">a, b = BitVec(<span class="string">&#x27;a b&#x27;</span>,<span class="number">8</span>)<span class="comment">#声明多个8位的变量</span></span><br></pre></td></tr></table></figure>
<h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><p><strong>0x1简单约束求解</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>solve(a&gt;<span class="number">6</span>,b&lt;<span class="number">10</span>,a*b-<span class="number">1</span>==<span class="number">48</span>)</span><br><span class="line">[a = <span class="number">49</span>, b = <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>0x2多条件条件约束器</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a,b = Ints(<span class="string">&#x27;a b&#x27;</span>)</span><br><span class="line">solver = Solver()<span class="comment">#创建一个求解器对象</span></span><br><span class="line">solver.add(a+b==<span class="number">10</span>)<span class="comment">#用add方法添加约束条件</span></span><br><span class="line">solver.add(a-b==<span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> solver.check() == sat: <span class="comment">#check()方法用来判断是否有解，sat(satisify)表示满足有解</span></span><br><span class="line">    ans = solver.model() <span class="comment">#model()方法得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans)</span><br><span class="line">    <span class="comment">#也可以用变量名作为下标得到解</span></span><br><span class="line">    <span class="built_in">print</span>(ans[a])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no ans!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>0x3表达式简化</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x=Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y=Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> (simplify(x + y + <span class="number">2</span>*x + <span class="number">3</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(x &lt; y + x + <span class="number">2</span>))</span><br><span class="line"><span class="built_in">print</span> (simplify(And(x + <span class="number">1</span> &gt;= <span class="number">3</span>, x**<span class="number">2</span> + x**<span class="number">2</span> + y**<span class="number">2</span> + <span class="number">2</span> &gt;= <span class="number">5</span>)))</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> + <span class="number">3</span>*x + y</span><br><span class="line">Not(y &lt;= -<span class="number">2</span>)</span><br><span class="line">And(x &gt;= <span class="number">2</span>, <span class="number">2</span>*x**<span class="number">2</span> + y**<span class="number">2</span> &gt;= <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p><strong>0x4表达式分析</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x = Int(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">y = Int(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">n = x + y &gt;= <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;num args: &quot;</span>, n.num_args())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;children: &quot;</span>, n.children())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;1st child:&quot;</span>, n.arg(<span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;2nd child:&quot;</span>, n.arg(<span class="number">1</span>))</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;operator: &quot;</span>, n.decl())</span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;op name:  &quot;</span>, n.decl().name())</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num args:  <span class="number">2</span></span><br><span class="line">children:  [x + y, <span class="number">3</span>]</span><br><span class="line">1st child: x + y</span><br><span class="line">2nd child: <span class="number">3</span></span><br><span class="line">operator:  &gt;=</span><br><span class="line">op name:   &gt;=</span><br></pre></td></tr></table></figure>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>z3只适用于求解非线性多项式</p>
<p>像这样的就无法求解</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = Real(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Solver()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">2</span>**x == <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (s.check())</span><br><span class="line">unknown</span><br></pre></td></tr></table></figure>
<h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h2><h3 id="2020De1ta-code-runner"><a href="#2020De1ta-code-runner" class="headerlink" title="2020De1ta-code_runner"></a>2020De1ta-code_runner</h3><p>这题一开始有一个sha256爆破,之后才能拿到二进制文件,这里直接从二进制文件分析开始</p>
<p>这是个mipsel架构的文件</p>
<p>main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// local variable allocation has failed, the output may be wrong!</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// $a0 OVERLAPPED</span></span><br><span class="line">  __int64 v4; <span class="comment">// $a2 OVERLAPPED</span></span><br><span class="line">  __int64 v6; <span class="comment">// [sp+28h] [+28h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v7</span>;</span> <span class="comment">// [sp+3Ch] [+3Ch] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">v8</span>;</span> <span class="comment">// [sp+44h] [+44h] BYREF</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v9[<span class="number">64</span>])(_DWORD, _DWORD, _DWORD, _DWORD); <span class="comment">// [sp+4Ch] [+4Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  gettimeofday(&amp;v7, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(v9, <span class="number">0</span>, <span class="keyword">sizeof</span>(v9));</span><br><span class="line">  sub_401BA4();</span><br><span class="line">  <span class="keyword">if</span> ( sub_401C6C() )</span><br><span class="line">  &#123;</span><br><span class="line">    gettimeofday(&amp;v8, <span class="number">0</span>);</span><br><span class="line">    v6 = (<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">1000000</span> * (v8.tv_sec - v7.tv_sec) + v8.tv_usec - v7.tv_usec);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;======== %lld.%llds ========\n&quot;</span>, v6 / <span class="number">1000000</span>, v6 % <span class="number">1000000</span>);</span><br><span class="line">    sub_401D48(v6, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Your time comes.\n&gt; &quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">unsigned</span> __int64)(v6 / <span class="number">100000</span>) &lt; <span class="number">0xD</span> )</span><br><span class="line">      read(<span class="number">0</span>, v9, <span class="number">-4</span> * (v6 / <span class="number">100000</span>) + <span class="number">52</span>);</span><br><span class="line">    v9[<span class="number">0</span>](v3, HIDWORD(v3), v4, HIDWORD(v4));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最后可以执行shellcode,观察到前面的时间计算,显然是限制需要在一定时间内完成某些挑战</p>
<p>在sub_401C6C()函数里有一大坨套娃函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sub_401C6C</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">256</span>]; <span class="comment">// [sp+1Ch] [+1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(v1, <span class="number">0</span>, <span class="keyword">sizeof</span>(v1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Faster &gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, v1, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">return</span> sub_401A9C((<span class="type">int</span>)v1);</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_400B30</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3221338814</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终需要满足各种条件到达sub_400B30()</p>
<p>序会先读取0x100的输入，然后对这个输入做一系列的验证，只有通过所有验证函数才可以返回一个非零值。这些验证函数，每一个函数处理4字节的输入，然后如果此4字节通过验证，会调用另一个函数再去处理接下来的4字节；如果此4字节没有通过验证，则直接返回0。这种模式我们称之为线性，也就是说一旦有4字节的输入不正确，接下来的所有输入都不会被验证。</p>
<p>线性模式的解题利器就是angr,一段不做任何优化处理的脚本可以是</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p = angr.Project(<span class="string">&quot;real_code&quot;</span>)</span><br><span class="line">state = p.factory.blank_state(addr=<span class="number">0x401e88</span>)</span><br><span class="line">sm = p.factory.simgr(state)</span><br><span class="line">sm.explore(find=<span class="number">0x400b30</span>)</span><br><span class="line"><span class="comment"># 0x400b30为最内层return非零值的汇编指令</span></span><br><span class="line"><span class="built_in">print</span>(sm.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>之后好像有点复杂,先摸了</p>
<h3 id="DEFCAMP2017-forgot-my-key"><a href="#DEFCAMP2017-forgot-my-key" class="headerlink" title="DEFCAMP2017-forgot_my_key"></a>DEFCAMP2017-forgot_my_key</h3><p>给了这么一个加密函数</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">my_encrypt</span>(<span class="params"><span class="variable">$flag</span>, <span class="variable">$key</span></span>) </span>&#123;</span><br><span class="line">  <span class="variable">$key</span> = <span class="title function_ invoke__">md5</span>(<span class="variable">$key</span>);</span><br><span class="line">  <span class="variable">$message</span> = <span class="variable">$flag</span> . <span class="string">&quot;|&quot;</span> . <span class="variable">$key</span>;</span><br><span class="line"></span><br><span class="line">  <span class="variable">$encrypted</span> = <span class="title function_ invoke__">chr</span>(<span class="title function_ invoke__">rand</span>(<span class="number">0</span>, <span class="number">126</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="title function_ invoke__">strlen</span>(<span class="variable">$message</span>);<span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$encrypted</span> .= <span class="title function_ invoke__">chr</span>((<span class="title function_ invoke__">ord</span>(<span class="variable">$message</span>[<span class="variable">$i</span>]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$key</span>[<span class="variable">$i</span> % <span class="title function_ invoke__">strlen</span>(<span class="variable">$key</span>)]) + <span class="title function_ invoke__">ord</span>(<span class="variable">$encrypted</span>[<span class="variable">$i</span>])) % <span class="number">126</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$hexstr</span> = <span class="title function_ invoke__">unpack</span>(<span class="string">&#x27;h*&#x27;</span>, <span class="variable">$encrypted</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_ invoke__">array_shift</span>(<span class="variable">$hexstr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加密串每一位都与明文、key、和加密串的前一位相关。但是由于第一位是随机出来的，所以很难从开头递推出来。</p>
<p>但是细心观察 message 的构成又可以发现，后面 32 位是 key 的 md5 串，倒数第 33 位又是已知，因此从这里就可以打开突破口。整理思路如下：</p>
<ul>
<li>第一步：通过倒数第 33 位明文已知，且密文已知，因此可以求得某一位 md5($key) 的值。</li>
<li>第二步：根据上一步推出来的值，又可以进一步推另一位 message 的值。如此往复下去，最终应该能找到所有的值。</li>
</ul>
<p>首先题目肯定保证了答案的唯一性，因此 Z3 求解成功就会得到 flag 无疑</p>
<p>其次，我们根据题目的变换方式，给 Z3 所有的正推关系式，把逆推的逻辑让 Z3 通过约束求解来完成，由于逆推可以一步步进行，因此也不会导致 Z3 复杂度爆炸求解不出来</p>
<p><strong>exp:</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">s = <span class="string">&#x27;5616f5962674d26741d2810600a6c5647620c4e3d2870177f09716b2379012c342d3b584c5672195d653722443f1c39254360007010381b721c741a532b03504d2849382d375c0d6806251a2946335a67365020100f160f17640c6a05583f49645d3b557856221b2&#x27;</span></span><br><span class="line"></span><br><span class="line">encrypted = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s), <span class="number">2</span>):</span><br><span class="line">    encrypted.append(binascii.unhexlify(s[i+<span class="number">1</span>] + s[i])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;message len:&#x27;</span>, <span class="built_in">len</span>(encrypted)-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(encrypted)</span><br><span class="line"><span class="comment"># 声明变量，encrypted 是已知，因此 IntVal 即可</span></span><br><span class="line">encrypted = [IntVal(i) <span class="keyword">for</span> i <span class="keyword">in</span> encrypted]</span><br><span class="line">message = [Int(<span class="string">&#x27;flag%d&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted)-<span class="number">1</span>)]</span><br><span class="line"><span class="comment"># 创建一个求解器，求解全靠它</span></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line">ml = <span class="built_in">len</span>(encrypted) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加明文字符的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    <span class="keyword">if</span> i == ml - <span class="number">33</span>:</span><br><span class="line">        solver.add(message[i] == <span class="built_in">ord</span>(<span class="string">&#x27;|&#x27;</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 肯定是可见字符，因此限定范围如下</span></span><br><span class="line">        solver.add(message[i] &lt; <span class="number">127</span>)</span><br><span class="line">        solver.add(message[i] &gt;= <span class="number">32</span>)</span><br><span class="line"><span class="comment"># 添加明文和密文对照关系的约束条件</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">    solver.add(encrypted[i+<span class="number">1</span>] == (message[i] + message[ml-<span class="number">32</span>+i%<span class="number">32</span>] + encrypted[i]) % <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    s = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(ml):</span><br><span class="line">        s.append(m[message[i]].as_long())</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">bytes</span>(s))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;unsat&#x27;</span>) </span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>符号执行与约束求解初探</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/20048/">https://ixout.github.io/posts/20048/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-05-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-05-09</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/">符号执行</a><a class="post-meta__tags" href="/tags/%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3/">约束求解</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/cfcb137bbbe3415.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/60418/" title="初探AFL-Fuzz"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">初探AFL-Fuzz</div></div></a></div><div class="next-post pull-right"><a href="/posts/9746/" title="pyjail-in-pwn初识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">pyjail-in-pwn初识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="iconfont icon-github1"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">55</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">63</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">5</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C"><span class="toc-number">1.</span> <span class="toc-text">符号执行</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#angr"><span class="toc-number">1.1.</span> <span class="toc-text">angr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BF%A1%E6%81%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%89%A7%E8%A1%8C"><span class="toc-number">1.1.2.</span> <span class="toc-text">动态执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">程序分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explore"><span class="toc-number">1.1.4.</span> <span class="toc-text">explore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2021%E7%BA%B5%E6%A8%AA%E6%9D%AF%E5%86%B3%E8%B5%9B-bin1"><span class="toc-number">1.2.1.</span> <span class="toc-text">2021纵横杯决赛-bin1</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F%E6%B1%82%E8%A7%A3"><span class="toc-number">2.</span> <span class="toc-text">约束求解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#z3"><span class="toc-number">2.1.</span> <span class="toc-text">z3</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.1.</span> <span class="toc-text">类型变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">2.1.2.</span> <span class="toc-text">基础使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">2.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2020De1ta-code-runner"><span class="toc-number">2.2.1.</span> <span class="toc-text">2020De1ta-code_runner</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DEFCAMP2017-forgot-my-key"><span class="toc-number">2.2.2.</span> <span class="toc-text">DEFCAMP2017-forgot_my_key</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>